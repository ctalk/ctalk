This is ctalk.info, produced by makeinfo version 4.8 from ctalk.texi.

INFO-DIR-SECTION Ctalk
START-INFO-DIR-ENTRY
* ctalk: (ctalk).	The Ctalk language reference manual.
END-INFO-DIR-ENTRY

This file documents Ctalk version 0.0.66.

Copyright (C) 2007-2015 Robert Kiesling

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled, "GNU
Free Documentation License."


File: ctalk.info,  Node: C,  Next: Copying,  Prev: Methods,  Up: Top

Ctalk Language Features
=======================

This section describes `ctalk''s C language features and its low-level
application programming interface.

* Menu:

* Preprocessor::        Compatibility with `cpp'.
* C statements::        How to use objects and C in the same programs.
* Externs::             Working with multiple input files.
* Class casting::       How to tell Ctalk which class an object is.
* Control structures::  Objects in loops and conditional statements.
* OBJECT typedef::      Ctalk's `OBJECT' type.
* Attributes::          Attributes help identify an object's context.
* C library functions:: How to use objects with C library functions.
* GNU tools::           Using automake, etc., with Ctalk programs.


File: ctalk.info,  Node: Preprocessor,  Next: C statements,  Up: C

`ctpp,' the `ctalk' Preprocessor
--------------------------------

Information about `ctpp', the Ctalk preprocessor, is contained in its
Texinfo manual, `ctpp.info'.

The preprocessor is compatible with GNU `cpp' and supports ISO C99
preprocessing features.  This allows you to include C header files in
Ctalk programs and class libraries.  Ctalk caches macros from include
files, so it can use, in the GNU compiler's terminology, _include once_
header files.

If you have a header file called, for example, `myheader.h', you would
wrap the definitions with the following preprocessor directives.


     #ifndef _MYHEADER_H
     #define _MYHEADER_H
     .
     . <Your definitions appear here.>
     .
     #endif /* _MYHEADER_H */

This makes certain that the preprocessor defines macros, data types,
and other library definitions only once, no matter how many times the
input includes the header file.


File: ctalk.info,  Node: C statements,  Next: Externs,  Prev: Preprocessor,  Up: C

Pragmas
-------

Ctalk recognizes GCC, G++, and C99 pragmas.

Pragmas that apply to floating point operations and code generation are
ignored and elided, unless the `--keeppragmas' command line option is
given.  *Note Invoking::.

Inclusion of a file that contains G++ pragmas causes the preprocessor
to issue a warning if the `-v' option is given, and `ctalk' ignores the
file. *Note Invoking::.

Here is the effect of the GCC and C99 pragmas.

`#pragma interface'

`#pragma implementation'
     The include file is not processed.

`#pragma GCC dependency FILE'
     Issues a warning if the source file is more recent than FILE.

`#pragma GCC poison IDENTIFIER ...'
     `ctalk' issues an error and discontinues processing if the source
     file contains an identifier given as an argument.

`#pragma GCC system header'
     The `ctalk' preprocessor processes all input files in the same
     manner and ignores this pragma.

`#pragma GCC pack'

`#pragma STDC FP_CONTRACT'

`#pragma STDC FENV_ACCESS'

`#pragma STDC CX_LIMITED_RANGE'
     `ctalk' ignores and elides these pragmas, which apply to floating
     point and code generation options, unless the `--keeppragmas'
     option is used. *Note Invoking::.


C Expressions
-------------

In version 0.0.66, you can use simple constant expressions as
receivers, as in this example.

     printf ("%s", "/home/users/joe" subString 1, self length - 1);

_Warning_ - This use of `self' is experimental in version 0.0.66 and
should be used with caution.

You can use a C constant in place of any receiver whose class
corresponds to a basic C data type.  These classes include `Character',
`String', `Float', `Integer', and `LongInteger'.

Expressions like the following work.
     if (99 == myInt)
      ...

     if ('c' == myInt asCharacter)
      ...

     if (3.1416 == pi)
      ...

The following code examples are equivalent.

     myString = "This is a string.";
     printf ("%d\n", myString length);

and,

     printf ("%d\n", "This is a string" length);

However, if you try to use a C variable on the left side of a method
that overloads a C operator, the expression might simply be interpreted
as C code, as in this example.

       String new progName;

       progName = "myprog";

       if (argv[0] == progName) {
         ...
       }

This is because Ctalk does not interpret `argv[0]' as a receiver
object, and then interprets `==' as a C operator.

Objects in Function Parameters
------------------------------

Programs cannot, at this time, use objects as parameters to C
functions.  If you need to use an object as a parameter, you need to
use a method instead of a function, or translate the object's value to
C. *Note Translating::.

Objects in Function Arguments
-----------------------------

You can use of Ctalk expressions as C function arguments, but the
values should be treated as read-only, as in this example.

     Integer new myIndex;
     char buf[255];

     myIndex = 0;

     /*
      *   This statement works correctly.
      */
     sprintf (buf, "%d", __ctalk_to_c_int (myIndex));

     /*
      *   This statement does not work correctly.
      */
     sscanf (myString, "%s %s", mySubString1, mySubString2);

If you need to read a string into objects, try `readFormat' (class
`String') instead.

If you receive an `Unimplemented C type' warning, it means that Ctalk
does not implement a class that corresponds to the data type.  In these
cases, you can generally assign the C variable to an instance of class
`Symbol,' and use that as the argument to a function.

The Classes that implement C data types are described in the next
section.

C Data Type Classes
-------------------

These classes correspond to the basic C types.

`Array'
     `char **'

`Character'
     `char'

`Float'
     `float' and `double'

`Integer'
     `int' and `long int'

`LongInteger'
     `long long int'

`String'
     `char *'


Typedefs in Function Arguments
------------------------------

Ctalk resolves many of the derived types defined in C99, as well as
incomplete types; however, variables that are of derived types can
still cause unpredictable results, if the variable is of an unusual or
complex type.

If you encounter a case where a derived type confuses the parser or
run-time library, the workaround is to declare the type as an
equivalent C type.  For example, if a variable is of type `time_t,' you
could equivalently declare it as type `long long int.'

C Functions in Complex Expressions
----------------------------------

You can use C functions in complex expressions within conditionals, as
in this example.
     int int_fn1 (void) {
       return 10;
     }

     char *add_int_fn_as_string (int a, int b, int c) {
       static char buf[30];
       sprintf (buf, "%d", a + b + c);
       return buf;
     }

     int main () {

       String new myString1;

       if ((myString1 = add_int_fn_as_string (int_fn1 (), 20, 30)) != "60")
         exit(1);

       printf ("%s\n", myString1);

     }
As long as your function returns one of the C data types `int, char,
char *,' or `double,' Ctalk can translate the function output to an
object, as well as call the function at run time using a method call.

If you try to use a C function that returns a complex or derived type,
Ctalk prints a warning and uses `Integer' as the default return class.
In these cases, you should consider writing a method instead.

_Note:_ When you use functions in complex expressions, the function's
arguments must also be C variables or expressions.  If you want to use
objects as the arguments to a function, then you must perform the
object-to-C translation manually.

Debugging
---------

Object Inspectors
.................

Ctalk provides a basic set of methods that can inspect and print the
contents of objects.

The `inspect' method in `Object' class is an interactive utility that
lets you examine a program's objects as the program is running.

To inspect an object, simply send it the message, `inspect' - it's a
shortcut for the `inspect' method in `ObjectInspector' class, which a
program can also call directly.


     String new globalString;

     int main () {
       Integer new i;

       globalString = "global string";

       i inspect;
     }

In either case, the program stops execution when it reaches the
`inspect' method, and presents a prompt where you can type commands.

Here's a transcript of a brief inspector session.


     $ ./inspect
     > p
     p
     name:       i
     class:      Integer (0x48bf4958)
     superclass: Magnitude (0x48bf29f0)
     value:      (null) (Integer)

     > p g globalString
     p g globalString
     name:       globalString
     class:      String (0x48cce8d0)
     superclass: Character (0x48c8acc0)
     value:      global string (String)

     > c
     c
     $

At the inspector prompt, `> ', the command `p' prints the inspector's
receiver object, and `p g globalString' prints the named global object,
`globalString'.  The `c' command exits the inspector and continues
running the program.

There are several commands that the inspector recognizes.  Typing `?,'
`h,' or `help' at the prompt displays a list of them.

The inspector uses the method `formatObject' to print the contents of
individual objects.

If you want to print a formatted object directly, without stopping the
program, Ctalk also has the method `dump' in `Object' class, which
simply calls `formatObject' with its receiver object to print the
object and then returns so the program can continue running.

Using `gdb' for Debugging
.........................

The GNU `gdb' debugger allows you to trace through Ctalk applications
as well as the compiler and the run-time libraries, at the level of
Ctalk's source code.

In order to debug Ctalk programs with `gdb', the source must be
compatible with the debugger; that means that you can debug Ctalk
programs using the intermediate C code to get source level debugging
within Ctalk apps.

You can also examine the contents of objects and their run-time
environment with the `inspect' method (in `Object' class), which
doesn't use line number information. *Note Object_inspect::.  There's a
tutorial on using object inspectors in the `ctalktools' Texinfo manual,
and yet more information in the `inspect.3ctalk' manual page.

The `-P' command line option disables line numbering.  You can then
debug the intermediate output, which is normal C that `gdb' can
interpret correctly.

This means that method line numbers are calculated from the start of
all of the input, which includes all other classes and header files.
So when you give the `-P' option to Ctalk, it reports the line if
possible, although without line number information, the compiler can't
track line numbers of preprocessor output; like for example, by
adjusting line numbers after including a file with the `#include'
directive.

The `ctdb' command builds Ctalk programs with the correct arguments for
debugging.  Then you can use `gdb' to debug the program.

     $ ctdb -k myprog.c -o myprog

If you need to debug either `ctalk' or the `libctalk' library, then you
need to build and install Ctalk without optimization.  You can do that
by adding the `--without-optimization' option to `configure' when
building Ctalk.  Compiler optimization often removes lines of code (and
variables) from the binary, so the output often doesn't correspond to
the source code.  Also, it often helps to add the
`--without-inline-functions' option to `configure'.


     $ ./configure --without-inline-functions --without-optimization

Then build and install Ctalk with `make' and `make install.'

Ctalk also provides other build options.  Typing
     $ ./configure --help
at the shell prompt prints a list of them.

Ctalk is compatible at the machine code level with C programs.  That
means you use most of `gdb's' functions, like peek into a running
program and examine core dumps.  The `gdb' documentation describes the
debugger's extensive set of options.


File: ctalk.info,  Node: Externs,  Next: Class casting,  Prev: C statements,  Up: C

Externs
-------

Ctalk provides a few facilities to help when compiling code in several
input modules.

There are also a few caveats when dealing with C variables in multiple
input modules, which are described below.

Ctalk allows you to prototype methods.  That is, you can declare a
method in a source code module before compiling another module later
where the method is actually defined.

Prototypes are similar to method declarations, except that the
prototype omits the method body.  For example, a method prototype
before the method is first used would look like this.

     String instanceMethod myLength (void);

You can also define a different return class in the prototype, as in
this example.

     String instanceMethod myLength (void) returnClass Integer;

For example, if the input file module1.ca looks like this:


     String instanceMethod trimStrLength (void) returnObjectClass Integer;

     int main () {

       String new myStr;

       myStr = "Hello, world!";

       printf ("%s\n", myStr subString 0, myStr trimStrLength 2);
     }

and the file module2.ca, which contains the definition of
`trimStrLength', looks like this:


     String instanceMethod trimStrLength (void) {
       returnObjectClass Integer;
       return self length - 1;
     }

Then you can build the program with a command line like the following,
and Ctalk will have the definition of `trimStringLength' while
compiling module1.ca, before it actually compiles the method in
module2.ca.


     $ ctcc module1.ca module2.ca -o myprog

C Variables and `extern' Declarations
.....................................

When using a global C variable in several input modules, you only need
to declare it once, before it is first used.  Ctalk combines the C code
of all of the input files with one copy of the class libraries, so it
isn't necessary to declare a C variable in the first module and then
declare it as extern in the modules that get compiled later.


File: ctalk.info,  Node: Class casting,  Next: Control structures,  Prev: Externs,  Up: C

Class casting
-------------

In many cases, it's obvious which class an object is, even when the
object's defition is removed from the place where a program needs to
perform an operation on it, or the object is aliased to `self' or to a
C variable, or you need to use a different type of language semantics
with an object.

If a program has a set of expressions, as in this hypothetical example:


     Integer new myInt;
     myList new myList;
     Key new myKey;
     Symbol new *intPtr;

     *intPtr = Integer new "Int 1", "1";
     myList push *intPtr;
     *intPtr = Integer new "Int 2", "2";
     myList push *intPtr;

     myKey = myList + 1;

     myInt = *myKey;

     myInt += 3;

     _... do stuff with myInt ..._

     myList map {
       printf ("%d\n", self value);
     }

When run, the program would produce output like this.


     $ ./myProg
     1
     2

That's because the changes to `myInt' would not take effect for the
member of `myList', because `Integer' objects, when a program assigns
values to them, normally assigns the value of one `Integer' to another.
However, in the example above, you might want to work on the original
list member - that is, you want the assignment to treat `myInt' as if
it were a reference.

One way to notify Ctalk of this is to use an `Object' to refer to the
list element, and use a _class cast_ to notify Ctalk that the `Object'
is actually an `Integer'.

Then the program example above looks like this.


     Object new myIntObject;
     myList new myList;
     Key new myKey;
     Symbol new *intPtr;

     *intPtr = Integer new "Int 1", "1";
     myList push *intPtr;
     *intPtr = Integer new "Int 2", "2";
     myList push *intPtr;

     myKey = myList + 1;

     myIntObject = *myKey;

     (Integer *)myIntObject += 3;  /* The cast tells Ctalk to treat myIntObject,
                                      which is declared as an Object,
                                      as an Integer, so it can work correctly
                                      with the first element of myList. */

     _... do stuff with myIntObject ..._

     myList map {
       printf ("%d\n", self value);
     }

Other places that you can use class casting is when a program uses a C
`OBJECT *'.  In that case, you can tell Ctalk what class the object is.
Here's an abbreviated example from a `map' method in `TreeNode' class.


       OBJECT *t, *list_elem;

       /* rcvr_obj is a TreeNode object. */
       for (t = __LIST_HEAD(rcvr_obj), have_break = NULL;
            t && !have_break; t = t -> next) {
         list_elem = obj_ref_str ((t -> instancevars) ?
     			     t -> instancevars -> __o_value :
     			     (IS_VALUE_INSTANCE_VAR(t) ?
     			      t -> __o_p_obj -> instancevars -> __o_value :
     			      "0x0"));

       _... do stuff ..._

       (TreeNode *)list_elem children __mapChildren methodfn;

       (TreeNode *)list_elem siblings __mapSiblings methodfn;

       }

This is a convenient way for a program to tell Ctalk that `list_elem'
is a `TreeNode' object.  It's up to the program to ensure that the C
variable actually does point to an object of that class, or the program
won't work correctly at run time.

Programs can also cast `self' to a class, in cases where Ctalk cannot
determine `self's' class from its context, like in this example


     myList map {

       (Float *)self = 0.01f;

     }

This feature is still experimental, and you should use it with caution;
in particular, it's up to the program to insure that the object
actually is a member of the class that you cast it to.  However, on the
occasions when a program needs to excercise some control over a set of
expressions' semantics, then class casting can be useful.


File: ctalk.info,  Node: Control structures,  Next: OBJECT typedef,  Prev: Class casting,  Up: C

Control Structures
------------------

Generally, Ctalk objects work the same as C variables when they appear
in `if', `for', `while', `switch', and `do-while' statements.

If Ctalk cannot figure out a way to resolve an expression that contains
both C variables or functions and objects, it will try to warn you.

One exception to these rules are the methods that perform logical
negation operator, which generally overload the `!' math operator.
When you place a `!' operator at the beginning of a conditional, Ctalk
checks whether the class of the expression's result overloads the
operator.  In that case, Ctalk treats `!' as a method.  If a class does
not overload the operator, then Ctalk treats it as a C operator.

That way, you can overload `!' in classes that define complex objects,
which provides a flexible way to determine if an object has been
initialized or contains valid data.

For example, in `X11Font' class, you can overload the `!' operator to
check whether or not an object's `fontId' instance variable is zero to
determine whether or not the object refers to a valid font.

If a class doesn't overload `!', then Ctalk uses the C semantics for
the operator - that is, it simply checks whether an operand is zero (or
NULL) or non-zero, and inverts the logical true or false value of the
operand.

In addition, Ctalk provides many methods to iterate over collections of
objects.  These methods include `map', `mapInstanceVariables',
`mapClassVariables', and overloaded math operators like those in `Key'
class.

For a complete description of the control structures Ctalk uses, refer
to the `Ctalk Tutorial'.


File: ctalk.info,  Node: OBJECT typedef,  Next: Attributes,  Prev: Control structures,  Up: C

`OBJECT' typedef
================

At the lowest level, ctalk declares objects as pointers to an `OBJECT'
struct.  You can access an object's members if you assign an object's
value to a C variable of the type `OBJECT *', as in this example.

     Object new myObject;
     OBJECT *myObjectValue;

     myObjectValue = myObject value;

     if (!strcmp (myObjectValue -> CLASSNAME, "Object"))
        printf ("myObjectValues class is, \"Object.\"\n");

The declaration of the OBJECT type is contained in `include/object.h'.

     typedef struct _object OBJECT;
     . . .
     struct _object {
       char sig[16];
       char __o_name[MAXLABEL];
       char __o_classname[MAXLABEL];
       OBJECT *__o_class;
       char __o_superclassname[MAXLABEL];
       OBJECT *__o_superclass;
       OBJECT *__o_p_obj;
       VARTAG *__o_vartags;
       char *__o_value;
       METHOD *instance_methods,
         *class_methods;
       int scope;
       int nrefs;
       int attrs
       struct _object *classvars;
       struct _object *instancevars;
       struct _object *next;
       struct _object *prev;
     };

Note that `__o_name', `__o_classname', `__o_superclassname', and
`__o_value' are all `char *', even if the object belongs to a class
like `Integer' or `Float'.  The struct members `__o_class' and
`__o_superclass' contain pointers to the library class and superclass
entries, which are also objects.

For numeric classes, the `value' member contains a formatted
representation of a numeric value.  Examples of directly assigning
values to objects are given in the section about writing methods.
*Note Method API::.

Ctalk uses the members `instance_methods,' `class_methods,' `classvars'
for class objects.

The `sig' member contains a numeric stamp that verifies that the
`OBJECT *' refers to a valid object.

The `scope' member describes an object's scope.  The scope can be one
of `GLOBAL_VAR', `LOCAL_VAR', `ARG_VAR', `RECEIVER_VAR',
`PROTOTYPE_VAR', or `BLOCK_VAR.'

The `nrefs' member keeps track of the number of references that exist
to an object at run time.  Every time ctalk creates a reference to an
object, internally ctalk increments `nrefs'.  When ctalk deletes a
reference, it decrements `nrefs'.  When `nrefs' drops to zero, `ctalk'
deletes the object.

The `attrs' member is a combination of one or more object attributes.
The next section describes object attributes in more detail.

The `tag' member is an abbreviation for the `__o_vartags -> tag ->
var_decl -> name' member; that is, the object's primary label.


File: ctalk.info,  Node: Attributes,  Next: C library functions,  Prev: OBJECT typedef,  Up: C

Object Attributes
-----------------

The Ctalk API defines a number of object attributes.  The attributes
help identify the context that the object appears in.  Many of the
attributes are only meaningful internally; some are also useful in the
method API.

The attributes are defined in `ctalkdefs.h', which you can include in
class libraries.  To set an object's attribute, it's generally
convenient to use the `__ctalkSetObjectAttr ()' library function, which
has the prototype:


     __ctalkSetObjectAttr (`OBJECT *'OBJECT, `int' ATTR)

Many attributes are only used by Ctalk internally.  The attributes that
are useful in methods are defined in `ctalkdefs.h'.  Those attributes,
and their values and uses, are listed here.

`OBJECT_IS_VALUE_VAR    (1 << 0)'
     The object is the `value' instance variable of its parent object.

`OBJECT_VALUE_IS_C_CHAR_PTR_PTR     (1 << 1)'
     Used to indicate that an object refers to a `char **' C array.

`OBJECT_IS_NULL_RESULT_OBJECT      (1 << 2)'
     Indentifies an object that is created when an operation produces a
     NULL result.

`OBJECT_HAS_PTR_CX     (1 << 3)'
     Set when an object appears on the left-hand side of an equation
     with a pointer reference; e.g.,

          *mySymbol = __ctalk_self_internal ().

`OBJECT_IS_GLOBAL_COPY     (1 << 4)'
     Set when a program copies a global object.

`OBJECT_IS_I_RESULT      (1 << 5)'
     Identifies temporary objects that are the result of an operation
     that sets the object tag's pointer references.

`OBJECT_IS_STRING_LITERAL     (1 << 6)'
     Used to identify an object created to represent a string literal.

`OBJECT_IS_MEMBER_OF_PARENT_COLLECTION     (1 << 7)'
     Indicates that an object (generally a `Key' object) is a member of
     a parent collection.  Normally used to identify individual
     collection members.

`OBJECT_HAS_LOCAL_TAG     (1 << 8)'
     Indicates that an object's tag was created as a placeholder for an
     ad-hoc object; for example, objects created by a `basicNew'
     method.  The local tag is not necessarily the primary tag - the
     object can also acquire other tags when being assigned.  Normally
     this attribute is set by the `__ctalkAddBasicNewTag ()' library
     function.

`OBJECT_IS_DEREF_RESULT'
     Set by the `Object : ->' method.  The attribute is used to
     indicate that the receiver of `->' is the result of a previous
     call to `->'; i.e., the expression contains several dereference
     operators; for example, `myObject -> instancevars -> __o_value'.



File: ctalk.info,  Node: C library functions,  Next: GNU tools,  Prev: Attributes,  Up: C

C Library Functions
-------------------

You can assign the result of a C library function to a Ctalk object,
provided that the return type of the function has a corresponding Ctalk
class.

All C functions must have prototypes.  The library functions in this
section already have their prototypes defined in the C library headers.
If a function in a program does not have a prototype, Ctalk prints an
error and exits.

Generally, if Ctalk has a method that is analogous to a C library
function, you can use the method with Ctalk objects, although in many
cases you can mix objects and C variables.  Of course, you can still
use any C library function with C data types.

There are some incompatibilities with more specialized libraries.  For
example, you should take care when using the X Window System Xt widgets
in Ctalk programs, because the widget classes use the some of the same
class names as the Ctalk library.

The following sections describe the C library functions that Ctalk can
use directly.

* Menu:

* abs::
* acos::
* acosh-asinh-atanh::
* asctime::
* asin::
* atexit::
* atof::
* atoi::
* atol::
* atoll::
* calloc::
* cbrt::
* ceil::
* chdir::
* clock::
* copysign::
* cos::
* cosh::
* ctime::
* difftime::
* erf::
* erfc::
* exp::
* expm1::
* fabs::
* fclose::
* fegetround::
* feholdexcept::
* feof::
* ferror::
* fesetround::
* fetestexcept::
* fflush::
* fgetc::
* fgetpos::
* fgets::
* floor::
* fmod::
* fopen::
* fprintf::
* fputc::
* fputs::
* fread::
* free::
* freopen::
* frexp::
* fscanf::
* fseek::
* fsetpos::
* fstat::
* ftell::
* fwrite::
* getc::
* getchar::
* getcwd::
* getenv::
* getpid::
* gmtime-localtime::
* index-function::
* isalnum-isxdigit::
* labs::
* llabs::
* llrint::
* llround::
* log::
* log10::
* log1p::
* lrint::
* lround::
* malloc::
* memchr::
* memcmp::
* memcpy::
* memmove::
* memset::
* mkdir::
* modf::
* nearbyint::
* perror::
* pow::
* printf::
* raise::
* rand::
* realloc::
* remove::
* rename::
* rindex::
* rint::
* rmdir::
* round::
* scanf::
* sin::
* sinh::
* snprintf::
* sprintf::
* sqrt::
* srand::
* sscanf::
* strcat-strcpy::
* strchr::
* strcoll::
* strspn::
* strerror::
* strftime::
* strlen::
* strncat-strncpy::
* strpbrk::
* strrchr::
* strstr::
* strtod::
* strtok::
* strtoll::
* strxfrm::
* system::
* tan::
* tanh::
* tmpnam::
* tolower::
* toupper::
* trunc::
* ungetc::
* vfprintf::
* vfscanf::
* vprintf::
* vscanf::
* vsnprintf::
* vsprintf::
* vsscanf::


File: ctalk.info,  Node: abs,  Next: acos,  Up: C library functions

`abs' Function
--------------


     #include <stdlib.h>

     Integer new i;

     i = abs (3);


File: ctalk.info,  Node: acos,  Next: acosh-asinh-atanh,  Prev: abs,  Up: C library functions

`acos' Function
---------------


     #include <math.h>

     Integer new i;

     i = acos (0.5);

Ctalk does not check if the argument is outside the range -1 to 1 and
does not check for an error.  Refer to the, `acos', manual page.


File: ctalk.info,  Node: acosh-asinh-atanh,  Next: asctime,  Prev: acos,  Up: C library functions

`acosh,' `asinh,' and `atanh' Functions
---------------------------------------


     #include <math.h>

     Float new myFloat;

     myFloat = acosh (2.0);

Ctalk does not check the range of the arguments or errors.  Refer to
the, `acosh(3), asinh(3),' and `atanh(3)' manual pages.


File: ctalk.info,  Node: asctime,  Next: asin,  Prev: acosh-asinh-atanh,  Up: C library functions

`asctime' Function
------------------


     #include <time.h>

     time_t t;
     struct tm *time_struct;
     String new s;

     time (&t);
     time_struct = localtime (&t);
     s = asctime (time_struct);

_Note:_ Ctalk does not have a class corresponding to a `struct tm *.'
An explicit assignment of a `struct tm *' to a `Symbol' passes the
address to `asctime.' *Note Objects in Function Arguments::.


File: ctalk.info,  Node: asin,  Next: atexit,  Prev: asctime,  Up: C library functions

`asin' Function
---------------

     #include <math.h>

     Float new f;

     f = asin (0.5);

Note that ctalk does not perform any range checking of the argument.


File: ctalk.info,  Node: atexit,  Next: atof,  Prev: asin,  Up: C library functions

`atexit' Function
-----------------

     #include <stdlib.h>

     Integer new i;

     i = atexit (exitfunc);


File: ctalk.info,  Node: atof,  Next: atoi,  Prev: atexit,  Up: C library functions

`atof' Function
---------------

     #include <stdlib.h>

     Float new pi;

     pi = atof ("3.1416");


File: ctalk.info,  Node: atoi,  Next: atol,  Prev: atof,  Up: C library functions

`atoi' Function
---------------

     #include <stdlib.h>

     Integer new i;

     i = atoi ("35");


File: ctalk.info,  Node: atol,  Next: atoll,  Prev: atoi,  Up: C library functions

`atol' Function
---------------

     #include <stdlib.h>

     Integer new i;

     i = atol ("35");

Note that, `Integer', class corresponds to the C types, `int', and,
`long int'.


File: ctalk.info,  Node: atoll,  Next: calloc,  Prev: atol,  Up: C library functions

`atoll' Function
----------------

#include <stdlib.h>

LongInteger new i;

i = atoll ("35");

_Note:_ The `atoll(3)' function is not implemented by the OS X or DJGPP
C libraries.  Use `atol(3)', `strtoll(3)', or a method instead.


File: ctalk.info,  Node: calloc,  Next: cbrt,  Prev: atoll,  Up: C library functions

`calloc' Function
-----------------

     #include <stdlib.h>

     Integer new n;
     Integer new size;
     int *intbuf;

     n = 10;
     size = sizeof (int);

     intbuf = calloc (n, size);


File: ctalk.info,  Node: cbrt,  Next: ceil,  Prev: calloc,  Up: C library functions

`cbrt' Function
---------------

#include <math.h>

Float new f;

f = cbrt (9.0);


File: ctalk.info,  Node: ceil,  Next: chdir,  Prev: cbrt,  Up: C library functions

`ceil' Function
---------------

#include <math.h>

Float new f;

f = ceil (3.5);


File: ctalk.info,  Node: chdir,  Next: clock,  Prev: ceil,  Up: C library functions

`chdir' Function
----------------

Integer new result; String new dirName;

dirName = "mySubdir";

result = chdir (mySubdir);


File: ctalk.info,  Node: clock,  Next: copysign,  Prev: chdir,  Up: C library functions

`clock' Function
----------------

     #include <time.h>

     Integer new i;

     i = clock ();


File: ctalk.info,  Node: copysign,  Next: cos,  Prev: clock,  Up: C library functions

`copysign' Function
-------------------

     #include <math.h>

     Float new f;

     f = copysign (3.0, -1.0);


File: ctalk.info,  Node: cos,  Next: cosh,  Prev: copysign,  Up: C library functions

`cos' Function
--------------

     #include <math.h>

     Float new f;

     f = cos (45.0);


File: ctalk.info,  Node: cosh,  Next: ctime,  Prev: cos,  Up: C library functions

`cosh' Function
---------------

     #include <math.h>

     Float new f;

     f = cosh (45.0);


File: ctalk.info,  Node: ctime,  Next: difftime,  Prev: cosh,  Up: C library functions

`ctime' Function
----------------

     #include <time.h>

     time_t t;
     String new s;

     time (&t);
     s = ctime (&t);

_Note:_ There is not a portable way to take the address of an object
with `&', although it may be possible to perform the translation
manually in some cases.  If the argument must be an object, then use
the `cTime' (class `CTime') method instead.


File: ctalk.info,  Node: difftime,  Next: erf,  Prev: ctime,  Up: C library functions

`difftime' Function
-------------------


     #include <time.h>

     Float new f;

     f = difftime (time1, time0);


File: ctalk.info,  Node: erf,  Next: erfc,  Prev: difftime,  Up: C library functions

`erf' Function
--------------


     #include <math.h>

     Float new f;

     f = erf (0.5);


File: ctalk.info,  Node: erfc,  Next: exp,  Prev: erf,  Up: C library functions

`erfc' Function
---------------


     #include <math.h>

     Float new f;

     f = erfc (0.5);


File: ctalk.info,  Node: exp,  Next: expm1,  Prev: erfc,  Up: C library functions

`exp' Function
--------------


     #include <math.h>

     Float new f;

     f = exp (2);


File: ctalk.info,  Node: expm1,  Next: fabs,  Prev: exp,  Up: C library functions

`expm1' Function
----------------


     #include <math.h>

     Float new f;

     f = expm1 (1.05);


File: ctalk.info,  Node: fabs,  Next: fclose,  Prev: expm1,  Up: C library functions

`fabs' Function
---------------


     #include <math.h>

     Float new f;

     f = fabs (-1.05);


File: ctalk.info,  Node: fclose,  Next: fegetround,  Prev: fabs,  Up: C library functions

`fclose' Function
-----------------


     #include <stdio.h>

     Integer new i;

     i = fclose (fileHandle);


File: ctalk.info,  Node: fegetround,  Next: feholdexcept,  Prev: fclose,  Up: C library functions

`fegetround' Function
---------------------


     #include <fenv.h>

     Integer new i;

     i = fegetround ();


File: ctalk.info,  Node: feholdexcept,  Next: feof,  Prev: fegetround,  Up: C library functions

`feholdexcept' Function
-----------------------


     #include <fenv.h>

     Integer new i;

     i = feholdexcept (fe_envp);


File: ctalk.info,  Node: feof,  Next: ferror,  Prev: feholdexcept,  Up: C library functions

`feof' Function
---------------


     #include <stdio.h>

     Integer new i;

     i = feof (fileStream);


File: ctalk.info,  Node: ferror,  Next: fesetround,  Prev: feof,  Up: C library functions

`ferror' Function
-----------------


     #include <stdio.h>

     Integer new i;

     i = ferror (fileStream);


File: ctalk.info,  Node: fesetround,  Next: fetestexcept,  Prev: ferror,  Up: C library functions

`fesetround' Function
---------------------


     #include <math.h>

     Integer new i;

     i = fesetround (mode);


File: ctalk.info,  Node: fetestexcept,  Next: fflush,  Prev: fesetround,  Up: C library functions

`fetestexcepts' Function
------------------------


     #include <math.h>

     Integer new i;

     i = fetestxcept (exceptions);


File: ctalk.info,  Node: fflush,  Next: fgetc,  Prev: fetestexcept,  Up: C library functions

`fflush' Function
-----------------


     #include <stdio.h>

     Integer new i;

     i = fflush (fileStream);


File: ctalk.info,  Node: fgetc,  Next: fgetpos,  Prev: fflush,  Up: C library functions

`fgetc' Function
----------------


     #include <stdio.h>

     Integer new i;

     i = fgetc (fileStream);


File: ctalk.info,  Node: fgetpos,  Next: fgets,  Prev: fgetc,  Up: C library functions

`fgetpos' Function
------------------


     #include <stdio.h>

     Integer new i;

     i = fgetpos (fileStream, pos);


File: ctalk.info,  Node: fgets,  Next: floor,  Prev: fgetpos,  Up: C library functions

`fgets' Function
----------------


     #include <stdio.h>

     String new s;

     s = fgets (s, s length, fileStream);


File: ctalk.info,  Node: floor,  Next: fmod,  Prev: fgets,  Up: C library functions

`floor' Function
----------------


     #include <math.h>

     Float new f;

     f = floor (3.01);


File: ctalk.info,  Node: fmod,  Next: fopen,  Prev: floor,  Up: C library functions

`fmod' Function
---------------


     #include <math.h>

     Float new f;

     f = fmod (3.0, 2.0);


File: ctalk.info,  Node: fopen,  Next: fprintf,  Prev: fmod,  Up: C library functions

`fopen' Function
----------------


     #include <stdio.h>

     FILE *f

     String new path;
     String new mode;

     path = "/home/user/.profile";
     mode = "r";

     f = fopen (path, mode);


File: ctalk.info,  Node: fprintf,  Next: fputc,  Prev: fopen,  Up: C library functions

`fprintf' Function
------------------

*Note Variable arguments::.


File: ctalk.info,  Node: fputc,  Next: fputs,  Prev: fprintf,  Up: C library functions

`fputc' Function
----------------


     #include <stdio.h>

     Integer new myInput;

     myInput = fgetc (stdin);
     fputc (myInput, stdout);


File: ctalk.info,  Node: fputs,  Next: fread,  Prev: fputc,  Up: C library functions

`fputc' Function
----------------

     #include <stdio.h>

     String new myInput;

     fgets (myInput, 255, stdin);
     fputs (myInput, stdout);


File: ctalk.info,  Node: fread,  Next: free,  Prev: fputs,  Up: C library functions

`fread' Function
----------------

     #include <stdio.h>

     String new myInput;

     myInput = "";

     fread (myInput, 255, sizeof (char), stdin);


File: ctalk.info,  Node: free,  Next: freopen,  Prev: fread,  Up: C library functions

`free' Function
---------------

Do not use `free' with objects.  Use the `__ctalkDeleteObject' library
function instead.

Also, calling `__objRefCntZero' before `__ctalkDeleteObject' insures
that the object will be completely deleted.  You can do this in two
ways: first, by sending the object a `delete' message; or by casting
the object to a C `OBJECT *' and then giving the `OBJECT *' as an
argument to `__objRefCntZero' and `__ctalkDeleteObject'.

     Object new myObject;
     OBJECT *myObject_alias;

     myObject_aliast = myObject;

     __objRefCntZero (OBJREF (myObject_alias));
     __ctalkDeleteObject (myObject_alias);


File: ctalk.info,  Node: freopen,  Next: frexp,  Prev: free,  Up: C library functions

`freopen' Function
------------------

     #include <stdio.h>

     FILE *f;

     String new path;
     String new mode;

     path = "/home/user/.profile";
     mode = "r";

     f2 = freopen (path, mode, stdin);


File: ctalk.info,  Node: frexp,  Next: fscanf,  Prev: freopen,  Up: C library functions

`frexp' Function
----------------

     #include <math.h>

     int i_exp_val;
     Integer new expInt;
     Float new myFloat;
     Float new myFraction;

     myFloat = "2.5";

     myFraction = frexp (myFloat, &i_exp_val);

     expInt = i_exp_val;


File: ctalk.info,  Node: fscanf,  Next: fseek,  Prev: frexp,  Up: C library functions

`fscanf' Function
-----------------

*Note Variable arguments::.

_Note:_ The C99 standard requires that `stdin,' `stdout,' and `stderr'
should be implemented as macros, which on some systems (notably
Solaris) causes problems with C-to-object translation.  If Ctalk cannot
register these macros as C variables, then either call `fscanf(3)' C
function with only C variables, or use a method with `stdoutStream' or
`stderrStream' *Note WriteFileStream::, or `stdinStream' *Note
ReadFileStream::.


File: ctalk.info,  Node: fseek,  Next: fsetpos,  Prev: fscanf,  Up: C library functions

`fseek' Function
----------------


File: ctalk.info,  Node: fsetpos,  Next: fstat,  Prev: fseek,  Up: C library functions

`fsetpos' Function
------------------

     #include <stdio.h>

     FILE *f;
     String new path;
     String new mode;
     Integer new offset;

     path = "/home/user/.profile.new";
     mode = "r";


     f = fopen (path, mode);

     offset = 0L;

     fsetpos (f, offset);


File: ctalk.info,  Node: fstat,  Next: ftell,  Prev: fsetpos,  Up: C library functions

`fstat' Function
----------------

     #include <sys/types.h>
     #include <sys/stat.h>
     #include <unistd.h>

     String new path;
     Integer new result;
     struct stat statbuf;

     path = "/home/user/.profile";

     result = fstat (path, &statbuf);


File: ctalk.info,  Node: ftell,  Next: fwrite,  Prev: fstat,  Up: C library functions

`ftell' Function
----------------

     #include <stdio.h>

     Integer new filePos;

     filePos = ftell (file);


File: ctalk.info,  Node: fwrite,  Next: getc,  Prev: ftell,  Up: C library functions

`fwrite' Function
-----------------

     #include <stdio.h>

     FILE *f;
     String new path;
     String new mode;
     String new promptLine;

     path = "/home/user/.profile.new";
     mode = "a";

     f = fopen (path, mode);

     promptLine = "PS1=#";

     fwrite (promptLine, promptLine length, sizeof (char), f);


File: ctalk.info,  Node: getc,  Next: getchar,  Prev: fwrite,  Up: C library functions

`getc' Function
---------------

     #include <stdio.h>

     Integer new myInput;

     myInput = getc (stdin);

     printf ("%c", myInput asCharacter);


File: ctalk.info,  Node: getchar,  Next: getcwd,  Prev: getc,  Up: C library functions

`getchar' Function
------------------

     #include <stdio.h>

     Integer new myInput;

     myInput = getchar ();

     printf ("%c", myInput asCharacter);


File: ctalk.info,  Node: getcwd,  Next: getenv,  Prev: getchar,  Up: C library functions

`getcwd' Function
-----------------

     #include <stdio.h>
     String new myString;
     getcwd (myString, FILENAME_MAX);
_Note:_ The argument `myString' must already be initialized to hold the
entire directory path.  If in doubt, use `getCwd' (class
`DirectoryStream') instead. *Note DirectoryStream::.


File: ctalk.info,  Node: getenv,  Next: getpid,  Prev: getcwd,  Up: C library functions

`getenv' Function
-----------------

     String new envPath;

     envPath = getenv ("PATH");

     printf ("%s", envPath);


File: ctalk.info,  Node: getpid,  Next: gmtime-localtime,  Prev: getenv,  Up: C library functions

`getpid' Function
-----------------


File: ctalk.info,  Node: gmtime-localtime,  Next: index-function,  Prev: getpid,  Up: C library functions

`gmtime,' `localtime' Functions
-------------------------------


File: ctalk.info,  Node: index-function,  Next: isalnum-isxdigit,  Prev: gmtime-localtime,  Up: C library functions

`index' Function
----------------

*Note strchr::.


File: ctalk.info,  Node: isalnum-isxdigit,  Next: labs,  Prev: index-function,  Up: C library functions

`isalnum,' `isalpha,' `isascii,' `isblank,' `iscntrl,' `isdigit,' `isgraph,' `islower,' `isprint,' `ispunct,' `isspace,' `isupper,' `isxdigit' Functions
--------------------------------------------------------------------------------------------------------------------------------------------------------

Ctalk does not support `ctype.h' macros portably.  Use the
corresponding method of class `Character' instead.  *Note Character::.

     Ctype.h Macro          Ctalk Method
     -------------          ------------
     isalnum                isAlNum
     isalpha                isAlpha
     isascii                isASCII
     isblank                isBlank
     iscntrl                isCntrl
     isdigit                isDigit
     isgraph                isGraph
     islower                isLower
     isprint                isPrint
     ispunct                isPunct
     isspace                isSpace
     isupper                isUpper
     isxdigit               isXDigit


File: ctalk.info,  Node: labs,  Next: llabs,  Prev: isalnum-isxdigit,  Up: C library functions

`labs' Function
---------------

     #include <stdlib.h>

     Integer new myValue;
     Integer new myAbsValue;

     myAbsValue = labs (myValue);


File: ctalk.info,  Node: llabs,  Next: llrint,  Prev: labs,  Up: C library functions

`llabs' Function
----------------

     #include <stdlib.h>

     LongInteger new myValue;
     LongInteger new myAbsValue;

     myAbsValue = llabs (myValue);


File: ctalk.info,  Node: llrint,  Next: llround,  Prev: llabs,  Up: C library functions

`lrint', `lrintf', `lrintl', `llrint', `llrintf', `llrintl' Functions
---------------------------------------------------------------------

     #include <math.h>

     Float new myFloat;
     LongInteger new myLongInt;

     myFloat = 2.5;

     myLongInt = llrint (myFloat);

Consult the manual page for `lrint(3)', etc., for detailed information
about each function.


File: ctalk.info,  Node: llround,  Next: log,  Prev: llrint,  Up: C library functions

`llround' Function
------------------

     #include <math.h>

     Float new myFloat;
     LongInteger new myLongInt;

     myFloat = 2.5;

     myLongInt = llround (myFloat);


File: ctalk.info,  Node: log,  Next: log10,  Prev: llround,  Up: C library functions

`log' Function
--------------

     #include <math.h>

     Float new myFloat;
     Float new myLog;

     myFloat = 2.5;

     myLog = log (myFloat);


File: ctalk.info,  Node: log10,  Next: log1p,  Prev: log,  Up: C library functions

`log10' Function
----------------

     #include <math.h>

     Float new myFloat;
     Float new myLog;

     myFloat = 2.5;

     myLog = log10 (myFloat);


File: ctalk.info,  Node: log1p,  Next: lrint,  Prev: log10,  Up: C library functions

`log1p' Function
----------------

     #include <math.h>

     Float new myFloat;
     Float new myLog;

     myFloat = 2.5;

     myLog = log1p (myFloat);


File: ctalk.info,  Node: lrint,  Next: lround,  Prev: log1p,  Up: C library functions

`lrint' Function
----------------

     #include <math.h>

     Float new myFloat;
     Integer new myInt;

     myFloat = 2.5;

     myLog = lrint (myFloat);


File: ctalk.info,  Node: lround,  Next: malloc,  Prev: lrint,  Up: C library functions

`lround' Function
-----------------

     #include <math.h>

     Float new myFloat;
     Integer new myInt;

     myFloat = 2.5;

     myLog = lround (myFloat);


File: ctalk.info,  Node: malloc,  Next: memchr,  Prev: lround,  Up: C library functions

`malloc' Function
-----------------

     #include <stdlib.h>

     Integer new size;
     int *intbuf

     size = sizeof (int) * 10;

     memblk = (int *)malloc (size);


File: ctalk.info,  Node: memchr,  Next: memcmp,  Prev: malloc,  Up: C library functions

`memchr' Function
-----------------

     #include <string.h>

     #define BUFLENGTH 1024

     Integer new searchChar;
     Integer new length;
     char buf[BUFLENGTH], *charptr;

     length = BUFLENGTH

     strcpy (buf, "Some text.");

     searchChar = '.';

     charptr = (char *)memchr ((void *)buf, searchChar, length);


File: ctalk.info,  Node: memcmp,  Next: memcpy,  Prev: memchr,  Up: C library functions

`memcmp' Function
-----------------

     #include <string.h>

     #define BUFLENGTH 1024

     Integer new length;
     Integer new result;
     char buf1[BUFLENGTH], buf2[BUFLENGTH];

     length = BUFLENGTH

     strcpy (buf1, "Some text.");
     strcpy (buf2, "Some other text.");

     result = memcmp ((void *)buf1, (void *)buf2, length);


File: ctalk.info,  Node: memcpy,  Next: memmove,  Prev: memcmp,  Up: C library functions

`memcpy' Function
-----------------

     #include <string.h>

     #define BUFLENGTH 1024

     Integer new length;
     Integer new result;
     char buf1[BUFLENGTH], buf2[BUFLENGTH], *charptr;

     length = BUFLENGTH

     strcpy (buf1, "Some text.");

     result = (char *)memcpy ((void *)buf1, (void *)buf2, length);


File: ctalk.info,  Node: memmove,  Next: memset,  Prev: memcpy,  Up: C library functions

`memmove' Function
------------------

     #include <string.h>

     #define BUFLENGTH 1024

     Integer new length;
     Integer new result;
     char buf1[BUFLENGTH], buf2[BUFLENGTH], *charptr;

     length = BUFLENGTH

     strcpy (buf1, "Some text.");

     charptr = (char *)memmove ((void *)buf1, (void *)buf2, length);


File: ctalk.info,  Node: memset,  Next: mkdir,  Prev: memmove,  Up: C library functions

`memset' Function
-----------------

     #include <string.h>

     #define BUFLENGTH 1024

     Integer new length;
     Integer new fillChar;
     char buf[BUFLENGTH], *charptr;

     length = BUFLENGTH
     fillChar = 0;

     charptr = (char *)memset ((void *)buf1, fillChar, length);


File: ctalk.info,  Node: mkdir,  Next: modf,  Prev: memset,  Up: C library functions

`mkdir' Function
----------------

     Integer new r;
     String new myDirName;

     myDirName = "myDir";

     r = mkdir (myDirName);


File: ctalk.info,  Node: modf,  Next: nearbyint,  Prev: mkdir,  Up: C library functions

`modf' Function
---------------

     #include <math.h>

     double dptr;
     Float new x;
     Float new frac;

     x = 2.54;

     frac = modf (x, &dptr);


File: ctalk.info,  Node: nearbyint,  Next: perror,  Prev: modf,  Up: C library functions

`nearbyint' Function
--------------------

     #include <math.h>

     Float new x;
     Float new result;

     x = 2.53;

     result = nearbyint (x);


File: ctalk.info,  Node: perror,  Next: pow,  Prev: nearbyint,  Up: C library functions

`perror' Function
-----------------

     #include <stdio.h>

     String new message;

     message = "Program error";

     perror (message);


File: ctalk.info,  Node: pow,  Next: printf,  Prev: perror,  Up: C library functions

`pow' Function
--------------

     #include <math.h>

     Float new x;
     Float new exp;
     Float new result;

     x = 2.5;
     exp = 2;

     result = pow (x, exp);


File: ctalk.info,  Node: printf,  Next: raise,  Prev: pow,  Up: C library functions

`printf' Function
-----------------

     #include <stdio.h>

     String new message;
     String new fmt;

     printf (fmt, message);


File: ctalk.info,  Node: raise,  Next: rand,  Prev: printf,  Up: C library functions

`raise' Function
----------------

     #include <signal.h>

     Integer new signal;
     Integer new result;

     signal = SIGTERM;

     result = raise (signal);


File: ctalk.info,  Node: rand,  Next: realloc,  Prev: raise,  Up: C library functions

`rand' Function
---------------

     #include <stdlib.h>

     Integer new random;

     random = rand ();


File: ctalk.info,  Node: realloc,  Next: remove,  Prev: rand,  Up: C library functions

`realloc' Function
------------------

     #include <stdlib.h>

     int *intptr;
     Integer new size;

     size = sizeof (int *);

     intptr = (int *)realloc (NULL, size);


File: ctalk.info,  Node: remove,  Next: rename,  Prev: realloc,  Up: C library functions

`remove' Function
-----------------

     #include <stdio.h>

     String new path;
     Integer new result;

     path = ``/home/user'';

     result = remove (path);


File: ctalk.info,  Node: rename,  Next: rindex,  Prev: remove,  Up: C library functions

`rename' Function
-----------------

     #include <stdio.h>

     String new oldPath;
     String new newPath;
     Integer new result;

     oldPath = "/home/user";
     newPath = "/home/joe";

     result = rename (oldPath, newPath);


File: ctalk.info,  Node: rindex,  Next: rint,  Prev: rename,  Up: C library functions

`rindex' Function
-----------------

*Note strrchr::.


File: ctalk.info,  Node: rint,  Next: rmdir,  Prev: rindex,  Up: C library functions

`rint' Function
---------------

     #include <math.h>

     Float new myFloat;
     Float new myIntValue;

     myFloat = 2.54;

     myIntValue = rint (myFloat);


File: ctalk.info,  Node: rmdir,  Next: round,  Prev: rint,  Up: C library functions

`rmdir' Function
----------------

     r = rmdir (dirToRemove);


File: ctalk.info,  Node: round,  Next: scanf,  Prev: rmdir,  Up: C library functions

`round' Function
----------------

     #include <math.h>

     Float new myFloat;
     Float new myIntValue;

     myFloat = 2.54;

     myIntValue = round (myFloat);


File: ctalk.info,  Node: scanf,  Next: sin,  Prev: round,  Up: C library functions

`scanf' Function
----------------

*Note Variable arguments::.


File: ctalk.info,  Node: sin,  Next: sinh,  Prev: scanf,  Up: C library functions

`sin' Function
--------------

     #include <math.h>

     Float new x;
     Float new sinX;

     x = 2.5;

     sinX = sin (x);


File: ctalk.info,  Node: sinh,  Next: snprintf,  Prev: sin,  Up: C library functions

`sinh' Function
---------------

     #include <math.h>

     Float new x;
     Float new sinX;

     x = 2.5;

     sinX = sinh (x);


File: ctalk.info,  Node: snprintf,  Next: sprintf,  Prev: sinh,  Up: C library functions

`snprintf' Function
-------------------

*Note Variable arguments::.


File: ctalk.info,  Node: sprintf,  Next: sqrt,  Prev: snprintf,  Up: C library functions

`sprintf' Function
------------------

*Note Variable arguments::.


File: ctalk.info,  Node: sqrt,  Next: srand,  Prev: sprintf,  Up: C library functions

`sqrt' Function
---------------

     #include <math.h>

     Array instanceMethod printSquareRoot (void) {

       Float new squareRoot;
       WriteFileStream classInit;

       /*
        *  Use Ctalk C API library function calls within a C function.
        */
       squareRoot = sqrt(__ctalk_to_c_double(__ctalk_self_internal ()));
       stdoutStream writeStream squareRoot;

       return NULL;
     }

     int main () {

       Array new floatArray;

       floatArray atPut 0, 1.0;
       floatArray atPut 1, 4.0;
       floatArray atPut 2, 9.0;
       floatArray atPut 3, 16.0;
       floatArray atPut 4, 25.0;

       floatArray map printSquareRoot;

     }


File: ctalk.info,  Node: srand,  Next: sscanf,  Prev: sqrt,  Up: C library functions

`srand' Function
----------------

     #include <stdlib.h>

     Integer new seed;

     seed = 2;

     srand (seed);


File: ctalk.info,  Node: sscanf,  Next: strcat-strcpy,  Prev: srand,  Up: C library functions

`sscanf' Function
-----------------

*Note Variable arguments::.

_Note:_ The C99 standard requires that `stdin,' `stdout,' and `stderr'
should be implemented as macros, which on some systems (notably
Solaris) causes problems with C-to-object translation.  If Ctalk cannot
register these macros as C variables, then either call `sscanf(3)' C
function with only C variables, or use a method with `stdoutStream' or
`stderrStream' *Note WriteFileStream::, or `stdinStream' *Note
ReadFileStream::.


File: ctalk.info,  Node: strcat-strcpy,  Next: strchr,  Prev: sscanf,  Up: C library functions

`strcat,' `strcasecmp', `strcmp,' and `strcpy' Functions
--------------------------------------------------------

The `strcat(3),' `strcasecmp(3),' `strcmp(3),' and `strcpy(3)'
functions work in most statements.  When necessary, Ctalk uses
`cStrcat', `cStrcasecmp', `cStrcmp', and `cStrcpy' (class `CFunction').
*Note CFunction::.


File: ctalk.info,  Node: strchr,  Next: strcoll,  Prev: strcat-strcpy,  Up: C library functions

`strchr' Function
-----------------

     #include <string.h>

     int main () {

       String new s;
       String new result;

       s = "s1";

       if ((result = strchr (s, '1')) == "1") {
         printf ("Pass\n");
       } else {
         printf ("Fail\n");
       }

       exit(0);
     }


File: ctalk.info,  Node: strcoll,  Next: strspn,  Prev: strchr,  Up: C library functions

`strcoll' Function
------------------

     #include <string.h>

     String new s1;
     String new s2;
     Integer new result;

     result = strcoll (s1, s2);


File: ctalk.info,  Node: strspn,  Next: strerror,  Prev: strcoll,  Up: C library functions

`strspn' Function
-----------------


File: ctalk.info,  Node: strerror,  Next: strftime,  Prev: strspn,  Up: C library functions

`strerror' Function
-------------------


File: ctalk.info,  Node: strftime,  Next: strlen,  Prev: strerror,  Up: C library functions

`strftime' Function
-------------------


File: ctalk.info,  Node: strlen,  Next: strncat-strncpy,  Prev: strftime,  Up: C library functions

`strlen' Function
-----------------


File: ctalk.info,  Node: strncat-strncpy,  Next: strpbrk,  Prev: strlen,  Up: C library functions

`strncat,' `strncmp,' and `strncpy' Functions
---------------------------------------------

The `strncat(3),' `strncasecmp(3),' `strncmp(3),' and `strncpy(3)'
functions work in most statements.  When necessary, Ctalk uses
`cStrncat,' `cStrncasecmp,' `cStrncmp,' and `cStrncpy' (class
`CFunction'). *Note CFunction::.


File: ctalk.info,  Node: strpbrk,  Next: strrchr,  Prev: strncat-strncpy,  Up: C library functions

`strpbrk' Function
------------------


File: ctalk.info,  Node: strrchr,  Next: strstr,  Prev: strpbrk,  Up: C library functions

`strrchr' Function
------------------

     #include <string.h>

     String new s1;
     Character new searchChar;
     String new charptr;

     searchChar = '/';
     s1 = "/home/user";

     charptr = strrchr (s1, searchChar);


File: ctalk.info,  Node: strstr,  Next: strtod,  Prev: strrchr,  Up: C library functions

`strstr' Function
-----------------


File: ctalk.info,  Node: strtod,  Next: strtok,  Prev: strstr,  Up: C library functions

`strtod' Function
-----------------


File: ctalk.info,  Node: strtok,  Next: strtoll,  Prev: strtod,  Up: C library functions

`strtok' Function
-----------------


File: ctalk.info,  Node: strtoll,  Next: strxfrm,  Prev: strtok,  Up: C library functions

`strtoll' Function
------------------


File: ctalk.info,  Node: strxfrm,  Next: system,  Prev: strtoll,  Up: C library functions

`strxfrm' Function
------------------


File: ctalk.info,  Node: system,  Next: tan,  Prev: strxfrm,  Up: C library functions

`system' Function
-----------------

     #include <stdlib.h>

     String new commandLine;

     commandLine = "ls -lR";

     system (commandLine);


File: ctalk.info,  Node: tan,  Next: tanh,  Prev: system,  Up: C library functions

`tan' Function
--------------


File: ctalk.info,  Node: tanh,  Next: tmpnam,  Prev: tan,  Up: C library functions

`tanh' Function
---------------


File: ctalk.info,  Node: tmpnam,  Next: tolower,  Prev: tanh,  Up: C library functions

`tmpnam' Function
-----------------


File: ctalk.info,  Node: tolower,  Next: toupper,  Prev: tmpnam,  Up: C library functions

`tolower' Function
------------------

The `tolower' function may be implemented in a non-portable manner.
Use the `toLower' method instead.


File: ctalk.info,  Node: toupper,  Next: trunc,  Prev: tolower,  Up: C library functions

`toupper' Function
------------------

The `toupper' function may be implemented in a non-portable manner.
Use the `toUpper' method instead.


File: ctalk.info,  Node: trunc,  Next: ungetc,  Prev: toupper,  Up: C library functions

`trunc' Function
----------------


File: ctalk.info,  Node: ungetc,  Next: vfprintf,  Prev: trunc,  Up: C library functions

`ungetc' Function
-----------------


File: ctalk.info,  Node: vfprintf,  Next: vfscanf,  Prev: ungetc,  Up: C library functions

`vfprintf' Function
-------------------

This version of Ctalk does not support the `va_list' data type.  You
should use `printf(3)' or `writeStream' (class `WriteFileStream')
instead.


File: ctalk.info,  Node: vfscanf,  Next: vprintf,  Prev: vfprintf,  Up: C library functions

`vfscanf' Function
------------------

This version of Ctalk does not support the `va_list' data type.  You
should use `scanf(3)' instead. *Note Variable arguments::.


File: ctalk.info,  Node: vprintf,  Next: vscanf,  Prev: vfscanf,  Up: C library functions

`vprintf' Function
------------------

This version of Ctalk does not support the `va_list' data type.  You
should use `printf(3)' or `writeStream' (class `WriteFileStream')
instead.


File: ctalk.info,  Node: vscanf,  Next: vsnprintf,  Prev: vprintf,  Up: C library functions

`vscanf' Function
-----------------

This version of Ctalk does not support the `va_list' data type.  You
should use `scanf(3)' instead. *Note Variable arguments::.


File: ctalk.info,  Node: vsnprintf,  Next: vsprintf,  Prev: vscanf,  Up: C library functions

`vsnprintf' Function
--------------------

This version of Ctalk does not support the `va_list' data type.  You
should use `sprintf(3)' instead. *Note Variable arguments::.


File: ctalk.info,  Node: vsprintf,  Next: vsscanf,  Prev: vsnprintf,  Up: C library functions

`vsprintf' Function
-------------------

This version of Ctalk does not support the `va_list' data type.  You
should use `sprintf(3)' instead. *Note Variable arguments::.


File: ctalk.info,  Node: vsscanf,  Prev: vsprintf,  Up: C library functions

`vsscanf' Function
------------------

This version of Ctalk does not support the `va_list' data type.  You
should use `sprintf(3)' instead. *Note Variable arguments::.


File: ctalk.info,  Node: GNU tools,  Prev: C library functions,  Up: C

Using GNU Tools with Ctalk
--------------------------

If you want to build Ctalk programs using the GNU configuration tools;
i.e, the `./configure,' `make,' `make install' sequence of commands,
you need to tell the build tools about Ctalk.

Doing this mostly involves telling the utility `automake,' which helps
write `Makefiles' for the `make' program, how to build a Ctalk source
file into an executable.

The `make' program allows Makefiles to define rules to build different
types of input files into programs, libraries, and other types of data
files.

In order to distinguish a Ctalk file, we give it the file extension
`.ca'.  This lets the build tools know that the Ctalk program isn't a
standard C input file.

Then, in `Makefile.am' (consult the `automake' manual if you're not
certain what this is), you can define a rule to build a `.ca' file into
an `.o' object file.


     SUFFIXES=.ca .o

     .ca.o:
     	$(top_builddir)/src/ctalk -I $(top_builddir)/classes $< \
     	  -o `basename $ .o`.i ; \
     	$(CC) -c $(AM_CFLAGS) $(AM_CPPFLAGS) $(DEFS) -o $ `basename $< .ca`.i

Then, add another line to link the object file into a program.


     methods$(EXEEXT) : methods.o
     	$(CC) methods.o $(AM_LDFLAGS) $(LDFLAGS) $(LIBS) -o methods$(EXEEXT)

Note that this example comes from the `methods' program in the Ctalk
distribution, where, "methods," is the canonical name of the output
file, as defined in the `bin_PROGRAMS' macro.  That allows `make' to
install the program normally when you type, `make install.'

If you're using Ctalk for another package, you'll almost certainly want
to change the paths to something that uses an already-installed Ctalk.
In that case, `Makefile.am' might contain lines like these.


     SUFFIXES=.ca .o

     .ca.o:
     	/usr/local/bin/ctalk -I /usr/local/include/classes $< \
     	  -o `basename $ .o`.i ; \
     	$(CC) -c $(AM_CFLAGS) $(AM_CPPFLAGS) $(DEFS) -o $ `basename $< .ca`.i

Cleaning Up Extra Files
.......................

Note that the `basename' command in these examples handles the
translation of the `make' targets into an intermediate Ctalk file.

This way `make' doesn't need to worry about any intermediate files,
except that the `Makefile' should clean them up.

So to define rules to clean up the extra files after the build, include
`make' targets like these in `Makefile.am.'


     clean-local:
     	rm -f *.i

     distclean-local:
     	rm -f *.i

Running Ctalk Utilities in an Emacs Window
..........................................

The `doc/' subdirectory of the Ctalk source code distribution contains
the Emacs Lisp programs `classes.el', `methods-brief.el', and
`methods-full.el'.  They define simple Emacs Lisp functions that let
you capture the output of the Ctalk utilities in an Emacs window.

The documentation file, `ctalktools.info' contains descriptions of
these functions, and the files also contain instructions to install and
use them.


File: ctalk.info,  Node: Copying,  Next: GNU Free Documentation License,  Prev: C,  Up: Top

Copying and Distributing Ctalk
==============================

Ctalk is free software.  You can copy, distribute, and modify Ctalk
under the terms of the GNU General Public License, Version 3 (see,
`COPYING', in the Ctalk distribution).  You can also distribute
executable programs which link to the `ctalk' run time libraries under
the terms of the GNU Lesser General Public License, Version 3
(`COPYING.LIB' in the Ctalk distribution).


File: ctalk.info,  Node: GNU Free Documentation License,  Next: Index,  Prev: Copying,  Up: Top

GNU Free Documentation License
==============================


                             Version 1.1, March 2000
          Copyright (C) 2000  Free Software Foundation, Inc.
          59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

          Everyone is permitted to copy and distribute verbatim copies
          of this license document, but changing it is not allowed.



       0. PREAMBLE

          The purpose of this License is to make a manual, textbook, or other
          written document "free" in the sense of freedom: to assure everyone
          the effective freedom to copy and redistribute it, with or without
          modifying it, either commercially or noncommercially.  Secondarily,
          this License preserves for the author and publisher a way to get
          credit for their work, while not being considered responsible for
          modifications made by others.

          This License is a kind of "copyleft", which means that derivative
          works of the document must themselves be free in the same sense.
          It complements the GNU General Public License, which is a copyleft
          license designed for free software.

          We have designed this License in order to use it for manuals for
          free software, because free software needs free documentation: a
          free program should come with manuals providing the same freedoms
          that the software does.  But this License is not limited to
          software manuals; it can be used for any textual work, regardless
          of subject matter or whether it is published as a printed book.
          We recommend this License principally for works whose purpose is
          instruction or reference.


       1. APPLICABILITY AND DEFINITIONS

          This License applies to any manual or other work that contains a
          notice placed by the copyright holder saying it can be distributed
          under the terms of this License.  The "Document", below, refers to
          any such manual or work.  Any member of the public is a licensee,
          and is addressed as "you."

          A "Modified Version" of the Document means any work containing the
          Document or a portion of it, either copied verbatim, or with
          modifications and/or translated into another language.

          A "Secondary Section" is a named appendix or a front-matter
          section of the Document that deals exclusively with the
          relationship of the publishers or authors of the Document to the
          Document's overall subject (or to related matters) and contains
          nothing that could fall directly within that overall subject.
          (For example, if the Document is in part a textbook of
          mathematics, a Secondary Section may not explain any mathematics.)
          The relationship could be a matter of historical connection with
          the subject or with related matters, or of legal, commercial,
          philosophical, ethical or political position regarding them.

          The "Invariant Sections" are certain Secondary Sections whose
          titles are designated, as being those of Invariant Sections, in
          the notice that says that the Document is released under this
          License.

          The "Cover Texts" are certain short passages of text that are
          listed, as Front-Cover Texts or Back-Cover Texts, in the notice
          that says that the Document is released under this License.

          A "Transparent" copy of the Document means a machine-readable copy,
          represented in a format whose specification is available to the
          general public, whose contents can be viewed and edited directly
          and straightforwardly with generic text editors or (for images
          composed of pixels) generic paint programs or (for drawings) some
          widely available drawing editor, and that is suitable for input to
          text formatters or for automatic translation to a variety of
          formats suitable for input to text formatters.  A copy made in an
          otherwise Transparent file format whose markup has been designed
          to thwart or discourage subsequent modification by readers is not
          Transparent.  A copy that is not "Transparent" is called "Opaque."

          Examples of suitable formats for Transparent copies include plain
          ASCII without markup, Texinfo input format, LaTeX input format,
          SGML or XML using a publicly available DTD, and
          standard-conforming simple HTML designed for human modification.
          Opaque formats include PostScript, PDF, proprietary formats that
          can be read and edited only by proprietary word processors, SGML
          or XML for which the DTD and/or processing tools are not generally
          available, and the machine-generated HTML produced by some word
          processors for output purposes only.

          The "Title Page" means, for a printed book, the title page itself,
          plus such following pages as are needed to hold, legibly, the
          material this License requires to appear in the title page.  For
          works in formats which do not have any title page as such, "Title
          Page" means the text near the most prominent appearance of the
          work's title, preceding the beginning of the body of the text.


       2. VERBATIM COPYING

          You may copy and distribute the Document in any medium, either
          commercially or noncommercially, provided that this License, the
          copyright notices, and the license notice saying this License
          applies to the Document are reproduced in all copies, and that you
          add no other conditions whatsoever to those of this License.  You
          may not use technical measures to obstruct or control the reading
          or further copying of the copies you make or distribute.  However,
          you may accept compensation in exchange for copies.  If you
          distribute a large enough number of copies you must also follow
          the conditions in section 3.

          You may also lend copies, under the same conditions stated above,
          and you may publicly display copies.


       3. COPYING IN QUANTITY

          If you publish printed copies of the Document numbering more than
          100, and the Document's license notice requires Cover Texts, you
          must enclose the copies in covers that carry, clearly and legibly,
          all these Cover Texts: Front-Cover Texts on the front cover, and
          Back-Cover Texts on the back cover.  Both covers must also clearly
          and legibly identify you as the publisher of these copies.  The
          front cover must present the full title with all words of the
          title equally prominent and visible.  You may add other material
          on the covers in addition.  Copying with changes limited to the
          covers, as long as they preserve the title of the Document and
          satisfy these conditions, can be treated as verbatim copying in
          other respects.

          If the required texts for either cover are too voluminous to fit
          legibly, you should put the first ones listed (as many as fit
          reasonably) on the actual cover, and continue the rest onto
          adjacent pages.

          If you publish or distribute Opaque copies of the Document
          numbering more than 100, you must either include a
          machine-readable Transparent copy along with each Opaque copy, or
          state in or with each Opaque copy a publicly-accessible
          computer-network location containing a complete Transparent copy
          of the Document, free of added material, which the general
          network-using public has access to download anonymously at no
          charge using public-standard network protocols.  If you use the
          latter option, you must take reasonably prudent steps, when you
          begin distribution of Opaque copies in quantity, to ensure that
          this Transparent copy will remain thus accessible at the stated
          location until at least one year after the last time you
          distribute an Opaque copy (directly or through your agents or
          retailers) of that edition to the public.

          It is requested, but not required, that you contact the authors of
          the Document well before redistributing any large number of
          copies, to give them a chance to provide you with an updated
          version of the Document.


       4. MODIFICATIONS

          You may copy and distribute a Modified Version of the Document
          under the conditions of sections 2 and 3 above, provided that you
          release the Modified Version under precisely this License, with
          the Modified Version filling the role of the Document, thus
          licensing distribution and modification of the Modified Version to
          whoever possesses a copy of it.  In addition, you must do these
          things in the Modified Version:

          A. Use in the Title Page (and on the covers, if any) a title
          distinct    from that of the Document, and from those of previous
          versions    (which should, if there were any, be listed in the
          History section    of the Document).  You may use the same title
          as a previous version    if the original publisher of that version
          gives permission.
          B. List on the Title Page, as authors, one or more persons or
          entities    responsible for authorship of the modifications in the
          Modified    Version, together with at least five of the principal
          authors of the    Document (all of its principal authors, if it
          has less than five).
          C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.
          D. Preserve all the copyright notices of the Document.
          E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.
          F. Include, immediately after the copyright notices, a license
          notice    giving the public permission to use the Modified Version
          under the    terms of this License, in the form shown in the
          Addendum below.
          G. Preserve in that license notice the full lists of Invariant
          Sections    and required Cover Texts given in the Document's
          license notice.
          H. Include an unaltered copy of this License.
          I. Preserve the section entitled "History", and its title, and add
          to    it an item stating at least the title, year, new authors, and
            publisher of the Modified Version as given on the Title Page.
          If    there is no section entitled "History" in the Document,
          create one    stating the title, year, authors, and publisher of
          the Document as    given on its Title Page, then add an item
          describing the Modified    Version as stated in the previous
          sentence.
          J. Preserve the network location, if any, given in the Document for
            public access to a Transparent copy of the Document, and
          likewise    the network locations given in the Document for
          previous versions    it was based on.  These may be placed in the
          "History" section.     You may omit a network location for a work
          that was published at    least four years before the Document
          itself, or if the original    publisher of the version it refers
          to gives permission.
          K. In any section entitled "Acknowledgements" or "Dedications",
          preserve the section's title, and preserve in the section all the
           substance and tone of each of the contributor acknowledgements
          and/or dedications given therein.
          L. Preserve all the Invariant Sections of the Document,
          unaltered in their text and in their titles.  Section numbers
          or the equivalent are not considered part of the section titles.
          M. Delete any section entitled "Endorsements."  Such a section
          may not be included in the Modified Version.
          N. Do not retitle any existing section as "Endorsements"    or to
          conflict in title with any Invariant Section.

          If the Modified Version includes new front-matter sections or
          appendices that qualify as Secondary Sections and contain no
          material copied from the Document, you may at your option
          designate some or all of these sections as invariant.  To do this,
          add their titles to the list of Invariant Sections in the Modified
          Version's license notice.  These titles must be distinct from any
          other section titles.

          You may add a section entitled "Endorsements", provided it contains
          nothing but endorsements of your Modified Version by various
          parties-for example, statements of peer review or that the text has
          been approved by an organization as the authoritative definition
          of a standard.

          You may add a passage of up to five words as a Front-Cover Text,
          and a passage of up to 25 words as a Back-Cover Text, to the end
          of the list of Cover Texts in the Modified Version.  Only one
          passage of Front-Cover Text and one of Back-Cover Text may be
          added by (or through arrangements made by) any one entity.  If the
          Document already includes a cover text for the same cover,
          previously added by you or by arrangement made by the same entity
          you are acting on behalf of, you may not add another; but you may
          replace the old one, on explicit permission from the previous
          publisher that added the old one.

          The author(s) and publisher(s) of the Document do not by this
          License give permission to use their names for publicity for or to
          assert or imply endorsement of any Modified Version.


       5. COMBINING DOCUMENTS

          You may combine the Document with other documents released under
          this License, under the terms defined in section 4 above for
          modified versions, provided that you include in the combination
          all of the Invariant Sections of all of the original documents,
          unmodified, and list them all as Invariant Sections of your
          combined work in its license notice.

          The combined work need only contain one copy of this License, and
          multiple identical Invariant Sections may be replaced with a single
          copy.  If there are multiple Invariant Sections with the same name
          but different contents, make the title of each such section unique
          by adding at the end of it, in parentheses, the name of the
          original author or publisher of that section if known, or else a
          unique number.  Make the same adjustment to the section titles in
          the list of Invariant Sections in the license notice of the
          combined work.

          In the combination, you must combine any sections entitled
          "History" in the various original documents, forming one section
          entitled "History"; likewise combine any sections entitled
          "Acknowledgements", and any sections entitled "Dedications."  You
          must delete all sections entitled "Endorsements."


       6. COLLECTIONS OF DOCUMENTS

          You may make a collection consisting of the Document and other
          documents released under this License, and replace the individual
          copies of this License in the various documents with a single copy
          that is included in the collection, provided that you follow the
          rules of this License for verbatim copying of each of the
          documents in all other respects.

          You may extract a single document from such a collection, and
          distribute it individually under this License, provided you insert
          a copy of this License into the extracted document, and follow
          this License in all other respects regarding verbatim copying of
          that document.


       7. AGGREGATION WITH INDEPENDENT WORKS

          A compilation of the Document or its derivatives with other
          separate and independent documents or works, in or on a volume of
          a storage or distribution medium, does not as a whole count as a
          Modified Version of the Document, provided no compilation
          copyright is claimed for the compilation.  Such a compilation is
          called an "aggregate", and this License does not apply to the
          other self-contained works thus compiled with the Document, on
          account of their being thus compiled, if they are not themselves
          derivative works of the Document.

          If the Cover Text requirement of section 3 is applicable to these
          copies of the Document, then if the Document is less than one
          quarter of the entire aggregate, the Document's Cover Texts may be
          placed on covers that surround only the Document within the
          aggregate.  Otherwise they must appear on covers around the whole
          aggregate.


       8. TRANSLATION

          Translation is considered a kind of modification, so you may
          distribute translations of the Document under the terms of section
          4.  Replacing Invariant Sections with translations requires special
          permission from their copyright holders, but you may include
          translations of some or all Invariant Sections in addition to the
          original versions of these Invariant Sections.  You may include a
          translation of this License provided that you also include the
          original English version of this License.  In case of a
          disagreement between the translation and the original English
          version of this License, the original English version will prevail.


       9. TERMINATION

          You may not copy, modify, sublicense, or distribute the Document
          except as expressly provided for under this License.  Any other
          attempt to copy, modify, sublicense or distribute the Document is
          void, and will automatically terminate your rights under this
          License.  However, parties who have received copies, or rights,
          from you under this License will not have their licenses
          terminated so long as such parties remain in full compliance.


      10. FUTURE REVISIONS OF THIS LICENSE

          The Free Software Foundation may publish new, revised versions of
          the GNU Free Documentation License from time to time.  Such new
          versions will be similar in spirit to the present version, but may
          differ in detail to address new problems or concerns.  See
          http://www.gnu.org/copyleft/.

          Each version of the License is given a distinguishing version
          number.  If the Document specifies that a particular numbered
          version of this License "or any later version" applies to it, you
          have the option of following the terms and conditions either of
          that specified version or of any later version that has been
          published (not as a draft) by the Free Software Foundation.  If
          the Document does not specify a version number of this License,
          you may choose any version ever published (not as a draft) by the
          Free Software Foundation.


     ADDENDUM: How to use this License for your documents

        To use this License in a document you have written, include a copy of
     the License in the document and put the following copyright and license
     notices just after the title page:

          Copyright (C)  YEAR  YOUR NAME.
          Permission is granted to copy, distribute and/or modify this document
          under the terms of the GNU Free Documentation License, Version 1.1
          or any later version published by the Free Software Foundation;
          with the Invariant Sections being LIST THEIR TITLES, with the
          Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
          A copy of the license is included in the section entitled "GNU
          Free Documentation License."

        If you have no Invariant Sections, write "with no Invariant Sections"
     instead of saying which ones are invariant.  If you have no Front-Cover
     Texts, write "no Front-Cover Texts" instead of "Front-Cover Texts being
     LIST"; likewise for Back-Cover Texts.

        If your document contains nontrivial examples of program code, we
     recommend releasing these examples in parallel under your choice of
     free software license, such as the GNU General Public License, to
     permit their use in free software.

