This is ctalk.info, produced by makeinfo version 6.7 from ctalk.texi.

INFO-DIR-SECTION Ctalk
START-INFO-DIR-ENTRY
* ctalk: (ctalk).	The Ctalk language reference manual.
END-INFO-DIR-ENTRY

This file documents Ctalk version 0.67 2021-03-11.

Copyright (C) 2007-2021 Robert Kiesling

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled, "GNU
Free Documentation License."


File: ctalk.info,  Node: Key,  Next: Vector,  Prev: Symbol,  Up: Classes

'Key' Class
-----------

Objects of class 'Key' are key-value pairs.  Other classes and programs
can use 'Key' objects' names when looking up objects.  The value of a
key object is a reference to the value object.

Many of the 'Collection' subclasses are composed entirely of 'Key'
objects, which act as the "glue" that maintains references to the the
actual contents of the collection.  *Note Collection::.

Programs can also manipulate 'Key' objects independently.  Most of the
math operators that work with collections actually work with 'Key'
objects.  So it's important to add the attribute
OBJECT_IS_MEMBER_OF_PARENT_COLLECTION to a 'Key' object when building
collections.  This tells Ctalk that the 'Key' object can be used
independently, as well as part of its parent collection.  *Note
Attributes::.

Here's a program that manipulates the 'Key' objects of a collection
(here, an 'AssociativeArray') directly.  *Note AssociativeArray::.


     int main (int argc, char **argv) {

       AssociativeArray new a;
       Key new k;

       a atPut "key1", "value1";
       a atPut "key2", "value2";
       a atPut "key3", "value3";
       a atPut "key4", "value4";

       k = *a;

       while (++k)
         printf ("%s --> %s\n", k name, *k);

     }


Instance Variables
------------------

'value'
     The value is the formatted representation of a hexadecimal pointer
     to a memory address.

Instance Methods
................

'+ (Integer N)'
     Increments the receiver by N.  For a 'Key' object, this sets the
     receiver to the NTH successive element in a collection.  The
     increments are numbered with '1' pointing to the first member of
     the collection, and so on.  If there are no more elements, the
     receiver's value is NULL. For an example, refer to '-', below.

'++'
     Increments the receiver to point to the next 'Key' in a collection.
     If the receiver is already the last item item in the collection,
     the value of the receiver after it is incremented is NULL. This
     method works as both a prefix and postfix method, and increments
     the receiver either before or after it is referenced, respectively.

     Here is an example of how to iterate over an 'AssociativeArray'
     using '++'.


            AssociativeArray new a;
            Key new k;

            a atPut "key1", "value1";
            a atPut "key2", "value2";
            a atPut "key3", "value3";
            a atPut "key4", "value4";

            k = *a;

            while (++k)
              printf ("%s --> %s\n", k name, *k);


'- (Integer N)'
     Decrements the receiver by N.  For a 'Key' object, this sets the
     receiver to the NTH previous element of the collection that the
     receiver is a member of.  Here is a brief example


          int main () {

            AssociativeArray new a;
            Key new k;

            a atPut "1", "value1";
            a atPut "2", "value2";
            a atPut "3", "value3";
            a atPut "4", "value4";

            k = *a;
            printf ("%s --> %s\n", k name, *k);
            k = k + 3;
            printf ("%s --> %s\n", k name, *k);
            k = k - 1;
            printf ("%s --> %s\n", k name, *k);
          }


     Running this program produces the following output.


          1 --> value1
          4 --> value4
          3 --> value3


'--'
     Decrements the receiver to point to the previous 'Key' in a
     collection.  If the receiver is the first item in the collection,
     the value of the receiver after it is decremented is NULL. Like
     '++', this method works as both a prefix and postfix method, and
     decrements the receiver either before or after it is referenced,
     respectively.

'='
     If the receiver refers to an object reference (that is, preceded by
     a '*' operator), sets the value of the receiver to the address of
     the argument.  Otherwise, sets the receiver to refer to the
     argument.

'getKeyObject (void)'
     Return the receiver.

'setName (char *KEY_NAME)'
     Set the receiver's name to the argument, a 'String' object.

     _Note:_ In some cases, the object's name is the only way that Ctalk
     can refer to it.  In that case, the program needs to maintain an
     alias to the object, like an 'OBJECT *,' so that it can refer to
     the object later.  In the following example, the program can refer
     to 'keyObject' by using 'key_alias_ptr,' regardless of the object's
     name.
          Key new keyObject;
          OBJECT *key_alias_ptr;
          ...
          key_alias_ptr = KeyObject setName keyNameString;

'ulink (void)'
     Detach the receiver object from its parent collection.  The method
     also removes the OBJECT_IS_MEMBER_OF_PARENT_COLLECTION attribute
     from the receiver.


File: ctalk.info,  Node: Vector,  Prev: Key,  Up: Classes

'Vector' Class
--------------

Objects of 'Vector' class refer to blocks of memory of arbitrary length.
The memory area that the 'Vector' object points to may contain any data,
including NULL bytes.

Whenever a program or method assigns a 'Vector' object a new area of
memory, the program or method also sets the 'Vector' object's 'length'
instance variable; for example, the method 'readVec' (class
'ReadFileStream') records the memory area's size in the 'length'
instance variable after it has read a chunk of data from a disk file.
*Note ReadFileStream::.

Here's an example program that writes a copy of a JPEG image file.


     int main () {
       ReadFileStream new readF;
       WriteFileStream new writeF;
       FileStream new f;
       Vector new vec;
       LongInteger new size;

       readF openOn "original.jpeg";
       readF statStream;
       size = readF streamSize;

       vec = readF readVec size;

       writeF openOn "copy.jpeg";
       writeF writeVec vec;

       writeF closeStream ;
       readF closeStream;
     }


Instance Variables
..................

'length'
     An 'Integer' that contains the size in bytes of the memory area
     that the 'Vector' object points to.

Instance Methods
................

'+ (Vector V)'
     Return a 'Vector' object that is the concatenation of the receiver
     and the argument.

'+= (Vector V)'
     Concatenate the receiver with the vector given as the argument.

'asString (void)'
     Returns the value of the receiver as a 'String' object terminated
     with a NUL byte to the value of the receiver's 'length' instance
     variable.  Does not check for NULs or non-printing characters in
     the value, so the returned 'String' may still be truncated to less
     than the receiver's length.

'basicNew (char *NAME, char *VALUE, int VALUE_LENGTH'
'basicNew (char *NAME, char *CLASSNAME, char *SUPERCLASSNAME, char *VALUE, int VALUE_LENGTH)'
     Create a new 'Vector' object with the name, contents, length, and,
     optionally, class name and superclass name given as the arguments.

     For the five-argument form of 'basicNew', the class should be
     'Vector' and the superclassname should be 'Symbol', unless the
     program has subclassed 'Vector'.

     In the three-argument form, the receiver must be a member of
     'Vector' class or its subclasses, in which case the method takes
     the class and superclass from the receiver, as in this example.


          myBuf = Vector basicNew "memorybuf", memory_buf_ptr, memory_buf_length;


     The VALUE argument may be any memory address that points to data of
     arbitrary size, and may contain any data, including NULL bytes.

     The VALUE_LENGTH argument supplies the length of the memory segment
     in bytes, which the returned 'Vector' object stores in its 'length'
     instance variable.

     Most of the internal work of setting the values and attributes of
     the returned object, and registering the memory area, is performed
     by '__ctalkSetObjectValueAddr', which each of these methods call.
     *Note ctalkSetObjectValueAddr::.

     It's also necessary that these methods take care of other
     initialization tasks which are necessary for all classes of
     objects.  They're described in general in the description of
     'basicNew' ('Object' class).  *Note ObjectbasicNew::.

'contains (String PATTERN)'
'contains (String PATTERN, Integer start_offset)'
     With one argument, returns an 'Integer' with the byte offset of the
     first occurence of PATTERN in the receiver, starting from the
     beginning of the receiver's value, or -1 if the pattern is not
     found.

     If a second argument is given, it contains the 'Integer' offset
     into the buffer where the method begins its search.  That allows
     programs to find multiple matches of the same pattern in the
     receiver's value.


File: ctalk.info,  Node: Methods,  Next: C,  Prev: Classes,  Up: Top

Methods
=======

The following sections outline some of the programming features that
Ctalk methods implement.  The 'Ctalk Tutorial' provides step-by-step
instructions on how to write some common method types.

Declaring a method is similar to declaring a C function, but the
declaration syntax adds some additional features.

   * The declaration specifies the class that the method belongs to.
   * The statement allows the method to be identified by an alias, so
     the method can overload operators.  Classes can implement
     overloaded methods in other ways, too.  *Note Overloading::.

To declare an instance method, use the 'instanceMethod' keyword, as in
the following example.

     String instanceMethod = set_value (char *s) {

      ... method statements

     }

This example declares an instance method, '=', which is recognized by
objects that belong to the class 'String' and its subclasses.  The '='
in the declaration overloads C's '=' operator, so that, instead of
assigning a value to a C variable, the method sets the value of its
receiver.

In this example, the receiver is an instance of class 'String.'

     newObject = "Hello, World!";

If the variable reference immediately preceding '=' refers to a C
variable, then '=' behaves as the C operator, '=.'

Ctalk can use most C operators as methods, with the exception of
parentheses and prefix operators.  Receivers always precede the method
message.

For example, the 'Integer' methods 'invert' and 'bitComp' perform the
same operations as the C prefix operators '!' and '~.'
     int i;              /* C variable. */
     Integer new myInt;  /* Ctalk object. */

     i = 0;
     myInt = 0;

     /* These two statements are equivalent. */
     printf ("%d", !i);
     printf ("%d", myInt invert).

     /* And so are these two statements. */
     printf ("%d", ~i);
     printf ("%d", myInt bitComp);

Declaring Methods
-----------------

The declaration syntax for instance methods is:

     CLASSNAME 'instanceMethod' [ALIAS] FUNCNAME (ARGS) { METHOD BODY }

and for class methods:

     CLASSNAME 'classMethod' [ALIAS] FUNCNAME (ARGS) { METHOD BODY }

If ALIAS is omitted, Ctalk refers to the method by FUNCNAME.

In the example at the beginning of this section, if '=' were omitted, a
program could refer to the method by the message, 'set_value.'

With the exception of the primitive methods 'class', 'new',
'classMethod', and 'instanceMethod', Ctalk declares methods in its class
library, or in the program input.  *Note Classes::.

Method Parameters
-----------------

You can use Ctalk class objects to declare method parameters, but you
can also declare parameters using C data types, in order to prevent
class libraries from being loaded recursively.  This is necessary in
many of the basic classes.

Regardless of how you declare method parameters, when the method's
message is sent to an object, Ctalk translates C language arguments into
class objects.

For example, these two declarations are equivalent.
     Integer instanceMethod + add (int i) {
     ...
     }

     Integer instanceMethod + add (Integer i) {
     ...
     }

Ctalk does not use objects in C function arguments, so if you need to
use objects as parameters, you must write a method instead of a C
function.

* Menu:

* Method API::            The method application programming interface.
* Self and super::        How to refer to receivers and superclass methods.
* Class initialization::  How to set class variables at run time.
* Translating::           C to objects and back again.
* C Macros::              Macros that provide convenient shortcuts.
* Prefixes::              Methods can also overload C unary operators.
* Required classes::      Preloading classes that you will need.
* Scoping::               An object can have many scopes.
* Templates::             Method wrappers for C-language tasks.
* Return values::         How to return objects of various classes.
* Variable arguments::    Calling C library functions with variable arguments.
* Overloading::           How Ctalk works with multiple method definitions.
* Variable method arguments::
                          Ctalk allows flexible argument lists.
* Method functions::      Methods that are called as C functions.
* Errors::                Exception and error handling.
* Cautions::              Precautions for using objects with C variables.
* Method keywords::       Ctalk keywords that apply to methods.
* Documentation::         Describing methods, classes, and variables
                          in publicly visible comments.
* Ctalk library::         Library function reference.


File: ctalk.info,  Node: Method API,  Next: Self and super,  Up: Methods

Method Application Programming Interface
----------------------------------------

This section describes the C functions and macros that methods use to
interface with the Ctalk run time libraries and with each other.

At this point, the method API is still developing, and relies heavily on
C library functions.

This example shows method '+' of class 'Integer', which adds two Integer
objects, creates an object for the result, and returns the result.

     Integer instanceMethod + add (int i) {

       OBJECT *op1, *op2;

       op1 = self value;
       op2 = i value;

       methodReturnInteger(atoi(op1->__o_value) + atoi(op2->__o_value))
     }

The keyword 'self' refers to the receiver of the method.  *Note Self and
super::.

The variables 'op1' and 'op2' are the 'value' instance variables of the
receiver and the argument.  Ctalk has a method, 'value' (class
'Object'), which returns the 'value' instance variable, but you can also
refer to instance variables by sending an instance variable's name as a
message to an object.

Internally, the receiver, arguments, and return value of a method are
all 'OBJECT *'.  When you use C functions with objects, you use the
members of an OBJECT type, a 'struct.' (*Note OBJECT typedef::.)  If you
declare an object as a C 'OBJECT *,' then the method uses it like any
other C 'struct *.'

All methods return an 'OBJECT *' as the result.  The macro
'methodReturnInteger' defines the object that the method returns.  *Note
Return values::.

The 'add' method is in 'classes/Integer'.  The file 'include/object.h'
contains the declaration of the 'OBJECT' type.


File: ctalk.info,  Node: Self and super,  Next: Class initialization,  Prev: Method API,  Up: Methods

'self' and 'super'
------------------

The keywords 'self' and 'super' refer to the method's receiver object
and a method in a superclass of the receiver's class, respectively.

Refer to the method '+' (class 'Integer') from the previous section.  If
you call '+' with the statement below, 'self' in the '+' method would
refer to 'i.'

     j = i + 2;

The 'super' keyword refers to a method in one of the superclasses of the
receiver.  It is commonly used in constructors.

For example, if a class implements its own 'new' method that performs
additional initialization for instances of a class, it can also call
'new' implemented by a superclass.

This constructor from the 'ReadFileStream' method, 'new', also calls
'new' from class 'Object.'

     ReadFileStream instanceMethod new (char *name) {

       ReadFileStream super new name;

       __ctalkInstanceVarsFromClassObject (name);

       ReadFileStream classInit;

       return name;
     }

The first statement, 'ReadFileStream super new name,' calls 'new' from
class 'Object' before performing its own initialization.


File: ctalk.info,  Node: Class initialization,  Next: Prefixes,  Prev: Self and super,  Up: Methods

Class Initialization
--------------------

Some classes that have class variables require initialization when the
program is run.  For example, class 'ReadFileStream' needs to have its
class variable 'stdinStream' set to the application's 'stdin' file
stream before the program can read from standard input.  For this, you
would use the library function 'xstdin', and use its value in
'stdinStreamVar'.


     __ctalkObjValPtr (stdinStreamVar, xstdin ());


Classes that require class variable initialization need to define a
method, 'classInit', which is called by a constructor when the first
object is created.  An example is the 'ReadFileStream' method 'new' from
the previous section.

Here is the 'classInit' method for class 'ReadFileStream'.


     ReadFileStream classMethod classInit (void) {
       "Initializes the classes' standard input stream.  This
       method is normally called by the ReadFileStream
       constructor.  The method needs to be called only once;
       on further calls to 'new', it is a no-op."
       OBJECT *classObject,
         *stdinStreamVar,
         *classInitVar;

       if (self classInitDone)
         return NULL;

       classObject = __ctalkGetClass ("ReadFileStream");
       stdinStreamVar = __ctalkFindClassVariable ("stdinStream", TRUE);
       __ctalkInstanceVarsFromClassObject (stdinStreamVar);

       __ctalkObjValPtr (stdinStreamVar, xstdin ());

       classInitVar =
         __ctalkCreateObjectInit ("classInitDone", "Integer",
     			     "Magnitude",
     			     classObject -> scope, "1");
       __ctalkAddClassVariable (classObject, "classInitDone", classInitVar);

       return NULL;
     }


A 'classInit' method needs to be called only once.  The method checks
the 'classInitDone' instance variable to determine the method has
already performed the initialization that the class needs.


File: ctalk.info,  Node: Prefixes,  Next: Translating,  Prev: Class initialization,  Up: Methods

Overloading C Unary Operators
-----------------------------

Methods can also overload C unary operators like '*', '&', '!', '~', and
'sizeof'.  For most unary operators, if the class defines a method to
overload the operator, then Ctalk uses the method; otherwise, it treats
the operator as a normal C operator.

Methods that overload unary operators contain the '__prefix__' attribute
in their declaration.  This simplifies method writing considerably,
because that allows a class to define two different method '*' methods,
for example, one a unary dereference operator, the other a
multiplication operator.

In the method's declaration, use the '__prefix__' attribute in place of
paramter declarations, as in this example.
     String instanceMethod * deref_prefix (__prefix__) {
     ... Method statements here ...
     }

When Ctalk encounters a 'sizeof' operator, it checks whether the
argument is a Ctalk object, or a C variable or type cast expression.  If
the argument is a C variable or type cast expression, then Ctalk uses
the C 'sizeof' operator.  Otherwise, it uses the 'sizeof' method
('Object' class).  This method's implementation is simple: it treats a
Ctalk object as an 'OBJECT *', and returns the size in bytes of a
pointer on the system.  On 32-bit systems, the 'sizeof' method always
returns 4.  However, you can overload the 'sizeof' operator in your own
classes if necessary.

You need to take care when using unary operators in complex statements,
due to the precedence of Ctalk's method messages.  In the following
highly experimental example, you would need to use parentheses to
specify the order of evaluation, because the expression needs the result
of '(*s) asString' to be a 'String' also.
     String new s;
     String new sFirstChar;
     Character new c;
     Integer new i;
     s = "Hello, ";
     sFirstChar = (*s) asString;
Ctalk also provides postfix equivalents for many of these operators,
like 'deref' (class 'Symbol') and 'invert' ('Character,' 'Integer,' and
'LongInteger' classes).

Ctalk can overload these operators even if the class defines a method
that uses the operator with an argument.  For example, the pointer ('*')
and unary minus ('-') operators can have different methods than the
methods that perform multiplication and subtraction.

The subject of method overloading is discussed further in its own
section.  *Note Overloading::.


File: ctalk.info,  Node: Translating,  Next: C Macros,  Prev: Prefixes,  Up: Methods

Translating C Variables into Object Values
------------------------------------------

The 'OBJECT' C data type that Ctalk uses internally stores objects'
values as C 'char *''s.  *Note OBJECT typedef::.

To store numeric values, you must format them as character strings,
using, for example, 'sprintf'.  In many cases, however, Ctalk performs
this translation automatically.

'Integer' objects can also translate values with 'atoi(3)' or
'__ctalkDecimalIntegerToASCII'. Other scalar data types have
corresponding functions that translate numbers to character strings.

If for some reason you need to translate an object to its C type or back
again, the Ctalk library provides the following functions.

'__ctalkToCArrayElement (OBJECT *O)'
     Translate the value of an 'Integer,' 'Character,' 'String,' or
     'LongInteger' array element to a 'void *' that points to its
     corresponding C data type.

'__ctalkToCCharPtr (OBJECT *O, int KEEP)'
     Translate the value of a 'String' object into a C 'char *.' If KEEP
     is 'FALSE', delete O.

'__ctalkToCIntArrayElement (OBJECT *O)'
     Translate the value of an 'Integer' array element to an 'int.'

'__ctalkToCInteger (OBJECT *O, int KEEP_OBJECT)'
     Translate the value of an 'Integer' to an 'int.' If KEEP_OBJECT is
     'FALSE,' then delete the object.

'__ctalkToCInteger (OBJECT *O, int KEEP_OBJECT)'
     Translate the value of an 'Integer' to a 'long int.' If KEEP_OBJECT
     is 'FALSE,' then delete the object.

'__ctalk_to_c_char_ptr (OBJECT *O)'
     Translate the value of a 'String' object into a C 'char *.' Note:
     This function is being phased out.  Use '__ctalkToCCharPtr ()',
     above, instead.

'__ctalk_to_c_double (OBJECT *O)'
     Translate the value of a 'Float' object into a C 'double.'

'__ctalk_to_c_int (OBJECT *O)'
     Translate the value of an 'Integer' object into a C 'int.'

'__ctalk_to_c_longlong (OBJECT *OBJ, int KEEP)'
     Translate the value of a 'LongInteger' object into a C 'long long
     int.' If KEEP is non-zero, does not delete OBJ, or, in compound
     expressions that need to interface with C variables, (like complex
     if-statement conditionals), whether to delete the library's
     internal C variable registrations.

     Formats the arguments of the second-most calling method and prints
     them on the receiver.  This function is meant to be used within a
     method that is called by another method.  One method that uses this
     function is 'String : vPrintOn'.  Refer to 'String : vPrintOn' for
     an example of this function's use.  *Note vPrintOn--class String::

'__ctalkCBoolToObj (bool B)'
     Create a 'Boolean' object with the boolean (either true or false)
     value of the argument.

'__ctalkCCharPtrToObj (char *S)'
     Create a 'String' object with the value S.

'__ctalkClassLibraryPath (void)'
     Return a 'char *' containing the directories that Ctalk searches
     for class libraries.  When compiling programs Ctalk searches first
     for directories given as arguments to the '-I' option, then
     directories given by the 'CLASSLIBDIRS' environment variable, then
     the standard class library directory which is defined when Ctalk is
     built.  In addition, for each directory, if a subdirectory named
     'ctalk' exists, then Ctalk searches that subdirectory also.

     The standard library directory defaults to
     '/usr/local/include/ctalk', although if you define a different
     '--prefix' when building and installing Ctalk, the class libraries
     will be located in PREFIX'/include/ctalk'.

     If it is necessary to look up class libraries at run time, Ctalk
     first searches the directories listed by the 'CLASSLIBDIRS'
     environment variable, then the default class library directory
     mentioned above.

'__ctalkClassSearchPath (void)'
     A synonym for '__ctalkClassLibraryPath()', above.

'__ctalkCDoubleToObj (double F)'
     Create a 'Float' object with the value F.

'__ctalkCIntToObj (int I)'
     Create an 'Integer' object with the value I.

'__ctalkCLongLongToObj (long long int L)'
     Create a 'LongInteger' object with the value L.

'__ctalkCSymbolToObj (unsigned int LABEL)'
     Create a 'Symbol' object with the value that is the address of
     LABEL.  This is used for expressions where a function name appears
     by itself, for example.  In that case, the result is a 'Symbol'
     object with the address of the function.

The functions that create objects give the objects the scope of the
function call, either global or local.

_Note:_ In future versions of Ctalk, the names of these functions are
likely to change.


File: ctalk.info,  Node: C Macros,  Next: Required classes,  Prev: Translating,  Up: Methods

C Macros
--------

Ctalk also provides many macros that help standardize the Ctalk-to-C
conventions.  They're defined in the 'ctalkdefs.h' include file.  To use
them, include 'ctalkdefs.h' in a source file or class library.


     #include <ctalk/ctalkdefs.h>


Some of the macro definitions in 'ctalkdefs.h' are described here.

'ARG'
     With a numeric argument, retrieves the n'th method or template
     argument from the stack; i.e., 'ARG(0)' refers to the first
     argument on the stack, 'ARG(1)' retrieves the second argument, and
     so on.

'CLASSNAME'
     Returns an object's classname.

     _Note:_ You should use this macro in new code.  While typing
     '__o_classname' directly with an 'OBJECT *' should work for a
     while, it's going to be phased out.

     Using __o_classname with an object and the '->' method is still
     okay, though.  For example:


            OBJECT *myObjRef;
            String new myString;

            /* The use of __o_classname as struct member is going away... */
            myObjRef -> __o_classname;
            /* Instead, write this. */
            myObjRef -> CLASSNAME;

            /* These are still okay, because -> is a method, not the C operator. */
            myString -> __o_classname;
            self -> __o_classname;

            /* The same is true for the SUPERCLASSNAME definition. */

            SUPERCLASSNAME(myObjRef);

            self -> SUPERCLASSNAME;
            myString ->  SUPERCLASSNAME;

'FILEEOF'
     Writes an fEOF to the 'char *' buffer given as its argument.

'FMT_0XHEX'
     When used with a function like 'sprintf ()', formats a pointer into
     its string representation.  For example:


          char buf[64];
          OBJECT *my_object_ptr;

          ....   /* Do stuff. */

          sprintf (buf, FMT_0XHEX(my_object_ptr));


     However, this macro is not very portable and using functions that
     use stdargs (e.g., printf, scanf, etc.)  can be cumbersome.
     Library functions like '__ctalkGenericPtrFromStr ()' *Note
     ctalkGenericPtrFromStr::, and '__ctalkFilePtrFromStr ()' *Note
     ctalkFilePtrFromStr::, might be faster and more reliable.

'IS_OBJECT'
     Returns True or False if its argument, a C pointer, refers to a
     valid object.

'IS_VALUE_INSTANCE_VAR'
     Returns True or False if its argument, a C pointer, refers to the
     value instance variable of an object.

'MEMADDR'
     Casts its operand to a 'void **', which is what Ctalk's internal
     function '__xfree ()' uses when freeing memory.  Normally you
     should use __ctalkFree () to free memory, but the MEMADDR macro is
     here in case you want to call __xfree () directly.  Refer to the
     entry for __ctalkFree () for details.  *Note ctalkFree::.

'STR_0XHEX_TO_PTR'
     Does the converse of 'FMT_0XHEX;' it converts the string
     representation of a pointer into an actual pointer, when used with
     a function like 'sscanf ()'.  For example:


          OBJECT *my_object;
          OBJECT *my_object_ptr;

          sscanf (my_object -> __o_value, STR_0XHEX_TO_PTR(my_object_ptr));


     Again, using stdargs functions can be cumbersome and not very
     portable.  In many cases, '__ctalkObjValPtr ()' accomplishes the
     same thing.  *Note ctalkObjValPtr::.

'SUPERCLASSNAME'
     Returns an object's superclass name.  This macro should be used
     only with OBJECT *'s, as it is rather extensive and written in C.
     Returns an empty string if the object doesn't have a superclass.
     *Note CLASSNAMEMacro::, above.

'__LIST_HEAD(List *l)'
     When given an argument that is a collection like a 'List' object,
     returns the first member of the collection.

'STR_IS_NULL(char *s)'
     Evaluates to True if the 'char *' argument evaluates to zero; i.e.,
     its value is '(null)', '0', '0x0' or the first character is an
     ASCII 'NUL' ('\0') byte.


File: ctalk.info,  Node: Required classes,  Next: Scoping,  Prev: C Macros,  Up: Methods

Required Classes
----------------

The keyword 'require' tells 'ctalk' to preload the class given as its
argument before any other classes or methods.

The following lines appear in the 'ctalklib' library.

     require Object;
     require Symbol;
     require String;

These statements tell 'ctalk' to first load the 'Object' class and its
methods, and then load the class 'Symbol' and its methods, and then
class 'String.' Ctalk loads the class and its methods at that point in
the program, before further processing of the source file.

The 'require' keyword always occurs in a global scope; that is, outside
of any method or function.


File: ctalk.info,  Node: Scoping,  Next: Templates,  Prev: Required classes,  Up: Methods

Scope of Objects
----------------

In Ctalk, an object can have a number of different scopes, and Ctalk
implements many more scopes for objects than for C variables.

All of the scopes are available when creating and modifying objects.  In
practice, however, you should only need to use a few of them.  Ctalk
uses many of the scopes internally.

These are the scopes that Ctalk implements.

'GLOBAL_VAR'
     An object that is declared globally; that is, outside of any
     function or method.
'LOCAL_VAR'
     An object declared within a function or method.
'ARG_VAR'
     An object derived from a C function argument that is used within a
     Ctalk expression.  This scope is normally used only internally.
'RECEIVER_VAR'
     An object created internally for receiver objects that do not
     already have objects.  Ctalk assigns RECEIVER_VAR objects C
     constants and constant expressions when they are used as receivers.
'PROTOTYPE_VAR'
     Used by the front end when evaluating objects that are declared as
     method parameters.
'CREATED_PARAM'
     Used mainly for temporary objects that are derived from C constants
     that are arguments to methods and functions.
'CVAR_VAR_ALIAS_COPY'
     Used for temporary and non-temporary objects that are created from
     C variables.
'CREATED_CVAR_SCOPE'
     This is a combination of CVAR_VAR_ALIAS_COPY|LOCAL_VAR scopes.
     Used for C variable objects that are only needed for the duration
     of an expression.  Also used for other values that aren't needed
     after an expression has been evaluated, like boolean method return
     values.
'SUBEXPR_CREATED_RESULT'
     Used internally for temporary objects that are the results of
     subexpressions.
'VAR_REF_OBJECT'
     Used for objects that are referred to by other objects; for example
     an object referred to by a 'Symbol' object may have this scope set.
'METHOD_USER_OBJECT'
     This scope is used mostly internally for objects that are returned
     by methods and saved as method resources.
'TYPECAST_OBJECT'
     Used internally for temporary objects that are derived from C type
     cast expressions.
You set a new object's scope with the '__ctalkCreateObject' or
'__ctalkCreateObjectInit' functions.  To change an existing object's
scope, use the '__ctalkSetObjectScope' library function to set an
object's scope.

Even though you can set an 'OBJECT *''s 'scope' directly, using these
functions insures that the object and all of its instance variables
maintain the same scope.

When creating an object with a function like '__ctalkCreateObjectInit',
you can declare a scope directly.
     result = __ctalkCreateObjectInit ("result",
                                       "Symbol", "Object",
                                       LOCAL_VAR, "0x0");
When altering the scope of an existing object, however, you should add
or subtract only that scope from the object's existing scope.

For example, to add a 'VAR_REF_OBJECT' scope to an object:
     __ctalkSetObjectScope (object, object -> scope | VAR_REF_OBJECT);
To remove the scope, use an expression like this.
     __ctalkSetObjectScope (object, object -> scope & ~VAR_REF_OBJECT);

For values of integral classes like 'Integer', 'LongInteger' or
'Symbol', '__ctalkCreateObjectInit' tries to convert the VALUE parameter
to its numeric value.  It the function can't figure out a way to convert
the argument to its numeric value, it issues a warning message.


     ctalk: can't convert d to an int.


In these cases (and in many others) it is easier to simply use an empty
string as the final parameter and then fill in the value after the
object is created, as in this example (assuming that the object is an
'Integer')..


     result = __ctalkCreateObjectInit
       (INTEGER_CLASSNAME, INTEGER_SUPERCLASSNAME, LOCAL_VAR, "");
     *(int *)result -> __o_value = int_value;
     *(int *)result -> instancevars -> __o_value = int_value;


In this case, the INTVAL, LLVAL, and SYMVAL macros can help make the
expression more readable, depending on whether the new object is an
'Integer', 'LongInteger', or 'Symbol'.


     INTVAL(result -> __o_value) = int_value;
     INTVAL(result -> instancevars -> __o_value) = int_value;



File: ctalk.info,  Node: Templates,  Next: Return values,  Prev: Scoping,  Up: Methods

Templates
---------

_Templates_ are simplified methods that are defined as macros and
written in C. They provide a method-compatible wrapper to C functions.

Template methods can appear in place of C functions in complex
expressions, and they must be used if a C function writes to its
arguments (e.g., like 'scanf(3)' or 'sscanf(3)').  For example, if we
have a template defined for the function 'myPrintMsg', then Ctalk
subsitutes the method expression wherever 'myPrintMsg' appears in an
expression like this one.


       if ((myInt = myPrintMsg (someMsg)) != 0) {
          _... do something..._
       }


After compilation, the expression looks like this.


       if ((myInt = CFunction cMyPrintMsg (someMsg)) != 0) {
          ...


You can also use 'myPrintMsg' on the left-hand side of an assignment,
like this.


       myInt = myPrintMsg (someMsg);

       _-or-_

       self = myPrintMsg (someMsg);


Additionally, you can use templates on their own, by prefacing the
method's name (the template function's alias) with its class object.


       CFuntion myPrintMsg (someMsg);


As the last example implies, templates are class methods in the
pseudo-class 'CFunction'.  Ctalk loads and caches templates where
necessary when compiling the input file, so you won't see any methods of
the 'CFunction' class unless the program calls for one or more of them.

If the template wraps a C function of the same name, then, of course,
you can also use the C function on its own.  However, templates don't
necessarily need to correspond to a C function; they can provide any set
of C expressions with a method compatible interface.

Ctalk defines a number of built-in templates for the standard C library.
You can determine if Ctalk substitutes a template for a C function by
giving the '--printtemplates' option to 'ctalk' when it compiles a
source file.  This displays the templates that the compiler loads and
caches (but doesn't necessarily send to the output).

You can define templates for application-specific C functions and
routines also.  Ctalk retrieves and caches them similarly to its
built-in templates, but they are cataloged and stored separately in each
user's '~/.ctalk/templates' directory.

As mentioned above, templates don't need to wrap a function of the same
name as the template.  That is, 'myPrintMsg', above, does not have to be
an actual function (although you need to prototype it that way).
Templates for C library functions always correspond to an actual library
function.  Program specific templates can serve as a wrapper for any
function or set of routines.

When compiling templates, the Ctalk compiler checks the user template
registry first.  If a user defines a template with the same name as one
of Ctalk's C library templates, then the compiler uses the user's
template instead of Ctalk's built-in template.  That means you can
define a template that replaces a C library template.

When creating a template for a function, you need to follow these steps.

   * Add a prototype of the function to the input file.  For example:


            OBJECT *myPrintMsg (char *text);


     Ctalk uses the prototype's argument list to check the number and
     type of arguments.  The prototype's argument list must be the same
     as the template's argument list.

   * Check that any terms in the expression before and after the
     template are compatible.  Ctalk can in most cases distinguish
     between objects and C variables in expressions.  Ctalk will try to
     warn you if it sees a mixed object/variable expression it can't
     handle.  If an expression causes an error, try breaking it into
     smaller pieces, with objects and methods in one set of terms, and C
     variables and operators in another.  Also, try making the template
     function the first term in the expression (or the first term after
     an assignment operator).  This expression, for example, is
     relatively easy to handle because everything that follows the
     template is normal C code.


          myFloat = rand () + 0.33 + (float)my_dbl;


   * Write a template for the function, and add it to the local
     directory's template cache with the 'template' command.  The
     following sections describe the format that templates use.

Writing Templates
-----------------

Templates are basically multiple line macros that provide a method
selector and method body in a #define preprocessor statement.  When
Ctalk finds a function name that has a template defined for it, it
subsitutes the template name for the function name in the expression,
adds the template's body to the output, and adds the template to the
CFunction classes' initialization.

Templates can accept arguments similarly to methods, and, like methods,
they return a C 'OBJECT *', or NULL.

Here is the template for the 'myPrintMsg()' C function.  The template
provides a wrapper for the 'printf(3)' function, and, like 'printf(3)',
returns an integer value (as an 'Integer' object).  The template
contains a few features that are part of the template protocol.


     #define myPrintMsg \n\
     cMyPrintMsg (char *text) {\n\
       char buf[255]; \n\
       int result; \n\
       OBJECT *objresult; \n\
       if (__ctalkIsObject(ARG(0))) {\n\
         result = printf ("myPrintMsg: %s\n", \n\
                           __ctalkToCCharPtr(ARG(0), 1)); \n\
         __ctalkDecimalIntegerToASCII (result, buf); \n\
         return __ctalkCreateObjectInit ("result", "Integer", \n\
                                         "Magnitude", LOCAL_VAR, buf); \n\
       } else { \n\
         __ctalkDecimalIntegerToASCII (-1, buf); \n\
         objresult =  __ctalkCreateObjectInit ("result", "Integer", \n\
                                         "Magnitude", LOCAL_VAR, buf); \n\
         __ctalkRegisterUserObject (objresult); \n\
         return objresult; \n\
       }\n\
     }


   * The template embeds newlines with the string '\n\'.  When the
     template is preprocessed, this expression joins the lines of the
     template but keeps the line endings intact.
   * The method selector, 'cMyPrintMsg' is built from the function name
     ('myPrintMsg') by uppercasing the first letter and prepending a 'c'
     to it.
   * The template must declare its arguments, like the 'char *text'
     declaration above, even though the actual arguments are objects, as
     described in the next item.
   * The expression '__ctalkIsObject(ARG(0))' checks that the argument
     to the template is a valid object.  You can acccess the template's
     arguments with the 'ARG' macro.  The first argument is 'ARG(0)',
     the second argment is 'ARG(1)', and so on.
   * The function, '__ctalkToCCharPtr()' translates the argument object
     into a 'char *' string that 'printf(3)' expects as its argument.
   * Normally templates create a return object manually, using the API
     function '__ctalkCreateObjectInit ()' or a similar function.  Note
     that '__ctalkCreateObjectInit ()' uses a 'char *' to store the
     value of the object, which is why many templates declare a buffer
     for the C function's result and use __ctalkDecimalIntegerToASCII
     ().  If the result is more complex, then the template might need to
     format it with a function like 'sprintf (3)'.  Templates can also
     return NULL, but if a program uses such a templated function in an
     assignment statement, it causes a program to generate a NULL
     argument object warning when the program is run.
   * Whenever a method returns an object it creates, it should register
     the object, for example by calling '__ctalkRegisterUserObject' as
     in the template above.  That way Ctalk can either maintain the
     object or clean it up when it needs to be deleted.  This function
     call is optional, but omitting it may cause memory leaks when the
     program is run.
   * A template can use macros, like 'LOCAL_VAR'.  The most convenient
     way to define macros is to '#include <ctalk/ctalkdefs.h>' somewhere
     in the input.  Many classes already do this, and the template can
     use the same set of macro definitions as the class libraries.

Cataloging Templates
--------------------

When looking up templates, Ctalk looks in the template registry file,
which is normally '~/.ctalk/templates/fnnames' for the name given in the
input.  If the function is aliased to another name by a macro
substitution, 'fnnames' contains the name of the alias also.

For example, on some systems, the function 'getc(3)' is a macro that
expands to '_IO_getc'.  The 'fnnames' file would then contain '_IO_getc'
as the templated function's name.

When the compiler finds the function's name or alias in 'fnnames', it
looks in the directory for the template file, which is named for the
first letter of the function's name.  That is, when looking for
'myPrintMsg's' template, Ctalk looks for a file named
'~/.ctalk/templates/m'.

The C library templates that come with Ctalk use the same scheme, except
that the template files are stored in a subdirectory of the class
library called 'libc'.  The registry is part or the run-time library, so
C library templates do not need a separate registry file.

The manual page, 'fnnames(5ctalk)' contains more information about the
'fnnames' file.  The 'templates(5ctalk)' manual page describes the
format of individual templates.


File: ctalk.info,  Node: Return values,  Next: Variable arguments,  Prev: Templates,  Up: Methods

Return Values
-------------

Internally, methods return either an 'OBJECT *' or 'NULL'.  If you write
a method that returns a C variable, Ctalk normally translates it into an
equivalent object.

Methods that return arrays declared in C generally assign the C array to
an equivalent 'Array' object.  The 'Array' object's size is the same as
the array declaration, regardless of how it the array's members are
initialized.

The 'Array' allocation only occurs for arrays declared with a subscript;
that is, a variable declared as 'int *' is not always stored in an
'Array' object, while a variable declared as 'int[SIZE]' is.

Ctalk treats C arrays declared as 'char[SIZE]' a little differently.  If
the method's definition says the return class of the method is 'Array',
then Ctalk returns an 'Array' of 'Character' objects; otherwise, it
returns a 'String' object.

Because Ctalk does not have equivalent classes for multi-dimensioned
arrays; that is, arrays with more than one subscript, it does not
translate the arrays automatically.  In these cases, the method might
return a multi-dimensioned array by assigning it to a 'Symbol' object.

Occasionally, you might need to return the result of an expression that
Ctalk can't translate automatically.  In that case, you can use the
'eval' keyword to evaluate the expression when the program is run, as in
this example.
     MyClass instanceMethod myMethod (void) {
       ...
       return eval <expression>
     }

If a method must create an object of its own to return, the object
should have the scope CREATED_PARAM, which tells the Ctalk libraries
that the the program only needs the object if it's the result of a
complete expression; if not, the program cleans up the object
automatically when it is no longer needed.  *Note
__ctalkRegisterUserObject::.


     return __ctalkCreateObjectInit ("myStringAnswer", "String",
                                     "Character", CREATED_PARAM,
                                     "The contents of the String object.");


If the program needs to store a return object for longer than the scope
that the object is called in, the method can save the object in its
object pool with the library function __ctalkRegisterUserObject, which
is described below.  *Note __ctalkRegisterUserObject::.


     String instanceMethod myMethod (void) {

       OBJECT *return_object;

       _... Do stuff. ..._

       return_object =  __ctalkCreateObjectInit ("myStringAnswer", "String",
                                     "Character", CREATED_PARAM,
                                     "The contents of the String object.");
       __ctalkRegisterUserObject (return_object);
       return return_object;

     }


Another case may be when a method needs to retrieve an object reference.
In these cases, the method may need to increase the object's reference
count.  However, such a method can also call
'__ctalkRegisterExtraObject' to save the object so its memory isn't lost
later.  The '__ctalkRegisterExtraObject' function does not, itself, set
the object's reference count, and it saves an object (not copies of
objects) only once.

Method Return Macros
....................

Alternatively, if a method needs to return an object of a particular
class, you can use the following 'methodReturn*' statements.  These are
macros that implement the statements to store and return objects which
represent different types or classes, like 'ints' as Integer objects,
'doubles' as Float objects, and so on.

These macros have been superseded in more recent versions of Ctalk,
which has the ability to insert the correct return code for any class of
object, and many C variables, functions, and expressions.  If the
compiler doesn't recognize some particular expression, however, these
macros may still be useful.

Remember that these return value functions are implemented as macros and
contain their own code block, so you can use them in places where normal
functions would cause a syntax error.

'methodReturnBoolean (int I)'
     Return a 'Boolean' object that Ctalk can evaluate to 'TRUE' or
     'FALSE' depending on the value of its argument.  Mostly deprecated;
     an expression like, '"return TRUE"' is equivalent.

'methodReturnFalse'
     Return a 'Boolean' object that evaluates to 'FALSE.' Deprecated;
     using the expression, 'return FALSE;' has the same effect.

'methodReturnInteger(int I)'
     Return an 'Integer' object with the value I.  Mostly deprecated; an
     expression like, '"return <int>"' is equivalent.

'methodReturnLongInteger(int L)'
     Return a 'LongInteger' object with the value L.  Mostly deprecated;
     an expression like, '"return <longlongint>|<longint>"' is
     equivalent.

'methodReturnNULL'
     Returns the C value 'NULL.' Deprecated; simply use the expression,
     'return NULL;' instead.

'methodReturnObject(OBJECT)'
     Return OBJECT.  Deprecated; the expression, 'return OBJECT' has the
     same effect.

'methodReturnObjectName(OBJECTNAME)'
     Return the object referred to by OBJECTNAME.  Also deprecated; like
     'methodReturObject', above, the expression, 'return OBJECT' has the
     same effect.

'methodReturnSelf'
     Returns the method's receiver, 'self'.  Slightly deprecated; simply
     using the statement, "'return self'," has the same effect.

'methodReturnString(char *S)'
     Return a 'String' object with the value S.  Mostly deprecated; an
     expression like, '"return <char *>|<string constant>"' is
     equivalent.

'methodReturnTrue'
     Return a 'Boolean' object that evaluates to 'TRUE.' Deprecated; use
     the expression, 'return TRUE;' instead.

The macros that return objects use the '__ctalkRegisterUserObject'
function to keep track of method's return values, and, if necessary,
other objects that the method creates.  *Note
__ctalkRegisterUserObject::.


File: ctalk.info,  Node: Variable arguments,  Next: Overloading,  Prev: Return values,  Up: Methods

Variable Arguments
------------------

C functions like 'scanf(3),' 'sscanf(3),' and 'fscanf(3)' have templates
that allow you to call them with a variable number of arguments.

If you need to call other C functions that use variable arguments, you
must call '__ctalkLibcFnWithMethodVarArgs' with the name of the
function, the method that contains the function's template, and the
function's return class.

The 'readFormat' method (implemented in 'String' and 'ReadFileStream'
classes) can scan a string or input file into the objects that the
program gives as arguments.  The methods also take care of
scalar-to-object translation, memory allocation, and several other
tasks.

However, programs can also accomplish the same thing manually.

For example, here is the code of the template method for 'fscanf(3),'
'cFscanf' ('CFunction' class), without the preprocessing directives.

     cFscanf (FILE *s, char *fmt,...) {
       EXPR_PARSER *parser;
       OBJECT *result_object;
       parser = __ctalkGetExprParserAt (__ctalkGetExprParserPtr ());
       result_object =
         __ctalkLibcFnWithMethodVarArgs ((int (*)())fscanf, parser -> e_method, "Integer");
       return result_object;
     }

At run time, the 'e_method' member of an expression parser contains the
method and its arguments.

The third argument of '__ctalkLibcFnWithMethodVarArgs' determines the
class of 'result_object.' For C library functions that use variable
arguments, the return class is 'Integer.'

The typecast '(int (*)())' in the first argument in front of 'fscanf' is
not strictly needed because we know that the number and types of
arguments to 'fscanf(3)' (or 'scanf(3)' or any other variable-argument
function) might vary from the '__ctalkLibcFnWithMethodVarArgs'
prototype, but it tells the compiler not to print a warning message in
that case.

If you simply need to print formatted output, the 'writeFormat' or
'printOn' methods (implemented in 'String', 'WriteFileStream' and many
other classes classes) perform format-argument translations
automatically.  Several classes also implement a 'readFmt' method, which
reads formatted input from a 'String' or 'ReadFileStream'.  *Note
writeFormat--class WriteFileStream::, and *note writeFormat--class
String::.


File: ctalk.info,  Node: Overloading,  Next: Variable method arguments,  Prev: Variable arguments,  Up: Methods

Overloading Methods
-------------------

You can always implement a method in different classes.  For example,
you can define a '+' method in 'Integer,' 'LongInteger,' 'Character,'
and 'Float' classes, and Ctalk calls the method defined for that class
of the receiver object.

Some operators also have methods implemented in a superclass, like
'Magnitude' in this case, which can provide any extra error checking and
processing that may be necessary, for example, if you try to use a unary
minus ('-') operator with a receiver like a 'Pen' or 'Rectangle' object.

When you overload methods _within_ a class, however, Ctalk does some
extra checking.  The compiler needs to examine the expression to find
out how many arguments the statement has, whether the operator is a
prefix operator, or whether the method's argument is a block of code or
a variable argument list, or whether the method uses a C calling
convention.

Ctalk can overload math operators when they are also used as prefix
operators.  Two examples of these are the unary minus ('-') and pointer
('*') methods, which have different methods than the operators that
perform subtraction and multiplication.  Writing methods that are prefix
operators is described above.  *Note Prefixes::.

Overloading Parameters
......................

Exactly when you should write methods that overload things like
parameters and variable arguments is somewhat within the philosophy of
programming languages.  For example, a common use of method overloading
based on the number of parameters is the, "getter/setter," type of
method, which retrieves and sets an object's private data.

In Ctalk, these are much less necessary than in other languages, because
Ctalk can address an object's private data with a message that has the
same name as an instance or class variable.  Since these messages bind
more tightly to receiver objects than messages that refer to methods,
these types of methods might not work the way you think they would.  So
be sure that if you write a method of this type, that the program is
actually using a method message, and not an instance data message.

Here is an example of overloading parameters.  Because the 'String'
class already has a 'concat' method (it overloads the '+' operator), we
overload the method, 'myConcat,' to concatenate one or two strings to
the receiver.

As long as the program is relatively simple, it's easy to keep track of
which methods already exist in a class.  In a bigger application,
though, you might want to define a subclass of 'String' class for this
program.


     String instanceMethod myConcat (String s1) {

       self = self + s1;

     }

     String instanceMethod myConcat (String s1, String s2) {

       self = self + s1 + s2;

     }

     int main () {
       String new s1;
       String new s2;
       String new s3;

       s1 = "Hello, ";
       s2 = "world! ";
       s3 = "Again.";

       s1 myConcat s2;
       printf ("%s\n", s1);

       s1 myConcat s2, s3;
       printf ("%s\n", s1);

     }


We should mention that the 'myConcat' method changes its receiver.  So
the arguments to the second 'myConcat' message simply get added to the
receiver again.  The output should look something like this.

     Hello, world!
     Hello, world! world! Again.


File: ctalk.info,  Node: Variable method arguments,  Next: Method functions,  Prev: Overloading,  Up: Methods

Variable Method Arguments
-------------------------

Ctalk supports variable arguments lists for methods that follow the
'stdarg.h' format for argument lists, where the argument assigned to the
last named parameter determines the number and type of the following
arguments.  (The manual page 'stdarg (3)' has more details.)


       String instanceMethod writeFormat (char *fmt, ...)


In addition, Ctalk supports argument lists with _no_ named parameters.
To implement this, Ctalk interprets an ellipsis as a variable argument
list, as usual.  It is then up to the method to interpret the arguments
as they appear on Ctalk's argument stack.

For this task, the '__ctalkNArgs' library function returns the number of
arguments that the run-time libraries place on the stack.  The method
can then interpret these arguments as necessary.

Here is the slightly abbreviated code for the 'List' : '=' method, which
should help illustrate this.  *Note List::.


     List instanceMethod = initEQ (...) {
       int n, i;
       OBJECT *arg;

       self delete;         /* Start with an empty List. */
       n = __ctalkNArgs ();

       for (i = (n - 1); i >= 0; --i) {
         arg = __ctalk_arg_internal (i);
         self push arg;
       }
     }



File: ctalk.info,  Node: Method functions,  Next: Errors,  Prev: Variable method arguments,  Up: Methods

Method Functions
----------------

Occasionally an application needs to call a method as a function.  One
example of this is a 'SignalHandler' method that the program installs as
the handler for signals from the operating system.

Methods that use a C calling convention need to do several things
differently than normal methods.
   * The method needs to use a C variable as its argument.
   * Because the method can be called with no receivers, Ctalk does not
     perform any of the normal initialization of local and parameter
     objects.
   * The method body needs to be written almost entirely in C.

In order to make Ctalk interpret a method parameter as a C variable, the
method must declare the parameter with the '__c_arg__' attribute.

_Note:_ C functions that are called by the operating system generally
need only one argument, and the '__c_arg__' attribute only works for
methods with a single parameter.

Additionally, to prevent Ctalk from adding local object initialization
code to the method, the method must contain the 'noMethodInit' keyword.

Here is an example of a method that is used as a signal handler, and
installed by the statements in 'main.'
     SignalHandler instanceMethod myHandler (__c_arg__ int signo) {
       noMethodInit;
       printf ("sigInt handler! Signal %d.\n", signo);
       return NULL;
     }

     int main () {

       SignalHandler new s;

       s setSigInt;
       s installHandler myHandler;
     }

The 'setSigInt' method (class 'SignalHandler') tells the 'SignalHandler'
object 's' that it is going to handle 'SIGINT' signals.  *Note
SignalHandler::, for the other signals that the class can handle.

The '__ctalkNewSignalEventInternal' function can generate and queue
'SignalEvent' objects, so the signal handler does not need to create
objects in order to send signal events to the application.  *Note
__ctalkNewSignalEventInternal::.

Including C Header Files
........................

Often you will need to use C functions and data types in method
functions.  However, you need to take care that if you include a C
header file, it might not be included later on if a class library
requires that file.

Normally Ctalk includes whatever C definitions it needs in the class
libraries.  However, that can cause the preprocessor to omit those
definitions from another source file, should the definitions be needed
later.

For example, in the method 'handleSignal', from the 'timeclient.c'
program, the method needs the definition of the 'time(2)' function.  If
you were to '#include' 'time.h' in the input, as in this example, then
'time.h''s definitions would not be included in the 'CTime' class later
on.
     #include <time.h>    /* Could cause errors later. */

     SignalHandler instanceMethod handleSignal (__c_arg__ int signo) {
       time_t t;
       char buf[MAXLABEL];
       noMethodInit;
       t = time (NULL);
       __ctalkDecimalIntegerToASCII (t, buf);
       __ctalkNewSignalEventInternal (signo, getpid (), buf);
       return NULL;
     }

The best way to avoid omitting dependencies is to include only the
definitions that the method needs.  In this case, you can include the
prototype of 'time(2)' in the source file.
     extern time_t time (time_t *__timer) __THROW;  /* From time.h. */

     SignalHandler instanceMethod handleSignal (__c_arg__ int signo) {
       time_t t;
       char buf[MAXLABEL];
       noMethodInit;
       t = time (NULL);
       __ctalkDecimalIntegerToASCII (t, buf);
       __ctalkNewSignalEventInternal (signo, getpid (), buf);
       return NULL;
     }

The 'time_t' type is defined with 'ctalklib', and is available to all
programs.

How to resolve multiple library definitions depends on the system's
header files, and may vary between different operating systems or
compiler versions.


File: ctalk.info,  Node: Errors,  Next: Cautions,  Prev: Method functions,  Up: Methods

Exception and Error Handling
----------------------------

There are two ways to handle error conditions in Ctalk.  You can simply
print an error or warning message in your code.  An error message
formats the text and data that you provide, the same as in a 'printf'
statement, and then exits the program.  Here is an example.
     _error ("Program exited with code %d.\n", result_code);

A '_warning' message is similar, but it prints the message and continues
processing.  *Note errorfuncs::.

The other way to handle errors is with exceptions.  This is the method
you need to use if an error occurs within a method, and the program
needs either to print a warning message, or exit.

There are two methods of class 'Exception' that handle exceptions in
application programs: 'pending' and 'handle.' There are also other API
functions, but they are mostly used internally to translate exceptions
into events that application programs can use.

These two methods are generally used together.  The method 'pending,' if
it returns 'TRUE,' signals that there is an exception pending.  Then the
function 'handle' handles the event by executing an exception handler.

Generally, events simply issue error messages.  It is up to you to
determine how the program should handle the exception: by exiting,
trying the procedure again, ignoring the condition, or some other
procedure.  Here is an example.

     Exception new e;
     ...
     inputStream openOn fileArg;
     if (e pending) {
        e handle;
       exit (1);
     }
     if (inputStream isDir) {
       printf ("Input is a directory.\n");
       exit (1);
     }
This is simply the way that Ctalk notifies the application if the method
'openOn' (class 'ReadFileStream') encountered an error while opening the
file named by its argument, 'fileArg.'

You should note that the program also checks whether the input is
actually a directory, because opening a directory as if it were a file
does not necessary cause an error condition.  The 'isDir' (class
'FileStream') method is one portable way to check if the input path is
actually a directory.

The method 'openOn,' like other methods, raises an exception if
necessary.  It does this with 'raiseException' (class
'SystemErrnoException').

Ctalk handles most 'stdio' error codes in this manner.  A program that
uses the 'ReadFileStream' and 'WriteFileStream' classes should rarely
need to use the C library's 'errno' macro, but it is still available if
applications need to check for other errors from the C libraries.

The Ctalk library also provides exceptions for missing arguments,
undefined methods, and other error conditions.  The file,
'include/except.h,' contains the definitions of Ctalk's compile and run
time exceptions.


File: ctalk.info,  Node: Cautions,  Next: Method keywords,  Prev: Errors,  Up: Methods

Cautions when Using Arguments with C Library Calls
--------------------------------------------------

The interface for C functions is in development.  You can use a C
function in a simple expression with any argument, as in the following
example.

     op1 = __ctalkGetInstanceVariableByName ("self", "value", TRUE);

However, if you want to use a C function in a complex expression, then
you must take care that the arguments to the function are C values that
correspond to a Ctalk class, unless the function has a template written
for it in the class library that performs the translations of specific
classes and data types.  *Note Templates::.

If you use a function in a method, and the compiler generates an,
"implicit declaration," warning, you can include the library function's
prototype in either the source file or in 'classes/ctalklib'.

Cautions when using 'Array' class elements in C expressions.
------------------------------------------------------------

If you want to use an 'Array' element in a C expression, you need to
take care that the value of the element translates to a 'void *,' which
is the C type that Ctalk returns the values of these elements as.

That means elements of class 'LongInteger' might be truncated, and
'Float' class array elements cannot be translated in this manner.

If array elements of these classes occur in C expressions, Ctalk prints
a warning at run time.

In these cases, it is necessary to convert the values to a compatible
pointer type, for example an object of class 'String.'


File: ctalk.info,  Node: Method keywords,  Next: Documentation,  Prev: Cautions,  Up: Methods

Method Keywords
---------------

'__c_arg__'
     Treat the next method argument as a C argument.  *Note Method
     functions::.

'classMethod'
     The 'classMethod' keyword declares a method, as described above.

'classVariable'
     Adds a class variable definition to a class.  This method needs to
     be used globally, when a class is declared.  The syntax is:

          PARENT_CLASS classVariable NAME [NATIVE_CLASS|TYPECAST_EXPR]
          [INITIAL_VALUE] [DOCSTRING] ;

     For example:


          FileStream class ReadFileStream;

          _..._

          ReadFileStream classVariable stdinStream Symbol 0x0;


     The value of INITIAL_VALUE can be either a constant or an
     expression that evaluates to a constant.

     Ctalk can also translate a typecast into a native class for the
     variable.  Also refer to the entry for 'instanceVariable', below.
     *Note InstanceVariableKeyword::.

     Similarly, the DOCSTRING element is also optional.  *Note
     VariableDocStrings::.

'eval'
     Do not try to evaluate the following statement until run time.
     Methods can use this keyword if they need to wait until run time to
     determine an receiver's class and are not able to alias the object
     or otherwise inform the front end of the receiver's class before
     the program is run.

'instanceMethod'
     The 'instanceMethod' keyword declares a method, as described above.

'instanceVariable'
     Adds an instance variable definition to a class.  This method needs
     be used when the class is declared.  The syntax is:

          PARENT_CLASS instanceVariable NAME
          [NATIVE_CLASS|TYPECAST_EXPR] [INITIAL_VALUE] [DOCSTRING] ;

     For example:

          FileStream class ReadFileStream;
          ReadFileStream instanceVariable pos LongInteger 0L;

     The value of INITIAL_VALUE can be either a constant or an
     expression that evaluates to a constant.

     You can also use a typecast in place of the variable's
     NATIVE_CLASS. Ctalk can translate most builtin C types or typedefs
     to a class, but for less common data types, Ctalk will translate a
     pointer to the type as a Symbol object.

     Similarly, the DOCSTRING element is also optional.  *Note
     VariableDocStrings::.

     Note that the 'instanceVariable' method does not _create_ any
     variables.  Ctalk only creates instance variables for each object
     when it receives a constructor message (e.g., 'new') by a program.

'noMethodInit'
     Do not include method initialization code for the method.  *Note
     Method functions::.

'require'
     Require a class to be loaded before any other classes or methods.

'returnObjectClass'
     Set the return class of a method to the argument if it is different
     than the receiver class.  *Note Return values::.

'self'
     Return the method's receiver object.  In version 0.67 2021-03-11,
     you can also use 'self' in arguments as a synonym for the receiver
     of the statement, as in this example.
          String new path;
          path = "/home/user/joe";

          printf ("%s", path subString 1, self length - 1);

     The use of 'self' in method arguments is experimental in version
     0.67 2021-03-11, and it should be used with caution.

'super'
     The keyword 'super' has two different meanings.  It can modify a
     method, as in the following example.

          MyReceiverClass super new instanceObject;

     'super' can also represent the receiver's superclass object, so it
     can appear as a receiver, as in this example.

          return super new checksum;


File: ctalk.info,  Node: Documentation,  Next: Ctalk library,  Prev: Method keywords,  Up: Methods

Documenting Methods, Classes, and Variables
-------------------------------------------

Ctalk allows you to add publicly visible comments to methods, classes,
and instance and class variables.  These comments are different than
comments within the code that may have meaning only for specific
routines

If you want to add documentation for a class, Ctalk allows documentation
string is class declarations (see below).  *Note ClassDocStrings::.

You can also document instance and class variables.  *Note
VariableDocStrings::.

When documenting methods, Ctalk recognizes both C-style comments and C++
comments.

In addition, Ctalk recognizes a character string at the beginning of a
method or function as a public documentation string, and it adds a few
rules for comments and documentation strings that make it easier to
describe methods when browsing the class library.

Basically, if the method contains a comment or documentation string at
the start of a method or function body, then that style of comment is
used as the method's public documentation when it is referenced by other
programs.


     MyClass instanceMethod myMethod (Object myArg) {
       /* Using a C-style comment at the start of a method body,
          or a series of C-style comments, makes those comments
          available as the method's public documentation. */
       /* The public documentation can span several comments if the
          comments appear before any lines of source code. */

          _Method body..._


       /* That allows you to add (perhaps temporary) comments elsewhere
          in the method that do not appear as part of the method's
          public documentation. */

          _More lines of code..._

     }

     MyClass instanceMethod myMethod (Object myArg) {
       // A series of C++ comments before the first line of
       // code also can appear as the method's public
       // documentation.

          _Method body..._

       /* A different style of comment anywhere else within
          the method does not appear in the method's public
          documentation. */
     }

     MyClass instanceMethod myMethod (Object myArg) {
       "A character string at the start of the method also gets
        interpreted as a public documentation string."

        _Method body..._
     }


The Ctalk libraries contain several methods that can be useful when
printing documentation.  Particularly, the method 'methods' (in 'Object'
class) and 'methodSource' (in 'Application' class) can retrieve the
names of the methods in a class and their source code, and the method
'tokenize' (in 'String' class) can split the source code into tokens,
which you can then process.

Here's a simple application that retrieves a method's source code and
splits it into tokens.


     int main () {

       Application new app;
       String new methodStr;
       List new tokens;

       /* The first argument to methodSource is the class name, and
          the second argument is the method name. */
       methodStr = app methodSource "Application", "methodSource";

       methodStr tokenize tokens;

       tokens map {
         printf ("%s ", self);  /* This example simply prints the method's
                                   tokens, but you can perform any processing
                                   or formatting that you want here. */
       }
       printf ("\n");
     }


If you want only the prototype of the method; that is, the declaration
and the argument list, feed the output of 'methodSource' to
'methodPrototypes', which is also in class 'Application.' The
'methodPrototypes' method takes a string with the source code of a
method or methods as input, which means you can also extract all of the
prototypes of a class library.


     int main () {

       Application new app;
       String new src;
       String new prototypes;

       src = app methodSource "Object", "basicNew";

       prototypes = app methodPrototypes src;

       printf ("%s\n", prototypes);

     }


There are a few caveats:

The 'methods' method is designed to be quick, so it only finds methods
whose declaration appears on one line.  If you prefer method
declarations spread over several lines, you can read the entire class
file using 'readAll' (class 'ReadFileStream').  *Note ReadFileStream::.
Then you can tokenize the entire class file at once, which disregards
any line formatting, although tokenizing an entire file takes
considerably longer.

Also, The 'methodPrototypes' method does not do any special formatting;
it simply collects the prototypes into one 'String' object.

Class Documentation
...................

Ctalk also allows you add documentation to class declarations.  The
declaration syntax allows you to add an option character string between
the class name and the closing semicolon.  The syntax of a class
documentation is the following.


     SUPERCLASSNAME class CLASSNAME <DOCSTRING>;


For example, here is the class declaration of 'WriteFileStream' which
contains a documentation string.


     FileStream class WriteFileStream   "Defines the methods and instance
     variables that write data to files. Also defines the class variables
     stdoutStream and stderrStream, which are the object representation
     of the standard output and standard error streams.";


The 'classdoc' program can print the documentation string of a class if
it provides one.  The 'classdoc(1)' manual page provides more
information.

Instance and Class Variable Documentation
.........................................

You can add an optional documentation string to an instance or class
variable's declaration by enclosing the text within quotes immediately
before the final semicolon.


     WriteFileStream classVariable stdoutStream
     "Defines an object that contains the value of the system's standard output";


The main thing to watch out for is, syntactically, a documentation
string could be mistaken for a variable's initial value if one isn't
included in the definition.  For example, this definition uses a
character string as its initial value.


     ObjectInspector instanceVariable promptString String "> ";


So in this case, if you wanted to add a documentation string, you would
also need to include an initial value, otherwise the documentation
string would be mistaken for the variable's value.


                                                           /* Incorrect! */
     ObjectInspector instanceVariable promptString String
     "The string that is displayed as the object inspector's
     prompt";


Instead, you need to add both an an initial value, and the documentation
string.


                                                                /* Correct. */
     ObjectInspector instanceVariable promptString String "> "
     "The string that is displayed as the object inspector's
     prompt";



File: ctalk.info,  Node: Ctalk library,  Prev: Documentation,  Up: Methods

Ctalk Library Reference
-----------------------

This section describes some of the Ctalk library functions that you can
use in methods and, in many cases, in Ctalk programs generally.

The file 'classes/ctalklib' contains the prototypes of the library
functions.

'__argvName (char *S)'
     Set the name of the program at run time.  Normally this is the same
     as 'argv[0]'.

'__argvFileName (void)'
     Returns the name of the executable program.

'__arg_trace (int STACK_INDEX)'
     Prints the object at argument stack index STACK_INDEX.

'__ctalkAddClassVariable (OBJECT *CLASS_OBJECT, char *NAME, OBJECT *VARIABLE_OBJECT)'
     Add a class variable VARIABLE_OBJECTto CLASS_OBJECT.

'__ctalkAddInstanceVariable (OBJECT *OBJECT, char *NAME, OBJECT *VARIABLE_OBJECT)'
     Add an instance variable to an object.  Note that the function adds
     a copy of VARIABLE_OBJECT to OBJECT.

'__ctalkAliasObject (OBJECT *RCVR, OBJECT * TARGET)'
     Set the RCVR object's label to the TARGET object, so the TARGET
     object can be referred to by the RCVR object's identifier.  This
     function does not require RCVR to be the actual receiver of the
     method, so the results can be unpredictable if it is used in a
     context other than where 'self' is the first argument.  To insure
     that RCVR is the actual receiver of the calling method, use
     '__ctalkAliasReceiver (),' below.

'__ctalkAliasReceiver (OBJECT *RCVR, OBJECT * TARGET)'
     Like '__ctalkAliasObject (),' above, but the function checks that
     RCVR is the actual receiver of the calling method and returns
     'ERROR' ('-1') if it isn't.  Here is an example.


          String instanceMethod = setEqual (OBJECT *__stringArg) {
            // String assignment method. Assigns the argument  to the
            // receiver label.  Also does some String-specific
            // semantic stuff for different sorts of String objects.
            // Returns the new String object.

            __ctalkStringifyName (self, __stringArg);
            if (__ctalkAliasReceiver (self, __stringArg) != 0) {
              __ctalkAddInstanceVariable (self, "value", __stringArg);
              return self;
            } else {
              return __stringArg;
            }
          }


'__ctalkANSIClearPaneLine (OBJECT *PANEOBJECT, int LINENUMBER)'
     Clear (to spaces) the pane line at LINENUMBER.

'__ctalkANSITerminalPaneMapWindow (Object *CHILDPANE)'
     Map CHILDPANE onto the receiver pane.  The child pane's upper
     left-hand corner origin is relative to the receiver pane's origin.
     The receiver pane should be large enough to completely enclose the
     child pane.  The child pane is displayed at the next 'refresh'
     message.

'__ctalkANSITerminalPaneUnmapWindow (Object *CHILDPANE)'
     Removes the pane given as the argument from the receiver pane.

'__ctalkANSITerminalPanePutChar (int X, int Y, char C)'
     Store character C at coordinates X,Y in the pane's content region.
     The character will be displayed after the next 'refresh' message.

'__ctalkANSITerminalPaneRefresh (void)'
     Display the contents of 'ANSITerminalPane' objects on the display,
     including text and window decorations if any.

'__ctalkANSITerminalPaneUnMapWindow (Object CHILDPANE)'
     Unmap CHILDPANE from the receiver pane's visible area.  The child
     pane is not deleted; it is simply not displayed at the next
     'refresh' message.

'__ctalkARB (void)'
     Returns a boolean value of true if the GLEW libraries support the
     GLEW_ARB_vertex_shader and GLEW_ARB_fragment_shader extensions.
     Programs must call the '__ctalkInitGLEW' function before using this
     function.

'__ctalkArgBlkReturnVal (void)'
     Called by the calling function of an argument block to retrieve the
     block's return value, if any.

'__ctalkArgBlkSetCallerReturn (void)'
     Called by a map method to indicate to a calling method or function
     that an argument block has requested a return from the function or
     method that called it.  Map-type methods for general use should
     include a call to this function, which provides argument block
     support for 'return' statements.  Refer to
     '__ctalkRegisterArgBlkReturn', below, and the 'String : map' method
     for an example of these functions' use.

'__ctalkArrayElementToCCharPtr (OBJECT *ARRAY_ELEMENT)'
'__ctalkArrayElementToCChar (OBJECT *ARRAY_ELEMENT)'
'__ctalkArrayElementToCDouble (OBJECT *ARRAY_ELEMENT)'
'__ctalkArrayElementToCInt (OBJECT *ARRAY_ELEMENT)'
'__ctalkArrayElementToCLongLongInt (OBJECT *ARRAY_ELEMENT)'
'__ctalkArrayElementToCPtr (OBJECT *ARRAY_ELEMENT)'
     Translates the object ARRAY_ELEMENT's value to a C 'char *',
     'char', 'double', 'int', 'long long int', or 'void *'.

'__ctalkBackgroundMethodObjectMessage (OBJECT *RCVR, OBJECT *METHOD_INSTANCE)'
     Perform a method call by sending RCVR the message defined by
     METHOD_INSTANCE, which is a previously defined 'Method' object.
     *Note Method::.

     The function starts METHOD_INSTANCE as a separate process, which
     runs concurrently with the process that launched it.  The
     background process exits when METHOD_INSTANCE returns.

     The METHOD INSTANCE argument is a normal method.  However,
     '__ctalkBackgroundMethodObjectMessage' does not save the return
     object before METHOD_INSTANCE exits, and METHOD_INSTANCE, does not
     take any arguments.

     The function returns the PID of the child process, or '-1' on
     error.

     This function is used by the method 'backgroundMethodObjectMessage'
     (class 'Object').  Refer to the description of the method for more
     information.  *Note Object::.

     For examples of method instance calls, *Note methodObjectMessage::.

'__ctalkBackgroundMethodObjectMessage2Args (OBJECT *RCVR, OBJECT *METHOD_INSTANCE, OBJECT *ARG1, OBJECT *ARG2)'

     This function combines a background method instance call with two
     arguments.  Its function is similar to
     '__ctalkMethodObjectMessage', below.

     For examples of method instance calls, *Note methodObjectMessage::.

'__ctalkCallMethodFn (METHOD *METHOD)'
     Used internally to perform a method call.

'__ctalkCallingFnObjectBecome (OBJECT *OLD, OBJECT *NEW)'
     Used by 'Object' : 'become' to translate the receiver when 'become'
     is called within a function.

'__ctalkCallingInstanceVarBecome (OBJECT *OLD, OBJECT *NEW)'
     Used by 'Object' : 'become' to translate the receiver when the
     receiver is an instance variable.

'__ctalkCallingMethodObjectBecome (OBJECT *OLD, OBJECT *NEW)'
     Used by 'Object' : 'become' to translate the receiver when
     'become's' receiver is an object declared in another method.

'__ctalkCallingReceiverBecome (OBJECT *OLD, OBJECT *NEW)'
     Used by 'Object' : 'become' to translate the receiver when
     'become's' receiver also the receiver of the method that calls
     'become'.

'__ctalkCBoolToObj (bool B)'
     Create a 'Boolean' object with the boolean (either true or false)
     value of the argument.

'__ctalkCCharPtrToObj (char *S)'
     Create a String object from a C 'char *'.

'__ctalkConsoleReadLine (OBJECT *string_object, char *prompt_string)'
     Prints the prompt PROMPT_STRING to standard output of a terminal,
     then reads a line of text from the standard input, until it
     encounters a newline, and saves it as the value of STRING_OBJECT.

     If Ctalk is built with support for the GNU readline libraries, the
     function provides the readline libraries' command line editing and
     history facilities.  Otherwise, the function reads input up to a
     newline using only the basic text input and editing facilities
     provided by the stdio functions.

'__ctalkCreateArg (OBJECT *RECEIVER, char *METHODNAME, char *ARG_EXPR)'
     Create an argument for the following '__ctalk_method' or
     '__ctalk_primitive_method' function call.  Unlike '__ctalk_arg',
     this function always creates a new object.  Its primary use is to
     create local method objects that are fully instantiated into a
     class by a following 'new' method.

'__ctalkCreateArgA (OBJECT *RECEIVER, char *METHODNAME, char *ARG_EXPR)'
     Like '__ctalkCreateArg', creates local method objects that are
     instantiated into a class by a following 'new' method.  The
     '__ctalkCreateArgA ()' function is more specialized so it can be
     used when performing method cache fixups.

'__ctalkCDoubleToObj (doubleD)'
     Create a Float object from a C 'float' or 'double'.

'__ctalkCharRadixToChar (char *S)'
     Return the character as a C 'char' that is represented by the
     formatted argument.

     If S contains a number of more than one digit, then it is converted
     from an integer to the ASCII code of a character.

'__ctalkCharRadixToCharASCII (char *S)'
     Return a C string with a lexically correct character - a character
     enclosed in single quotes - from the formatted argument.  If S is
     already a character, then no conversion is done.

     If S contains a decimal number of more than one digit, then it is
     converted from a decimal integer to a character.

'__ctalkCFUNCReturnClass (CFUNC *FN, char *BUF)'
     Return in BUF the name of the class that corresponds to FN's return
     type.

'__ctalkCIntToObj (int I)'
     Create an 'Integer' object from a C 'int.'

'__ctalkCLongLongToObj (long long int L)'
     Create a 'LongInteger' object from a C 'long long int.'

'__ctalkClassMethodInitReturnClass (char *RCVR_CLASS, char *METHOD_NAME, char *RETURN_CLASS);'
     Set the return class of METHOD in RCVR_CLASS to RETURN_CLASS.

'__ctalkClassMethodParam (char *RCVRCLASSNAME, char *METHODNAME, OBJECT *(*SELECTOR_FN)(), char *PARAMCLASS, char *PARAMNAME, int PARAM_IS_POINTER)'
     Define a method parameter when initializing a class method.
     Normally the compiler generates this call for inclusion in
     '__ctalk_init ()' for the method initialization at run time.

'__ctalkClassObject (OBJECT *OBJECT)'
     Returns the class object of the argument.

'__ctalkClassVariableObject (OBJECT *var)'
     Return the object that 'var' is a class variable of, or NULL.

'__ctalkFree (void *P)'
     This is an API wrapper for Ctalk's memory free routines.  Much of
     the old code in the class libraries still uses __xfree () (which
     now gets macroized to __ctalkFree () anyway), but you should use
     __ctalkFree () in new class libraries.

     In cases where you prefer to call __xfree () directly, then you
     need to use the MEMADDR macro to cast the argument to a 'void **',
     i.e.,


            char *my_buf;

            ... do stuff ...

            __xfree (MEMADDR(my_buf));


     which is what __ctalkFree () does automagically.

'__ctalkLocalTime (long int UTCTIME, int *SECONDS_RETURN, int *MINUTES_RETURN, int *HOURS_RETURN, int *DOM_RETURN, int *MON_RETURN, int *YEARS_RETURN, int *DOW_RETURN, int *DOY_RETURN, int *HAVE_DST_RETURN)'
     Returns the system's local time in the arguments that return the
     current second, minute, hour, day of the month, month, year, day of
     the week, day of the year, and (T/F) whether the time uses daylight
     savings time.

     The first argument is the system's UTC time, as returned by the
     'time ()' library function.

'__ctalkCloseGLXPane (OBJECT *PANE_OBJECT)'
     Releases the pane's GLX context and the context's XVisualInfo
     struct, and deletes the PANE_OBJECT'S X11 window.

'__ctalkCloseX11Pane (OBJECT *PANE_OBJECT)'
     Deletes and closes subpanes of a main X11 window.

'__ctalkCopyPaneStreams (OBJECT *SRC, OBJECT *DEST)'
     Copy the SRC 'inputHandle' and 'outputHandle' values to DEST.

'__ctalkCopyCVariable (CVAR *C)'
     Return a 'CVAR *' to a copy of the argument.

'__ctalkCopyObject (OBJREF_T SRC, OBJREF_T DEST)'
     Return an 'OBJECT *' to a copy of the argument.

     _Note:_ When copying normal objects, you can translate them to
     'OBJREF_T' types with the 'OBJREF' macro.  When copying method
     arguments, it is necessary to alias the argument to an object.  See
     'at' (class 'Array') and 'atPut' (class 'AssociativeArray') for
     examples.

'__ctalkCreateArgEntry (void)'
     Used internally to create an ARG type, which maintains a method's
     argument entries.

'__ctalkCreateArgEntryInit (OBJECT *OBJ)'
     Creates an internal method argument entry and initializes the entry
     to the argument object.

'__ctalkDeleteArgEntry (ARG *ARG)'
     Delete a method ARG entry.

'__ctalkCreateObject (char *NAME, char *CLASS, char *SUPERCLASS, int SCOPE)'
     Create an object without instance variables with name NAME of class
     CLASS and superclass SUPERCLASS with scope SCOPE.

'__ctalkCreateObjectInit (char *NAME, char *CLASS, char *SUPERCLASS, int SCOPE, char *VALUE)'
     Create an object with name NAME of class CLASS and superclass
     SUPERCLASS with scope SCOPE and value VALUE.

     For more information about how to use '__ctalkCreateObjectInit',
     refer to the examples in *Note Scoping::, and other examples in
     this manual.

'__ctalkCreateWinBuffer (int X_SIZE, int Y_SIZE, int CELL_SIZE)'
     Create a buffer for a 'Pane' object's window.

'__ctalkCreateGLXMainWindow (OBJECT * PANE_OBJECT)'
     Normally called by the 'initialize' method in class
     'GLXCanvasPane', creates a X11 window with a GLX visual.  The
     visual's default attributes are: 'GLX_RGBA', 'GLX_DEPTH_SIZE', 24
     bits per pixel, and 'GLX_DOUBLEBUFFER'.  These attributes are
     adjustable via the instance variables in 'GLXCanvasPane' class.

     The SELF_OBJECT argument must be an instance of 'GLXCanvasPane'
     class.  This function fills in the object's 'visualInfoPtr'
     instance variable with a pointer to the 'XVisualInfo' structure
     specified by SELF_OBJECT.  *Note GLXCanvasPane::.

     Called by the 'initialize' methods (class 'X11Pane') to create a X
     window.  Returns the window system's ID for the window, an 'int'.

     If a program doesn't specify a window size, then default size is
     250x250 pixels.  If the program doesn't specify a location for the
     window, then this function sets the window's _X,Y_ origin to 0,
     although the actual window placement depends on the machine's
     window manager.  *Note ctalkX11SetSizeHints::.

     Application programs can provide a window geometry specification
     which is used to set the window's size and placement *Note
     parseX11Geometry::.

     If X11PANE_OBJECT contains a 'background' or 'backgroundColor'
     instance variable or resource, the function sets the window's
     background color to the X11 color named in that value.

     If a program doesn't specify a foreground and background color, the
     window's background is set to white and the foreground is set to
     black.

     Refer also to the '__ctalkCreateX11MainWindowTitle' and
     '__ctalkCreanteX11SubWindow' functions.  *Note X11Pane::.

     'char *'TITLE) Similar to '__ctalkCreateX11MainWindow', except that
     if TITLE is non-null, the function uses it to set the new window's
     title.  Returns the X resource ID of the new window, an 'int'.
     *Note X11Pane::.

     Creates an X subwindow that has the parent window defined by
     PARENTPANE_OBJECT'S 'xWindowID' instance variable.  The dimensions
     of the subwindow within the parent window are determined by the
     SUBPANE_OBJECT'S 'origin' and 'size' instance variables.  Creates a
     new graphics context for the window and saves its address in the
     SUBPANE_OBJECT'S 'xGC' instance variable.

     If X11PANE_OBJECT contains a 'background' or 'backgroundColor'
     instance variable or resource, the function sets the window's
     background color to the X11 color named in that value.

     If a program doesn't specify a foreground and background color, the
     window's background is set to white and the foreground is set to
     black.

     Then the function initiazes and clears the window to the value of
     the 'backgroundColor' instance variable.  Otherwise, the function
     sets the window's color to black and clears the window.

     Also sets the display depth in the 'depth' instance variable, and
     the ID of the subwindow in the 'xWindowID' instance variable.

'__ctalkCriticalExceptionInternal (MESSAGE *ORIG, EXCEPTION EX, char *TEXT)'
     Raise a critical exception at run time.  The argument ORIG should
     be 'NULL.' This function should be called from a method.  This
     function saves a snapshot of the _calling method's_ run-time
     context.

     For an example, see 'raiseCriticalException' (class
     'SysErrnoException') in the Ctalk class library, which calls
     '__ctalkCriticalSysErrExceptionInternal,' below.

'__ctalkCriticalSysErrExceptionInternal (MESSAGE *ORIG, int ERRNO, char *TEXT)'
     A convenience function that calls
     '__ctalkCriticalExceptionInternal' with the Ctalk exception that
     corresponds to ERRNO, the C library's error macro.

'__ctalkCVARReturnClass (CVAR *VAR, char *BUF)'
     Return in BUF the name of the class that corresponds to VAR's data
     type.

     '__ctalkDecimalIntegerToChar' C function
'__ctalkDecimalIntegerToChar (int N, char *BUF)'
     Formats the ASCII 8-bit character representation of N as the first
     character in BUF, and returns '(char)n' as its return value.  If N
     is greater than 255 (0xff hex), returns the formatted character
     '(char)(n & 255)'.

'__ctalkDecimalIntegerToASCII (int I, char *S);'
     Format an ASCII representation of I, a decimal integer, in S.

'__ctalkLongLongToDecimalASCII (long long int L, char *BUF);'
'__ctalkLongLongToHexASCII (long long int L, char *BUF, bool UPPERCASE);'
'__ctalkLongToDecimalASCII (long int L, char *BUF);'
'__ctalkLongToHexASCII (long int L, char *BUF, bool UPPERCASE);'
     Format a decimal or hexadecimal ASCII representation of L, a long
     long int, in BUF, and return BUF.

     When using '__ctalkLongLongToHexASCII,' or '__ctalkLongToHexASCII,'
     if UPPERCASE is 'true', format the number using uppercase letters;
     e.g., '0XFFFF'; otherwise format the number using lowercase
     letters: '0xffff'.

'__ctalkDefaultSignalHandler (int SIGNO)'
     Set the handler of signal SIGNO to the system's default handler.

'__ctalkDefineClassMethod (char *CLASS, char *NAME, OBJECT *(*)(fn), int REQUIRED_ARGS);'

     Define a class method in class CLASS with name NAME, which calls
     the function FN, and requires REQUIRED_ARGS arguments.

'__ctalkDefineClassVariable (char *CLASS, char *NAME, char *VARCLASS, char *INIT_EXPR);'

     Define a class variable in class CLASS with NAME.  The variable is
     an object of class VARCLASS with the initial value INIT_EXPR.

'__ctalkDefineInstanceMethod (char *CLASS, char *NAME, OBJECT *(*)(fn), int REQUIRED_ARGS);'

     Define an instance method in class CLASS with name NAME, which
     calls the function FN, and requires REQUIRED_ARGS arguments.

'__ctalkDefineInstanceVariable (char *CLASS, char *NAME, char *VARCLASS, char *INIT_EXPR);'

     Define an instance variable in class CLASS with NAME.  The variable
     is an object of class VARCLASS with the initial value INIT_EXPR.

'__ctalkDefinedClassMethodObject (OBJECT *RCVR, char *CLASSNAME, char *METHOD_NAME)'
     Initialize a 'Method' object from the class method METHOD_NAME from
     class CLASSNAME.  Note that this function only works for methods
     that are already defined.  *Note Method::.

'__ctalkDefinedInstanceMethodObject (OBJECT *RCVR, char *CLASSNAME, char *METHOD_NAME)'
     Initialize a 'Method' object from the instance method METHOD_NAME
     from class CLASSNAME.  Note that this function only works for
     methods that are already defined.  *Note Method::.

'__ctalkDefineTemplateMethod (char *CLASSNAME, char *NAME, OBJECT *(*CFUNC)(), int REQUIRED_ARGS, int N_ARGS)'
     Defines a template method.  First calls __ctalkDefineClassMethod
     (), then performs additional initialization needed for templates.

'__ctalkDeleteLastExceptionInternal (void)'
     Deletes the most recent exception from Ctalk's internal exception
     list.

'__ctalkDeleteObject (OBJECT *OBJECT)'
     Delete an object, and any objects it refers to, if they are not
     referenced elsewhere.  It's a good idea to call '__objRefCntZero'
     first.  The object then won't be showing any extra references.

     Zeroing the reference count first causes the function to delete the
     object _completely_.  It bypasses Ctalk's internal mechanisms that
     decide when objects are no longer needed.  Don't use these
     functions unless you know where the object and any objects it
     refers to are declared.

     It should seldom be necessary to remove an object from a particular
     scope manually anyway.  But in that case, call '__objRefCntDec'
     instead, and then let Ctalk try to clean up the object when it goes
     out of scope.

     For example, to delete a scratch object using C,


          Object new tmpObject;
          OBJECT *tmpObject_alias;

          tmpObject_alias = tmpObject;

          __objRefCntZero (OBJREF(tmpObject_alias));
          __ctalkDeleteObject(tmpObject_alias);


     Translating the object to C should work in all cases, regardless of
     the surrounding code.  Of course, you can also use the 'delete'
     method (class 'Object') with many simple C expressions.


          Object tmpObject;
          OBJECT *tmpObject_alias;

          tmpObject delete;

          _..or.._

          tmpObject_alias delete;

          _..or even this expression.._

          tmpObject_alias -> instancevars delete;


     Deletes OBJ if there are no references to it, or if this is the
     last reference to the object.  In this case, the function works
     similarly to '__ctalkDeleteObject'.  Otherwise, the function
     decreases the object's reference count by 1.

'__ctalkDeleteObjectList (OBJECT *OBJECT)'
     Delete an object and any objects that link to it.

'__ctalkDeleteWinBuffer (OBJECT *PANEBUFFER_INSTANCE_VAR)'
     Deletes a 'paneBuffer' backing store allocated when a subclass of
     'Pane' creates an object.

'__ctalkDocDir (void)'
     Returns a 'char *' that contains the path where the Ctalk-specific
     documentation is installed on the system (i.e., documentation other
     than man pages and Texinfo manuals).

'__ctalkDoubleToASCII (double D, char *S);'
'__ctalkFloatToASCII (float F, char *S);'
'__ctalkLongDoubleToASCII (long double F, char *S);'
     Format an ASCII representation of the first argument in S.  Returns
     S.

     '__ctalkEnterArgBlockScope' C function
'__ctalkEnterArgBlockScope (void)'
     Ctalk inserts this call at the beginning of argument blocks.
     Checks that the block call is the result of an inline method call
     and sets the run-time stack's RTINFO structure to indicate a block
     call with the correct stack frame for the block's scope.

     '__ctalkEntryIconXPM' C function
'__ctalkEntryIconXPM (int ICONID)'
     Returns a 'char **' with the contents of an eye or slashed eye icon
     used when X11TextEntryPane objects echo dots.  The argument,
     ICONID, may be one of the following.


          #define ENTRY_ICON_EYE_NON       0
          #define ENTRY_ICON_EYE_OK        1
          #define ENTRY_ICON_EYE_SLASHED   2


     The definitions are included in 'x11defs.h' and 'ctalkdefs.h',
     which should be included in classes or programs with a statement
     like this.


          #include <ctalk/ctalkdefs.h>


     '__ctalkExec' C function
'__ctalkExec(char *CMDLINE, OBJECT *STROBJECT)'
     Executes the command line given as the argument and waits for the
     subprocess to finish.  If the STROBJECT argument is non-NULL, the
     function saves the subprocesses' standard output as the object's
     'value'.  Normally, STROBJECT should be a 'String' object.

     If the STROBJECT argument is NULL, '__ctalkExec' reads and prints
     the subprogram's standard output to the terminal's standard output.

     '__ctalkExec' supports the redirection operators '>' or '>>', which
     send the subprocess's standard output to the file given as the
     redirection operator's target.  If CMDLINE is a shell script, it is
     executed by a sub-shell using the 'system(3)' library function.

     '__ctalkExitArgBlockScope' C function
'__ctalkExitArgBlockScope (void)'
     Ctalk inserts this function, which is currenly a no-op, as the last
     function call in an argument block.

     '__ctalkExpandPath' C function
'__ctalkEpandPath (char *DIRGLOBPATTERN, char *EXPANDEDPATHOUT)'
     Expands DIRGLOBPATTERN into the full path name, and stores it in
     EXPANEDPATHOUT.  Returns the value of EXPANDEDPATHOUT.

'__ctalkErrorExit (void)'
     Cleans up the program's immediate object environment before a call
     to the C 'exit(3)' function.

'__ctalkEvalExpr (char *EXPR)'
     Evaluate EXPR and return an 'OBJECT *' to the result.

'__ctalkEvalExprU (char *EXPR)'
     Like '__ctalkEvalExpr', above, but '__ctalkEvalExprU' returns a C
     NULL instead of a null result object when an expression evaluates
     to 0.

'__ctalkExceptionInternal (MESSAGE *MSG, EXCEPTION E, char *TEXT)'
     Generate an exception of type E.  Exceptions are listed in
     'except.h', and in the description of 'Exception' class.  *Note
     Exception::.  If MSG is non-NULL, which is usually the case when
     the compiler generates and exception, the function records the line
     and column number of the exception.  If TEXT is non-NULL, the
     exception handler adds the text to the exception record, so it can
     be displayed when the program handles the exception.

     Programs should handle run-time exceptions as soon as possible
     after returning from a method.  The function
     '__ctalkHandleRunTimeExceptionInternal' is the normal exception
     handler, and '__ctalkTrapExceptionInternal' determines whether an
     exception has occurred.

'__ctalkFindClassVariable (char *VARNAME, int WARN)'
     Search the class library for _first occurrence_ of the class
     variable VARNAME.

     If WARN is 'TRUE,' issues a warning if the variable is not found.

     '__ctalkFindMethodByName' C function
'__ctalkFindMethodByName (OBJECT **OBJECT, const char *NAME, int WARN)'
     Returns the first instance or class method NAME if it exists in
     OBJECT's class or superclasses, or NULL if a method with that name
     isn't found.  If WARN is true, prints a warning message if the
     method isn't found.

'__ctalkFindPrefixMethodByName (OBJECT **RCVR, const char *NAME, int WARN)'
     Looks up a classes' instance method that matches NAME which has the
     'prefix' attribute set.  If WARN is true, prints a warning if the
     method is not found.

'__ctalkExceptionNotifyInternal (I_EXCEPTION *I)'
     The handler function of most exceptions.  Prints a message
     including any text provided as an argument to
     '__ctalkExceptionInternal'.

'__ctalkFilePtrFromStr (char *sFORMATTED_PTR)'
     Like '__ctalkGenericPtrFromStr (),' below, converts a string
     containing a formatted hexadecimal number to a pointer, and also
     checks that the pointer is a valid file.

     The function returns a 'void *' in order to keep Ctalk's header
     inclusion simple, or NULL if the argument does not contain a valid
     hexadecimal number, or if the pointer does not point to a valid
     file.

     This function can also set 'errno' in case of an error.

     Because the function returns a 'void *' an app or method must
     perform the cast from 'void *' to 'File *' when it calls this
     function.

'__ctalkFindClassMethodByFn (OBJECT **RCVR_P, OBJECT *(*FN)(), int WARN)'
     Finds a class method by calling '__ctalkGetClassMethodByFn' for the
     method's receiver and then the receivers of previous method calls.
     On success, returns the method, and RCVR_P contains the address of
     the method's receiver.

     If WARN is 'TRUE,' issues a warning if the method is not found.

'__ctalkFindClassMethodByName (OBJECT **RCVR_P, char *NAME, int WARN)'
     Finds a class method by by calling '__ctalkGetClassMethodByName'
     for the method's receiver and then the receivers of previous method
     calls.  On success, returns the method, and RCVR_P contains the
     address of the method's receiver.

     If WARN is 'TRUE,' issues a warning if the method is not found.

'__ctalkFindInstanceMethodByFn (OBJECT **RCVR_P, char *NAME, int WARN)'
     Finds an instance method by calling '__ctalkGetInstanceMethodByFn'
     for the method's receiver and then the receivers of previous method
     calls.  On success, returns the method, and RCVR_P contains the
     address of the method's receiver.

     If WARN is 'TRUE,' issues a warning if the method is not found.

'__ctalkFindInstanceMethodByName (OBJECT **RCVR_P, char *NAME, int WARN)'
     Finds an instance method by by calling
     '__ctalkGetInstanceMethodByName' for the method's receiver and then
     the receivers of previous method calls.  On success, returns the
     method, and RCVR_P contains the address of the method's receiver.

     If WARN is 'TRUE,' issues a warning if the method is not found.

'__ctalkSaveCVARArrayResource (char *NAME, int INITIALIZER_SIZE, void *var)'
     Saves an 'Array' object with the contents of 'var' in a method's
     object pool.

'__ctalkSaveCVARResource (char *NAME)'
     Saves the contents of C variable NAME in a method's object pool.

'__ctalkSaveOBJECTMemberResource (OBJECT *OBJECT)'
     Saves an 'OBJECT *' member to a method's resource pool.

'__ctalkSleep (int USECS)'
     Put a program to sleep for USECS microseconds.  The operating
     system restores the program to a running state no sooner than that
     amount of time has elapsed.

'__ctalkSort (OBJECT *COLLECTION, bool SORTDESCENDING)'
'__ctalkSortByName (OBJECT *COLLECTION, bool SORTDESCENDING)'
     Sorts a collection's members into ascending or descending order.
     '__ctalkSort' performs the sort using the collection members'
     values, while '__ctalkSortByName' uses the members' names.

     The algorithm used is very simple minded, although due to the
     mechanics of finding earlier/later collection members, it is as
     fast as divide-and-conquer algorithms for small or medium sized
     collections.  For large collections it is probably more practical
     to sort the collection as an 'OBJECT **' array and create a new
     list based on the collection members' sorted order.

     However, it is almost always faster to add members to collections
     in the order you want them sorted rather than trying to re-arrange
     the collection later.  For this, refer to the methods in the
     'SortedList' class *Note SortedList::.

'__ctalkStrToPtr (char *PTR)'
     Converts a formatted hexadecimal number to a 'void *'.  The
     function '__ctalkGenericPtrFromStr', below, performs some extra
     validation.

'__ctalkGenericPtrFromStr (char *S)'
     A wrapper function for '__ctalkStrToPtr ()' that performs some
     extra validation of the string argument.  These functions convert a
     string containing a formatted hexadecimal number (e.g.,
     '"0xnnnnnn"' or "'"0XNNNNNN"' into a 'void *.' Both of the
     functions return a 'void *', or NULL if the string does not contain
     a valid hexadecimal number.

'__ctalkGetCallingFnObject (char *NAME, char *CLASSNAME)'
     When used within 'Object : become', returns the object with the
     name NAME in the class CLASSNAME from 'become's' calling function.
     Also adjusts its caller indexes if 'become' is called within an
     argument block.

'__ctalkGetCallingMethodObject (char *NAME, char *CLASSNAME)'
     When used within 'Object : become', returns the object with the
     name NAME in the class CLASSNAME from 'become's' calling method.
     Also adjusts its caller indexes if 'become' is called within an
     argument block.

'__ctalkGetCArg (OBJECT *OBJ)'
     Retrieves the CVAR of the C variable named by OBJ.

'__ctalkGetInstanceMethodByFn (OBJECT *class_object, OBJECT *(*FN)(void), int WARN)'
     Returns the method that defines function FN from CLASS_OBJECT, or
     NULL if the method doesn't exist.  If WARN is true, prints a
     warning message if the method isn't found.

'__ctalkGetInstanceMethodByName (OBJECT *class_object, const char *NAME, int WARN)'
     Returns the method named NAME from CLASS_OBJECT, or NULL if the
     class doesn't define a method with that name.  If WARN is true,
     prints a warning message if the method isn't found.

'__ctalkGetReceiverPtr (void)'
     Returns an 'int' with the current value of the receiver stack
     pointer.

'__ctalkGetRS (void)'
     Returns a 'char' with the current record separator.  The record
     separator determines, among other uses, how regular expression
     characters act at line endings.  *Note RecordSeparator::.

'__ctalkGetRunTimeException (void)'
     Remove the first exception from the exception queue and return the
     exception's message as a char *.

'__ctalkGetTemplateCallerCVAR (char * NAME)'
     If called from within a function template, looks up the 'CVAR' NAME
     in the calling function or method.  This function returns a
     temporary object with the name and class, superclass, and value
     that correspond to the 'CVAR''s data type.  The return object
     persists until the next time this function is called.

'__ctalkGetClass (char * CLASSNAME)'
     Get the class object for CLASSNAME.

'__ctalkGetClassMethodByFn (OBJECT *RCVR, OBJECT *(*FN)(void), int WARN)'
     Return a class method of RCVR'S class with the run-time function
     FN.

     If WARN is 'TRUE,' issue a warning if the method is not found.

'__ctalkGetClassMethodByName (OBJECT *RCVR, char *NAME, int WARN)'
     Return a class method of RCVR'S class with the name NAME.

     If WARN is 'TRUE,' issue a warning if the method is not found.

'__ctalkGetExprParserAt (int IDX)'
     Return the expression parser, which is a struct 'EXPR_PARSER'
     typedef, at stack index IDX.

'__ctalkGetExprParserPtr (void)'
     Return the expression parser pointer, and 'int.'

'__ctalkGetClassVariable (OBJECT *RECEIVER, char *VARNAME, int)'
     WARN) Return the class variable named VARNAME from the receiver's
     class object, or 'NULL' if the variable does not exist.  If WARN is
     'TRUE,' issue a warning message if the variable is not found.

'__ctalkGetExceptionTrace (void)'
     Return 'TRUE' if a program has enabled exception walkbacks, 'FALSE'
     otherwise.

'__ctalkGetInstanceVariable (OBJECT *RECEIVER, char *VARNAME, int)'
     WARN) Return the instance variable named VARNAME from the receiver,
     or 'NULL' if the variable does not exist.  If WARN is 'TRUE,' issue
     a warning message if the variable is not found.

'__ctalkGetInstanceVariableByName (char *RECEIVER_NAME, char *VARNAME, int)'
     WARN) Return the instance variable named VARNAME from the object
     named by RECEIVER_NAME, or 'NULL' if the variable does not exist.
     If WARN is 'TRUE,' issue a warning message if the variable is not
     found.

'__ctalkGetPrefixMethodByName (OBJECT *class_object, const char *NAME, int WARN)'
     Returns the method named NAME from CLASS_OBJECT that has the
     'prefix' attribute set, or NULL if the class doesn't define a
     prefix method with that name.  If WARN is true, prints a warning
     message if the method isn't found.

'__ctalkGetTypeDef (char * NAME)'
     Return the 'CVAR' of the typedef NAME.

'__ctalkGetX11KeySym (int KEYCODE, int SHIFT_STATE, int KEYPRESS)'
     Returns an 'int' with the keyboard mapping of a keypress in X
     applications.  This allows programs to distinguish between modifier
     keypresses (e.g., shift, control, and alt), and alphanumeric
     keypresses.

     The first and second parameters are taken from an XKeyPressEvent or
     XKeyReleaseEvent structure.  The third parameter, KEYPRESS, should
     be true for Keypress events and false for keyrelease events.

     For alphanumeric keys, this function does not automatically modify
     the ASCII code of a key that is pressed when the shift key (or any
     other modifier key) is pressed.  That is, pressing 'A' and 'a' both
     return the ASCII value 97.  It is up to the program to record
     whether the shift key is pressed at the same time, and to provide
     the shifted character itself if necessary.

     Refer to the 'run' method in 'GLXCanvasPane' class for an example.

     This function uses 'XGetKeyboardMapping(3)' internally.

'__ctalkGLEW20 (void)'
     Returns a boolean value of true if the GLEW library supports
     version 2.0 extensions, mainly for OpenGL programs that use
     shaders.  Programs must call the '__ctalkInitGLEW' function before
     using this function.

'__ctalkGlobalObjectBecome (OBJECT *OLD, OBJECT *NEW)'
     Called when the receiver of 'Object : become' is a global object.

'__ctalkGlobFiles (char *PATTERN, OBJECT *list)'
     If the system's C libraries support file globbing with the 'glob'
     library function, '__ctalkGlobFiles' returns the file and directory
     pathnames that match PATTERN in the 'List' object given as the LIST
     argument.

     For information about how the C library matches file patterns,
     refer to the 'glob(3)' and related manual pages.

'__ctalkGLUTVersion (void)'
'__ctalkGLUTCreateMainWindow (char *TITLE)'
'__ctalkGLUTInitWindowGeometry (int X, int Y, int WIDTH, int HEIGHT)'
'__ctalkGLUTInit (int ARGC, char **ARGV)'
'__ctalkGLUTRun (void)'
'__ctalkGLUTInstallDisplayFn (void (*FN)())'
'__ctalkGLUTInstallReshapeFn (void (*FN)(int, int))'
'__ctalkGLUTInstallIdleFn (void (*FN)())'
'__ctalkGLUTInstallOverlayDisplayFunc (void (*FN)())'
'__ctalkGLUTInstallKeyboardFunc (void (*FN)(unsigned char, int, int))'
'__ctalkGLUTInstallMouseFunc (void (*FN)(int, int, int, int))'
'__ctalkGLUTInstallMotionFunc (void (*FN)(int, int))'
'__ctalkGLUTInstallPassiveMotionFunc (void (*FN)(int, int))'
'__ctalkGLUTInstallVisibilityFunc (void (*FN)(int))'
'__ctalkGLUTInstallEntryFunc (void (*FN)(int))'
'__ctalkGLUTInstallSpecialFunc (void (*FN)(int, int, int))'
'__ctalkGLUTInstallSpaceballMotionFunc (void (*FN)(int, int, int))'
'__ctalkGLUTInstallSpaceballRotateFunc (void (*FN)(int, int, int))'
'__ctalkGLUTInstallSpaceballButtonFunc (void (*FN)(int, int))'
'__ctalkGLUTInstallButtonBoxFunc (void (*FN)(int, int))'
'__ctalkGLUTInstallDialsFunc (void (*FN)(int, int))'
'__ctalkGLUTInstallTabletMotionFunc (void (*FN)(int, int, int, int))'
'__ctalkGLUTInstallMenuStatusFunc (void (*FN)(int, int, int))'
'__ctalkGLUTInstallMenuStateFunc (void (*FN)(int))'
'__ctalkGLUTInstallMenuStateFunc (void (*FN)(int))'
'__ctalkGLUTSphere (double, int, int, int);'
'__ctalkGLUTCube (double, int);'
'__ctalkGLUTCone (double, double, int, int, int);'
'__ctalkGLUTTorus (double, double, int, int, int);'
'__ctalkGLUTDodecahedron (int);'
'__ctalkGLUTOctahedron (int);'
'__ctalkGLUTTetrahedron (int);'
'__ctalkGLUTIcosahedron (int);'
'__ctalkGLUTTeapot (double, int);'
'__ctalkGLUTFullScreen (void);'
'__ctalkGLUTPosition (int, int);'
'__ctalkGLUTReshape (int, int);'
'__ctalkGLUTWindowID (char *WINDOW_NAME)'
     The functions that make up Ctalk's glue layer for the GLUT API. For
     their use, refer to the methods in GLUTApplication class.

'__ctalkGLXAlpha (float ALPHA)'
     Sets the alpha (opacity) channel for outline text rendering.
     Values should be between 0.0 (transparent) and 1.0 (opaque).  The
     Ctalk library's default value is 1.0 (opaque).

'__ctalkGLXDrawText (char *TEXT)'
     This is another convenience function that draws text on a
     'GLXCanvasPane' using a X font that the program registered with the
     pane's GLX context via a previous call to '__ctalkGLXUseXFont'.

     The 'GLXCanvasPane' class defines several methods that facilitate
     drawing with X fonts when using GLX. *Note GLXCanvasPane::.

'__ctalkGLXDrawTextFT (char *TEXT, float X, float Y)'
     Draws TEXT at the matrix coordinates given by the X,Y arguments.
     Programs should call at least '__ctalkGLXUseFTFont' before calling
     this function.

'__ctalkGLXExtensionsString (void)'
     Returns a 'char *' containing the extensions supported glX.

'__ctalkGLXExtensionSupported (char *EXTNAME)'
     Returns a boolean value of True if the system's glX extension
     supports EXTNAME, False otherwise.

'__ctalkGLXFrameRate (void)'
     Returns a 'float' with the frames per second of the calling
     program.  The function averages the rate over each interval of
     approximately five seconds.

'__ctalkGLXFreeFTFont (void)'
     Frees the font and library data from a previous call to
     '__ctalkGLXUseFTFont.'

'__ctalkGLXFreeXFont (void)'
     Frees X font data that was allocated by a previous call to
     '__ctalkGLXUseXFont'.  The 'GLXCanvasPane' class defines several
     methods that facilitate drawing with X fonts when using GLX. *Note
     GLXCanvasPane::.

'__ctalkGLXFullScreen (OBJECT *SELFOBJECT, char *WINTITLE)'
     Toggles the window's full screen mode on and off.

'__ctalkGLXNamedColorFT (char *COLORNAME)'
     Sets the foreground color for drawing text with Freetype fonts to
     the named X11 color given as the argument.

'__ctalkGLXPixelHeightFT (int PXHEIGHT)'
     Sets the height of the current Freetype face in use to the pixel
     height given as the argument.

'__ctalkGLXRefreshRate (void)'
     Returns a 'float' with the display's refresh rate if the OpenGL
     installation supports the 'GLX_OML_sync_control' extension.  If
     OpenGL doesn't support 'GLX_OML_sync_control', the function prints
     a warning message on the terminal and returns -1.

'__ctalkGLXSwapBuffers (OBJECT *GLXPANE_OBJECT)'
     This is an API-level wrapper for the GLXSwapBuffers library
     function.

'__ctalkGLXSwapControl (int INTERVAL)'
     Sets the swap buffer synchronization to 1/interval.  If interval is
     0, disables buffer swap synchronization.  If the machine's OpenGL
     does not support the 'GLX_MESA_swap_control' extension, the
     function is a no-op.  Returns 0 on success, -1 if the extension is
     not supported.

'__ctalkGLXTextWidth (char *TEXT)'
     Returns an 'int' with the width in pixels of TEXT rendered in the
     current font.  The program must first have selected a X font using
     '__ctalkGLXUseFon'.  If no font is selected, the function returns
     '-1'.

'__ctalkGLXUseFTFont (String FONTFILENAME)'
     Initializes the Freetype library and loads the font from the file
     given as the argument.  Use '__ctalkGLXFreeFTFont' to release the
     font data before calling this function again when changing fonts.

'__ctalkGLXUseXFont (OBJECT *GLXCANVASPANEOBJECT, char *FONTNAME)'
     This is a convenience function that registers the X font, FONTNAME
     for use with GLXCANVASPANEOBJECT, first by retrieving the X font
     data for FONTNAME, then registering the font using
     'glXUseXFont(3)'.

     After the program has finished drawing with the font, the program
     should call '__ctalkGLXFreeXFont'.

     The 'GLXCanvasPane' class defines several methods that facilitate
     drawing with X fonts when using GLX. *Note GLXCanvasPane::.

'__ctalkGLXFullScreen (void)'
     Returns a boolean value of true if the window is using Freetype
     fonts, false otherwise.

'__ctalkGLXWindowPos2i (int X, int Y)'
     This is a wrapper for the 'glWindowPos2i' function, which several
     methods in 'GLXCanvasPane' class use.

     Because 'glWindowPos2i' is an extension in many GL implementations,
     Ctalk checks for the function's presence when compiling the
     libraries.

     If the GL implementation does not provide 'glWindowPos2i', then any
     Ctalk program that tries to use this function (or one of the
     methods that call it), prints an error message and exits.

'__ctalkGLXWinXOrg (void)'
'__ctalkGLXWinYOrg (void)'
'__ctalkGLXWinXSize (void)'
'__ctalkGLXWinYSize (void)'
     These functions return an int with the window's current origin and
     size.

'__ctalkGUIPaneDrawCircleBasic (void *DISPLAY, int WINDOW_ID, int GC, int CENTER_X, int CENTER_Y, int RADIUS, int FILL, int PEN_WIDTH, int ALPHA char *FG_COLOR_NAME, char *BG_COLOR_NAME)'
     Draws a circle centered at CENTER_X,CENTER_Y with radius RADIUS.
     The dimensions are given in pixels.  If FILLED is true, then the
     function draws a filled circle; otherwise, the circle's edge has
     the width PEN_WIDTH.

     This function is a synonym for '__ctalkX11PaneDrawCircleBasic'.

'__ctalkGUIPaneClearRectangle (OBJECT *PANE_OBJECT, int X, int Y, int WIDTH, int HEIGHT)'
     Clear a rectangular region in a GUI Pane object.  Also clear the
     region in any buffers associated with the object.

'__ctalkGUIPaneClearWindow (OBJECT *PANE_OBJECT)'
     Clear a pane object's window.

'__ctalkGUIPaneDrawLine (OBJECT *PANE_OBJECT, OBJECT *LINE_OBJECT, OBJECT *PEN_OBJECT)'
     Draw a line specified by LINE_OBJECT (an instance of 'Line' class)
     using PEN_OBJECT (an instance of 'Pen' class).

'__ctalkGUIPaneDrawLineBasic (void *DISPLAY, int DRAWABLE_ID, int GC_PTR, int X_START, int Y_START, int X_END, int Y_END, int PEN_WIDTH, int ALPHA, char *PEN_COLOR)'
'__ctalkX11PaneDrawLineBasic (void *DISPLAY, int DRAWABLE_ID, int GC_PTR, int X_START, int Y_START, int X_END, int Y_END, int PEN_WIDTH, int ALPHA, char *PEN_COLOR)'
     Draw a line between the points (x_start,y_start) and (x_end, y_end)
     with the color, and transparency using the drawable ID, graphics
     context, and pen color, width, and transparency given as arguments.

     This function is a synonym for '__ctalkX11PaneDrawPointBasic.'

'__ctalkGUIPaneDrawPoint (OBJECT *PANE_OBJECT, OBJECT *POINT_OBJECT, OBJECT *PEN_OBJECT)'
     Draw a point on PANE_OBJECT specified by POINT_OBJECT using
     PEN_OBJECT.

'__ctalkGUIPaneDrawRectangle (OBJECT *PANE_OBJECT, OBJECT *RECTANGLE_OBJECT, OBJECT *PEN_OBJECT, int FILL)'
     Draw a rectangle on PANE_OBJECT specified by RECTANGLE_OBJECT using
     PEN_OBJECT.  If FILL is non-zero, draw a filled rectangle.

'__ctalkGUIPaneDrawRoundedRectangle (OBJECT *PANE_OBJECT, OBJECT *RECTANGLE_OBJECT, OBJECT *PEN_OBJECT, int FILL, int RADIUS)'
     This is similar to '__ctalkGUIPaneDrawRectangle', except that it
     takes an extra argument, RADIUS, which specifies the radius of the
     arcs that are used to draw the corners.

'__ctalkGUIPanePutStr (OBJECT *PANE_OBJECT, int X, int Y, char *STRING)'
     Display 'String' object STRING at coordinates X,Y on PANE_OBJECT.
     You can select the font with the 'font' method in class 'X11Pane'.
     This function relies on instance variables defined in 'X11Pane'
     class.  The '__ctalkX11PanePutStrBasic' function, below, provides a
     more flexible interface to the X libraries.

'__ctalkGUIPaneRefresh (OBJECT *PANE_OBJECT, int SRCX, int SRCY, int SRCWIDTH, int SRCHEIGHT, int DESTX, int DESTY)'
     Refresh the Pane object by updating the visible window with
     PANE_OBJECT's buffers and, if necessary, notifying the GUI library
     that the window has been updated.

'__ctalkGUISetBackground (OBJECT *PANE_OBJECT, char *COLOR)'
     Set the background of a pane's window to COLOR.  This function is
     intended only for objects that have an actual window; e.g.,
     'X11Pane' objects.  For all other visual types, like pixmaps, use
     __ctalkX11SetBackgroundBasic.

'__ctalkX11CreatePopupMenu (OBJECT *MENUOBJECT, int SCREEN_X, int SCREEN_Y)'
     Creates a popup menu window with the origin at SCREEN_X and
     SCREEN_Y.  The MENUOBJECT argument is a 'X11PopupMenu' object, with
     the menu's width and height determined by the items added to the
     menu before this function is called.  The menu is to be popped up
     at the point (SCREEN_X,SCREEN_Y), but it will not be visible until
     the '__ctalkX11MapMenu' function is called.

'__ctalkX11MapMenu (OBJECT *MENUOBJECT, int SCREEN_X, int SCREEN_Y)'
     Maps a popup menu object of the class 'X11PopupMenu' to the display
     at the display coordinates (SCREEN_X,SCREEN_Y).  The MENUOBJECT
     must have already been initialized with a call to
     '__ctalkX11CreatePopupMenu'.

'__ctalkX11MenuDrawLine (void *DISPLAY, unsigned int W, unsigned long GCPTR, int XSTART, int YSTART, int XEND, int YEND, int PENWIDTH, int ALPHA, char * COLORNAME)'
'__ctalkX11MenuDrawString (void *DISPLAY, unsigned int DRAWABLE, unsigned long GCPTR, int XSTART, int YSTART, int XEND, int PENWIDTH, int ALPHA, char *COLORNAME)'
     Library functions used to draw on 'X11PopupMenu' objects.  For
     their use, refer to the 'X11PopupMenu' class.

'__ctalkX11SubWindowGeometry (OBJECT * PARENTPANE, char * GEOMSTR, int *X_OUT, int *Y_OUT, int *width_out, int *HEIGHT_OUT)'
     Parses a string that contains the geometry specification of a
     subwindow, and returns the width and height of the subwindow and
     its X,Y position within the parent pane's window.

     A geometry specification has the form:


          width[%]xheight[%][+x_org[%]+y_org[%]]


     The _x, y, width, and height_ parameters are interpreted as the
     actual origin and size of the subwindow, unless a parameter is
     followed by a percent sign ('%').  In that case, the dimension is
     interpreted as a fraction of the parent window's corresponding
     vertical or horizontal dimension.

     For some 'Pane' classes, like dialog windows, if _x_org_ and
     _y_org_ are missing, then the class positions the dialog window
     centered over the parent window.

'__ctalkX11TextFromData (void *DISPLAY, int DRAWABLE_ID, int GD_PTR, char *TEXT)'
     Displays TEXT on DRAWABLE_ID.

'__ctalkX11TextWidth (char *FONTDESC, char *TEXT)'
     Returns an 'int' with the width in screen pixels of the TEXT
     argument when rendered in the font named by FONTDESC.  There is
     more information about how to use fonts in the sections that
     discuss the X graphics classes.  *Note X11Font::.

'__ctalkX11WithdrawMenu (OBJECT *MENUPANE_PARAM)'
     Withdraws all popup menus from the display.  The parameter,
     MENUPANE_PARAM, is not used at this time.

'__ctalkX11WxHGeometry (int PARENTWIDTH, int PARENTHHEIGHT, char *GEOMSPEC, int XOUT, int YOUT, int WIDTHOUT, int HEIGHTOUT)'
     Calculate the dimensions specified by GEOMSPEC within PARENTWIDTH
     and PARENTHEIGHT, and return the results in XOUT, YOUT, WIDTHOUT,
     and HEIGHTOUT.  For information about the format of GEOMSPEC, refer
     to the 'Window Geometry' subsection of the 'X11PaneDispatcher'
     class.  *Note X11PaneDispatcher::.

'__ctalkHandleRunTimeException (void)'
     Execute the exception handler for a pending exception.  The
     'handle' method (class 'Exception') calls this function.  *Note
     Exception::.

'__ctalkHandleRunTimeExceptionInternal (void)'
     Execute the exception handler for a pending exception.  If the
     exception is generated by an expression, execute the exception
     handler only if further expressions or subexpressions need to be
     evaluated.

'__ctalkHaveFTFaceBasic (void)'
     Returns TRUE if an application has created a new FreeType2 font
     face, FALSE otherwise.  This is a lower level library function that
     apps should not need to use directly, and may go away in the
     future.

'__ctalkHexIntegerToASCII (unsigned int PTR, char *S)'
     Format a hexadecimal representation of PTR in S.  The return value
     is the formatted string in S.

     On 64-bit machines, the prototype is:


          char *__ctalkHexIntegerToASCII (unsigned long long int ptr, char *buf)


'__ctalkIconXPM (int ICONID)'
     Returns a 'char **' with the XPM data for the dialog icon given by
     ICONID.  The library defines the following icon IDs.


          ICON_NONE
          ICON_STOP
          ICON_CAUTION
          ICON_INFO


'__ctalkIgnoreSignal (int SIGNO)'
     Set the handler for SIGNO to ignore the signal.

'__ctalkIncKeyRef (OBJECT *OBJECT, int INC, int OP)'
'__ctalkIncStringRef (OBJECT *OBJECT, int IDX, int OP)'
     Increment the reference to the value of OBJECT, a 'String' or 'Key'
     object, or one of its subclasses, by IDX.  If IDX is negative,
     decrements the reference to the value of the receiver.  If the
     reference is before or after the start or end of the receiver's
     value, further uses of the object return NULL.

     The argument OP can be one of the following constants, which are
     defined in 'ctalkdefs.h'.

     'TAG_REF_PREFIX'
          Increments (or decrements) the value of the receiver
          immediately.  Normally this is used for prefix '++' and '--'
          operators, and also '+=' and '-=' operators.

     'TAG_REF_POSTFIX'
          Increments (or decrements) the value of the receiver after its
          value is accessed.  Used normally for postfix '++' and '--'
          operators.

     'TAG_REF_TEMP'
          Adds a temporary reference that is cleared after the receiver
          is next read.  Normally you would use this for expressions
          that assign the reference to another object, as in this
          example.


               String new str1;
               String new str2;

               str1 = "Hello, world!";

               str2 = str1 + 3;


          The object 'str2' is assigned the calculated reference.  The
          value of 'str1' is unaffected.

'__ctalkInitGLEW (void)'
     Initialize the GLEW library.  Programs must call this function
     before performing any operations that use OpenGL extensions.

'__ctalkInlineMethod (OBJECT *RCVR, METHOD *METHOD, int N_ARGS, ...)'
     Call a method or block of code that is an argument to another
     method.  The class of RCVR and the class of METHOD do not need to
     be the same.  Currently, only the 'map' method uses inline method
     calls.  For an example of the '__ctalkInlineMethod ()''s use, see
     'map' (implemented by the 'List', 'Array', and 'AssociativeArray'
     classes).  This function can (and should) be used to implement
     inline method messages or code blocks when streaming over
     collections.

     The N_ARGS argument specifies the number of arguments to be passed
     to the target method.  Currently '__ctalkInlineMethod ()' supports
     0 - 6 arguments.

'__ctalkIntRadixToDecimalASCII (char *INTBUF)'
     Return a C string with the integer formatted in INTBUF formatted as
     a decimal (base 10) integer.

'__ctalkInstallHandler (int SIGNO, OBJECT *(*METHOD_C_FUNCTION)())'
     Set the handler of signal SIGNO to METHOD_C_FUNCTION.  The
     prototype of METHOD_C_FUNCTION is similar to the intermediate C
     prototype of Ctalk's methods.  Signal handlers installed with this
     function reset the handler to the default after each use, except
     for handlers on DJGPP platforms.

'__ctalkInstallPrefix (void)'
     Returns a 'char *' with the top-level directory where Ctalk is
     installed.  Ctalk's installation uses this directory as the
     top-level directory of its installation layout; for example, in
     relative terms, this is where Ctalk's various components get
     installed:


          Executables:            _prefixdir_/bin
          Libraries:              _prefixdir_/lib
          Class Libraries:        _prefixdir_/include/ctalk
          Texinfo Manuals:        _prefixdir_share/info
          Manual Pages:           _prefixdir_/share/man
          Searchable Docs:        _prefixdir_/share/ctalk


'__ctalkIntanceMethodInitReturnClass (char *RCVRCLASSNAME, char *METHODNAME, char *RETURNCLASSNAME)'
     Set the return class of method METHODNAME of class RCVRCLASSNAME to
     RETURNCLASSNAME.

'__ctalkInstanceVarsFromClassObject (OBJECT *OBJ)'
     Add the instance variables defined by OBJ'S class object.

'__ctalkInstanceVarIsCallersReceiver (void)'
     Used by 'Object: become'.  Returns True if the receiver object is
     an instance variable, False otherwise.

'__ctalkInitFTLib (void)'
     Initialize the system's FreeType2 library.  Returns 0 if
     successful, ERROR ('-1') if unsuccessful or if the library isn't
     available.  This is a lower level function that should not normally
     be needed by apps directly, and may go away in the future.

'__ctalkInstanceMethodParam (char *RCVRCLASSNAME, char *METHODNAME, OBJECT *(*SELECTOR_FN)(), char *PARAMCLASS, char *PARAMNAME, int PARAM_IS_POINTER)'
     Define a method parameter when initializing a method.  Normally the
     compiler generates this call for inclusion in '__ctalk_init ()' for
     the method initialization at run time.

'__ctalkIntFromCharConstant (char *STR)'
     Returns the 'int' value of the character constant STR.  Recognizes
     all of the escape sequences that Ctalk uses, whether the constant
     is enclosed in single quotes or not.  Also recognizes backslash
     escape sequences and the following control character constants.


          Escape Sequence    Int Value
          \0                 0
          \a                 1
          \b                 2
          \e                 27
          \f                 6
          \n                 10
          \r                 13
          \t                 9
          \v                 11


     The '\e' escape sequence is an extension to the C language
     standard.

'__ctalkIsClassVariableOf (char *CLASS, char *VARNAME)'
     Returns 'TRUE' if VARNAME is a class variable of CLASS, 'FALSE'
     otherwise.

'__ctalkIsCallersReceiver (void)'
     Used by 'Object : become' to determine if an object is the calling
     method's receiver.

'__ctalkIsDir (char *PATH)'
     Returns 'TRUE' if PATH is a directory, 'FALSE' otherwise.

'__ctalkIsInstanceMethod (OBJECT *SELF_OBJECT, char *METHOD_NAME)'
'__ctalkIsClassMethod (OBJECT *SELF_OBJECT, char *METHOD_NAME)'
     The functions return True if the method given by METHOD_NAME is an
     instance or class method, respectively, in SELF_OBJECT'S class.

'__ctalkIsInstanceVariableOf (char *CLASS, char *VARNAME)'
     Returns 'TRUE' if VARNAME is an instance variable of CLASS, 'FALSE'
     otherwise.

'__ctalkIsObject (OBJECT *O)'
     Return 'TRUE' if if O is a valid object, 'FALSE' otherwise.

'__ctalkIsSubClassOf (char *CLASSNAME, char *SUPERCLASSNAME)'
     Return 'TRUE' if CLASSNAME is a subclass of SUPERCLASSNAME, 'FALSE'
     otherwise.

'__ctalkLastMatchLength (void)'
     Return the length of the match from the last call to
     '__ctalkMatchText', below.

'__ctalkLibcFnWithMethodVarArgs (int (*LIBCFN)(), METHOD *METHOD, char *LIBCFN_RETURN_CLASS)'
     Call the C library function LIBCFN using with its template method
     METHOD.  For C library functions that use 'stdarg.h' variable
     arguments, LIBCFN_RETURN_CLASS should be 'Integer.'

     When evaluating an expression, the currently executing method is
     contained in the current 'EXPR_PARSER'.  *Note
     __ctalkGetExprParserAt::.

     _Note:_ This version of Ctalk only supports variable-argument
     functions on 32-bit Intel platforms.  If you try to use a
     variable-argument function on another hardware platform, Ctalk
     issues a warning and returns 'NULL.'

'__ctalkLogMessage (char *, ...)'
     Formats the message given as the argument and writes the message to
     the system's syslog facility.

'__ctalkMatchAt (Integer N)'
'__ctalkMatchIndexAt (Integer N)'
     Returns, respectively, the text, or the character index matched by
     the N'TH parenthesized subexpression during a previous call to
     '__ctalkMatchText' (i.e., a backreference).  The argument, N, is
     '0' for the first parenthesized subexpression, '1' for the next
     subexpression, and so on.  If the _n'_th pattern didn't match any
     text, returns NULL. *Note Pattern Matching::.

'__ctalkMatchText (char *PATTERN, char *TEXT, long long int *OFFSETS)'
     Find the occurences of PATTERN in TEXT.  Returns the index of each
     match in the OFFSETS array, with the list terminated by -1.
     Returns the number of matches, or -1 if there are no matches.

'__ctalkMatchPrintToks (bool PRINTTOKS)'
     If PRINTTOKS is 'true', then Ctalk prints the regular expression
     tokens and the matching text for every regular expression match,
     which can be useful for debugging regular expressions.

'__ctalkMapGLXWindow (OBJECT *GLXCANVASPANE_OBJECT)'
     Maps a 'GLXCanvasPane's' window to the display and creates a
     'GLXContext' for the window, and makes the GLXContext current.

     Saves the GLXContext pointer in the receiver's 'glxContextPtr'
     instance variable.  *Note GLXCanvasPane::.

'__ctalkMapX11Window (OBJECT *X11PANE_OBJECT)'
     The X library interface of the 'map' (class 'X11Pane') method *Note
     X11Pane::.  This function is a wrapper for the 'XMapWindow' and
     'XMapSubwindows' Xlib functions.

'__ctalkMethodObjectMessage (OBJECT *RCVR, OBJECT *METHOD_INSTANCE)'
     Perform a method call by sending RCVR the message defined by
     METHOD_INSTANCE, which is a previously defined 'Method' object.
     *Note Method::.

     The function returns '0' on success, '-1' on error.

     For examples of 'Method' object calls, *Note methodObjectMessage::.

'__ctalkMethodObjectMessage (OBJECT *RCVR, OBJECT *METHOD_INSTANCE, OBJECT *ARG1, OBJECT *ARG2)'
     Perform a method call by sending RCVR the message defined by
     METHOD_INSTANCE, which is a previously defined 'Method' object.

     The parameters ARG1 and ARG2 are the arguments to the method
     instance.  'Method' objects with two arguments are commonly used in
     graphical event dispatchers, particularly in 'X11PaneDispatcher'
     class.  This helps simplify the event dispatcher methods.

     The function returns '0' on success, '-1' on error.

     For examples of 'Method' object calls, *Note methodObjectMessage::.

'__ctalkMethodPoolMax (void)'
'__ctalkSetMethodPoolMax (int NEW_SIZE)'
     Get or set a program's method pool size, in the number of objects
     that each method's pool retains.  The default pool size is set when
     the Ctalk libraries are built, and is displayed in the configure
     program's status report during the build process.  When a method's
     pool size reaches this number of objects, the pool deletes the
     oldest object in the pool to make room for the new object.

     Generally, the default pool size is suitable for the language tools
     and demonstration programs that come packaged with Ctalk.  Some of
     the test programs in the 'test/expect' subdirectory that run
     through many iterations (i.e., thousands of iterations) require a
     larger pool size.  This is especially true if a program uses many C
     variables when iterating through its operations, and whether the C
     variables are simply scalar or constant values (e.g., ints,
     doubles, and literal strings), and whether the variables are
     pointers to objects in memory.

'__ctalkMethodReturnClass (char *CLASSNAME)'
     Set the return class of an instance or class method during method
     initialization.

'__ctalkNArgs (void)'
     Returns an 'int' with the number of arguments passed to the current
     method.

'__ctalkNMatches (void)'
     Returns an 'int' with the number of matches from the last call to
     __ctalkMatchText.

'__ctalkNewFTFace (void)'
     Initialize a new FreeType2 face object.  This is a lower level
     library function that apps should not need to use directly, and may
     go away in the future.

'__ctalkNewSignalEventInternal (int SIGNO, int PID, char *DATA)'
     Generate and queue a 'SignalEvent' object for signal SIGNO with
     process ID PID.  The DATA argument is a 'String' object that the
     program can use to pass information back to the application.

'__ctalkNonLocalArgBlkReturn (void)'
     Returns a 'bool' value of true or false to an argument block's
     parent method to indicate whether the argument block executed a
     'return' statement.

'__ctalkObjValPtr (OBJECT *O, void *PTR)'
     Set the value of the object O to PTR.

'__ctalkPaneResource (OBJECT *PANEOBJECT, char *RESOURCENAME, bool WARN)'
     Returns an 'OBJECT *' with the value corresponding to RESOURCENAME
     from PANEOBJECT'S 'resource' instance variable.  If WARN is true,
     displays a warning if the resource isn't found.

'__ctalkPeekExceptionTrace (void)'
     Returns a 'char *' with the text of the most recent exception and
     its stack trace.

'__ctalkPeekRunTimeException (void)'
     Returns a 'char *' with the text of the most recent exception.

'__ctalkPendingException (void)'
     A convenience method for '__ctalkTrapException.' Returns 'TRUE' if
     an exception is pending, 'FALSE' otherwise.

'__ctalkPrintExceptionTrace (void)'
     Print a walkback of the current exception's copy of the program
     call stack.

'__ctalkPrintObject (OBJECT *OBJECT)'
     Print the object given by the argument, and its instance variables,
     to standard output.

'__ctalkPrintObjectByName (OBJECT *OBJECT_NAME)'
     Print the object named by OBJECT_NAME to the standard output.

'__ctalkProcessWait (int CHILD_PROCESSID, int *CHILD_RETURN_VALUE_OUT, int *CHILD_TERM_SIG_OUT, int *ERRNO_OUT)'
     Checks the status of the child process specified by
     CHILD_PROCESSID.

     If the return value of '__ctalkProcessWait' is 0, then there is no
     change in the child processes' status to report.  A return value
     equal to CHILD_PROCESSID indicates that the child process has
     exited.  If the return value is -1, then there was an error either
     in the process that called '__ctalkProcessWait', the child process,
     or both.

     When '__ctalkProcessWait's' return value is equal to
     CHILD_PROCESSID, the function returns the child processes' return
     value in CHILD_RETURN_VALUE_OUT.  If the child process was
     terminated by an uncaught signal, the signal number is returned in
     CHILD_TERM_SIG_OUT.

     If the function's return value is -1, then function returns the
     system's error code in ERRNO_OUT.

'__ctalkRaiseX11Window (OBJECT *X11PANE_OBJECT)'
     The X library interface of the 'raise' (class 'X11Pane') method.

'__ctalkReceiverReceiverBecome (OBJECT *OBJECT)'
     Used by 'become' (class 'Object') to change the calling method's
     receiver to the object given as the argument.

'__ctalkReferenceObject (OBJECT *OBJ, OBJECT *REFFED_OBJ)'
     Sets OBJ'S value to REFFED_OBJ'S hexadecimal address.  Also
     incrememts REFFED_OBJ'S reference count by 1 and adds
     VAR_REF_OBJECT to its scope.

'__ctalkRegisterArgBlkReturn (int RETURN_CODE, OBJECT *RETURN_OBJECT)'
     This function gets called when Ctalk encounters a return statement
     in an argument block.  The first argument is the return code of the
     argument block itself (typically an 'Integer' object with a value
     of -2, which signals the 'map' method that the argument block has
     requested a return from the parent function or method), and the
     second argument is the object that is to be returned by the caller.

     The following example should hopefully explain how these functions
     work together.  The comments indicate where the compiler inserted
     these functions.


          int main () {
            String new str;

            str = "Hello, world!";

            str map {
              if (self == 'o') {
                break;
              }
              printf ("%c", self);
            }
            printf ("\n");

            str map {
              switch (self)
                {
                case 'a':
                case 'e':
                case 'i':
                case 'o':
                case 'u':
          	if (self == 'o') {
          	  printf ("\n");
          	  return 11;          /* __ctalkRegisterArgBlkReturn inserted   */
          	}                    /* here.  The String map method, which is */
          	break;                /* the argument block's direct caller,    */
                }                      /* contains a __ctalkArgBlkSetCallerReturn*/
              (Character *)self -= 32;  /* function call.                         */
              printf ("%c", self);
            }
            printf ("\n");
          }


          /* After the argument block call, the compiler inserts a
             construct like the following:

              if (__ctalkNonLocalArgBlkReturn ()) {
                  return __ctalkToCInteger (__ctalkArgBlkReturnVal (), 1);
              }

            This retrieves the argument block's return value if any,
            and returns from the calling function.
          */

     The 'String : map' method contains an example of how an argument
     block can signal a return from the function or method that called
     it.  Refer also to the '__ctalkArgBlkSetCallerReturn' and
     '__ctalkArgBlkClearCallerReturn' functions above.

'__ctalkRegisterBoolReturn (int T-OR-F-ARG)'
     Returns a boolean object with a true or false value depending on
     the value of T-OR-F-ARG.  If the Boolean class variables 'boolTrue'
     or 'boolFalse' are defined, returns one of those objects.
     Otherwise, creates a 'Boolean' object with the value true or false.

'__ctalkRegisterCharPtrReturn (char *VAR)'
     Saves a C 'char *' method return value to the method's resource
     pool.

'__ctalkRegisterCharPtrReturn (char VAR)'
     Saves a C 'char' method return value to the method's resource pool.

'(char *TYPE, char *QUALIFIER, char *QUALIFIER2, char *QUALIFIER3, char *QUALIFIER4, char *STORAGE_CLASS, char *NAME, int N_DEREFS, int ATTRS, int IS_UNSIGNED, int SCOPE)'
     Register a C typedef with an application.  This function is
     typically used by '__ctalk_init' to register typedefs defined in C
     include files and elsewhere.

'__ctalkRegisterExtraObject (OBJECT *CREATED_OBJECT)'
     Save an object retrieved by a function so it may be referred to
     later.  This function registers each object only once and does not
     adjust the object's reference count or scope.  The
     '__ctalkRegisterExtraObject' function silently ignores request to
     register global and class objects.  Refer to the entry for
     '__ctalkRegisterUserObject,' below.

'__ctalkRegisterFloatReturn (double d)'
     Registers a C 'double' return value as a 'Float' method resource
     object.  Note that the C libraries do not automatically convert C
     'floats' to 'doubles', so if you register a C 'float' as a method
     resource, you need to cast it to a 'double' first.

'__ctalkRegisterIntReturn (int RETURNVAL)'
     Registers a C 'int' method return value as an 'Integer' method
     resource object.

'__ctalkRegisterIntReturn (long long int RETURNVAL)'
     Registers a C 'long long int' method return value as a
     'LongInteger' method resource.

'__ctalkRegisterUserFunctionName (char *NAME)'
     Registers the names of C functions in the program, mainly for
     diagnostic messages.  This function is added automatically to
     '__ctalk_init' whenever a C function in the source code is parsed
     and is called at the start of a program.

'__ctalkRegisterUserObject (OBJECT *CREATED_OBJECT)'
     Save objects created by a method so they may be referred to later.
     New objects registered by this function have a reference count of
     1, and have the additional scope 'METHOD_USER_OBJECT'.  This
     function is also used by many of the 'methodReturn*' macros, and if
     necessary you can included it in a method if you need to register
     an object in some non-standard manner.  *Note Returning method
     values::.

     Note that global objects and class objects do not need to be
     registered.  In fact, registering such objects as method resources
     can confuse the object's entries in their respective dictionaries,
     because method resources have a separate dictionary of their own.
     If a method tries to register a class object or global object,
     '__ctalkRegisterUserObject' silently ignores the request.

'__ctalkReplaceVarEntry (VARENTRY *VARENTRY, OBJECT *NEW_OBJECT)'
     This function has been superceded.  If you want to attach an Object
     to another tag, it's only necessary to use an assignment statement.
     See '__ctalkAliasReceiver ()' for an example

'__ctalkRtGetMethod (void)'
     Returns the currently executing method as a 'METHOD *' from the
     call stack, or NULL if called from within a C function.

'__ctalkRtReceiver (OBJECT *RECEIVER_OBJECT)'
     Sets the call stack's receiver to RECEIVER_OBJECT.  The function
     however, does not alter the currently executing method's receiver
     on the receiver stack.

'__ctalkRtReceiverObject (void)'
     Returns the currently executing method's receiver object from the
     call stack.

'__ctalkRtSaveSourceFileName (char *FN)'
     Called during the initialization of a function or method to store
     the name of its source file.

'__ctalkRtGetMethodFn (void)'
     Returns the C function pointer (an 'OBJECT *(*)()' of the currently
     executing method, or NULL if called from within a C function.

'__ctalkRtMethodClass (OBJECT *CLASS_OBJECT)'
     Sets the class object of the currently executing method to
     CLASS_OBJECT.

'(OBJECT *CLASS_OBJECT)'
     Returns the class object of the currently executing method.

'__ctalkSearchBuffer (char *PATTERN, char *BUFFER, long long *OFFSETS)'
     Finds all occurrences of PATTERN in BUFFER, and returns the
     positions of the matches in OFFSETS, terminated by -1.

'__ctalkSelectXFontFace (void *DISPLAY, int DRAWABLE_ID, int GC_PTR, int FACE)'
     Selects the typeface of the currently selected font, if available,
     which should have been loaded with a call like
     '__ctalkX11UseFontBasic', or the equivalent calls for FreeType
     fonts.

     The argument, FACE, may be one of the following.


          X_FACE_REGULAR
          X_FACE_BOLD
          X_FACE_ITALIC
          X_FACE_BOLD_ITALIC


     Because these functions use shared memory to manage each X
     typeface's metrics, it is generally necessary to call this function
     after calling '__ctalkOpenX11InputClient' in order to display
     multiple faces with the correct character spacing.

'__ctalkSelfPrintOn (void)'
     Print the calling method's arguments to the receiver.  This
     function is called directly by 'printOn' (class 'String') and
     similar methods.  *Note String::.

'__ctalkSetExceptionTrace (int VAL)'
     Enable or disable exception method traces in 'handle' (class
     'Exception') and other methods.  *Note Exception::.

'__ctalkSetObjectAttr (OBJECT *OBJECT, unsigned intATTRIBUTE)'
'__ctalkObjectAttrAnd (OBJECT *OBJECT, unsigned intATTRIBUTE)'
'__ctalkObjectAttrOr (OBJECT *OBJECT, unsigned intATTRIBUTE)'
     These methods sets the 'attr' member of OBJECT to ATTRIBUTE.

     Note that when setting or clearing attributes on complex objects,
     it is better to use '__ctalkObjectAttrAnd' or
     '__ctalkObjectAttrOr', because complex objects can contain instance
     variables that use different attributes.

     For example, an instance variable that is a 'Symbol' would have the
     additional attribute 'OBJECT_VALUE_IS_BIN_SYMBOL', so if a method
     or function contained an expression like this:


          __ctalkSetObjectAttr (myObj, myObj -> attrs | OBJ_HAS_PTR_CX);


     This would have the effect of setting the parent object's
     attributes as well as the instance variables, which would clear any
     additional attributes that the instance variables have.

     What would actually happen is that the parent object 'myObj', and
     its instance variables would have their attributes set like this.


          <obj> -> attrs = (myObj -> attrs | OBJ_HAS_PTR_CX);


     so it is better to use an expression like this one.


          __ctalkObjectAttrOr (myObj, OBJ_HAS_PTR_CX);


     This has the effect of applying the following to the parent object
     and each instance variable:


          <obj> -> attrs |= OBJ_HAS_PTR_CX);


     Conversely, to clear a single attribute, a function or method would
     contain an expression like this.


          __ctalkObjectAttrAnd (myObj, ~OBJ_HAS_PTR_CX);


'__ctalkSetObjectName (OBJECT *OBJECT, char *NAME)'
     Sets the name of OBJECT to NAME.

'__ctalkSetObjectScope (OBJECT *OBJECT, int SCOPE)'
     Set the scope of OBJECT to SCOPE.  Note that many of Ctalk's scopes
     are only used internally.  The scopes that are useful in methods
     are defined in 'ctalkdefs.h'.  Those definitions are listed here
     along with their values.  *Note Scoping::.


          GLOBAL_VAR          (1 << 0)
          LOCAL_VAR           (1 << 1)
          CREATED_PARAM       (1 << 6)
          CVAR_VAR_ALIAS_COPY (1 << 7)
          VAR_REF_OBJECT      (1 << 9)
          METHOD_USER_OBJECT  (1 << 10)


'__ctalkSetObjectValue (OBJECT *OBJECT, char *VALUE)'
     This is a wrapper for '__ctalkSetObjectValueVar ()', below, which
     was used in earlier versions of the class libraries.  You should
     use '__ctalkSetObjectValueVar ()' instead.

'__ctalkSetObjectValueAddr (OBJECT *OBJECT, void *MEM_ADDR, int DATA_LENGTH)'
     Set OBJECT'S value to a pointer to the memory area MEM_ADDR.  The
     object must be a member of Vector class or one of its subclasses.
     The function also sets the object 'length' instance variable, and
     adds OBJECT_VALUE_IS_MEMORY_VECTOR to its attributes, and registers
     the vector * address.

'__ctalkSetObjectValueBuf (OBJECT *OBJECT, char *BUF)'
     Set the 'value' instance variable to the buffer BUF.  Unlike
     '__ctalkSetObjectValue ()' and '__ctalkSetObjectValueVar (),' this
     function replaces the value of OBJECT with BUF, even if BUF is
     empty, so you can add a random-length buffer to OBJECT.

'__ctalkSetObjectValueVar (OBJECT *OBJECT, char *VALUE)'
     Set the value of OBJECT to VALUE.  If VALUE is 'NULL', sets
     OBJECT's value to Ctalk's '(null)' string.

'__ctalkSetObjPtr (OBJECT *OBJECT, void *P)'
     Save the pointer P in OBJECT.

'__ctalkSetRS (char RECORD_SEPARATOR_CHAR)'
     Set's the current program's record separator character, which
     determines, among other things, how regular expression
     metacharacters work with line endings.  *Note RecordSeparator::.

'__ctalkSignalHandlerBasic (int SIGNO)'
     Provides a basic signal handler that is more robust than the
     methods in 'SignalHandler' class, but less flexible.  Causes the
     application to terminate and print a walkback trace if enabled.

     Applications can use '__ctalkInstallHandler ()' to install the
     signal handler.  In this case it works similarly to a method with a
     C calling protocol.  Here is the 'installExitHandlerBasic' method
     from 'Application' class.


          Application instanceMethod installExitHandlerBasic (void) {
            __ctalkInstallHandler
              (__ctalkSystemSignalNumber ("SIGINT"),
               (OBJECT *(*)())__ctalkSignalHandlerBasic);

            return NULL;
          }


'__ctalkSpawn (char *COMMAND, int RESTRICT_IO)'
     The '__ctalkSpawn' function launches the program named by COMMAND
     as a daemon process, and then returns to the parent program and
     continues execution of the parent.

     The function returns the process id of the child process.

     The daemon process runs as a true daemon - that is, without a
     controlling terminal, and without the standard input, output, or
     error channels.  All communication between the daemon and the
     parent program should take place with UNIX interprocess
     communication facilities.

     If RESTRICT_IO is non-zero, the program changes the daemon
     processes' working directory to '/' and sets its umask to '0'.

     Traditionally, a parent program exits immediately after spawning a
     daemon process.  But '__ctalkSpawn' maintains the session process -
     the process that handles the session and I/O initialization before
     it launches the daemon.  The session process stays active until the
     parent process exits and orphans it.  Then the session process
     exits also, leaving the daemon to run completely in the background
     until it is killed.  That means, while the parent program is
     running, there can be _three_ entries in the system's process
     table, when viewed with a program like 'ps' or 'top'.  However, it
     also mimimizes the possibility of causing zombie processes should
     any part of the program quit unexpectedly.

     You should note that '__ctalkSpawn' does not use a shell or any
     shell facilities to exec the daemon process, which means the
     function doesn't support I/O redirection or globbing.  If you want
     the parent process to handle the child processes' I/O, refer to the
     '__ctalkExec' function.  *Note ctalkExec::.

'__ctalkStringifyName (OBJECT *SRC, OBJECT *DEST)'
     When called by a function like 'String' : '=', performs some
     munging of different types of 'String' objects in order to keep the
     API consistent for different types of 'String' objects.

'__ctalkSplitText (char *TEXT, OBJECT *LIST_OUT)'
     Splits a text buffer into word tokens, and returns the tokens as
     members of LIST_OUT.  This function preserves newlines and spaces,
     and places HTML-style format tags in their own tokens.  This is
     used by classes like 'X11TextPane' to split its text buffer before
     displaying the wrapped text.  *Note X11TextPane::.

'__ctalkStrToPtr (char *S)'
     If S is a C string formatted as a hexadecimal number with the
     format '0x'NNNNNNN, return a C 'void *' pointer with that address.

'__ctalkSysErrExceptionInternal (MESSAGE *ORIG, int ERRNO, char *TEXT)'
     Generates an exception base on ERRNO with the text TEXT.  Ctalk
     translates ERRNO in an exception that represents the C library's
     'errno' error definitions.  The ORIG argument provides the line and
     column number where the exception occurred.  If NULL, the exception
     doesn't record the line and column information.

'__ctalkSystemSignalName (int SIGNO)'
     Returns a string containing a mnemonic name like 'SIGINT' or
     'SIGHUP' that corresponds to SIGNO.  Includes the mnemonics of the
     common signals defined by POSIX standards.

'__ctalkSymbolReferenceByName (OBJECT *OBJECT)'
     Used in 'Symbol : =' and similar methods returns a boolean value of
     'true' if the object (the argument to the method normally) was
     retrieved by its name, or false if the argument is the result of
     pointer math or indirection.  This allows the method to determine
     whether it needs to perform additional indirection or pointer math
     on the argument before assigning it the the receiver.

'__ctalkSystemSignalNumber (char *SIGNAME)'
     For a signal named SIGNAME, return the number system-dependent
     number of the signal.  The function defines names POSIX 1990
     signals on most systems.  Refer to the system's 'signal(2)' (or
     similar) manual page for information.

'__ctalkTemplateCallerCVARCleanup (void)'
     Cleans up after a '__ctalkGetTemplateCallerCVAR' call.  *Note
     __ctalkGetTemplateCallerCVAR::.  Ctalk calls this function
     internally; you should not need to use it in your own programs.

     Note that this function does not know about parameter substitution.
     If you want to print an object that is an argument to a method, use
     the 'ARG(N)' macro, and reference the 'name' member.  *Note ARG
     macro::.
          __ctalkPrintObject(ARG(0)->__o_name);

'__ctalkTerminalHeight (void)'
'__ctalkTerminalWidth (void)'
     Returns the height and width of the terminal in character rows and
     columns.  If the terminal does not support reporting its size,
     these functions return 0.

'__ctalkToCArrayElement (OBJECT *O)'
     Translate the value of an 'Integer,' 'Character,' 'String,' or
     'LongInteger' array element to a 'void *' that points to its
     corresponding C data type.

'__ctalkToCCharPtr (OBJECT *OBJ, int KEEP)'
     Returns the value of OBJ as a C 'char *'.  If KEEP is zero, deletes
     OBJ if possible.

'__ctalkToCDouble (OBJECT *OBJ)'
     Returns the value of OBJ as a C 'double'.

'__ctalkToCIntArrayElement (OBJECT *OBJ)'
     Returns the value of OBJ as a C 'int'.  This function has mostly
     been superceded by '__ctalkToCInteger' (below).

'__ctalkToCInteger (OBJECT *OBJ)'
     Returns the value of OBJ as a C 'int'.  The value can be a binary,
     octal, decimal, or hexadecimal number.  Prints a warning message if
     the value is not a valid number or is out of range.

'__ctalkTrapException (void)'
     If there is a run-time exception pending, returns the first
     exception in Ctalk's internal format.  Otherwise, returns NULL.

'__ctalkTrapExceptionInternal (void)'
     Similar to '__ctalkTrapException', except that it works with the
     passes in the compiler as well as the run time library.

'__ctalkObjectPrintOn (OBJECT *OBJECT)'
     Print the calling method's arguments to the argument's 'value'
     instance variable.  This function is called directly by 'printOn'
     (class 'ANSITerminalStream') and similar methods.  *Note
     ANSITerminalStream::.

'__ctalkOpenX11InputClient (OBJECT *X11TERMINALSTREAM_OBJECT)'
     Start a GUI program's input client in the background.  The input
     client receives input events, like mouse motion and keypresses, and
     window events, like resize notifications from the X display server,
     and sends the information to the application program so that it can
     queue 'InputEvent' objects which the app can then process.

     The argument is a 'X11TerminalStream' object, which is normally
     created with a 'X11Pane' object, and which programs can refer to by
     the 'X11Pane' object's 'inputStream' instance variable.

     This is the lower-level function that the 'openEventStream' (class
     'X11Pane') method uses to begin communicating with the X display
     server.  For an example, refer to the 'X11TerminalStream' section.
     *Note X11TerminalStream::.

'__ctalkUNIXSocketOpenReader (char *SOCKETPATH)'
     Opens a UNIX domain socket, binds the socket to the path given by
     SOCKETPATH, and places the socket in listening mode.

     Returns the file descriptor of the new socket on success, or -1 if
     an error occured, in which case the C library sets the variable
     'errno'.

'__ctalkUNIXSocketOpenWriter (char *SOCKETPATH)'
     Opens a UNIX domain socket and connects to the socket given by
     SOCKETPATH.

     Returns the file descriptor of the new socket on success, or -1 if
     an error occurs, in which case the C library sets the variable
     'errno'.

'__ctalkUNIXSocketRead (int SOCKFD, void * BUF_OUT)'
     Reads data from the socket given by SOCKFD.  On success, returns
     the data read in BUF_OUT and the return value is the number of
     bytes read.  On error returns -1 and the C library sets the
     variable ERRNO.

'__ctalkUNIXSocketShutdown (int SOCKFD, int HOW)'
     This function is a wrapper for the C library's 'shutdown' function.
     Shuts down the socket identified by the SOCKFD argument.  The
     second argument, HOW, can be either 'SHUT_RD, SHUT_WR, or SHUT_RW.'
     These constants are defined in 'UNIXNetworkStream' class and
     described in the 'shutdown(1)' manual page.

     The function returns 0 on success, or -1 if an error occurred.

'__ctalkUNIXSocketWrite (int SOCKFD, void * DATA, int LENGTH)'
     Writes LENGTH bytes of DATA to the socket given by SOCKFD.

     On success returns the number of bytes written, or returns -1 on
     error, in which case the C library sets the variable 'errno'.

'__ctalkUTCTime (void)'
     Returns an 'int' with the system's UTC time.  This function is
     currently a wrapper for the 'time(2)' function.  Because
     'time(2)''s argument is an 'int *', it can often be more reliable
     to use '__ctalkUTCTime' and let the library worry about the
     argument's storage.  There is also a template for 'time(2)' if you
     want to use the function directly in complex expressions.

'__ctalkWarning (char *FMT, ...)'
     Prints a formatted message to the terminal.  Unlike '_warning' and
     other functions, does not add line numbers or input file
     information to the output.

'__ctalkWrapText (unsigned int DRAWABLE, unsigned int GC_PTR, OBJECT *TEXT_LIST, int PANE_WIDTH, int LMARGIN)'
     Formats the text in TEXT_LIST to be displayed between LMARGIN and
     PANE_WIDTH (the right edge of the drawing surface given as the
     first argument..  The TEXT_LIST list should have been generated by
     '__ctalkSplitText'.  The '__ctalkWrapText' function uses the
     current typeface to determine character widths.  If no font or
     typeface is selected, uses the default font, "fixed" to format the
     text.

'__ctalkX11CloseClient (OBJECT *PANE_OBJECT)'
     Closes the main program's connection to the X11 client and exits
     the client process.

'__ctalkX11CloseParentPane (OBJECT *PANE_OBJECT)'
     Closes and deletes an application's main X11 window, and its
     buffers and other data.  Does not delete subpanes - see
     __ctalkCloseX11Pane () (above) to delete subpanes.  Applications
     should delete subpanes before closing and deleting the main window.
     For an example of the functions' use, refer to the method 'X11Pane
     : deleteAndClose'.  *Note X11Pane::.

'__ctalkX11ClosePopupMenuPane (OBJECT *MENU_OBJECT)'
     Deletes the popup menu's record from the library's internal menu
     stack.

'__ctalkX11ClearRectangleBasic (void *DISPLAY, int VISUAL_ID, int GC_PTR, int X, int Y, int WIDTH, int HEIGHT)'
     Clear a rectangle of a visual type like a pixmap to the background
     color.

'__ctalkX11Colormap (void)'
     Returns the X resource ID of the display's default colormap.  It's
     contained in a library function because the X headers define some
     of the DefaultColormap's dependent macros after DefaultColormap,
     which is not compatible with the ctpp preprocessor.

'__ctalkX11CopyPixmapBasic (void *DISPLAY, int DEST_DRAWABLE_ID, int DEST_GC_PTR, int SRC_DRAWABLE_ID, int SRC_X_ORG, int SRC_Y_ORG, int SRC_WIDTH, int SRC_HEIGHT, int DEST_X_ORG, int DEST_Y_ORG)'
     Copies the drawable SRC_DRAWABLE_ID to DEST_DRAWABLE_ID, with the
     dimensions of the source graphic given by SRC_X_ORG, SRC_Y_ORG,
     SRC_WIDTH, and SRC_HEIGHT.  The image is drawn with its upper
     left-hand corner positioned at DEST_X_ORG, DEST_Y_ORG on the
     destination drawable.

     This function is called by 'X11CanvasPane' : 'copy'.  For an
     example, refer the 'X11CanvasPane' classes' description.  *Note
     X11CanvasPane::.

'__ctalkX11CreateGC (void *DISPLAY, int DRAWABLE)'
     Create a X Graphics Context and return its address as a 'void *'.
     The GC is created with the following values:


          foreground     white
          background     black
          fill_style     FillSolid
          function       GXcopy
          font           fixed


'__ctalkX11CreatePixmap (void *DISPLAY, int X_DRAWABLE, int WIDTH, int HEIGHT, int DEPTH)'
     reate a X pixmap and return its X resource ID as an unsigned int.

'__ctalkX11CreatePaneBuffer (OBJECT *PANE_OBJECT, int WIDTH, int HEIGHT, int DEPTH)'
     Create the buffers for a pane object's X window.  Applications
     normally call this function when the pane object is created or when
     a subpane is attached to a parent pane.  This function sets the
     PANE_OBJECT'S 'paneBuffer' and 'paneBackingStore' instance
     variables.

'__ctalkX11DeletePixmap (int DRAWABLE_ID)'
     Delete the server-side pixmap whose ID is given as the argument.

'__ctalkX11Display (void)'
     Return a pointer to the X display, opening the display if
     necessary.

'__ctalkX11DisplayHeight (void)'
     Returns an 'int' with the display's height in pixels.

'__ctalkX11DisplayWidth (void)'
     Returns an 'int' with the display's width in pixels.

'__ctalkX11FontCursor (OBJECT *CURSOR_OBJECT, int CURSOR_ID)'
     Set CURSOR_OBJECT's value to a X11 CURSOR_ID.  Cursor ID's are
     defined by the X server in the include file 'X11/cursorfont.h'.
     *Note X11Cursor::.

'__ctalkX11FreeGC (int GC_ADDR)'
     Free the X11 graphics context pointed to by GC_ADDR.  The address
     of the GC is given as an 'int' which does not require any special
     handling by methods; the library function casts GC_ADDR to a 'GC
     *'.

'__ctalkX11FreePaneBuffer (OBJECT *PANE_OBJECT)'
     Release the server-side buffers used by PANE_OBJECT.  Note that
     this function is being phased out; programs should use
     '__ctalkX11DeletePixmap', which does not rely on hard-coded
     instance variable names.

'__ctalkX11FreeSizeHints (void)'
     Frees the data allocated by '__ctalkX11SetSizeHints ()', below.

'__ctalkX11GetSizeHints (int WIN_ID, int *X_ORG_RETURN, int *Y_ORG_RETURN, int *WIDTH_RETURN, int *HEIGHT_RETURN, int *WIN_GRAVITY_RETURN, int *FLAGS_RETURN)'
     Get the actual size and placement of the window, as reported by the
     X server, after the window is created, normally with
     '__ctalkCreateX11MainWindow ()'.

'__ctalkX11InputClient (OBJECT *STREAMOBJECT int FD)'
     The 'X11TerminalStream' input client.  This function is not used
     directly by any method but is a process of the
     '__ctalkOpenX11InputClient' function, above.

'__ctalkX11MakeEvent (OBJECT *EVENTOBJECT_VALUE_VAR, OBJECT *inputqueue)'
     Encapsulates much of the function of the 'X11TerminalStream :
     queueInput' method: receives the data for an X event from the X11
     input client and saves it in an 'InputEvent' object, then queues
     the 'InputEvent' object in the 'X11TerminalStream''s 'inputQueue'.

'__ctalkX11MenuDrawLine (void *DISPLAY, unsigned int DRAWABLE, unsigned long GC_PTR, int X_START, int Y_START, int X_END, int Y_END, int PEN_WIDTH, int ALPHA, char *COLORNAME)'
     Draws a line on the menu's 'paneBuffer', from X_START,Y_START to
     X_END,Y_END, with the line width, opacity, and color given by the
     arguments.

'__ctalkX11MenuDrawString (void *DISPLAY, unsigned int DRAWABLE, int X, int Y, int TEXT_X_SIZE, int TEXT_Y_SIZE, int RECT_X_SIZE, int RECT_Y_SIZE, char *STR, char *COLOR)'
     Draws menu text STR within the margins of the rectangle defined by
     X,Y,RECT_X_SIZE,RECT_Y_SIZE.  The text is centered vertically, and
     is justified to the left margin defined by X.

'__ctalkX11MoveWindow (OBJECT *PANE_OBJECT, int X, int Y)'
     Move PANE_OBJECT's window so that its origin is at X,Y.

'__ctalkX11NamedColor (char *COLORNAME, int *RED_OUT, int *GREEN_OUT, int *BLUE_OUT, unsigned long int *PIXEL_OUT)'
     Looks up the X11 color given by COLORNAME, and returns its red,
     green, and blue components, and the color's pixel value as given by
     the X server.  If the color name is supported by the X server, the
     function returns 0 (SUCCESS), or -1 (ERROR) if COLORNAME is not a
     valid X11 color name.  For a list of the colors that X supports,
     refer to 'rgb(1)'.

     To look up RGB color combinations that the X server may not
     support, refer to *Note ctalkX11RGBColor::.

     If '__ctalkX11NamedColor' cannot find the color, it sets RED_OUT,
     GREEN_OUT, and BLUE_OUT to 0 and sets PIXEL_OUT to the display
     server's black pixel.

'__ctalkX11OpenInputClient (OBJECT *STREAMOBJECT)'
     The library interface of the 'X11TerminalStream' class's input
     client.  This function is called by 'openInputClient' (class
     'X11TerminalStream').  The STREAMOBJECT argument is a
     'X11TerminalStream' object, generally the stream created by 'new'
     (class 'X11Pane').  *Note X11TerminalStream::.

'__ctalkX11ParseGeometry (char *GEOMSTRING, int* X, int* Y, int* Y, int* WIDTH, int* HEIGHT)'
     Parses a X11 geometry string and returns the values specified in
     the X, Y, WIDTH, or HEIGHT variables.  If the geometry string does
     not specify one of these values, sets the corresponding variable to
     zero.

     For information about the format of a X11 geometry specification,
     refer to the 'XParseGeometry(3)' manual page.

'__ctalkX11PaneDrawCircleBasic (void *DISPLAY, int WINDOW_ID, int GC, int CENTER_X, int CENTER_Y, int RADIUS, int FILL, int PEN_WIDTH, int ALPHA, char *FG_COLOR_NAME, char * BG_COLOR_NAME)'
     Draws a circle centered at CENTER_X,CENTER_Y with radius RADIUS.
     The dimensions are given in pixels.  If FILLED is true, then the
     function draws a filled circle; otherwise, the circle's edge has
     the width PEN_WIDTH.

     This function is a synonym for '__ctalkGUIPaneDrawCircleBasic'.

'__ctalkX11PaneDrawRectangleBasic (void *DISPLAY, int DRAWABLE_ID, unsigned long intGC_PTR, int XORG, int YORG, int XSIZE, int YSIZE, int FILL, int PEN_WIDTH, char *PEN_COLOR, int CORNER_RADIUS)'
     Draw a rectangle on the drawable with the ID DRAWABLE_ID, with the
     dimensions givent in the arguments.  If FILL is non-zero, draws a
     filled rectangle; otherwise uses the line width given by the
     PEN_WIDTH argument.  If CORNER_RADIUS is non-zero, draws a
     rectangle with rounded corners with the radius in pixels given by
     CORNER_RADIUS.

     This function is a synonym for '__ctalkGUIPaneDrawRectangleBasic'.

'__ctalkX11PanePutStr (OBJECT *PANE_OBJECT, int X, int Y, char *STR)'
     Displays STR at window coordinates X,Y on PANE_OBJECT's drawable in
     the pane's current font.  If 'pane_object' is buffered, writes the
     string to the pane's buffers, and the string is displayed at the
     next 'refresh' method call.

     Note that this method is slowly being superceded because it relies
     on instance variable names that are defined in several class
     libraries.  If the application uses different drawables than
     PANE_OBJECT's window surface or its buffers, use
     '__ctalkX11PanePutStrBasic' instead.

'__ctalkX11NamedColor (char *COLORSPEC, int *RED_OUT, int *GREEN_OUT, int *BLUE_OUT, unsigned long int *PIXEL_OUT)'
     Parses the color specification given by COLORSPEC, and returns the
     red, green, and blue components of the color as given by the X
     server, and also the server's pixel value for the color, which the
     function allocates.

     The COLORSPEC argument may have one of the forms that the X server
     recognizes as RGB color specifications.


          #rgb, #rrggbb, #rrrgggbbb, #rrrrggggbbbb

          rgb:r/g/b, rgb:rr/gg/bb, rgb:rrr/ggg/bbb, rgb:rrrr/gggg/bbbb


     The function returns 0 (SUCCESS) and sets RED_OUT, GREEN_OUT,
     BLUE_OUT, and PIXEL_OUT if it was able to obtain a pixel value for
     the color.  If the function can't parse COLORSPEC, or it can't
     allocate the color, it returns -1 (ERROR), and sets the color
     channels to 0, and PIXEL_VALUE to the X server's black pixel value.

     For more information about the COLORSPEC formats, refer to
     'XParseColor(3)'.

'__ctalkX11SetSizeHints (int X, int Y, intp WIDTH, int HEIGHT, int GEOM_FLAGS)'
     Set the window size hints based on the window dimensions set by the
     application.  The GEOM_FLAGS argument has the format provided by
     the '__ctalkX11ParseGeometry ()' function, above.  Normally this
     function is called by a 'X11Pane*' class when initializing a
     window.

     If an application calls this function, it must also call
     '__ctalkX11FreeSizeHints ()', above.

'__ctalkX11ResizePaneBuffer (OBJECT *PANE_OBJECT, int WIDTH, int HEIGHT)'
     Resize PANE_OBJECT's buffers to width WIDTH and height HEIGHT.  New
     programs should use '__ctalkX11ResizePixmap', which does not rely
     on hard-coded instance variable names.

'__ctalkX11ResizePixmap (void *DISPLAY, int, PARENT_DRAWABLE_ID, int SELF_XID, int GC, int OLD_WIDTH, int OLD_HEIGHT, int NEW_WIDTH, int NEW_HEIGHT, int DEPTH, int *NEW_PIXMAP_RETURN)'
     Create a new Pixmap with the dimensions NEW_WIDTH and NEW_HEIGHT
     that contains the contents of the original pixmap.  Returns the X
     ID of the new pixmap in NEW_PIXMAP_RETURN.

'__ctalkX11ResizeWindow (OBJECT *PANE_OBJECT, int WIDTH, int HEIGHT, int DEPTH)'
     Resize a pane object's X window.  Returns '1' on success, '0' if
     the window's new size is <= its current size, and '-1' if there is
     an error.

'__ctalkX11PaneClearRectangle (OBJECT *PANE_OBJECT, int X, int Y, int WIDTH, int HEIGHT)'
     Clears a rectangle in PANE_OBJECT's window.  Note that this
     function is deprecated - it relies on the Pane object having
     specific instance variables.  New programs should use
     '__ctalkX11PaneClearRectangleBasic' instead.

'__ctalkX11PaneDrawLine (OBJECT *PANE_OBJECT, OBJECT *LINE_OBJECT, OBJECT *PEN_OBJECT)'
     Draw a line on the drawable identified by PANE_OBJECT *Note
     X11Pane::, with the endpoints given by LINE_OBJECT *Note Line::,
     with the line width and color defined in PEN_OBJECT *Note Pen::.
     This function is a synonym for '__ctalkGUIPaneDrawLine' on systems
     with a X Window System display.

'__ctalkX11PaneDrawLineBasic (int DRAWABLE_ID, int GC_PTR, int X_START, int Y_START, int X_END, int Y_END, int PEN_WIDTH, int ALPHA, char *PEN_COLOR)'
     Draw a line between the points (x_start,y_start) and (x_end, y_end)
     with the color, and transparency using the drawable ID, graphics
     context, and pen color, width, and transparency given as arguments.

'__ctalkX11PaneDrawPoint (OBJECT *PANE_OBJECT, OBJECT *point_object, OBJECT *PEN_OBJECT)'
     Draw a point on the drawable id given in PANE_OBJECT *Note
     X11Pane::, with the location given by POINT_OBJECT *Note Point::,
     with the radius and color given by PEN_OBJECT *Note Pen::.  This
     function is a synonym for '__ctalkGUIPaneDrawPoint' on systems that
     use the X Window system.

'__ctalkX11PaneDrawPointBasic (void *DISPLAY, int DRAWABLE_ID, int GC_PTR, int X, int Y, int PEN_WIDTH, int ALPHA, char *PEN_COLOR)'
     Draw a point of the size, position, color, and transparency using
     the drawable ID, graphics context, and Pen color, transparency, and
     width given as arguments.

'__ctalkX11PaneClearWindow (OBJECT *PANE_OBJECT)'
     Clears PANE_OBJECT's window.  Note that this function is deprecated
     - it relies on the Pane object having specific instance variables.
     New programs should use

'__ctalkX11PaneDrawRectangle (OBJECT *PANE_OBJECT, OBJECT *RECTANGLE_OBJECT, OBJECT *PEN_OBJECT, Integer FILL)'
     Draw a rectangle on the drawable identified by PANE_OBJECT *Note
     X11Pane::, with the dimensions given by RECTANGLE_OBJECT *Note
     Rectangle::, and with the line width and color given by PEN_OBJECT
     *Note Pen::.  If FILL is true, draw a filled rectangle.

'__ctalkX11PanePutStrBasic (void *DISPLAY, int VISUAL_ID,int GC_PTR, int X, int Y, char *TEXT)'
     Write the string TEXT on the drawable named by VISUAL_ID at X,Y
     using the graphics context pointed to by GC_PTR.  If the drawable
     is a 'X11CanvasPane' buffer, the text will not be visible until the
     next call to the pane's 'refresh' method.

'__ctalkX11PaneRefresh (OBJECT *PANE_OBJECT, int SRC_X_ORG, int SRC_Y_ORG, int SRC_WIDTH, int SRC_HEIGHT, int DEST_X_ORG, int DEST_Y_ORG)'
     If PANE_OBJECT is a buffered pane, copy the contents of the pane
     buffer(s) within the rectangle given by SRC_X_ORG, SRC_Y_ORG,
     SRC_WIDTH, SRC_HEIGHT to the visible window at DEST_X, DEST_Y.

'__ctalkX11QueryFont (OBJECT *FONT_OBJECT, char *XLFD)'
     Fills in FONT_OBJECT's 'ascent', 'descent', 'maxWidth', 'height',
     and 'fontDesc' instance variables with the font metrics returned by
     the X server for the font given by XLFD.

'__ctalkX11SetBackground (OBJECT *PANE_OBJECT, char *COLOR_NAME)'
     Set PANE_OBJECT's background color to COLOR_NAME.  This function is
     being phased out because it uses named instance variables of
     PANE_OBJECT.  Programs should use '__ctalkX11SetBackgroundBasic
     ()', below, instead.

'__ctalkX11SetBackgroundBasic (void *DISPLAY, int visual_xid, int GC_PTR, char *COLOR)'
     Sets the background color of any class with a X11 visual and
     graphics context.

'__ctalkX11SetForegroundBasic (void *DISPLAY, int visual_xid, int GC_PTR, char *COLOR)'
     Sets the foreground color of any class with a X11 drawable and
     graphics context.

'__ctalkX11SetResource (void *DISPLAY, int DRAWABLE_ID, char *RESOURCE_NAME, char *RESOURCE_VALUE)'
     Sets the X11 resource RESOURCE_NAME to RESOURCE_VALUE for the
     drawable identified by DRAWABLE_ID.

'__ctalkX11SetWMNameProp (OBJECT *PANE_OBJECT, char *NAME)'
     Sets the WMName property PANE_OBJECT's window to NAME.  This is the
     window property that window managers use to set the window frame's
     title.

'__ctalkX11UseCursor (OBJECT *PANE_OBJECT, OBJECT *CURSOR_OBJECT)'
     Sets the X11 cursor of PANE_OBJECT to CURSOR_OBJECT.  *Note
     X11Cursor::.

'__ctalkX11UseXRender (bool B)'
     If B is true, draw using the X Render entension if it is available.
     If B is false, use Xlib for drawing even if X Render is available.

'__ctalkX11UseFontBasic (void *DISPLAY, int DRAWABLE_ID, int GC_PTR, char *FONT_DESC)'
     Sets the font of the graphics context GC_PTR and drawable
     DRAWABLE_ID for further string printing operations.  See use in
     'X11Bitmap' class, where the GC pointer, which is an opaque object,
     is encoded as an 'int', in order to avoid confusion with 'OBJECT
     *'s'.

'__ctalkX11UsingXRender (void)'
     Returns a boolean value of True if the program is using the X
     Render extension for drawing, False otherwise.  To use the X Render
     extension, the extension and its supporting libraries must be
     available when the Ctalk libraries are built, and the program has
     not changed the default setting, normally via
     '__ctalkX11UseRender', above.

'__ctalkX11XPMFromData (void *DISPLAY, int DRAWABLE_ID, int GC_PTR, int X_ORG, int Y_ORG, char **XPM_DATA)'
     Draw a X pixmap at the x,y position on the drawable named by
     DRAWABLE_ID.  The XPM_DATA argument is the declaration of the data
     given in a XPM file, and has the C data type 'char **'.

'__ctalkX11XPMInfo (void *DISPLAY, char **XPM_DATA, int *WIDTH_RET, int *HEIGHT_RET, int *N_COLORS_RET, int *CHARS_PER_COLOR_RET)'
     Returns the width, height, number of colors, and characters per
     color of the XPM data referred to by XPM_DATA

'__ctalkXPMToGLTexture (char **XPM_DATA, unsigned short int ALPHA, int *WIDTH_OUT, int *HEIGHT_OUT, void **TEXEL_DATA_OUT)'
'__ctalkXPMToGLXTexture (char **XPM_DATA, unsigned short int ALPHA, int *WIDTH_OUT, int *HEIGHT_OUT, void **TEXEL_DATA_OUT)'
     Read the XPM data pointed to by XPM_DATA, and return the OpenGL
     texture data pointed to by TEXEL_DATA_OUT.

     The ALPHA parameter defines the texture data transparency and
     should be in the range 0 - 0xffff.  The alpha channel's effect may
     not be apparent in the image that is displayed, because OpenGL has
     its own set of functions to perform texture blending.

     For Mesa OpenGL implementations, like those found on Linux systems,
     textures have the format GL_RGBA and the data type
     GL_UNSIGNED_INT_8_8_8_8.  To define a basic 2-dimensional texture
     to the OpenGL API, use an OpenGL function like this.


          glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, my_width, my_height, 0,
                        GL_RGBA, GL_UNSIGNED_INT_8_8_8_8, my_texel_data);


     Apple OpenGL implmentations use a different internal format, so a
     program would define a texture from the '__ctalkXPMToGLXTexture'
     function's output like this.


          glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, my_width, my_height, 0,
                        GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, my_texel_data);


     Note that the function does not make any changes for 1-dimensional
     or 3-dimensional textures, nor for textures that might be rendered
     as mipmaps.  The specific texture parameters depend on the nature
     of the texture and the surface that it's applied to...  in most
     cases, though OpenGL works best with a XPM that has a geometry that
     is an even multiple of 2; e.g., 512x512 or 1024x1024 pixels.

     Both functions are similar, and generic enough to work with any
     OpenGL toolkit - the main difference is that either of the
     functions can be implemented for either a GLUT or GLX development
     environemnt independently, and that the GLX version is compatible
     with 64-bit machines.

'__ctalkXftAscent (void)'
     Returns an 'int' with the currently selected font's height in
     pixels above the baseline.

'__ctalkXftDescStr (void)'
     Returns a string with the font descriptor of the currently selected
     font that containing the attributes that the Ctalk Xft library
     uses: family, point size, slant, and weight.

     For the complete descriptor string that the Freetype library
     derives from the selected font's pattern, refer to the
     '__ctalkXftSelectedFontDescriptor' function.

'__ctalkXftAscent (void)'
     Returns an 'int' with the currently selected font's height in
     pixels below the baseline.

'__ctalkXftFgRed (void)'
'__ctalkXftFgGreen (void)'
'__ctalkXftFgBlue (void)'
'__ctalkXftFgAlpha (void)'
     Returns 'int' values 0-0xffff for the selected font's red, green,
     blue, and alpha values.

'__ctalkXftRed (unsigned short VAL)'
'__ctalkXftGreen (unsigned short VAL)'
'__ctalkXftBlue (unsigned short VAL)'
'__ctalkXftAlpha (unsigned short VAL)'
     Set the current Xft font's foreground color channels individually.
     The value of the argument must be between 0 and 65535 (0xffff hex).

'__ctalkXftFontPathFirst (char *PATTERN)'
     Return the path of the first font file that matches PATTERN.  If
     pattern is '*' or an empty string ('""'), return the first path of
     all the fonts that are available to the library.

'__ctalkXftFontPathNext (void)'
     Return a string containing the path of the next font file that
     matches the pattern given to '__ctalkXftFontPathFirst ()', above.

'__ctalkXftGetStringDimensions (char *STR, int *X, int *Y, int *WIDTH, int *HEIGHT, int * RBEARING)'
     Return the x and y origin, and width and height of STR in the
     currently selected FreeType font.  Because the dimensions are
     absolute, X and Y are normally 0.  If the Xft library is not
     initialized or not available, the function returns 0 for all of the
     dimensions.  If the library is initialized but the application
     hasn't yet specified a font, then the value returned for RBEARING
     is '0'.

     Note that this function works entirely on the client side, and some
     uses or systems may not be compatible with it.  For cases like
     those, refer to the server-side function, *Note
     ctalkXftTextDimensionsBasic::.

'__ctalkXftHandle (void)'
     Returns a 'void *' with the handle of the selected font.  Typically
     this is a cast from a 'XftFont *' when used in a normal Xft
     configuration.  The font library uses this value whenever the
     font's face is requested after it is first initialized with the
     parameters from the font specification: i.e., when the family,
     weight, slant, height, and spacing haven't changed since the app
     first opened the font.

'__ctalkXftHeight (void)'
     Returns an 'int' with the font's height above and below the
     baseline in pixels, and including any additional vertical spacing.

'__ctalkXftInitLib (void)'
     Initializes the Freetype outline font library.  If Ctalk isn't
     built with libXft or Fontconfig support, this function returns
     'ERROR' ('-1'.  This is the only Xft-related function to return
     silently; all other functions exit with an error message.  However
     applications can check the 'X11Pane : haveXft' instance variable to
     determine if the libraries were initialized.  *Note haveXft::.

     If the system is not configured to use outline fonts *Note
     X11FreeTypeFont::, then the function prints a message and exits the
     program.  If the library is already initialized, then this function
     returns 'SUCCESS' '0'.

'__ctalkXftInitialized (void)'
     Returns TRUE if the FreeType font library is available and
     initialized, FALSE otherwise.

'__ctalkXftIsMonospace (void)'
     A read-only function that returns 'true' if the program's selected
     font is monospace, false otherwise.

'__ctalkXftListFontsFirst (char *XFTPATTERN)'
     Initializes the FreeType library to list fonts and returns a 'char
     *' that contains the first font descriptor that contains the string
     XFTPATTERN.  If XFTPATTERN is emtpy ('""') or '*', then the
     function returns the first font, and the following calls to
     '__ctalkXftListFontsNext ()' match all of the fonts available to
     the FreeType library.

'__ctalkXftListFontsNext (void)'
     Returns a 'char *' with the next matching font descriptor of a font
     listing initialized by '__ctalkXftListFontsFirst ()'.

'__ctalkXftListFontsNext (void)'
     Cleans up after a series of list fonts function calls.

'__ctalkXftMajorVersion (void)'
     Returns an 'int' with the Xft library's major version number.  Like
     all libXft library functions, '__ctalkXftMajorVersion' causes the
     program to exit with an error if Ctalk is built without libXft
     support.

'__ctalkXftMaxAdvance (void)'
     Returns an 'int' with the maximum horizontal dimension in pixels of
     any of the selected font's characters.

'__ctalkXftMinorVersion (void)'
     Returns an 'int' with the Xft library's minor version number.
     Returns an 'int' with the Xft library's major version number.  Like
     all libXft library functions, '__ctalkXftMinorVersion' causes the
     program to exit with an error if Ctalk is built without libXft
     support.

'__ctalkXftQualifyFontName (char *PATTERN)'
     Return the qualified font name string for PATTERN.

'__ctalkXftRequestedFamily (void)'
'__ctalkXftRequestedPointSize (void)'
'__ctalkXftRequestedSlant (void)'
'__ctalkXftRequestedWeight (void)'
'__ctalkXftRequestedDPI (void)'
     Returns the font attributes requested after parsing a Fontconfig
     string by '__ctalkXftSelectFontFromFontConfig' and
     '__ctalkXftSelectFontFromXLFD'.

     _Note:_ The caching in the recent Ctalk and font libraries has
     rendered these functions mostly redundant.  Programs should use the
     equivalent '__ctalkXftSelected*' functions instead.

'__ctalkXftTextDimensionsBasic (void *DISPLAY, unsigned int DRAWABLE, unsigned GC_PTR, char *STR, int *X, int *Y, int *WIDTH, int *HEIGHT, int * RBEARING)'
     Returns the dimensions of STR in the currenly selected font.
     Unlike the function '__ctalkXftGetStringDimensions', which works
     entirely within a client app's process space, this function directs
     the server process to perform the measurements.

'__ctalkXftRevision (void)'
     Returns an 'int' with the Xft library's revision number.  Returns
     an 'int' with the Xft library's major version number.  Like all
     libXft library functions, '__ctalkXftRevision' causes the program
     to exit with an error if Ctalk is built without libXft support.

'__ctalkXftSelectFontFromFontConfig (char *FONTDESC)'
     Parses a Fontconfig font descriptor and selects the font.  For
     information about selecting fonts using Fontconfig descriptors,
     refer to the 'X11FreeTypeFont' class.  *Note X11FreeTypeFont::.

'__ctalkXftShowFontLoad (int WARNINGLEVEL)'
     Enables or disables the display on standard output of fonts that
     the library is loading.  The Ctalk library defines the following
     constants.


          XFT_NOTIFY_NONE
          XFT_NOTIFY_ERRORS
          XFT_NOTIFY_LOAD
          XFT_NOTIFY_VERBOSE


     See also '__ctalkXftVerbosity'.

     Note that programs should call this function before launching any
     processes.  Generally, this is before the program calls the
     'X11Pane : openEventStream' method.  Otherwise, the program will
     only display message for the process that this function was called
     from.

'__ctalkXftSelectedFamily (void)'
     Returns a 'char *' string that contains family of the selected
     font.

'__ctalkXftSelectedPointSize (void)'
     Return the point size of the selected font as a C DOUBLE.

'__ctalkXftSelectedSlant (void)'
     Returns an 'int' that contains slant of the selected font.

'__ctalkXftSelectedFamily (void)'
     Returns a 'String' that contains font's style parameter, if any.

'__ctalkXftSelectedSlant (void)'
     Returns an 'int' that contains slant of the selected font.

'__ctalkXftSelectedFontDescriptor (void)'
     Returns a 'char *' string that contains the descriptor of the
     selected font.

'__ctalkXftSelectedFontDescriptor (void)'
     Returns a 'char *' string that contains the file path descriptor of
     the selected font.

'__ctalkXftSelectFont (char *FAMILY, int SLANT, int WEIGHT, int DPI, double POINT_SIZE)'
     Selects the FreeType font that matches the arguments.  Returns 0 if
     successful in matching the font given by the arguments.  If no
     matching font is found, the current font does not change, and the
     method returns -1.  The 'selectFont' method (class
     'X11FreeTypeFont' contains a description of the parameters
     recognized by the function.  *Note X11FreeTypeFont-selectFont::.

'__ctalkXftSelectFontFromXLFD (char *XLFD)'
     Selects fonts in the FreeType font library using a XLFD
     specification.  When selecting outline fonts: the libraries use the
     fields: family, weight, slant, dpi-x, and pixel height.  An example
     XLFD would be the following.


          -*-Nimbus Sans L-medium-r-*-*-12-72-*-*-*-*-*-*


     Note that the function does not translate between bitmap and
     outline font families - the font libraries pick the closest match
     to the font metrics given in the XLFD, regardless of type style.

     Also, the outline font libraries use a single dpi metric for both
     the vertical and horizontal dot pitch of the display, so only the
     'resx' field of the XLFD is actually used.

'__ctalkXftSetForegrounc (int RED, int GREEN, int BLUE, int ALPHA)'
     Sets the red, green, blue, and alpha values for the selected font.
     The values are 'ints' and have a range of 0-0xffff.

'__ctalkXftSetForegroundFromNamedColor (String COLORNAME)'
     Sets the selected outline font's red, green, and blue values from
     the named X11 color given as the argument.

'__ctalkXftSelectedFontDescriptor (void)'
     Return the font descriptor of the selected font as a 'char *'.

'__ctalkXftVerbosity (void)'
     Returns the current Xft message reporting level.  The values that
     are defined in 'ctalk/ctalkdefs.h' are:


          XFT_NOTIFY_NONE
          XFT_NOTIFY_ERRORS
          XFT_NOTIFY_LOAD
          XFT_NOTIFY_VERBOSE


     See also '__ctalkXftShowFontLoad.'

'__ctalkXftVersion (void)'
     Returns an 'int' with the Xft library's version number, which is
     (__ctalkXftMajorVersion () * 10000) + (__ctalkXftMinorVersion *
     100) + __ctalkXftRevsion ().

'__ctalk_arg (char *RCVR, char *METHOD,void *ARG)'
     Define an argument for the following '__ctalk_method ()' call.

'__ctalk_arg_cleanup (OBJECT *RESULT)'
     Remove an argument used by the previous method call.  If used
     within an expression, then RESULT, the return object of the
     previous method call, may not be NULL. If used after a
     '__ctalk_method ()' call, then RESULT may be NULL.

'__ctalk_arg_internal (int N_TH_ARG)'
     Return the N_TH_ARG that method was called with, as an 'OBJECT *.'
     The first argument's index on the stack is 0 within the caller's
     argument frame, and the last argument is METHOD -> N_PARAMS - 1.

'__ctalk_arg_value_internal (int N_TH_ARG)'
     Return the value object of the N_TH_ARG that method was called
     with, as an 'OBJECT *,' if available.  If it isn't (for example, if
     the value instance variable is used as an argument alone, and not
     the parent object), then the function returns the argument object.

     As with '__ctalk_arg_internal (),' The first argument's index on
     the stack is 0 within the caller's argument frame, and the last
     argument is METHOD -> N_PARAMS - 1.

'__ctalk_arg_pop (void)'
'__ctalk_arg_pop_deref (void)'
     Removes and returns the last object pushed onto the argument stack.
     '__ctalk_arg_pop_deref' also decreases the object's reference count
     by one.

'__ctalk_class_initialize (void)'
     Called by __ctalk_init () to perform any neeeded initialization the
     before any classes are defined.

'__ctalk_define_class (ARG**ARGS)'
     The primitive method that Ctalk executes when it encounters the
     'class' keyword.

'__ctalk_dictionary_add (OBJECT*OBJECT)'
     Add an object to the Ctalk global dictionary, or, if the object is
     a class object, to the class library.

'__ctalk_exitFn (int APP_EXIT)'
     Called just before a 'return' statement when returning from a C
     function.  If the function is 'main', then APP_EXIT should be
     non-zero, to indicate that the program is finished, and to clean up
     the global objects and the class library.

'__ctalk_initFn (void)'
     Called at the beginning of a function to register the function's
     name.

'__ctalk_initLocalObjects (void)'
     Called during method or function initialization to delete old local
     objects before creating new objects.

'__ctalk_get_object (char *NAME, char *CLASSNAME)'
'__ctalk_get_object_return (char *NAME, char *CLASSNAME)'
     Retrieves the object NAME.  If CLASSNAME is non-null, retrieves the
     object by name and class.

     The '__ctalk_get_object_return' function is similar, but it is used
     only as an operand to a 'return' keyword.  The function checks the
     call stack's local object cache, in case an expression cleanup
     removed the most recent call's local variable list during recursive
     or successive calls of the same method.

'__ctalk_init (char *PROGRAM_NAME)'
     Initialize the Ctalk class libraries when the program starts.  The
     argument, PROGRAM_NAME is normally 'argv[0]'.

'__ctalk_method (char *RCVR_OBJECT_NAME, OBJECT *(METHOD_FN *)(), char *METHOD_NAME)'
     Perform a simple Ctalk method call, in places where the call can be
     used after one or more calls to '__ctalk_arg' and followed by
     '__ctalk_arg_cleanup'.  For complex expressions or expressions
     occurring within control structures, Ctalk normally uses
     '__ctalkEvalExpr' instead.

'__ctalk_new_object (ARG **ARGS)'
     The primitive function that is called by the 'new' method.

'__ctalk_primitive_method (char *RCVR_NAME, char *METHOD_NAME, int ATTRS)'
     Call primitive method METHOD_NAME with receiver RCVR_NAME.  The
     ATTRS argument can be METHOD_SUPER_ATTR, which uses the receiver's
     superclass as the receiver redirects the method's arguments to a
     superclass method.

'__ctalk_process_exitFn (int APP_EXIT)'
     Similar to '__ctalk_exitFn', above, except that the function is
     meant to be invoked by child processes on exit, so it does not try
     to manage other child processes.

'__ctalk_receiver_pop (void)'
     Pops the most recent receiver object off the receiver stack and
     returns it.

'__ctalk_receiver_push (OBJECT *OBJECT)'
     Push OBJECT onto the receiver stack, without changing its reference
     count.  This can be useful in conjunction with
     '__ctalk_receiver_pop' to quickly retrieve the current receiver
     object.


           currentReceiver = __ctalk_receiver_pop ();
           __ctalk_receiver_push (currentReceiver);


'__ctalk_register_c_method_arg (char *DECL, char *TYPE, char *QUALIFIER, char *QUALIFIER2, char *STORAGE_CLASS, char *NAME, int TYPE_ATTRS, int N_DEREFS, int INITIALIZER_SIZE, int SCOPE, int ATTRS, void *VAR)'
     Registers a C variable for use as an argument in the following
     method call.  The arguments provide the information given by the
     variable's declaration so that it can be re-created by Ctalk.  The
     last parameter, VAR, contains the address of the actual C variable
     in memory.

     There are also abbreviated versions of
     '__ctalk_register_c_method_arg',
     __ctalk_register_c_method_arg_b|c|d, which work similarly but don't
     try to handle syntax elements that aren't present in the variable's
     declaration.

'__ctalk_self_internal (void)'
     Return the current method's receiver object as an 'OBJECT *'.

'__ctalk_self_internal (void)'
     Return the current method receiver's 'value' instance variable as
     an 'OBJECT *' if it exists, or the receiver object otherwise (for
     example, if the receiver is the 'value' instance variable itself
     instead of the parent object).

'__ctalk_set_global (char *NAME, char *CLASSNAME)'
     Adds the object NAME of class CLASSNAME to ctalk's global
     dictionary.  This function is normally called during program
     initialization.

'__ctalk_set_local (OBJECT *OBJ)'
'__ctalk_set_local_by_name (char *OBJ_NAME)'
     Make OBJ a method- or function-local object.  This function is
     normally called during a method or function's initialization when
     the local objects are created with a 'new' method.  The
     '__ctalk_set_local_by_name' function is similar, except that it
     retrieves the global object by looking up its name in the global
     dictionary.

'__ctalk_to_c_char (OBJECT *OBJ)'
     Returns the value of OBJ as a C 'char' if possible.  If the value
     is an ASCII code, converts the value to the actual 'char'.

'__ctalk_to_c_char_ptr (OBJECT *OBJ)'
     Returns the value of OBJ as a C 'char *'.  This function has been
     mostly replaced by '__ctalkToCCharPtr', which you should use
     instead.

'__ctalk_to_c_double (OBJECT *OBJ)'
     Returns the value of OBJ as a C 'double'.  This function performs
     the conversion with the C library function 'strtod'.  Currently
     only supports the translation of base 10 values.

'__ctalk_to_c_int (OBJECT *OBJ)'
     Returns the value of OBJ as a C 'int'.  This function handles
     values in hexadecimal, octal, using the C library function
     'strtol', and binary, using Ctalk's internal routines.  Also
     handles ASCII-to-char conversions if the argument is a 'Character'
     object.

'__ctalk_to_c_longlong (OBJECT *obj)'
     Returns the value of OBJ, which is normally an instance of
     'LongInteger' class, as a C 'long long int'.  This function uses
     the C library function 'strtoll' to perform the conversion.
     Currently only handles 'LongInteger' object values in base 10.

'__ctalk_to_c_ptr (OBJECT *O)'
     Translate the value of an object into a C 'void *.' If the value
     isn't a pointer, then return the address of the value in memory.

'__ctalk_to_c_ptr_u (OBJECT *O)'
     Translate the value of an object into a C 'void *.' This is an
     unbuffered verson of '__ctalk_to_c_ptr ()', above.  That is, if the
     value of the object is an empty string, '(NULL)', or '0x0', it
     returns 'NULL'.  This allows you to compare objects to 'NULLs' in C
     expressions without the generating compiler warnings.

     ('X11TextEditorPane' class)

'__edittext_delete_char (OBJECT *x11texteditorpane_object)'
'__edittext_insert_at_point (OBJECT *x11texteditorpane_object, int keycode, int shift_state, int keypress)'
'__edittext_line_end (OBJECT *x11texteditorpane_object)'
'__edittext_line_start (OBJECT *x11texteditorpane_object)'
'__edittext_xk_keysym (int KEYCODE, int SHIFT_STATE, int KEYPRESS)'
'__edittext_next_char (OBJECT *x11texteditorpane_object)'
'__edittext_next_line (OBJECT *x11texteditorpane_object)'
'__edittext_next_page (OBJECT *x11texteditorpane_object)'
'__edittext_prev_char (OBJECT *x11texteditorpane_object)'
'__edittext_prev_line (OBJECT *x11texteditorpane_object)'
'__edittext_prev_page (OBJECT *x11texteditorpane_object)'
'__edittext_scroll_down (OBJECT *x11texteditorpane_object)'
'__edittext_scroll_up (OBJECT *x11texteditorpane_object)'
'__edittext_text_start (OBJECT *x11texteditorpane_object)'
'__edittext_text_end (OBJECT *x11texteditorpane_object)'
'__edittext_point_to_click (OBJECT *x11texteditorpane_object, int pointer_x, int pointer_y)'
'__edittext_index_from_pointer (OBJECT *x11texteditorpane_object, int pointer_x, int pointer_y)'
'__edittext_insert_str_at_click (OBJECT *x11texteditorpane_object, int click_x, int click_y, char *)'
'__edittext_insert_str_at_point (OBJECT *x11texteditorpane_object, char *)'
'__edittext_get_primary_selection (OBJECT *x11texteditorpan_eobject, void **buf_out, int *size_out)'
'__edittext_set_selection_owner (OBJECT *x11texteditorpane_object)'
'__edittext_recenter (OBJECT *x11texteditorpane_object)'
'__edittext_get_clipboard (OBJECT *x11texteditorpane_object, void **buf_out, int *size_out);'
'__exittext_set_clipboard_owner (OBJECT *x11texteditorpane_object)'
     Text editing functions used by 'X11TextEditorPane' objects.  For
     more information, refer to 'X11TextEditorPane' class..  *Note
     X11TextEditorPane::.

'__entrytext_set_selection_owner (void *DISPLAYPTR, unsigned int WIN_ID unsigned long int GC_PTR)'
'__entrytext_get_primary_selection (OBJECT *entrypane_object)'
'__entrytext_update_selection (void *DISPLAYPTR, unsigned int WIN_ID, unsigned long int GC_PTR)'
'__entrytext_send_selection (void *DISPLAYPTR, void * XEVENT)'
     These functions handle requesting ownership of the X display's
     primary selection, storing current values of the selection text
     that might be requested by other programs, and requesting the
     contents of the primary selection when another X application owns
     the selection.  The functions are normally called by methods in
     'X11TextEntryPane' class that handle X events.

'_error (char *FMT, ...)'
     Display an error message and exit the program.

'__inspector_trace (int STACK_INDEX)'
'__inspect_get_arg (int STACK_INDEX)'
'__inspect_get_receiver (int STACK_INDEX)'
'__inspect_get_global (char *OBJ_NAME)'
'__inspect_get_local (int STACK_INDEX, char *OBJ_NAME)'
'__receiver_trace (int STACK_INDEX)'
'__inspect_globals (void)'
'__inspect_locals (void)'
'__inspect_short_help (void)'
'__inspect_long_help (void)'
     Functions used internally by Ctalk's object inspector.  The
     function parameters are designed to be consistent with the syntax
     of the inspector commands, although not every function makes use of
     them.  For details refer to the 'inspect(3ctalk)' manual page, the
     'inspectors' section of the 'ctalktools.info' Texinfo manual, and
     the 'inspect' method in 'ObjectInspector' class.

'__rt_init_library_paths (void)'
     Initialize Ctalk's library paths.  The function first checks the
     value of the 'CLASSLIBDIRS' environment variable for a
     colon-separated list of directories, then adds the location of
     CLASSLIBDIR which is configured when Ctalk is built, and
     CLASSLIBDIR'ctalk'.

'__warning_trace (void)'
     A generic stack trace function that prints a trace of the call
     stack wherever it is inserted in a program.

'__xalloc (int SIZE)'
     Allocates a block of memory of SIZE characters and returns a
     pointer to the memory.  If the alloc call fails, generates an
     '_error' message and exits the program.

'__xfree (void **ADDR)'
     Frees the block of memory pointed to by *ADDR, then sets the ADDR
     to to NULL. *ADDR must be a block of memory previously allocated by
     '__xalloc', above, or a similar 'malloc' call.  When used in a
     program, wrapping ADDR in the 'MEMADDR()' macro provides the
     correct dereferencing for the allocated memory and its pointer.
     The example shows how the 'MEMADDR()' macro is used.


          char *my_ptr;

          my_ptr = (char *)__xalloc (BUF_SIZE);

          _... do stuff ..._

          __xfree (MEMADDR(my_ptr));


'__xrealloc (void **ADDR, int SIZE)'
     Re-allocates the block of memory pointed to by *ADDR to size.  If
     SIZE is larger than the original block of memory, the contents of
     ADDR are preserved.  As with '__xfree', above, the 'MEMADDR' macro
     provides the correct dereferencing for the reference to ADDR.

'_warning (char *FMT, ...)'
     Print a warning message.

'__objRefCntInc (obj_ref)'

     Increment the reference count of an object and its instance
     variables.  This function takes an object reference as its
     argument.  You can use the 'OBJREF' macro to cast the object to an
     object reference.

'__objRefCntDec (obj_ref)'

     Decrement the reference count of an object and its instance
     variables.  As with all of the '__objRefCnt*' functions,
     '__objRefCntDec' takes an object reference as its argument.  You
     can use the 'OBJREF' macro to cast the object to an object
     reference.

'__objRefCntSet (obj_ref, int REFCOUNT)'

     Set the reference count of an object and its instance variables to
     REFCNT.  As with all of the '__objRefCnt*' functions,
     '__objRefCntDec' takes an object reference as its argument.  You
     can use the 'OBJREF' macro to cast the object to an object
     reference.

     _Note:_ '__objRefCntSet' will not set an object's reference count
     to zero.  That is, if you give '0' as the second argument, the call
     has no effect.  Use '__objRefCntZero' instead.  That might sound
     silly, but it's much more reliable overall, in a
     programming-by-contract way.

'__objRefCntZero (obj_ref)'

     Set the reference count of an object and its instance variables to
     0 (zero).  As with all of the '__objRefCnt*' functions,
     '__objRefCntZero' takes an object reference as its argument.  You
     can use the 'OBJREF' macro to cast the object to an object
     reference.

     You should not need to use this function unless you're _completely_
     deleting an object.  Refer to the '__ctalkDeleteObject' function
     for more information.

'obj_ref_range_chk (OBJECT **HOSTOBJ, OBJECT **TARGETOBJECT)'
     Returns a 'bool' value of 'true' or 'false' depending on whether
     the host object and the target object it references occupy the same
     data segment.

'__refObj (OBJECT **OBJ1, OBJECT **OBJ2)'
     Assign OBJ2 to OBJ1.  If OBJ1 already points to an object,
     decrement its reference count.  Increment the reference count of
     OBJ2 by 1.  When calling functions that use 'OBJECT **' arguments,
     they correspond to the OBJREF_T typedef, and Ctalk defines the
     macro OBJREF() to cast an object to an OBJREF_T.

'_store_int (OBJECT *RECEIVER, OBJECT *arg)'
     This is a primitive that stores the value of ARG in RECEIVER, which
     is an 'Integer'.  Checks the class of 'arg', and if ARG is not an
     'Integer', converts it to an 'Integer' value.  If RECEIVER a
     pointer to a value, then it stores ARG as a fully-fledged object.

'BOOLVAL(INTEGERORBOOLVALUE)'
     This macro returns the value of an 'Integer' or 'Boolean' object,
     or any of 'Boolean's' subclasses (or just about any other scalar
     value), as a C 'bool'.  For an example of its use, refer to the
     entry for the *Note INTVAL_Macro::.

'INTVAL(INTEGEROBJECTVALUE)'
     A macro that returns the value of an 'Integer' object, or any of
     'Integer's' subclasses, as a C 'int'.  Uses an 'OBJECT *'s'
     '__o_value' member directly, as in this example.


          OBJECT *my_int_object_alias = myInt;

          int a = INTVAL(my_int_object_alias -> __o_value);


'is_zero_q (char *str)'
     Returns a 'bool' if the number represented by the string evaluates
     to zero, false otherwise.

'LLVAL(LONGINTEGERVALUE)'
     A macro that returns the value of a 'LongInteger' object, or any of
     'LongInteger's' subclasses, as a C long long int.  For an example
     of its use, refer to the entry for the *Note INTVAL_Macro::.

'obj_ref_str (char *STR)'
     If STR contains a formatted hexadecimal number of the format
     '0xNNNNNN' that points to an object, return an 'OBJECT *' reference
     to the object, 'NULL' otherwise.

'str_is_zero_q (char *STR)'
     Like 'is_zero_q', above, except that it also checks for an empty
     string (and returns true), as well as a string that contains only
     the digit '0', which causes the function to return false.

'substrcat (char *DEST, char *SRC, int START_INDEX, int END_INDEX)'
     Concatenate the substring of SRC from START_INDEX to END_INDEX to
     DEST.

'substrcpy (char *DEST, char *SRC, int START_INDEX, int END_INDEX)'
     Copy a substring of SRC from START_INDEX to END_INDEX to DEST.

'SYMTOOBJ (SYMBOLVALUE)'
     This is another macro that converts a 'Symbol's' reference to an
     'OBJECT *'.  This macro can be used on the right-hand side of an
     assignment statement.


          if ((value_object =
              SYMTOOBJ((self_object -> instancevars) ?
                       (self_object -> instancevars -> __o_value) :
                       (self_object -> __o_value))) != NULL) {
                return value_object;
              }


'SYMVAL(SYMBOLVALUE)'
     A macro that returns the value of a 'Symbol' object, or any of
     'Symbol's' subclasses, as a C 'uintptr_t *', which is guaranteed to
     be valid for 32- and 64-bit machines.

     However, due to the way that pointers work in C, 'SYMVAL' only
     works on the left-hand side of an assignment; you just need a cast
     (for example to 'OBJECT *') in order to avoid compiler warnings
     when it appears on the right-hand side of an assignment.  Here is
     an example:


          SYMVAL(object_alias->__o_value) = (OBJECT *)some_ptr;


     However, if he label on the right-hand side is also a 'Symbol', the
     'Symbol' class duplicates the address that the operand points to,
     not the operand itself.


          SYMVAL(object_alias->__o_value) = SYMVAL(some_ptr -> __o_value);


     For another, perhaps more basic, example of the macro's use, refer
     to the entry for the *Note INTVAL_Macro::.

'OBJREF(OBJ)'
     Creates a reference to an object.  This macro returns an 'OBJECT
     **', but using the macro allows the definition of an object
     reference to change without affecting too much code.  'OBJREF' is
     used with the '__objRefCnt*' functions, and in other places.

'TRIM_LITERAL(S)'
     A macro that trims the quotes from a literal string.  It expands to
     'substrcpy (S, S, 1, strlen (S) - 2)'.

'TRIM_CHAR(C)'
     A macro that trims the quotes from a literal character.  It expands
     to 'substrcpy (C, C, 1, strlen (C) - 2)'

'TRIM_CHAR_BUF(S)'
     A macro that trims nested single quotes from a literal character.
     'TRIM_CHAR_BUF' also checks whether a single quote (''') is the
     actual character.

'xfopen (const char *path, const char *mode)'
'xfprintf (FILE *stream, const char *fmt, ...)'
'xfscanf (FILE *stream, const char *fmt, ...)'
'xmemcpy (void *s, const void *s, size_t)'
'xmemmove (void *s, const void *s, size_t)'
'xmemset (void *s, int c, size_t n)'
'xsprintf (char *s, const char *fmt, ...)'
'xstrcat (char *d, const char *s)'
'xstrncat (char *d, const char *s, size_t)'
'xstrcpy (char *d, const char *s)'
'xstrncpy (char *d, const char *, size_t)'
     These are portable wrappers for systems that #define their own
     (possibly more secure) versions of library functions.  For the
     exact prototype and definition, you should consult the system's
     manual page for the corresponding library function (e.g.,
     'strcpy(3)' for the definition of 'xstrcpy').

'xstdin (void)'
'xstdout (void)'
'xstderr (void)'
     These functions return a 'FILE *' with the 'stdin, stdout,' or
     'stderr' file stream.  They're useful if your compiler redefined
     either 'stdin, stdout,' or 'stderr' internally.  The functions
     provide a consistent interface and leave any implementation details
     in the library, where they belong.


File: ctalk.info,  Node: C,  Next: Copying,  Prev: Methods,  Up: Top

Ctalk Language Features
=======================

This section describes 'ctalk''s C language features and its low-level
application programming interface.

* Menu:

* Preprocessor::        Compatibility with 'cpp'.
* C statements::        How to use objects and C in the same programs.
* Externs::             Working with multiple input files.
* Class casting::       How to tell Ctalk which class an object is.
* Control structures::  Objects in loops and conditional statements.
* OBJECT typedef::      Ctalk's 'OBJECT' type.
* Attributes::          Attributes help identify an object's context.
* C library functions:: How to use objects with C library functions.
* GNU tools::           Using automake, etc., with Ctalk programs.


File: ctalk.info,  Node: Preprocessor,  Next: C statements,  Up: C

'ctpp,' the 'ctalk' Preprocessor
--------------------------------

Information about 'ctpp', the Ctalk preprocessor, is contained in its
Texinfo manual, 'ctpp.info'.

The preprocessor is compatible with GNU 'cpp' and supports ISO C99
preprocessing features.  This allows you to include C header files in
Ctalk programs and class libraries.  Ctalk caches macros from include
files, so it can use, in the GNU compiler's terminology, _include once_
header files.

If you have a header file called, for example, 'myheader.h', you would
wrap the definitions with the following preprocessor directives.


     #ifndef _MYHEADER_H
     #define _MYHEADER_H
     .
     . <Your definitions appear here.>
     .
     #endif /* _MYHEADER_H */

This makes certain that the preprocessor defines macros, data types, and
other library definitions only once, no matter how many times the input
includes the header file.


File: ctalk.info,  Node: C statements,  Next: Externs,  Prev: Preprocessor,  Up: C

Pragmas
-------

Ctalk recognizes GCC, G++, and C99 pragmas.

Pragmas that apply to floating point operations and code generation are
ignored and elided, unless the '--keeppragmas' command line option is
given.  *Note Invoking::.

Inclusion of a file that contains G++ pragmas causes the preprocessor to
issue a warning if the '-v' option is given, and 'ctalk' ignores the
file.  *Note Invoking::.

Here is the effect of the GCC and C99 pragmas.

'#pragma interface'
'#pragma implementation'
     The include file is not processed.

'#pragma GCC dependency FILE'
     Issues a warning if the source file is more recent than FILE.

'#pragma GCC poison IDENTIFIER ...'
     'ctalk' issues an error and discontinues processing if the source
     file contains an identifier given as an argument.

'#pragma GCC system header'
     The 'ctalk' preprocessor processes all input files in the same
     manner and ignores this pragma.

'#pragma GCC pack'
'#pragma STDC FP_CONTRACT'
'#pragma STDC FENV_ACCESS'
'#pragma STDC CX_LIMITED_RANGE'
     'ctalk' ignores and elides these pragmas, which apply to floating
     point and code generation options, unless the '--keeppragmas'
     option is used.  *Note Invoking::.

C Expressions
-------------

In version 0.67 2021-03-11, you can use simple constant expressions as
receivers, as in this example.

     printf ("%s", "/home/users/joe" subString 1, self length - 1);

_Warning_ - This use of 'self' is experimental in version 0.67
2021-03-11 and should be used with caution.

You can use a C constant in place of any receiver whose class
corresponds to a basic C data type.  These classes include 'Character',
'String', 'Float', 'Integer', and 'LongInteger'.

Expressions like the following work.
     if (99 == myInt)
      ...

     if ('c' == myInt asCharacter)
      ...

     if (3.1416 == pi)
      ...

The following code examples are equivalent.

     myString = "This is a string.";
     printf ("%d\n", myString length);

and,

     printf ("%d\n", "This is a string" length);

However, if you try to use a C variable on the left side of a method
that overloads a C operator, the expression might simply be interpreted
as C code, as in this example.

       String new progName;

       progName = "myprog";

       if (argv[0] == progName) {
         ...
       }

This is because Ctalk does not interpret 'argv[0]' as a receiver object,
and then interprets '==' as a C operator.

Objects in Function Parameters
------------------------------

Programs cannot, at this time, use objects as parameters to C functions.
If you need to use an object as a parameter, you need to use a method
instead of a function, or translate the object's value to C. *Note
Translating::.

Objects in Function Arguments
-----------------------------

You can use of Ctalk expressions as C function arguments, but the values
should be treated as read-only, as in this example.

     Integer new myIndex;
     char buf[255];

     myIndex = 0;

     /*
      *   This statement works correctly.
      */
     sprintf (buf, "%d", __ctalk_to_c_int (myIndex));

     /*
      *   This statement does not work correctly.
      */
     sscanf (myString, "%s %s", mySubString1, mySubString2);

If you need to read a string into objects, try 'readFormat' (class
'String') instead.

If you receive an 'Unimplemented C type' warning, it means that Ctalk
does not implement a class that corresponds to the data type.  In these
cases, you can generally assign the C variable to an instance of class
'Symbol,' and use that as the argument to a function.

The Classes that implement C data types are described in the next
section.

C Data Type Classes
-------------------

These classes correspond to the basic C types.

'Array'
     'char **'

'Character'
     'char'

'Float'
     'float' and 'double'

'Integer'
     'int' and 'long int'

'LongInteger'
     'long long int'

'String'
     'char *'

Typedefs in Function Arguments
------------------------------

Ctalk resolves many of the derived types defined in C99, as well as
incomplete types; however, variables that are of derived types can still
cause unpredictable results, if the variable is of an unusual or complex
type.

If you encounter a case where a derived type confuses the parser or
run-time library, the workaround is to declare the type as an equivalent
C type.  For example, if a variable is of type 'time_t,' you could
equivalently declare it as type 'long long int.'

C Functions in Complex Expressions
----------------------------------

You can use C functions in complex expressions within conditionals, as
in this example.
     int int_fn1 (void) {
       return 10;
     }

     char *add_int_fn_as_string (int a, int b, int c) {
       static char buf[30];
       sprintf (buf, "%d", a + b + c);
       return buf;
     }

     int main () {

       String new myString1;

       if ((myString1 = add_int_fn_as_string (int_fn1 (), 20, 30)) != "60")
         exit(1);

       printf ("%s\n", myString1);

     }
As long as your function returns one of the C data types 'int, char,
char *,' or 'double,' Ctalk can translate the function output to an
object, as well as call the function at run time using a method call.

If you try to use a C function that returns a complex or derived type,
Ctalk prints a warning and uses 'Integer' as the default return class.
In these cases, you should consider writing a method instead.

_Note:_ When you use functions in complex expressions, the function's
arguments must also be C variables or expressions.  If you want to use
objects as the arguments to a function, then you must perform the
object-to-C translation manually.

Debugging
---------

Object Inspectors
.................

Ctalk provides a basic set of methods that can inspect and print the
contents of objects.

The 'inspect' method in 'Object' class is an interactive utility that
lets you examine a program's objects as the program is running.

To inspect an object, simply send it the message, 'inspect' - it's a
shortcut for the 'inspect' method in 'ObjectInspector' class, which a
program can also call directly.


     String new globalString;

     int main () {
       Integer new i;

       globalString = "global string";

       i inspect;
     }


In either case, the program stops execution when it reaches the
'inspect' method, and presents a prompt where you can type commands.

Here's a transcript of a brief inspector session.


     $ ./inspect
     > p
     p
     name:       i
     class:      Integer (0x48bf4958)
     superclass: Magnitude (0x48bf29f0)
     value:      (null) (Integer)

     > p g globalString
     p g globalString
     name:       globalString
     class:      String (0x48cce8d0)
     superclass: Character (0x48c8acc0)
     value:      global string (String)

     > c
     c
     $


At the inspector prompt, '> ', the command 'p' prints the inspector's
receiver object, and 'p g globalString' prints the named global object,
'globalString'.  The 'c' command exits the inspector and continues
running the program.

There are several commands that the inspector recognizes.  Typing '?,'
'h,' or 'help' at the prompt displays a list of them.

The inspector uses the method 'formatObject' to print the contents of
individual objects.

If you want to print a formatted object directly, without stopping the
program, Ctalk also has the method 'dump' in 'Object' class, which
simply calls 'formatObject' with its receiver object to print the object
and then returns so the program can continue running.

Using 'gdb' for Debugging
.........................

The GNU 'gdb' debugger allows you to trace through Ctalk applications as
well as the compiler and the run-time libraries, at the level of Ctalk's
source code.

In order to debug Ctalk programs with 'gdb', the source must be
compatible with the debugger; that means that you can debug Ctalk
programs using the intermediate C code to get source level debugging
within Ctalk apps.

You can also examine the contents of objects and their run-time
environment with the 'inspect' method (in 'Object' class), which doesn't
use line number information.  *Note Object_inspect::.  There's a
tutorial on using object inspectors in the 'ctalktools' Texinfo manual,
and yet more information in the 'inspect.3ctalk' manual page.

The '-P' command line option disables line numbering.  You can then
debug the intermediate output, which is normal C that 'gdb' can
interpret correctly.

This means that method line numbers are calculated from the start of all
of the input, which includes all other classes and header files.  So
when you give the '-P' option to Ctalk, it reports the line if possible,
although without line number information, the compiler can't track line
numbers of preprocessor output; like for example, by adjusting line
numbers after including a file with the '#include' directive.

The 'ctdb' command builds Ctalk programs with the correct arguments for
debugging.  Then you can use 'gdb' to debug the program.

     $ ctdb -k myprog.c -o myprog

If you need to debug either 'ctalk' or the 'libctalk' library, then you
need to build and install Ctalk without optimization.  You can do that
by adding the '--without-optimization' option to 'configure' when
building Ctalk.  Compiler optimization often removes lines of code (and
variables) from the binary, so the output often doesn't correspond to
the source code.  Also, it often helps to add the
'--without-inline-functions' option to 'configure'.


     $ ./configure --without-inline-functions --without-optimization


Then build and install Ctalk with 'make' and 'make install.'

Ctalk also provides other build options.  Typing
     $ ./configure --help
at the shell prompt prints a list of them.

Ctalk is compatible at the machine code level with C programs.  That
means you use most of 'gdb's' functions, like peek into a running
program and examine core dumps.  The 'gdb' documentation describes the
debugger's extensive set of options.


File: ctalk.info,  Node: Externs,  Next: Class casting,  Prev: C statements,  Up: C

Externs
-------

Ctalk provides a few facilities to help when compiling code in several
input modules.

There are also a few caveats when dealing with C variables in multiple
input modules, which are described below.

Ctalk allows you to prototype methods.  That is, you can declare a
method in a source code module before compiling another module later
where the method is actually defined.

Prototypes are similar to method declarations, except that the prototype
omits the method body.  For example, a method prototype before the
method is first used would look like this.

     String instanceMethod myLength (void);

You can also define a different return class in the prototype, as in
this example.

     String instanceMethod myLength (void) returnClass Integer;

For example, if the input file module1.ca looks like this:


     String instanceMethod trimStrLength (void) returnObjectClass Integer;

     int main () {

       String new myStr;

       myStr = "Hello, world!";

       printf ("%s\n", myStr subString 0, myStr trimStrLength 2);
     }


and the file module2.ca, which contains the definition of
'trimStrLength', looks like this:


     String instanceMethod trimStrLength (void) {
       returnObjectClass Integer;
       return self length - 1;
     }


Then you can build the program with a command line like the following,
and Ctalk will have the definition of 'trimStringLength' while compiling
module1.ca, before it actually compiles the method in module2.ca.


     $ ctcc module1.ca module2.ca -o myprog


C Variables and 'extern' Declarations
.....................................

When using a global C variable in several input modules, you only need
to declare it once, before it is first used.  Ctalk combines the C code
of all of the input files with one copy of the class libraries, so it
isn't necessary to declare a C variable in the first module and then
declare it as extern in the modules that get compiled later.


File: ctalk.info,  Node: Class casting,  Next: Control structures,  Prev: Externs,  Up: C

Class casting
-------------

In many cases, it's obvious which class an object is, even when the
object's defition is removed from the place where a program needs to
perform an operation on it, or the object is aliased to 'self' or to a C
variable, or you need to use a different type of language semantics with
an object.

If a program has a set of expressions, as in this hypothetical example:


     Integer new myInt;
     myList new myList;
     Key new myKey;
     Symbol new *intPtr;

     *intPtr = Integer new "Int 1", "1";
     myList push *intPtr;
     *intPtr = Integer new "Int 2", "2";
     myList push *intPtr;

     myKey = myList + 1;

     myInt = *myKey;

     myInt += 3;

     _... do stuff with myInt ..._

     myList map {
       printf ("%d\n", self value);
     }


When run, the program would produce output like this.


     $ ./myProg
     1
     2


That's because the changes to 'myInt' would not take effect for the
member of 'myList', because 'Integer' objects, when a program assigns
values to them, normally assigns the value of one 'Integer' to another.
However, in the example above, you might want to work on the original
list member - that is, you want the assignment to treat 'myInt' as if it
were a reference.

One way to notify Ctalk of this is to use an 'Object' to refer to the
list element, and use a _class cast_ to notify Ctalk that the 'Object'
is actually an 'Integer'.

Then the program example above looks like this.


     Object new myIntObject;
     myList new myList;
     Key new myKey;
     Symbol new *intPtr;

     *intPtr = Integer new "Int 1", "1";
     myList push *intPtr;
     *intPtr = Integer new "Int 2", "2";
     myList push *intPtr;

     myKey = myList + 1;

     myIntObject = *myKey;

     (Integer *)myIntObject += 3;  /* The cast tells Ctalk to treat myIntObject,
                                      which is declared as an Object,
                                      as an Integer, so it can work correctly
                                      with the first element of myList. */

     _... do stuff with myIntObject ..._

     myList map {
       printf ("%d\n", self value);
     }


Other places that you can use class casting is when a program uses a C
'OBJECT *'.  In that case, you can tell Ctalk what class the object is.
Here's an abbreviated example from a 'map' method in 'TreeNode' class.


       OBJECT *t, *list_elem;

       /* rcvr_obj is a TreeNode object. */
       for (t = __LIST_HEAD(rcvr_obj), have_break = NULL;
            t && !have_break; t = t -> next) {
         list_elem = obj_ref_str ((t -> instancevars) ?
     			     t -> instancevars -> __o_value :
     			     (IS_VALUE_INSTANCE_VAR(t) ?
     			      t -> __o_p_obj -> instancevars -> __o_value :
     			      "0x0"));

       _... do stuff ..._

       (TreeNode *)list_elem children __mapChildren methodfn;

       (TreeNode *)list_elem siblings __mapSiblings methodfn;

       }

This is a convenient way for a program to tell Ctalk that 'list_elem' is
a 'TreeNode' object.  It's up to the program to ensure that the C
variable actually does point to an object of that class, or the program
won't work correctly at run time.

Programs can also cast 'self' to a class, in cases where Ctalk cannot
determine 'self's' class from its context, like in this example


     myList map {

       (Float *)self = 0.01f;

     }


This feature is still experimental, and you should use it with caution;
in particular, it's up to the program to insure that the object actually
is a member of the class that you cast it to.  However, on the occasions
when a program needs to excercise some control over a set of
expressions' semantics, then class casting can be useful.


File: ctalk.info,  Node: Control structures,  Next: OBJECT typedef,  Prev: Class casting,  Up: C

Control Structures
------------------

Generally, Ctalk objects work the same as C variables when they appear
in 'if', 'for', 'while', 'switch', and 'do-while' statements.

If Ctalk cannot figure out a way to resolve an expression that contains
both C variables or functions and objects, it will try to warn you.

One exception to these rules are the methods that perform logical
negation operator, which generally overload the '!' math operator.  When
you place a '!' operator at the beginning of a conditional, Ctalk checks
whether the class of the expression's result overloads the operator.  In
that case, Ctalk treats '!' as a method.  If a class does not overload
the operator, then Ctalk treats it as a C operator.

That way, you can overload '!' in classes that define complex objects,
which provides a flexible way to determine if an object has been
initialized or contains valid data.

For example, in 'X11Font' class, you can overload the '!' operator to
check whether or not an object's 'fontId' instance variable is zero to
determine whether or not the object refers to a valid font.

If a class doesn't overload '!', then Ctalk uses the C semantics for the
operator - that is, it simply checks whether an operand is zero (or
NULL) or non-zero, and inverts the logical true or false value of the
operand.

In addition, Ctalk provides many methods to iterate over collections of
objects.  These methods include 'map', 'mapInstanceVariables',
'mapClassVariables', and overloaded math operators like those in 'Key'
class.

For a complete description of the control structures Ctalk uses, refer
to the 'Ctalk Tutorial'.


File: ctalk.info,  Node: OBJECT typedef,  Next: Attributes,  Prev: Control structures,  Up: C

'OBJECT' typedef
================

At the lowest level, ctalk declares objects as pointers to an 'OBJECT'
struct.  You can access an object's members if you assign an object's
value to a C variable of the type 'OBJECT *', as in this example.

     Object new myObject;
     OBJECT *myObjectValue;

     myObjectValue = myObject value;

     if (!strcmp (myObjectValue -> CLASSNAME, "Object"))
        printf ("myObjectValues class is, \"Object.\"\n");

The declaration of the OBJECT type is contained in 'include/object.h'.

     typedef struct _object OBJECT;
     . . .
     struct _object {
       char sig[16];
       char __o_name[MAXLABEL];
       char __o_classname[MAXLABEL];
       OBJECT *__o_class;
       char __o_superclassname[MAXLABEL];
       OBJECT *__o_superclass;
       OBJECT *__o_p_obj;
       VARTAG *__o_vartags;
       char *__o_value;
       METHOD *instance_methods,
         *class_methods;
       int scope;
       int nrefs;
       int attrs
       struct _object *classvars;
       struct _object *instancevars;
       struct _object *next;
       struct _object *prev;
     };

Note that '__o_name', '__o_classname', '__o_superclassname', and
'__o_value' are all 'char *', even if the object belongs to a class like
'Integer' or 'Float'.  The struct members '__o_class' and
'__o_superclass' contain pointers to the library class and superclass
entries, which are also objects.

For numeric classes, the 'value' member contains a formatted
representation of a numeric value.  Examples of directly assigning
values to objects are given in the section about writing methods.  *Note
Method API::.

Ctalk uses the members 'instance_methods,' 'class_methods,' 'classvars'
for class objects.

The 'sig' member contains a numeric stamp that verifies that the 'OBJECT
*' refers to a valid object.

The 'scope' member describes an object's scope.  The scope can be one of
'GLOBAL_VAR', 'LOCAL_VAR', 'ARG_VAR', 'RECEIVER_VAR', 'PROTOTYPE_VAR',
or 'BLOCK_VAR.'

The 'nrefs' member keeps track of the number of references that exist to
an object at run time.  Every time ctalk creates a reference to an
object, internally ctalk increments 'nrefs'.  When ctalk deletes a
reference, it decrements 'nrefs'.  When 'nrefs' drops to zero, 'ctalk'
deletes the object.

The 'attrs' member is a combination of one or more object attributes.
The next section describes object attributes in more detail.

The 'tag' member is an abbreviation for the '__o_vartags -> tag ->
var_decl -> name' member; that is, the object's primary label.


File: ctalk.info,  Node: Attributes,  Next: C library functions,  Prev: OBJECT typedef,  Up: C

Object Attributes
-----------------

The Ctalk API defines a number of object attributes.  The attributes
help identify the context that the object appears in.  Many of the
attributes are only meaningful internally; some are also useful in the
method API.

The attributes are defined in 'ctalkdefs.h', which you can include in
class libraries.  To set an object's attribute, it's generally
convenient to use the '__ctalkSetObjectAttr ()' library function, which
has the prototype:


     __ctalkSetObjectAttr (OBJECT *OBJECT, int ATTR)


Many attributes are only used by Ctalk internally.  The attributes that
are useful in methods are defined in 'ctalkdefs.h'.  Those attributes,
and their values and uses, are listed here.

'OBJECT_IS_VALUE_VAR (1 << 0)'
     The object is the 'value' instance variable of its parent object.
'OBJECT_VALUE_IS_C_CHAR_PTR_PTR (1 << 1)'
     Used to indicate that an object refers to a 'char **' C array.
'OBJECT_IS_NULL_RESULT_OBJECT (1 << 2)'
     Indentifies an object that is created when an operation produces a
     NULL result.
'OBJECT_HAS_PTR_CX (1 << 3)'
     Set when an object appears on the left-hand side of an equation
     with a pointer reference; e.g.,

          *mySymbol = __ctalk_self_internal ().


'OBJECT_IS_GLOBAL_COPY (1 << 4)'
     Set when a program copies a global object.

'OBJECT_IS_I_RESULT (1 << 5)'
     Identifies temporary objects that are the result of an operation
     that sets the object tag's pointer references.

'OBJECT_IS_STRING_LITERAL (1 << 6)'
     Used to identify an object created to represent a string literal.

'OBJECT_IS_MEMBER_OF_PARENT_COLLECTION (1 << 7)'
     Indicates that an object (generally a 'Key' object) is a member of
     a parent collection.  Normally used to identify individual
     collection members.

'OBJECT_HAS_LOCAL_TAG (1 << 8)'
     Indicates that an object's tag was created as a placeholder for an
     ad-hoc object; for example, objects created by a 'basicNew' method.
     The local tag is not necessarily the primary tag - the object can
     also acquire other tags when being assigned.  Normally this
     attribute is set by the '__ctalkAddBasicNewTag ()' library
     function.

'OBJECT_IS_DEREF_RESULT'
     Set by the 'Object : ->' method.  The attribute is used to indicate
     that the receiver of '->' is the result of a previous call to '->';
     i.e., the expression contains several dereference operators; for
     example, 'myObject -> instancevars -> __o_value'.


File: ctalk.info,  Node: C library functions,  Next: GNU tools,  Prev: Attributes,  Up: C

C Library Functions
-------------------

You can assign the result of a C library function to a Ctalk object,
provided that the return type of the function has a corresponding Ctalk
class.

All C functions must have prototypes.  The library functions in this
section already have their prototypes defined in the C library headers.
If a function in a program does not have a prototype, Ctalk prints an
error and exits.

Generally, if Ctalk has a method that is analogous to a C library
function, you can use the method with Ctalk objects, although in many
cases you can mix objects and C variables.  Of course, you can still use
any C library function with C data types.

There are some incompatibilities with more specialized libraries.  For
example, you should take care when using the X Window System Xt widgets
in Ctalk programs, because the widget classes use the some of the same
class names as the Ctalk library.

The following sections describe the C library functions that Ctalk can
use directly.

* Menu:

* abs::
* acos::
* acosh-asinh-atanh::
* asctime::
* asin::
* atexit::
* atof::
* atoi::
* atol::
* atoll::
* calloc::
* cbrt::
* ceil::
* chdir::
* clock::
* copysign::
* cos::
* cosh::
* ctime::
* difftime::
* erf::
* erfc::
* exp::
* expm1::
* fabs::
* fclose::
* fegetround::
* feholdexcept::
* feof::
* ferror::
* fesetround::
* fetestexcept::
* fflush::
* fgetc::
* fgetpos::
* fgets::
* floor::
* fmod::
* fopen::
* fprintf::
* fputc::
* fputs::
* fread::
* free::
* freopen::
* frexp::
* fscanf::
* fseek::
* fsetpos::
* fstat::
* ftell::
* fwrite::
* getc::
* getchar::
* getcwd::
* getenv::
* getpid::
* gmtime-localtime::
* index-function::
* isalnum-isxdigit::
* labs::
* llabs::
* llrint::
* llround::
* log::
* log10::
* log1p::
* lrint::
* lround::
* malloc::
* memchr::
* memcmp::
* memcpy::
* memmove::
* memset::
* mkdir::
* modf::
* nearbyint::
* perror::
* pow::
* printf::
* raise::
* rand::
* realloc::
* remove::
* rename::
* rindex::
* rint::
* rmdir::
* round::
* scanf::
* sin::
* sinh::
* snprintf::
* sprintf::
* sqrt::
* srand::
* sscanf::
* strcat-strcpy::
* strchr::
* strcoll::
* strspn::
* strerror::
* strftime::
* strlen::
* strncat-strncpy::
* strpbrk::
* strrchr::
* strstr::
* strtod::
* strtok::
* strtoll::
* strxfrm::
* system::
* tan::
* tanh::
* tmpnam::
* tolower::
* toupper::
* trunc::
* ungetc::
* vfprintf::
* vfscanf::
* vprintf::
* vscanf::
* vsnprintf::
* vsprintf::
* vsscanf::


File: ctalk.info,  Node: abs,  Next: acos,  Up: C library functions

'abs' Function
--------------


     #include <stdlib.h>

     Integer new i;

     i = abs (3);



File: ctalk.info,  Node: acos,  Next: acosh-asinh-atanh,  Prev: abs,  Up: C library functions

'acos' Function
---------------


     #include <math.h>

     Integer new i;

     i = acos (0.5);


Ctalk does not check if the argument is outside the range -1 to 1 and
does not check for an error.  Refer to the, 'acos', manual page.


File: ctalk.info,  Node: acosh-asinh-atanh,  Next: asctime,  Prev: acos,  Up: C library functions

'acosh,' 'asinh,' and 'atanh' Functions
---------------------------------------


     #include <math.h>

     Float new myFloat;

     myFloat = acosh (2.0);


Ctalk does not check the range of the arguments or errors.  Refer to
the, 'acosh(3), asinh(3),' and 'atanh(3)' manual pages.


File: ctalk.info,  Node: asctime,  Next: asin,  Prev: acosh-asinh-atanh,  Up: C library functions

'asctime' Function
------------------


     #include <time.h>

     time_t t;
     struct tm *time_struct;
     String new s;

     time (&t);
     time_struct = localtime (&t);
     s = asctime (time_struct);


_Note:_ Ctalk does not have a class corresponding to a 'struct tm *.' An
explicit assignment of a 'struct tm *' to a 'Symbol' passes the address
to 'asctime.' *Note Objects in Function Arguments::.


File: ctalk.info,  Node: asin,  Next: atexit,  Prev: asctime,  Up: C library functions

'asin' Function
---------------

     #include <math.h>

     Float new f;

     f = asin (0.5);

Note that ctalk does not perform any range checking of the argument.


File: ctalk.info,  Node: atexit,  Next: atof,  Prev: asin,  Up: C library functions

'atexit' Function
-----------------

     #include <stdlib.h>

     Integer new i;

     i = atexit (exitfunc);



File: ctalk.info,  Node: atof,  Next: atoi,  Prev: atexit,  Up: C library functions

'atof' Function
---------------

     #include <stdlib.h>

     Float new pi;

     pi = atof ("3.1416");


File: ctalk.info,  Node: atoi,  Next: atol,  Prev: atof,  Up: C library functions

'atoi' Function
---------------

     #include <stdlib.h>

     Integer new i;

     i = atoi ("35");


File: ctalk.info,  Node: atol,  Next: atoll,  Prev: atoi,  Up: C library functions

'atol' Function
---------------

     #include <stdlib.h>

     Integer new i;

     i = atol ("35");

Note that, 'Integer', class corresponds to the C types, 'int', and,
'long int'.


File: ctalk.info,  Node: atoll,  Next: calloc,  Prev: atol,  Up: C library functions

'atoll' Function
----------------

#include <stdlib.h>

LongInteger new i;

i = atoll ("35");

_Note:_ The 'atoll(3)' function is not implemented by the OS X or DJGPP
C libraries.  Use 'atol(3)', 'strtoll(3)', or a method instead.


File: ctalk.info,  Node: calloc,  Next: cbrt,  Prev: atoll,  Up: C library functions

'calloc' Function
-----------------

     #include <stdlib.h>

     Integer new n;
     Integer new size;
     int *intbuf;

     n = 10;
     size = sizeof (int);

     intbuf = calloc (n, size);


File: ctalk.info,  Node: cbrt,  Next: ceil,  Prev: calloc,  Up: C library functions

'cbrt' Function
---------------

#include <math.h>

Float new f;

f = cbrt (9.0);


File: ctalk.info,  Node: ceil,  Next: chdir,  Prev: cbrt,  Up: C library functions

'ceil' Function
---------------

#include <math.h>

Float new f;

f = ceil (3.5);


File: ctalk.info,  Node: chdir,  Next: clock,  Prev: ceil,  Up: C library functions

'chdir' Function
----------------

Integer new result; String new dirName;

dirName = "mySubdir";

result = chdir (mySubdir);


File: ctalk.info,  Node: clock,  Next: copysign,  Prev: chdir,  Up: C library functions

'clock' Function
----------------

     #include <time.h>

     Integer new i;

     i = clock ();


File: ctalk.info,  Node: copysign,  Next: cos,  Prev: clock,  Up: C library functions

'copysign' Function
-------------------

     #include <math.h>

     Float new f;

     f = copysign (3.0, -1.0);


File: ctalk.info,  Node: cos,  Next: cosh,  Prev: copysign,  Up: C library functions

'cos' Function
--------------

     #include <math.h>

     Float new f;

     f = cos (45.0);


File: ctalk.info,  Node: cosh,  Next: ctime,  Prev: cos,  Up: C library functions

'cosh' Function
---------------

     #include <math.h>

     Float new f;

     f = cosh (45.0);


File: ctalk.info,  Node: ctime,  Next: difftime,  Prev: cosh,  Up: C library functions

'ctime' Function
----------------

     #include <time.h>

     time_t t;
     String new s;

     time (&t);
     s = ctime (&t);

_Note:_ There is not a portable way to take the address of an object
with '&', although it may be possible to perform the translation
manually in some cases.  If the argument must be an object, then use the
'cTime' (class 'CTime') method instead.


File: ctalk.info,  Node: difftime,  Next: erf,  Prev: ctime,  Up: C library functions

'difftime' Function
-------------------


     #include <time.h>

     Float new f;

     f = difftime (time1, time0);



File: ctalk.info,  Node: erf,  Next: erfc,  Prev: difftime,  Up: C library functions

'erf' Function
--------------


     #include <math.h>

     Float new f;

     f = erf (0.5);



File: ctalk.info,  Node: erfc,  Next: exp,  Prev: erf,  Up: C library functions

'erfc' Function
---------------


     #include <math.h>

     Float new f;

     f = erfc (0.5);



File: ctalk.info,  Node: exp,  Next: expm1,  Prev: erfc,  Up: C library functions

'exp' Function
--------------


     #include <math.h>

     Float new f;

     f = exp (2);



File: ctalk.info,  Node: expm1,  Next: fabs,  Prev: exp,  Up: C library functions

'expm1' Function
----------------


     #include <math.h>

     Float new f;

     f = expm1 (1.05);



File: ctalk.info,  Node: fabs,  Next: fclose,  Prev: expm1,  Up: C library functions

'fabs' Function
---------------


     #include <math.h>

     Float new f;

     f = fabs (-1.05);



File: ctalk.info,  Node: fclose,  Next: fegetround,  Prev: fabs,  Up: C library functions

'fclose' Function
-----------------


     #include <stdio.h>

     Integer new i;

     i = fclose (fileHandle);



File: ctalk.info,  Node: fegetround,  Next: feholdexcept,  Prev: fclose,  Up: C library functions

'fegetround' Function
---------------------


     #include <fenv.h>

     Integer new i;

     i = fegetround ();



File: ctalk.info,  Node: feholdexcept,  Next: feof,  Prev: fegetround,  Up: C library functions

'feholdexcept' Function
-----------------------


     #include <fenv.h>

     Integer new i;

     i = feholdexcept (fe_envp);



File: ctalk.info,  Node: feof,  Next: ferror,  Prev: feholdexcept,  Up: C library functions

'feof' Function
---------------


     #include <stdio.h>

     Integer new i;

     i = feof (fileStream);



File: ctalk.info,  Node: ferror,  Next: fesetround,  Prev: feof,  Up: C library functions

'ferror' Function
-----------------


     #include <stdio.h>

     Integer new i;

     i = ferror (fileStream);



File: ctalk.info,  Node: fesetround,  Next: fetestexcept,  Prev: ferror,  Up: C library functions

'fesetround' Function
---------------------


     #include <math.h>

     Integer new i;

     i = fesetround (mode);



File: ctalk.info,  Node: fetestexcept,  Next: fflush,  Prev: fesetround,  Up: C library functions

'fetestexcepts' Function
------------------------


     #include <math.h>

     Integer new i;

     i = fetestxcept (exceptions);



File: ctalk.info,  Node: fflush,  Next: fgetc,  Prev: fetestexcept,  Up: C library functions

'fflush' Function
-----------------


     #include <stdio.h>

     Integer new i;

     i = fflush (fileStream);



File: ctalk.info,  Node: fgetc,  Next: fgetpos,  Prev: fflush,  Up: C library functions

'fgetc' Function
----------------


     #include <stdio.h>

     Integer new i;

     i = fgetc (fileStream);



File: ctalk.info,  Node: fgetpos,  Next: fgets,  Prev: fgetc,  Up: C library functions

'fgetpos' Function
------------------


     #include <stdio.h>

     Integer new i;

     i = fgetpos (fileStream, pos);



File: ctalk.info,  Node: fgets,  Next: floor,  Prev: fgetpos,  Up: C library functions

'fgets' Function
----------------


     #include <stdio.h>

     String new s;

     s = fgets (s, s length, fileStream);



File: ctalk.info,  Node: floor,  Next: fmod,  Prev: fgets,  Up: C library functions

'floor' Function
----------------


     #include <math.h>

     Float new f;

     f = floor (3.01);



File: ctalk.info,  Node: fmod,  Next: fopen,  Prev: floor,  Up: C library functions

'fmod' Function
---------------


     #include <math.h>

     Float new f;

     f = fmod (3.0, 2.0);



File: ctalk.info,  Node: fopen,  Next: fprintf,  Prev: fmod,  Up: C library functions

'fopen' Function
----------------


     #include <stdio.h>

     FILE *f

     String new path;
     String new mode;

     path = "/home/user/.profile";
     mode = "r";

     f = fopen (path, mode);



File: ctalk.info,  Node: fprintf,  Next: fputc,  Prev: fopen,  Up: C library functions

'fprintf' Function
------------------

*Note Variable arguments::.


File: ctalk.info,  Node: fputc,  Next: fputs,  Prev: fprintf,  Up: C library functions

'fputc' Function
----------------


     #include <stdio.h>

     Integer new myInput;

     myInput = fgetc (xstdin ());
     fputc (myInput, xstdout ());



File: ctalk.info,  Node: fputs,  Next: fread,  Prev: fputc,  Up: C library functions

'fputc' Function
----------------

     #include <stdio.h>

     String new myInput;

     fgets (myInput, 255, xstdin ());
     fputs (myInput, xstdout ());


File: ctalk.info,  Node: fread,  Next: free,  Prev: fputs,  Up: C library functions

'fread' Function
----------------

     #include <stdio.h>

     String new myInput;

     myInput = "";

     fread (myInput, 255, sizeof (char), xstdin ());


File: ctalk.info,  Node: free,  Next: freopen,  Prev: fread,  Up: C library functions

'free' Function
---------------

Do not use 'free' with objects.  Use the '__ctalkDeleteObject' library
function instead.

Also, calling '__objRefCntZero' before '__ctalkDeleteObject' insures
that the object will be completely deleted.  You can do this in two
ways: first, by sending the object a 'delete' message; or by casting the
object to a C 'OBJECT *' and then giving the 'OBJECT *' as an argument
to '__objRefCntZero' and '__ctalkDeleteObject'.

     Object new myObject;
     OBJECT *myObject_alias;

     myObject_aliast = myObject;

     __objRefCntZero (OBJREF (myObject_alias));
     __ctalkDeleteObject (myObject_alias);


File: ctalk.info,  Node: freopen,  Next: frexp,  Prev: free,  Up: C library functions

'freopen' Function
------------------

     #include <stdio.h>

     FILE *f;

     String new path;
     String new mode;

     path = "/home/user/.profile";
     mode = "r";

     f2 = freopen (path, mode, xstdin ());


File: ctalk.info,  Node: frexp,  Next: fscanf,  Prev: freopen,  Up: C library functions

'frexp' Function
----------------

     #include <math.h>

     int i_exp_val;
     Integer new expInt;
     Float new myFloat;
     Float new myFraction;

     myFloat = "2.5";

     myFraction = frexp (myFloat, &i_exp_val);

     expInt = i_exp_val;


File: ctalk.info,  Node: fscanf,  Next: fseek,  Prev: frexp,  Up: C library functions

'fscanf' Function
-----------------

*Note Variable arguments::.

Ctalk wraps 'stdin, stdout,' and 'stderr' in the functions 'xstdin,
xstdout,' and 'xstderr,' which gives the streams a constant interface
for methods to use regardless of the streams' internal implementation.


File: ctalk.info,  Node: fseek,  Next: fsetpos,  Prev: fscanf,  Up: C library functions

'fseek' Function
----------------


File: ctalk.info,  Node: fsetpos,  Next: fstat,  Prev: fseek,  Up: C library functions

'fsetpos' Function
------------------

     #include <stdio.h>

     FILE *f;
     String new path;
     String new mode;
     Integer new offset;

     path = "/home/user/.profile.new";
     mode = "r";


     f = fopen (path, mode);

     offset = 0L;

     fsetpos (f, offset);


File: ctalk.info,  Node: fstat,  Next: ftell,  Prev: fsetpos,  Up: C library functions

'fstat' Function
----------------

     #include <sys/types.h>
     #include <sys/stat.h>
     #include <unistd.h>

     String new path;
     Integer new result;
     struct stat statbuf;

     path = "/home/user/.profile";

     result = fstat (path, &statbuf);



File: ctalk.info,  Node: ftell,  Next: fwrite,  Prev: fstat,  Up: C library functions

'ftell' Function
----------------

     #include <stdio.h>

     Integer new filePos;

     filePos = ftell (file);


File: ctalk.info,  Node: fwrite,  Next: getc,  Prev: ftell,  Up: C library functions

'fwrite' Function
-----------------

     #include <stdio.h>

     FILE *f;
     String new path;
     String new mode;
     String new promptLine;

     path = "/home/user/.profile.new";
     mode = "a";

     f = fopen (path, mode);

     promptLine = "PS1=#";

     fwrite (promptLine, promptLine length, sizeof (char), f);


File: ctalk.info,  Node: getc,  Next: getchar,  Prev: fwrite,  Up: C library functions

'getc' Function
---------------

     #include <stdio.h>

     Integer new myInput;

     myInput = getc (xstdin ());

     printf ("%c", myInput asCharacter);


File: ctalk.info,  Node: getchar,  Next: getcwd,  Prev: getc,  Up: C library functions

'getchar' Function
------------------

     #include <stdio.h>

     Integer new myInput;

     myInput = getchar ();

     printf ("%c", myInput asCharacter);


File: ctalk.info,  Node: getcwd,  Next: getenv,  Prev: getchar,  Up: C library functions

'getcwd' Function
-----------------

     #include <stdio.h>
     String new myString;
     getcwd (myString, FILENAME_MAX);
_Note:_ The argument 'myString' must already be initialized to hold the
entire directory path.  If in doubt, use 'getCwd' (class
'DirectoryStream') instead.  *Note DirectoryStream::.


File: ctalk.info,  Node: getenv,  Next: getpid,  Prev: getcwd,  Up: C library functions

'getenv' Function
-----------------

     String new envPath;

     envPath = getenv ("PATH");

     printf ("%s", envPath);


File: ctalk.info,  Node: getpid,  Next: gmtime-localtime,  Prev: getenv,  Up: C library functions

'getpid' Function
-----------------


File: ctalk.info,  Node: gmtime-localtime,  Next: index-function,  Prev: getpid,  Up: C library functions

'gmtime,' 'localtime' Functions
-------------------------------


File: ctalk.info,  Node: index-function,  Next: isalnum-isxdigit,  Prev: gmtime-localtime,  Up: C library functions

'index' Function
----------------

*Note strchr::.


File: ctalk.info,  Node: isalnum-isxdigit,  Next: labs,  Prev: index-function,  Up: C library functions

'isalnum,' 'isalpha,' 'isascii,' 'isblank,' 'iscntrl,' 'isdigit,' 'isgraph,' 'islower,' 'isprint,' 'ispunct,' 'isspace,' 'isupper,' 'isxdigit' Functions
--------------------------------------------------------------------------------------------------------------------------------------------------------

Ctalk does not support 'ctype.h' macros portably.  Use the corresponding
method of class 'Character' instead.  *Note Character::.

     Ctype.h Macro          Ctalk Method
     -------------          ------------
     isalnum                isAlNum
     isalpha                isAlpha
     isascii                isASCII
     isblank                isBlank
     iscntrl                isCntrl
     isdigit                isDigit
     isgraph                isGraph
     islower                isLower
     isprint                isPrint
     ispunct                isPunct
     isspace                isSpace
     isupper                isUpper
     isxdigit               isXDigit


File: ctalk.info,  Node: labs,  Next: llabs,  Prev: isalnum-isxdigit,  Up: C library functions

'labs' Function
---------------

     #include <stdlib.h>

     Integer new myValue;
     Integer new myAbsValue;

     myAbsValue = labs (myValue);


File: ctalk.info,  Node: llabs,  Next: llrint,  Prev: labs,  Up: C library functions

'llabs' Function
----------------

     #include <stdlib.h>

     LongInteger new myValue;
     LongInteger new myAbsValue;

     myAbsValue = llabs (myValue);


File: ctalk.info,  Node: llrint,  Next: llround,  Prev: llabs,  Up: C library functions

'lrint', 'lrintf', 'lrintl', 'llrint', 'llrintf', 'llrintl' Functions
---------------------------------------------------------------------

     #include <math.h>

     Float new myFloat;
     LongInteger new myLongInt;

     myFloat = 2.5;

     myLongInt = llrint (myFloat);

Consult the manual page for 'lrint(3)', etc., for detailed information
about each function.


File: ctalk.info,  Node: llround,  Next: log,  Prev: llrint,  Up: C library functions

'llround' Function
------------------

     #include <math.h>

     Float new myFloat;
     LongInteger new myLongInt;

     myFloat = 2.5;

     myLongInt = llround (myFloat);


File: ctalk.info,  Node: log,  Next: log10,  Prev: llround,  Up: C library functions

'log' Function
--------------

     #include <math.h>

     Float new myFloat;
     Float new myLog;

     myFloat = 2.5;

     myLog = log (myFloat);


File: ctalk.info,  Node: log10,  Next: log1p,  Prev: log,  Up: C library functions

'log10' Function
----------------

     #include <math.h>

     Float new myFloat;
     Float new myLog;

     myFloat = 2.5;

     myLog = log10 (myFloat);


File: ctalk.info,  Node: log1p,  Next: lrint,  Prev: log10,  Up: C library functions

'log1p' Function
----------------

     #include <math.h>

     Float new myFloat;
     Float new myLog;

     myFloat = 2.5;

     myLog = log1p (myFloat);


File: ctalk.info,  Node: lrint,  Next: lround,  Prev: log1p,  Up: C library functions

'lrint' Function
----------------

     #include <math.h>

     Float new myFloat;
     Integer new myInt;

     myFloat = 2.5;

     myLog = lrint (myFloat);


File: ctalk.info,  Node: lround,  Next: malloc,  Prev: lrint,  Up: C library functions

'lround' Function
-----------------

     #include <math.h>

     Float new myFloat;
     Integer new myInt;

     myFloat = 2.5;

     myLog = lround (myFloat);


File: ctalk.info,  Node: malloc,  Next: memchr,  Prev: lround,  Up: C library functions

'malloc' Function
-----------------

     #include <stdlib.h>

     Integer new size;
     int *intbuf

     size = sizeof (int) * 10;

     memblk = (int *)malloc (size);


File: ctalk.info,  Node: memchr,  Next: memcmp,  Prev: malloc,  Up: C library functions

'memchr' Function
-----------------

     #include <string.h>

     #define BUFLENGTH 1024

     Integer new searchChar;
     Integer new length;
     char buf[BUFLENGTH], *charptr;

     length = BUFLENGTH

     strcpy (buf, "Some text.");

     searchChar = '.';

     charptr = (char *)memchr ((void *)buf, searchChar, length);



File: ctalk.info,  Node: memcmp,  Next: memcpy,  Prev: memchr,  Up: C library functions

'memcmp' Function
-----------------

     #include <string.h>

     #define BUFLENGTH 1024

     Integer new length;
     Integer new result;
     char buf1[BUFLENGTH], buf2[BUFLENGTH];

     length = BUFLENGTH

     strcpy (buf1, "Some text.");
     strcpy (buf2, "Some other text.");

     result = memcmp ((void *)buf1, (void *)buf2, length);



File: ctalk.info,  Node: memcpy,  Next: memmove,  Prev: memcmp,  Up: C library functions

'memcpy' Function
-----------------

     #include <string.h>

     #define BUFLENGTH 1024

     Integer new length;
     Integer new result;
     char buf1[BUFLENGTH], buf2[BUFLENGTH], *charptr;

     length = BUFLENGTH

     strcpy (buf1, "Some text.");

     result = (char *)memcpy ((void *)buf1, (void *)buf2, length);



File: ctalk.info,  Node: memmove,  Next: memset,  Prev: memcpy,  Up: C library functions

'memmove' Function
------------------

     #include <string.h>

     #define BUFLENGTH 1024

     Integer new length;
     Integer new result;
     char buf1[BUFLENGTH], buf2[BUFLENGTH], *charptr;

     length = BUFLENGTH

     strcpy (buf1, "Some text.");

     charptr = (char *)memmove ((void *)buf1, (void *)buf2, length);



File: ctalk.info,  Node: memset,  Next: mkdir,  Prev: memmove,  Up: C library functions

'memset' Function
-----------------

     #include <string.h>

     #define BUFLENGTH 1024

     Integer new length;
     Integer new fillChar;
     char buf[BUFLENGTH], *charptr;

     length = BUFLENGTH
     fillChar = 0;

     charptr = (char *)memset ((void *)buf1, fillChar, length);



File: ctalk.info,  Node: mkdir,  Next: modf,  Prev: memset,  Up: C library functions

'mkdir' Function
----------------

     Integer new r;
     String new myDirName;

     myDirName = "myDir";

     r = mkdir (myDirName);


File: ctalk.info,  Node: modf,  Next: nearbyint,  Prev: mkdir,  Up: C library functions

'modf' Function
---------------

     #include <math.h>

     double dptr;
     Float new x;
     Float new frac;

     x = 2.54;

     frac = modf (x, &dptr);


File: ctalk.info,  Node: nearbyint,  Next: perror,  Prev: modf,  Up: C library functions

'nearbyint' Function
--------------------

     #include <math.h>

     Float new x;
     Float new result;

     x = 2.53;

     result = nearbyint (x);


File: ctalk.info,  Node: perror,  Next: pow,  Prev: nearbyint,  Up: C library functions

'perror' Function
-----------------

     #include <stdio.h>

     String new message;

     message = "Program error";

     perror (message);


File: ctalk.info,  Node: pow,  Next: printf,  Prev: perror,  Up: C library functions

'pow' Function
--------------

     #include <math.h>

     Float new x;
     Float new exp;
     Float new result;

     x = 2.5;
     exp = 2;

     result = pow (x, exp);


File: ctalk.info,  Node: printf,  Next: raise,  Prev: pow,  Up: C library functions

'printf' Function
-----------------

     #include <stdio.h>

     String new message;
     String new fmt;

     printf (fmt, message);


File: ctalk.info,  Node: raise,  Next: rand,  Prev: printf,  Up: C library functions

'raise' Function
----------------

     #include <signal.h>

     Integer new signal;
     Integer new result;

     signal = SIGTERM;

     result = raise (signal);


File: ctalk.info,  Node: rand,  Next: realloc,  Prev: raise,  Up: C library functions

'rand' Function
---------------

     #include <stdlib.h>

     Integer new random;

     random = rand ();


File: ctalk.info,  Node: realloc,  Next: remove,  Prev: rand,  Up: C library functions

'realloc' Function
------------------

     #include <stdlib.h>

     int *intptr;
     Integer new size;

     size = sizeof (int *);

     intptr = (int *)realloc (NULL, size);



File: ctalk.info,  Node: remove,  Next: rename,  Prev: realloc,  Up: C library functions

'remove' Function
-----------------

     #include <stdio.h>

     String new path;
     Integer new result;

     path = ``/home/user'';

     result = remove (path);



File: ctalk.info,  Node: rename,  Next: rindex,  Prev: remove,  Up: C library functions

'rename' Function
-----------------

     #include <stdio.h>

     String new oldPath;
     String new newPath;
     Integer new result;

     oldPath = "/home/user";
     newPath = "/home/joe";

     result = rename (oldPath, newPath);



File: ctalk.info,  Node: rindex,  Next: rint,  Prev: rename,  Up: C library functions

'rindex' Function
-----------------

*Note strrchr::.


File: ctalk.info,  Node: rint,  Next: rmdir,  Prev: rindex,  Up: C library functions

'rint' Function
---------------

     #include <math.h>

     Float new myFloat;
     Float new myIntValue;

     myFloat = 2.54;

     myIntValue = rint (myFloat);



File: ctalk.info,  Node: rmdir,  Next: round,  Prev: rint,  Up: C library functions

'rmdir' Function
----------------

     r = rmdir (dirToRemove);


File: ctalk.info,  Node: round,  Next: scanf,  Prev: rmdir,  Up: C library functions

'round' Function
----------------

     #include <math.h>

     Float new myFloat;
     Float new myIntValue;

     myFloat = 2.54;

     myIntValue = round (myFloat);



File: ctalk.info,  Node: scanf,  Next: sin,  Prev: round,  Up: C library functions

'scanf' Function
----------------

*Note Variable arguments::.


File: ctalk.info,  Node: sin,  Next: sinh,  Prev: scanf,  Up: C library functions

'sin' Function
--------------

     #include <math.h>

     Float new x;
     Float new sinX;

     x = 2.5;

     sinX = sin (x);


File: ctalk.info,  Node: sinh,  Next: snprintf,  Prev: sin,  Up: C library functions

'sinh' Function
---------------

     #include <math.h>

     Float new x;
     Float new sinX;

     x = 2.5;

     sinX = sinh (x);


File: ctalk.info,  Node: snprintf,  Next: sprintf,  Prev: sinh,  Up: C library functions

'snprintf' Function
-------------------

*Note Variable arguments::.


File: ctalk.info,  Node: sprintf,  Next: sqrt,  Prev: snprintf,  Up: C library functions

'sprintf' Function
------------------

*Note Variable arguments::.


File: ctalk.info,  Node: sqrt,  Next: srand,  Prev: sprintf,  Up: C library functions

'sqrt' Function
---------------

     #include <math.h>

     Array instanceMethod printSquareRoot (void) {

       Float new squareRoot;
       WriteFileStream classInit;

       /*
        *  Use Ctalk C API library function calls within a C function.
        */
       squareRoot = sqrt(__ctalk_to_c_double(__ctalk_self_internal ()));
       stdoutStream writeStream squareRoot;

       return NULL;
     }

     int main () {

       Array new floatArray;

       floatArray atPut 0, 1.0;
       floatArray atPut 1, 4.0;
       floatArray atPut 2, 9.0;
       floatArray atPut 3, 16.0;
       floatArray atPut 4, 25.0;

       floatArray map printSquareRoot;

     }


File: ctalk.info,  Node: srand,  Next: sscanf,  Prev: sqrt,  Up: C library functions

'srand' Function
----------------

     #include <stdlib.h>

     Integer new seed;

     seed = 2;

     srand (seed);



File: ctalk.info,  Node: sscanf,  Next: strcat-strcpy,  Prev: srand,  Up: C library functions

'sscanf' Function
-----------------

*Note Variable arguments::.

_Note:_ The C99 standard requires that 'stdin,' 'stdout,' and 'stderr'
should be implemented as macros, which on some systems (notably Solaris)
causes problems with C-to-object translation.  If Ctalk cannot register
these macros as C variables, then either call 'sscanf(3)' C function
with only C variables, or use a method with 'stdoutStream' or
'stderrStream' *Note WriteFileStream::, or 'stdinStream' *Note
ReadFileStream::.


File: ctalk.info,  Node: strcat-strcpy,  Next: strchr,  Prev: sscanf,  Up: C library functions

'strcat,' 'strcasecmp', 'strcmp,' and 'strcpy' Functions
--------------------------------------------------------

The 'strcat(3),' 'strcasecmp(3),' 'strcmp(3),' and 'strcpy(3)' functions
work in most statements.  When necessary, Ctalk uses 'cStrcat',
'cStrcasecmp', 'cStrcmp', and 'cStrcpy' (class 'CFunction').  *Note
CFunction::.


File: ctalk.info,  Node: strchr,  Next: strcoll,  Prev: strcat-strcpy,  Up: C library functions

'strchr' Function
-----------------

     #include <string.h>

     int main () {

       String new s;
       String new result;

       s = "s1";

       if ((result = strchr (s, '1')) == "1") {
         printf ("Pass\n");
       } else {
         printf ("Fail\n");
       }

       exit(0);
     }


File: ctalk.info,  Node: strcoll,  Next: strspn,  Prev: strchr,  Up: C library functions

'strcoll' Function
------------------

     #include <string.h>

     String new s1;
     String new s2;
     Integer new result;

     result = strcoll (s1, s2);


File: ctalk.info,  Node: strspn,  Next: strerror,  Prev: strcoll,  Up: C library functions

'strspn' Function
-----------------


File: ctalk.info,  Node: strerror,  Next: strftime,  Prev: strspn,  Up: C library functions

'strerror' Function
-------------------


File: ctalk.info,  Node: strftime,  Next: strlen,  Prev: strerror,  Up: C library functions

'strftime' Function
-------------------


File: ctalk.info,  Node: strlen,  Next: strncat-strncpy,  Prev: strftime,  Up: C library functions

'strlen' Function
-----------------


File: ctalk.info,  Node: strncat-strncpy,  Next: strpbrk,  Prev: strlen,  Up: C library functions

'strncat,' 'strncmp,' and 'strncpy' Functions
---------------------------------------------

The 'strncat(3),' 'strncasecmp(3),' 'strncmp(3),' and 'strncpy(3)'
functions work in most statements.  When necessary, Ctalk uses
'cStrncat,' 'cStrncasecmp,' 'cStrncmp,' and 'cStrncpy' (class
'CFunction').  *Note CFunction::.


File: ctalk.info,  Node: strpbrk,  Next: strrchr,  Prev: strncat-strncpy,  Up: C library functions

'strpbrk' Function
------------------


File: ctalk.info,  Node: strrchr,  Next: strstr,  Prev: strpbrk,  Up: C library functions

'strrchr' Function
------------------

     #include <string.h>

     String new s1;
     Character new searchChar;
     String new charptr;

     searchChar = '/';
     s1 = "/home/user";

     charptr = strrchr (s1, searchChar);


File: ctalk.info,  Node: strstr,  Next: strtod,  Prev: strrchr,  Up: C library functions

'strstr' Function
-----------------


File: ctalk.info,  Node: strtod,  Next: strtok,  Prev: strstr,  Up: C library functions

'strtod' Function
-----------------


File: ctalk.info,  Node: strtok,  Next: strtoll,  Prev: strtod,  Up: C library functions

'strtok' Function
-----------------


File: ctalk.info,  Node: strtoll,  Next: strxfrm,  Prev: strtok,  Up: C library functions

'strtoll' Function
------------------


File: ctalk.info,  Node: strxfrm,  Next: system,  Prev: strtoll,  Up: C library functions

'strxfrm' Function
------------------


File: ctalk.info,  Node: system,  Next: tan,  Prev: strxfrm,  Up: C library functions

'system' Function
-----------------

     #include <stdlib.h>

     String new commandLine;

     commandLine = "ls -lR";

     system (commandLine);


File: ctalk.info,  Node: tan,  Next: tanh,  Prev: system,  Up: C library functions

'tan' Function
--------------


File: ctalk.info,  Node: tanh,  Next: tmpnam,  Prev: tan,  Up: C library functions

'tanh' Function
---------------


File: ctalk.info,  Node: tmpnam,  Next: tolower,  Prev: tanh,  Up: C library functions

'tmpnam' Function
-----------------


File: ctalk.info,  Node: tolower,  Next: toupper,  Prev: tmpnam,  Up: C library functions

'tolower' Function
------------------

The 'tolower' function may be implemented in a non-portable manner.  Use
the 'toLower' method instead.


File: ctalk.info,  Node: toupper,  Next: trunc,  Prev: tolower,  Up: C library functions

'toupper' Function
------------------

The 'toupper' function may be implemented in a non-portable manner.  Use
the 'toUpper' method instead.


File: ctalk.info,  Node: trunc,  Next: ungetc,  Prev: toupper,  Up: C library functions

'trunc' Function
----------------


File: ctalk.info,  Node: ungetc,  Next: vfprintf,  Prev: trunc,  Up: C library functions

'ungetc' Function
-----------------


File: ctalk.info,  Node: vfprintf,  Next: vfscanf,  Prev: ungetc,  Up: C library functions

'vfprintf' Function
-------------------

This version of Ctalk does not support the 'va_list' data type.  You
should use 'printf(3)' or 'writeStream' (class 'WriteFileStream')
instead.


File: ctalk.info,  Node: vfscanf,  Next: vprintf,  Prev: vfprintf,  Up: C library functions

'vfscanf' Function
------------------

This version of Ctalk does not support the 'va_list' data type.  You
should use 'scanf(3)' instead.  *Note Variable arguments::.


File: ctalk.info,  Node: vprintf,  Next: vscanf,  Prev: vfscanf,  Up: C library functions

'vprintf' Function
------------------

This version of Ctalk does not support the 'va_list' data type.  You
should use 'printf(3)' or 'writeStream' (class 'WriteFileStream')
instead.


File: ctalk.info,  Node: vscanf,  Next: vsnprintf,  Prev: vprintf,  Up: C library functions

'vscanf' Function
-----------------

This version of Ctalk does not support the 'va_list' data type.  You
should use 'scanf(3)' instead.  *Note Variable arguments::.


File: ctalk.info,  Node: vsnprintf,  Next: vsprintf,  Prev: vscanf,  Up: C library functions

'vsnprintf' Function
--------------------

This version of Ctalk does not support the 'va_list' data type.  You
should use 'sprintf(3)' instead.  *Note Variable arguments::.


File: ctalk.info,  Node: vsprintf,  Next: vsscanf,  Prev: vsnprintf,  Up: C library functions

'vsprintf' Function
-------------------

This version of Ctalk does not support the 'va_list' data type.  You
should use 'sprintf(3)' instead.  *Note Variable arguments::.


File: ctalk.info,  Node: vsscanf,  Prev: vsprintf,  Up: C library functions

'vsscanf' Function
------------------

This version of Ctalk does not support the 'va_list' data type.  You
should use 'sprintf(3)' instead.  *Note Variable arguments::.


File: ctalk.info,  Node: GNU tools,  Prev: C library functions,  Up: C

Using GNU Tools with Ctalk
--------------------------

If you want to build Ctalk programs using the GNU configuration tools;
i.e, the './configure,' 'make,' 'make install' sequence of commands, you
need to tell the build tools about Ctalk.

Doing this mostly involves telling the utility 'automake,' which helps
write 'Makefiles' for the 'make' program, how to build a Ctalk source
file into an executable.

The 'make' program allows Makefiles to define rules to build different
types of input files into programs, libraries, and other types of data
files.

In order to distinguish a Ctalk file, we give it the file extension
'.ca'.  This lets the build tools know that the Ctalk program isn't a
standard C input file.

Then, in 'Makefile.am' (consult the 'automake' manual if you're not
certain what this is), you can define a rule to build a '.ca' file into
an '.o' object file.


     SUFFIXES=.ca .o

     .ca.o:
     	$(top_builddir)/src/ctalk -I $(top_builddir)/classes $< \
     	  -o `basename $ .o`.i ; \
     	$(CC) -c $(AM_CFLAGS) $(AM_CPPFLAGS) $(DEFS) -o $ `basename $< .ca`.i


Then, add another line to link the object file into a program.


     methods$(EXEEXT) : methods.o
     	$(CC) methods.o $(AM_LDFLAGS) $(LDFLAGS) $(LIBS) -o methods$(EXEEXT)


Note that this example comes from the 'methods' program in the Ctalk
distribution, where, "methods," is the canonical name of the output
file, as defined in the 'bin_PROGRAMS' macro.  That allows 'make' to
install the program normally when you type, 'make install.'

If you're using Ctalk for another package, you'll almost certainly want
to change the paths to something that uses an already-installed Ctalk.
In that case, 'Makefile.am' might contain lines like these.


     SUFFIXES=.ca .o

     .ca.o:
     	/usr/local/bin/ctalk -I /usr/local/include/classes $< \
     	  -o `basename $ .o`.i ; \
     	$(CC) -c $(AM_CFLAGS) $(AM_CPPFLAGS) $(DEFS) -o $ `basename $< .ca`.i


Cleaning Up Extra Files
.......................

Note that the 'basename' command in these examples handles the
translation of the 'make' targets into an intermediate Ctalk file.

This way 'make' doesn't need to worry about any intermediate files,
except that the 'Makefile' should clean them up.

So to define rules to clean up the extra files after the build, include
'make' targets like these in 'Makefile.am.'


     clean-local:
     	rm -f *.i

     distclean-local:
     	rm -f *.i



Running Ctalk Utilities in an Emacs Window
..........................................

The 'doc/' subdirectory of the Ctalk source code distribution contains
the Emacs Lisp programs 'classes.el', 'methods-brief.el', and
'methods-full.el'.  They define simple Emacs Lisp functions that let you
capture the output of the Ctalk utilities in an Emacs window.

The documentation file, 'ctalktools.info' contains descriptions of these
functions, and the files also contain instructions to install and use
them.


File: ctalk.info,  Node: Copying,  Next: GNU Free Documentation License,  Prev: C,  Up: Top

Copying and Distributing Ctalk
==============================

Ctalk is free software.  You can copy, distribute, and modify Ctalk
under the terms of the GNU General Public License, Version 3 (see,
'COPYING', in the Ctalk distribution).  You can also distribute
executable programs which link to the 'ctalk' run time libraries under
the terms of the GNU Lesser General Public License, Version 3
('COPYING.LIB' in the Ctalk distribution).


File: ctalk.info,  Node: GNU Free Documentation License,  Next: Index,  Prev: Copying,  Up: Top

GNU Free Documentation License
==============================


                             Version 1.1, March 2000
          Copyright (C) 2000  Free Software Foundation, Inc.
          59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

          Everyone is permitted to copy and distribute verbatim copies
          of this license document, but changing it is not allowed.



       0. PREAMBLE

          The purpose of this License is to make a manual, textbook, or other
          written document "free" in the sense of freedom: to assure everyone
          the effective freedom to copy and redistribute it, with or without
          modifying it, either commercially or noncommercially.  Secondarily,
          this License preserves for the author and publisher a way to get
          credit for their work, while not being considered responsible for
          modifications made by others.

          This License is a kind of "copyleft", which means that derivative
          works of the document must themselves be free in the same sense.
          It complements the GNU General Public License, which is a copyleft
          license designed for free software.

          We have designed this License in order to use it for manuals for
          free software, because free software needs free documentation: a
          free program should come with manuals providing the same freedoms
          that the software does.  But this License is not limited to
          software manuals; it can be used for any textual work, regardless
          of subject matter or whether it is published as a printed book.
          We recommend this License principally for works whose purpose is
          instruction or reference.


       1. APPLICABILITY AND DEFINITIONS

          This License applies to any manual or other work that contains a
          notice placed by the copyright holder saying it can be distributed
          under the terms of this License.  The "Document", below, refers to
          any such manual or work.  Any member of the public is a licensee,
          and is addressed as "you."

          A "Modified Version" of the Document means any work containing the
          Document or a portion of it, either copied verbatim, or with
          modifications and/or translated into another language.

          A "Secondary Section" is a named appendix or a front-matter
          section of the Document that deals exclusively with the
          relationship of the publishers or authors of the Document to the
          Document's overall subject (or to related matters) and contains
          nothing that could fall directly within that overall subject.
          (For example, if the Document is in part a textbook of
          mathematics, a Secondary Section may not explain any mathematics.)
          The relationship could be a matter of historical connection with
          the subject or with related matters, or of legal, commercial,
          philosophical, ethical or political position regarding them.

          The "Invariant Sections" are certain Secondary Sections whose
          titles are designated, as being those of Invariant Sections, in
          the notice that says that the Document is released under this
          License.

          The "Cover Texts" are certain short passages of text that are
          listed, as Front-Cover Texts or Back-Cover Texts, in the notice
          that says that the Document is released under this License.

          A "Transparent" copy of the Document means a machine-readable copy,
          represented in a format whose specification is available to the
          general public, whose contents can be viewed and edited directly
          and straightforwardly with generic text editors or (for images
          composed of pixels) generic paint programs or (for drawings) some
          widely available drawing editor, and that is suitable for input to
          text formatters or for automatic translation to a variety of
          formats suitable for input to text formatters.  A copy made in an
          otherwise Transparent file format whose markup has been designed
          to thwart or discourage subsequent modification by readers is not
          Transparent.  A copy that is not "Transparent" is called "Opaque."

          Examples of suitable formats for Transparent copies include plain
          ASCII without markup, Texinfo input format, LaTeX input format,
          SGML or XML using a publicly available DTD, and
          standard-conforming simple HTML designed for human modification.
          Opaque formats include PostScript, PDF, proprietary formats that
          can be read and edited only by proprietary word processors, SGML
          or XML for which the DTD and/or processing tools are not generally
          available, and the machine-generated HTML produced by some word
          processors for output purposes only.

          The "Title Page" means, for a printed book, the title page itself,
          plus such following pages as are needed to hold, legibly, the
          material this License requires to appear in the title page.  For
          works in formats which do not have any title page as such, "Title
          Page" means the text near the most prominent appearance of the
          work's title, preceding the beginning of the body of the text.


       2. VERBATIM COPYING

          You may copy and distribute the Document in any medium, either
          commercially or noncommercially, provided that this License, the
          copyright notices, and the license notice saying this License
          applies to the Document are reproduced in all copies, and that you
          add no other conditions whatsoever to those of this License.  You
          may not use technical measures to obstruct or control the reading
          or further copying of the copies you make or distribute.  However,
          you may accept compensation in exchange for copies.  If you
          distribute a large enough number of copies you must also follow
          the conditions in section 3.

          You may also lend copies, under the same conditions stated above,
          and you may publicly display copies.


       3. COPYING IN QUANTITY

          If you publish printed copies of the Document numbering more than
          100, and the Document's license notice requires Cover Texts, you
          must enclose the copies in covers that carry, clearly and legibly,
          all these Cover Texts: Front-Cover Texts on the front cover, and
          Back-Cover Texts on the back cover.  Both covers must also clearly
          and legibly identify you as the publisher of these copies.  The
          front cover must present the full title with all words of the
          title equally prominent and visible.  You may add other material
          on the covers in addition.  Copying with changes limited to the
          covers, as long as they preserve the title of the Document and
          satisfy these conditions, can be treated as verbatim copying in
          other respects.

          If the required texts for either cover are too voluminous to fit
          legibly, you should put the first ones listed (as many as fit
          reasonably) on the actual cover, and continue the rest onto
          adjacent pages.

          If you publish or distribute Opaque copies of the Document
          numbering more than 100, you must either include a
          machine-readable Transparent copy along with each Opaque copy, or
          state in or with each Opaque copy a publicly-accessible
          computer-network location containing a complete Transparent copy
          of the Document, free of added material, which the general
          network-using public has access to download anonymously at no
          charge using public-standard network protocols.  If you use the
          latter option, you must take reasonably prudent steps, when you
          begin distribution of Opaque copies in quantity, to ensure that
          this Transparent copy will remain thus accessible at the stated
          location until at least one year after the last time you
          distribute an Opaque copy (directly or through your agents or
          retailers) of that edition to the public.

          It is requested, but not required, that you contact the authors of
          the Document well before redistributing any large number of
          copies, to give them a chance to provide you with an updated
          version of the Document.


       4. MODIFICATIONS

          You may copy and distribute a Modified Version of the Document
          under the conditions of sections 2 and 3 above, provided that you
          release the Modified Version under precisely this License, with
          the Modified Version filling the role of the Document, thus
          licensing distribution and modification of the Modified Version to
          whoever possesses a copy of it.  In addition, you must do these
          things in the Modified Version:

          A. Use in the Title Page (and on the covers, if any) a title
          distinct    from that of the Document, and from those of previous
          versions    (which should, if there were any, be listed in the
          History section    of the Document).  You may use the same title
          as a previous version    if the original publisher of that version
          gives permission.
          B. List on the Title Page, as authors, one or more persons or
          entities    responsible for authorship of the modifications in the
          Modified    Version, together with at least five of the principal
          authors of the    Document (all of its principal authors, if it
          has less than five).
          C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.
          D. Preserve all the copyright notices of the Document.
          E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.
          F. Include, immediately after the copyright notices, a license
          notice    giving the public permission to use the Modified Version
          under the    terms of this License, in the form shown in the
          Addendum below.
          G. Preserve in that license notice the full lists of Invariant
          Sections    and required Cover Texts given in the Document's
          license notice.
          H. Include an unaltered copy of this License.
          I. Preserve the section entitled "History", and its title, and add
          to    it an item stating at least the title, year, new authors, and
            publisher of the Modified Version as given on the Title Page.
          If    there is no section entitled "History" in the Document,
          create one    stating the title, year, authors, and publisher of
          the Document as    given on its Title Page, then add an item
          describing the Modified    Version as stated in the previous
          sentence.
          J. Preserve the network location, if any, given in the Document for
            public access to a Transparent copy of the Document, and
          likewise    the network locations given in the Document for
          previous versions    it was based on.  These may be placed in the
          "History" section.     You may omit a network location for a work
          that was published at    least four years before the Document
          itself, or if the original    publisher of the version it refers
          to gives permission.
          K. In any section entitled "Acknowledgements" or "Dedications",
          preserve the section's title, and preserve in the section all the
           substance and tone of each of the contributor acknowledgements
          and/or dedications given therein.
          L. Preserve all the Invariant Sections of the Document,
          unaltered in their text and in their titles.  Section numbers
          or the equivalent are not considered part of the section titles.
          M. Delete any section entitled "Endorsements."  Such a section
          may not be included in the Modified Version.
          N. Do not retitle any existing section as "Endorsements"    or to
          conflict in title with any Invariant Section.

          If the Modified Version includes new front-matter sections or
          appendices that qualify as Secondary Sections and contain no
          material copied from the Document, you may at your option
          designate some or all of these sections as invariant.  To do this,
          add their titles to the list of Invariant Sections in the Modified
          Version's license notice.  These titles must be distinct from any
          other section titles.

          You may add a section entitled "Endorsements", provided it contains
          nothing but endorsements of your Modified Version by various
          parties-for example, statements of peer review or that the text has
          been approved by an organization as the authoritative definition
          of a standard.

          You may add a passage of up to five words as a Front-Cover Text,
          and a passage of up to 25 words as a Back-Cover Text, to the end
          of the list of Cover Texts in the Modified Version.  Only one
          passage of Front-Cover Text and one of Back-Cover Text may be
          added by (or through arrangements made by) any one entity.  If the
          Document already includes a cover text for the same cover,
          previously added by you or by arrangement made by the same entity
          you are acting on behalf of, you may not add another; but you may
          replace the old one, on explicit permission from the previous
          publisher that added the old one.

          The author(s) and publisher(s) of the Document do not by this
          License give permission to use their names for publicity for or to
          assert or imply endorsement of any Modified Version.


       5. COMBINING DOCUMENTS

          You may combine the Document with other documents released under
          this License, under the terms defined in section 4 above for
          modified versions, provided that you include in the combination
          all of the Invariant Sections of all of the original documents,
          unmodified, and list them all as Invariant Sections of your
          combined work in its license notice.

          The combined work need only contain one copy of this License, and
          multiple identical Invariant Sections may be replaced with a single
          copy.  If there are multiple Invariant Sections with the same name
          but different contents, make the title of each such section unique
          by adding at the end of it, in parentheses, the name of the
          original author or publisher of that section if known, or else a
          unique number.  Make the same adjustment to the section titles in
          the list of Invariant Sections in the license notice of the
          combined work.

          In the combination, you must combine any sections entitled
          "History" in the various original documents, forming one section
          entitled "History"; likewise combine any sections entitled
          "Acknowledgements", and any sections entitled "Dedications."  You
          must delete all sections entitled "Endorsements."


       6. COLLECTIONS OF DOCUMENTS

          You may make a collection consisting of the Document and other
          documents released under this License, and replace the individual
          copies of this License in the various documents with a single copy
          that is included in the collection, provided that you follow the
          rules of this License for verbatim copying of each of the
          documents in all other respects.

          You may extract a single document from such a collection, and
          distribute it individually under this License, provided you insert
          a copy of this License into the extracted document, and follow
          this License in all other respects regarding verbatim copying of
          that document.


       7. AGGREGATION WITH INDEPENDENT WORKS

          A compilation of the Document or its derivatives with other
          separate and independent documents or works, in or on a volume of
          a storage or distribution medium, does not as a whole count as a
          Modified Version of the Document, provided no compilation
          copyright is claimed for the compilation.  Such a compilation is
          called an "aggregate", and this License does not apply to the
          other self-contained works thus compiled with the Document, on
          account of their being thus compiled, if they are not themselves
          derivative works of the Document.

          If the Cover Text requirement of section 3 is applicable to these
          copies of the Document, then if the Document is less than one
          quarter of the entire aggregate, the Document's Cover Texts may be
          placed on covers that surround only the Document within the
          aggregate.  Otherwise they must appear on covers around the whole
          aggregate.


       8. TRANSLATION

          Translation is considered a kind of modification, so you may
          distribute translations of the Document under the terms of section
          4.  Replacing Invariant Sections with translations requires special
          permission from their copyright holders, but you may include
          translations of some or all Invariant Sections in addition to the
          original versions of these Invariant Sections.  You may include a
          translation of this License provided that you also include the
          original English version of this License.  In case of a
          disagreement between the translation and the original English
          version of this License, the original English version will prevail.


       9. TERMINATION

          You may not copy, modify, sublicense, or distribute the Document
          except as expressly provided for under this License.  Any other
          attempt to copy, modify, sublicense or distribute the Document is
          void, and will automatically terminate your rights under this
          License.  However, parties who have received copies, or rights,
          from you under this License will not have their licenses
          terminated so long as such parties remain in full compliance.


      10. FUTURE REVISIONS OF THIS LICENSE

          The Free Software Foundation may publish new, revised versions of
          the GNU Free Documentation License from time to time.  Such new
          versions will be similar in spirit to the present version, but may
          differ in detail to address new problems or concerns.  See
          http://www.gnu.org/copyleft/.

          Each version of the License is given a distinguishing version
          number.  If the Document specifies that a particular numbered
          version of this License "or any later version" applies to it, you
          have the option of following the terms and conditions either of
          that specified version or of any later version that has been
          published (not as a draft) by the Free Software Foundation.  If
          the Document does not specify a version number of this License,
          you may choose any version ever published (not as a draft) by the
          Free Software Foundation.


     ADDENDUM: How to use this License for your documents

        To use this License in a document you have written, include a copy of
     the License in the document and put the following copyright and license
     notices just after the title page:

          Copyright (C)  YEAR  YOUR NAME.
          Permission is granted to copy, distribute and/or modify this document
          under the terms of the GNU Free Documentation License, Version 1.1
          or any later version published by the Free Software Foundation;
          with the Invariant Sections being LIST THEIR TITLES, with the
          Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
          A copy of the license is included in the section entitled "GNU
          Free Documentation License."

        If you have no Invariant Sections, write "with no Invariant Sections"
     instead of saying which ones are invariant.  If you have no Front-Cover
     Texts, write "no Front-Cover Texts" instead of "Front-Cover Texts being
     LIST"; likewise for Back-Cover Texts.

        If your document contains nontrivial examples of program code, we
     recommend releasing these examples in parallel under your choice of
     free software license, such as the GNU General Public License, to
     permit their use in free software.


