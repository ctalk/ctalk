\input texinfo @c -*-texinfo-*-
@c $Id: ctalk.texi,v 1.130 2020/04/03 20:47:05 rkiesling Exp $
@c %**start of header  
@setfilename ctalk.info
@settitle Ctalk
@setchapternewpage odd
@paragraphindent 0
@c %**end of header

@set VERSION 0.0.66

@macro idxfncite{fnname}
@cite{\fnname\} C function
@end macro

@macro idxclscite{fnname}
(@code{\fnname\} class)
@end macro

@macro mnm{methodname}
@code{\methodname\}
@end macro

@macro flnm{filename}
@code{\filename\}
@end macro

@macro idxlibfn{fnname}
@cindex @code{\fnname\ ()} function
@end macro

@ifinfo

@dircategory Ctalk
@direntry
* ctalk: (ctalk).	The Ctalk language reference manual.
@end direntry

This file documents Ctalk version @value{VERSION}.

Copyright @copyright{} 2007-2015 Robert Kiesling

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled,
``GNU Free Documentation License.''

@end ifinfo

@iftex

@titlepage
@title Ctalk Language Reference
@subtitle Object Oriented Extensions for C
@author Robert Kiesling

@page
@vskip 0pt plus 1filll

Ctalk Language Reference.  This manual describes Ctalk, version
@value{VERSION}.

Copyright @copyright{} 2007-2015, Robert Kiesling

Permission is granted to distribute this document
under the terms of the GNU Free Documentation
License. @xref{GNU Free Documentation License}.

@end titlepage

@contents

@end iftex

@ifinfo
@node Top, , (dir), (dir)
@end ifinfo
@ifhtml
@node Top, , Top, 
@end ifhtml

@c title, next, previous, up
@iftex
@chapter Introduction to Ctalk
@end iftex
@ifnottex
@chapheading Ctalk Language Reference

This document describes the Ctalk programming language, version
@value{VERSION}.

@end ifnottex

@iftex
Ctalk provides an extensions to the C programming language that allow
programmers to use object oriented language features, like class
objects, methods, operator overloading, and inheritance, in C
programs.  This manual describes Ctalk, version @value{VERSION}.

If you are not familiar with object oriented programming concepts, you
might like to read an introductory text on the subject.  Using Ctalk
requires that you are familiar with the concepts of object oriented
programming, as well as the C language.  This manual uses object
oriented programming terms extensively.

The next chapter describes how to use Ctalk to create programs and use
the Ctalk compiler's command line interface.  The following chapters
describe the class hierarchy, method application programming
interface, the interface with C and its run-time libraries, and
finally, some simple example programs.

@section C Language Conformance
@cindex C language conformance

Ctalk conforms as closely as possible to the C language defined by
@cite{International Standard ISO/IEC 9899}, commonly known as C99.

@section Compiler Compatibility
@cindex Compiler compatibility

Ctalk is compatible with GNU GCC, version 2.95 and later.  Ctalk
recognizes GCC extensions like function and data attributes, and the
preprocessor can use directives like @code{#include_next}.  Ctalk
recognizes but does not process deprecated language extensions and
preprocessor directives like @code{#sccs} and @code{#unassert}.

To adapt Ctalk to another compiler, you may need to provide
compiler-specific definitions.  You will also need to add your
compiler's definition file and initialization code, if necessary, to
the file, @file{src/ccompat.c}, which contains the
@code{COMPAT_INCLUDE} definition and functions for specific compilers.

The @command{ctpp} preprocessor also contains system-specific 
definitions.  Consult its documentation for details.

@chapheading Some Document Conventions

When the term, ``Ctalk,'' appears in this manual, it refers to the
programming language, and when @command{ctalk} appears, it
refers to the Ctalk compiler and libraries.

@table @code
@item identifier  
Names of classes, variables, methods and messages, file names, 
and source code examples appear in monospaced type.
@end table
@table @var
@item variable
Metasyntactic variables and citations appear in italic or oblique
type.
@end table
@end iftex

@menu
* Invoking::                          Command line options.
* Classes::                           The Ctalk class library.
* Methods::                           How to use and implement methods.
* C::                                 C language implementation.
* Copying::                           Ctalk is free software.
* GNU Free Documentation License::    Copying and distributing this manual.
* Index::
@end menu

@node Invoking, Classes, Top, Top
@iftex
@chapter Using Ctalk
@end iftex
@ifnottex
@heading Invoking Ctalk
@end ifnottex
@cindex Invoking @command{ctalk}

Ctalk has two parts: a preprocessor and interpreter that translates
Ctalk code into C, which a compiler can use to create an executable
program, and a run-time library, which the compiler links with the
executable.

@cindex @command{ctpp} preprocessor
Ctalk has its own C99 compatible preprocessor, @command{ctpp,}
which is described in its Texinfo manual, @flnm{ctpp.info}.

@cindex @command{ctalk} command
To use @command{ctalk,} you must provide at least the name of the
input file.  Normally, you also provide the name of the output file
with the @samp{-o} option.  If you use the conventions followed by GNU
C, the output file is normally the base name of the input file with
the extension @samp{.i}, as in this example.

@example
$ ctalk myprog.c -o myprog.i
@end example

The @command{ctalk} program preprocesses @flnm{myprog.c} and
translates it into standard C.  After @command{ctalk} has finished,
you can compile and link the output of @command{ctalk} to produce an
executable program.

@example
$ gcc myprog.i -o myprog -lctalk
@end example

@cindex @command{ctcc} command
More conveniently, the @command{ctcc} command combines these
operations, with the appropriate command line options, to build an
executable program.
@example
$ ctcc myprog.c -o myprog
@end example

@cindex @command{ctdb} command
@cindex @command{gdb} command
If you need to build a program for debugging, the @code{ctdb} command
builds executables that you can debug with @code{gdb}. @xref{Debugging}.

For more information, refer to the @cite{ctalk(1),} 
@cite{ctcc(1),} @cite{ctdb(1),} @cite{gcc(1),} and @cite{gdb(1)}
manual pages.

@iftex
@section Command Line Options
@end iftex
@ifnottex
@heading Command Line Options
@end ifnottex
@cindex Command line options

@table @code

@item --clearpreload 
Clear preloaded methods so they can be rewritten.

@item -E
Preprocess the input and exit.

@item -h, --help
Print a help message and exit.

@item -I @var{dir}
Add @var{dir} to the @command{ctalk} include search path.

@item --keeppragmas
Write pragmas untranslated to the output.

@item --nolibinc
Do not include Ctalk's system headers in the output.

@item --nopreload
Do not use preloaded methods.

@item -o @var{file}
Write the @command{ctalk} output to @var{file.}

@item --printlibdirs
Print the library directories and exit.

@item --printtemplates
Print the templates that Ctalk loads and caches (but does not
necessarily send to the output).

@item --progress
Print dots to indicate Ctalk's progress.

@item -P
Do not output line number information.

@item -s @var{dir}
Add @var{dir} to the compiler system include search path.

@item -V
Print the Ctalk version number and exit.

@item -v
@item --verbose
Print verbose warnings.  This option also sets the
@code{--warnextension}, @code{--warnduplicatenames}
and @code{--warnunresolvedselexpr} options.

@item --warnclasslibs
Print the names of class libraries as they are loaded.

@item --warnduplicatenames
Print a warning when an object duplicates a C variable name.  Because
of the way Ctalk's just-in-time interpreter works, the front end
prints warnings of any duplicate names.  The variables and objects
need not be in the same scope.  Usually, though, Ctalk can make an
intelligent decision about how to process objects and variables with
duplicate names.  This option does not affect errors caused by duplicate
symbols or shadowing.

@item --warnextension
Print warnings for some compiler extensions.

@item --warnunresolvedselfexpr
Prints warnings if @code{self} appears in an argument block
with either an instance variable label or an unresolvable method
label following it.  In expressions like these, the class of each
element of a collection, when represented by @code{self} within
the argument block, often can't be determined until run time.

You can specify a class for @code{self} by placing a class cast
expression (described in the section @cite{Class casting}) before
the @code{self} keyword. @xref{Class casting}.

For example, if a program contains an expression like this:

@example

List new textLines;

   @emph{...The program adds items to textLines...}

textLines map @{

  if (self length > 0) @{

    @emph{...do something...}

  @}

@}

@end example

Then the expression, @code{self length} would generate a warning due to the
label, @code{length,} because the class membership of, @code{self,} which
represents each successive element of the, @code{textLines,} list,
normally isn't determined until run time, and so the receiver class of
@code{length} is also undetermined.

However, if you know that @code{textLines} contains only @code{String}
objects, then you can add a class cast expression in the argument
block.

@example

textLines map @{

  if ((String *)self length > 0) @{

    @emph{...do something...}

  @}

@}

@end example

This tells the program to treat @code{length's} receiver, @code{self,}
as a String object, so it's possible to determine, before the program
is actually executed, whether, @code{self length,} is a valid
expression.

@end table

@node Classes, Methods, Invoking, Top
@iftex
@chapter Classes
@end iftex
@ifnottex
@heading Classes
@end ifnottex
@cindex Classes

Class library files contain class and method definitions and are
located in the @flnm{classes} subdirectory.  After installation, the
libraries are in a @flnm{ctalk} include subdirectory defined by the
macro @var{CLASSLIBDIR} when the program is built.

@iftex
@section Class Hierarchy
@example
Object
 Bitmap
  DisplayFont
   X11Font
     X11Cursor
   X11FreeTypeFont
  X11Bitmap
 Boolean
 Collection
  Array
  List
   AssociativeArray
   SortedList
  Stream
   FileStream
    DirectoryStream
    ReadFileStream
    WriteFileStream
   TerminalStream
    ANSITerminalStream
    Win32TerminalStream
    X11TerminalStream
   NetworkStream
    TCPIPNetworkStream
     TCPIPNetworkStreamReader
     TCPIPNetworkStreamWriter
    TCPIPV6NetworkStream
     TCPIPV6NetworkStreamReader
     TCPIPV6NetworkStreamWriter
    UNIXNetworkStream
     UNIXNetworkStreamReader
     UNIXNetworkStreamWriter
 TreeNode
 Event
  Application
   ClassLibraryTree
   GLUTApplication
   ObjectInspector
   LibrarySearch
  Exception
   SystemErrnoException
  InputEvent
  SignalEvent
   SignalHandler
 Expr
  CFunction
 Magnitude
  Character
   String
  Float
  Integer
   CTime
     CalendarTime
  LongInteger
  Pen
  Point
   Line
    Rectangle
   Circle
 Method
 Pane
  ANSITerminalPane
   ANSIWidgetPane
    ANSIButtonPane
    ANSILabelPane
    ANSIListBoxPane
    ANSIMessageBoxPane
    ANSIProgressBarPane
    ANSIScrollingListBoxPane
    ANSIScrollPane
    ANSITextBoxPane
    ANSITextEntryPane
    ANSIYesNoBoxPane
  X11Pane
   GLXCanvasPane
   X11PaneDispatcher
    X11CanvasPane
     X11ButtonPane
     X11LabelPane
     X11MessageBoxPane
     X11ScrollBarPane
    X11TextPane
     X11TextEditorPane
 Symbol
  Key
  Vector
@end example
@end iftex
@ifnottex
@menu
* Object::
*  Bitmap::
*   DisplayFont::
*    X11Font::
*      X11Cursor::
*    X11FreeTypeFont::
*   X11Bitmap::
*  Boolean::
*  Collection::
*   Array::
*   List::
*    AssociativeArray::
*    SortedList::
*   Stream::
*    FileStream::
*     DirectoryStream::
*     ReadFileStream::
*     WriteFileStream::
*    TerminalStream::
*     ANSITerminalStream::
*     Win32TerminalStream::
*     X11TerminalStream::
*    NetworkStream::
*     TCPIPNetworkStream::
*      TCPIPNetworkStreamReader::
*      TCPIPNetworkStreamWriter::
*     TCPIPV6NetworkStream::
*      TCPIPV6NetworkStreamReader::
*      TCPIPV6NetworkStreamWriter::
*     UNIXNetworkStream::
*      UNIXNetworkStreamReader::
*      UNIXNetworkStreamWriter::
*  TreeNode::
*  Event::
*   Application::
*    ClassLibraryTree::
*    GLUTApplication::
*    ObjectInspector::
*    LibrarySearch::
*   Exception::
*    SystemErrnoException::
*   InputEvent::
*   SignalEvent::
*    SignalHandler::
*  Expr::
*   CFunction::
*  Magnitude::
*   Character::
*    String::
*   Float::
*   Integer::
*    CTime::
*      CalendarTime::
*   LongInteger::
*   Pen::
*   Point::
*    Line::
*     Rectangle::
*    Circle::
*  Method::
*  Pane::
*   ANSITerminalPane::
*    ANSIWidgetPane::
*     ANSIButtonPane::
*     ANSILabelPane::
*     ANSIListBoxPane::
*     ANSIMessageBoxPane::
*     ANSIProgressBarPane::
*     ANSIScrollingListBoxPane::
*     ANSIScrollPane::
*     ANSITextBoxPane::
*     ANSITextEntryPane::
*     ANSIYesNoBoxPane::
*   X11Pane::
*    GLXCanvasPane::
*    X11PaneDispatcher::
*     X11CanvasPane::
*      X11ButtonPane::
*      X11LabelPane::
*      X11MessageBoxPane::
*      X11ScrollBarPane::
*     X11TextPane::
*      X11TextEditorPane::
*  Symbol::
*   Key::
*   Vector::
@end menu
@end ifnottex

@c CLASS-DOC-START-COOKIE ***
@node Object, Bitmap, , Classes

@iftex
@section @code{Object} class
@end iftex
@ifnottex
@subheading @code{Object} Class
@end ifnottex

@cindex @code{Object} class

Ctalk defines the @code{Object} class by default at run time.  All
other classes are subclasses of @code{Object}.

@subsubheading Instance Variables

@table @code

@cindex @code{value} instance variable @idxclscite{Object}

@item value
The value of the object.  For classes that correspond to the C data
types: @code{Character}, @code{Float}, @code{Integer},
@code{LongInteger}, and @code{String}, ctalk formats the value as it
would appear as if output by the C @code{printf} function.

When you use one of these classes in a C expression, ctalk translates
the object's value to its C data type.

Other classes may define @code{value} to return class specific data.

@anchor{NullObjects}
@subsubheading Null Objects
@cindex STR_IS_NULL macro
@cindex Null objects
To help make Ctalk compatible with C, Ctalk defines the macro
STR_IS_NULL, which checks whether the object's value evaluates to
false in C.  That means that objects that have the value
@samp{(null)}, are an empty string, or if the object's value is a NULL
pointer, all evaluate similarly.  The STR_IS_NULL macro is defined in
the include file @flnm{ctalkdefs.h}, so to use it, add the following
line at the start of a class library.

@example

#include <ctalk/ctalkdefs.h>

@end example

Ctalk also assigns an object the value of @samp{(null)} when an object
is created or when Ctalk encounters a C NULL in an expression (which
is a macro that expands to @samp{((void *)0)}).

@end table

@subsubheading Instance Methods

@table @code

@cindex @mnm{!} instance method @idxclscite{Object}
@item @mnm{!} (@code{void})
Overloads the @samp{!} prefix operator.

@cindex @mnm{!=} instance method @idxclscite{Object}
@item @mnm{!=} (@code{Object} @var{arg})
Returns a @code{Boolean} value of False if the receiver and the
argument are the same object, True otherwise.  Also returns False if
the receiver and argument's values both evaluate to False.

@cindex @mnm{&} instance method @idxclscite{Object}
@item @mnm{&} (@code{void})
When used to overload C's ``address of'' (@samp{&}) operator, is
synonymous with the @mnm{addressOf} method, below.

@cindex @mnm{->} instance method @idxclscite{Object}
@item @mnm{->} (@code{String} @var{member_name})
Given the name of an a C @code{OBJECT *} member name, like
@code{__o_name}, @code{__o_classname}, @code{__o_class} and
so on, return a @code{String,} @code{Integer,} or
@code{Symbol} with the value of that member. @xref{OBJECT
typedef}.  

The class of the returned object depends on which OBJECT * is
selected.  Some of the results are returned as references contained in
Symbol objects, which avoids unexpectedly changing the target object.

@smallexample
OBJECT Member        Expression                  Class of Result Object
-------------        ----------                  ----------------------
__o_name             obj -> __o_name             String
__o_classname        obj -> __o_classname        String
__o_superclassname   obj -> __o_superclassname   String
__o_value            obj -> __o_value            String
__o_class            obj -> __o_class            <obj's> class
__o_superclass       obj -> __o_superclass       <obj's> superclass
instancevars         obj -> instancevars         Symbol 
classvars            obj -> classvars            <obj's> class
__o_p_obj            obj -> __o_p_obj            <obj's> parent's class
scope                obj -> scope                Integer
attrs                obj -> attrs                Integer
nrefs                obj -> nrefs                Integer
@end smallexample

@cindex @code{OBJECT_IS_DEREF_RESULT} attribute;
The method sets the OBJECT_IS_DEREF_RESULT attribute on objects that
the method creates.

The result of retrieving an object's instance or class variables
depends on the object.  If the object is not a class object, then the
@code{classvars} member will be NULL.  The class of an instance
variable is the parent object, so the Ctalk library returns the
address of the first instance variable.  If you want to check each
variable, it is much easier to use the methods
@mnm{mapInstanceVariables} or @mnm{mapClassVariables}, below.

@b{Examples}

@example

/* Set a Symbol object and an Object instance to
   another object's class, and display the classes'
   name. */
int main () @{

  String new myObject;
  Symbol new optr;
  Object new classObj;
  
  myObject = "String"; /*Needed by classObject, below.*/

  printf ("%p\n", myObject -> __o_class);
  printf ("%s\n", myObject -> __o_class -> __o_name);

  *optr = myObject -> __o_class;
  printf ("%p\n", (*optr) -> __o_class);
  printf ("%s\n", (*optr) -> __o_class -> __o_name);

  classObj = (*optr) classObject;
  printf ("%p\n", classObj);
  printf ("%s\n", classObj -> __o_name);

  classObj = myObject classObject;
  printf ("%p\n", classObj);
  printf ("%s\n", classObj -> __o_name);

@}

/* To print an object's value. */
int main () @{

  String new s;
 
  s = "StringValue";
 
  printf ("%s\n", s -> __o_value);

@}

/* To save an object's scope to an Integer object, and
   print them. */
int main () @{

  String new s;
  Integer new scopeInt;
  

  scopeInt = s -> scope;

  printf ("%d == %d\n", s -> scope, scopeInt);

@}


/* To save an object's attributes to an Integer and
   print them. */

int main () @{

  Integer new attrsInt;
  List new l;
  String new member1;
  String new member2;
  

  l = member1, member2;

  /* Check for an OBJECT_IS_MEMBER_OF_PARENT_COLLECTION attribute
     (currently its definition is (1 << 7), or 128), which is set
     in each of the list's Key objects. (The '->' operator in the
     expressions has a higher precedence than '*', so parentheses
     are necessary.) */
  attrsInt = (*l) -> attrs;

  printf ("%d == %d\n", (*l) -> attrs, attrsInt);
@}


@end example

@emph{Note:}  The use of @code{__o_classname} and
@code{__o_superclassname} as separate object member is
being superceded by the @code{CLASSNAME} and @code{SUPERCLASSNAME}
definitions.  The @mnm{->} method recognizes both the old and
new names, but if @code{->} is used with an @code{OBJECT *}
as a C operator, then the program must use the @code{CLASSNAME}
or @code{SUPERCLASSNAME} macros. @xref{CLASSNAMEMacro}. 

@cindex @mnm{=} instance method @idxclscite{Object}
@item @mnm{=} (@code{Object} @var{new_object})
A basic assignment method.  Assigns @var{new_object} so that
the receiver label can refer to it.

@cindex @mnm{==} instance method @idxclscite{Object}
@item @mnm{==} (@code{Object} @var{arg})
Returns a @code{Boolean} value of True if the receiver and the
argument are the same object, False otherwise.

As a special case, the method returns True if the receiver and
argument's values evaluate to a C NULL.  Refer to the description
of null objects above. @xref{NullObjects}.

@cindex @mnm{addInstanceVariable} instance method @idxclscite{Object}
@item @mnm{addInstanceVariable} (@code{char *}@var{name}, @code{OBJECT *}@var{value})
Add instance variable @var{name} with @var{value} to the receiver.

@cindex @mnm{addressOf} instance method @idxclscite{Object}
@item @mnm{addressOf} (@code{void})
Return a @code{Symbol} that contains the address of the receiver.
This method is functionally equivalent to the C language @samp{&}
operator.

@cindex @mnm{asFloat} instance method @idxclscite{Object}
@item @mnm{asFloat} (@code{void})
Return a @code{Float} object with the value of the receiver.

@cindex @mnm{asString} instance method @idxclscite{Object}
@item @mnm{asString} (@code{void})
Return a @code{String} object of the receiver.

@cindex @mnm{asSymbol} instance method @idxclscite{Object}
@item @mnm{asSymbol} (@code{void})
If the value of the receiver is an object reference, return
a Symbol object with that reference.  Otherwise, return a
Symbol object with a reference to the receiver.

@cindex @mnm{backgroundMethodObjectMessage} instance method @idxclscite{Object}
@item @mnm{backgroundMethodObjectMessage} (@code{Method} @var{method_object})
Send the message defined in @var{method_object} to the receiver as a
new process, which runs concurrently until @var{method_object} returns.

The argument, @var{method_object}, is a previously defined method
which takes no arguments.  The return value, if any is not saved when
the background process exits.

Here is a brief example that opens an @code{ObjectInspector} on a
process.

@c test/expect/examples/background1.c
@example

Object instanceMethod bgMethod (void) @{
  self inspect "bgMethod> ";
  printf ("bgMethod printed this.\n");
@}

int main () @{
  Integer new i;
  Method new bgMethodObject;
  int status;

  bgMethodObject definedInstanceMethod "Object", "bgMethod";
  i backgroundMethodObjectMessage bgMethodObject;

  wait (&status);  /* Returns when the background */
                   /* process exits.              */

@}

@end example

@anchor{ObjectbasicNew}
@cindex @mnm{basicNew} instance method @idxclscite{Object}
@item @mnm{basicNew} (@code{char *}@var{name})
@item @mnm{basicNew} (@code{char *}@var{name}, @code{char *}@var{value_expr})
@item @mnm{basicNew} (@code{char *}@var{name}, @code{char *}@var{classname}, @code{char *}@var{superclassname}, @code{char *}@var{value_expr})
If given with one argument, the receiver must be a class object, and
the method creates a new object with the name given as the
argument and a value of @samp{(null)}.  

With two arguments, create a new object with the name and value given
in the arguments, and with the class and superclass of the receiver,
which needs to be a class object in this case also.

If the method is used with four arguments, create a new object with
the name, class, superclass and value given by the arguments - in this
case, @mnm{basicNew} doesn't use the class and superclass of the
receiver.

In each case, the newly created object contains all of the instance
variables defined by the class object and has a scope of
LOCAL_VAR|METHOD_USER_OBJECT and a reference count of 1.

@emph{Note:} The addition of the receiver's instance variables
means you need to be careful when the receiver is not a class
object.  The @mnm{basicNew} method does not check for cascading
or circular instance variables.  So if you're creating and then pushing
a lot of items, make sure the method's receiver is a class object,
and assigning the new object using a @code{Symbol} is more robust
that assigning other types of objects.

That is, a set of statements like

@example

*tokSym = String basicNew "token", valuebuf;
myList push *tokSym;

@end example

is much more reliable than, say

@example

myTok = myString basicNew "token", valuebuf;
myList push myTok;

@end example

@cindex @mnm{become} instance method @idxclscite{Object}
@item @mnm{become} (@code{OBJECT *}@var{original_object})
Make the receiver a duplicate of the argument object.

@cindex @mnm{callStackTrace} instance method @idxclscite{Object}
@item @mnm{callStackTrace} (@code{void})
Print a call stack trace.

@cindex @mnm{class} instance method @idxclscite{Object}
@item @mnm{class} (@code{char *}@var{classname})
Declare a new class @code{classname}.  The class declaration
consists of a superclass name, the @code{class} keyword, the
name of the new class, and an optional documentation string.  For
example;

@example

FileStream new WriteFileStream;

@emph{... or, with a docstring between the class name and semicolon ...}

FileStream new WriteFileStream
"Defines the methods and instance variables that write data to files. Also
defines the class variables stdoutStream and stderrStream, which are the 
object representation of the standard output and standard error streams.";

@end example

@cindex @mnm{className} instance method @idxclscite{Object}
@item @mnm{className} (@code{void})
Return a @code{String} object containing the class name of the receiver.

@cindex @mnm{classObject} instance method @idxclscite{Object}
@item @mnm{classObject} (@code{void})
Return the class object named by the receiver's value.  Normally the
receiver should be a @code{String} object - the method uses the C
value of the receiver to retrieve the class object by its name.  If
the receiver is a class object, the method returns the receiver
itself.

@cindex @mnm{copy} instance method @idxclscite{Object}
@item @mnm{copy} (@code{Object} @var{source_object}) 
Copy @var{source_object} to the receiver.  This method
replaces the receiver, which received the message, with a
completely new copy of the @var{source_object} argument.
The original receiver object no longer exists.

@cindex @mnm{decReferenceCount} instance method @idxclscite{Object}
@item @mnm{decReferenceCount} (@code{void})
Decrease the receiver object's reference count by one.

@cindex @mnm{delete} instance method @idxclscite{Object}
@item @mnm{delete} (@code{void})
Delete the receiver object and its instance variables.

For some of the details of how Ctalk deletes objects, refer to 
the @code{__ctalkDeleteObject ()} API function. @xref{__ctalkDeleteObject}. 

@cindex @mnm{disableExceptionTrace} instance method @idxclscite{Object}
@item @mnm{disableExceptionTrace} (@code{void})
Disable method walkback displays when handling exceptions.

@cindex @mnm{docDir} instance method @idxclscite{Object}
@item @mnm{docDir} (@code{void})
Returns a @code{String} that contains the path where the
Ctalk-specific documentation is installed on the system (i.e.,
documentation other than man pages and Texinfo manuals).

@cindex @mnm{dump} instance method @idxclscite{Object}
@item @mnm{dump} (@code{void})
Create an @code{ObjectInspector} object and print the object's
contents on the terminal.  This is a convenience method for the
ObjectInspector : formatObject method.

@cindex @mnm{enableExceptionTrace} instance method @idxclscite{Object}
@item @mnm{enableExceptionTrace} (@code{void})
Enable method walkback displays when handling exceptions.

@cindex @mnm{getReferenceCount} instance method @idxclscite{Object}
@item @mnm{getReferenceCount} (@code{void})
Return an Integer with the receiver's reference count.

@cindex @mnm{hasPointerContext} instance method @idxclscite{Object}
@item @mnm{hasPointerContext} (@code{void})
Returns a @code{Boolean} value of True if the receiver appears
in a pointer context; i.e., on the left-hand side of an assignment
operator in an expression with some dereferencing method (usually
a ``@mnm{*}''), as in this example.

@example

Symbol new myNewObjectPtr;
Symbol new myOldObjectPtr;


*myNewObjectPtr = myOldObjectPtr;

@end example

@cindex @mnm{incReferenceCount} instance method @idxclscite{Object}
@item @mnm{incReferenceCount} (@code{void})
Increase the receiver object's reference count by one.

@anchor{Object_inspect}
@cindex @mnm{inspect} instance method @idxclscite{Object}
@item @mnm{inspect} (@code{void})
@item @mnm{inspect} (@code{String} @var{promptStr})
Open an inspector on the receiver object.  At the prompt, typing
@samp{?} or @samp{help} displays a list of the inspector's commands.
If given a String object as its argument, displays the string as the
inspector's command prompt.  This method is a shortcut for
@mnm{inspect} in @code{ObjectInspector}
class. @xref{ObjectInspector_inspect}.

@cindex @mnm{is} instance method @idxclscite{Object}
@item @mnm{is} (@code{char *}@var{className})
Return @code{TRUE} if the receiver is a member of the class given in
the argument, @code{FALSE} otherwise.  @emph{Note:} Don't use an
expression like, @samp{obj is Class}.  The argument must be a valid,
defined class, which simplifies the method considerably.

To determine if an object is a class object, use @mnm{isClassObject},
which is mentioned below.  This example illustrates the difference.

@example

if (myObject is String) @{   /* OK - String is a defined class. */
 ...
@}

if (myObject is Class) @{    /* Not OK - 'Class' is not a defined class. */
 ...
@}

if (myObject isClassObject) @{  /* OK - Just check whether the object is
 ...                              its own class object. */
@}

@end example



@cindex @mnm{isClassMethod} instance method @idxclscite{Object}
@item @mnm{isClassMethod} (@code{char *}@var{classMethodName})
Return @code{TRUE} if the receiver's class defines an
instance method named @var{classMethodName}, @code{FALSE}
otherwise.  If the receiver is an instance or class
variable, look for the method in the class of the receiver's 
value.

@cindex @mnm{isClassObject} instance method @idxclscite{Object}
@item @mnm{isClassObject} (@code{void})
Returns a Boolean value of True if the receiver is a class object,
False otherwise.

@cindex @mnm{isInstanceMethod} instance method @idxclscite{Object}
@item @mnm{isInstanceMethod} (@code{char *}@var{instanceMethodName})
Return @code{TRUE} if the receiver's class defines an
instance method named @var{instanceMethodName}, @code{FALSE}
otherwise.  If the receiver is an instance or class
variable, look for the method in the class of the receiver's 
value.

@cindex @mnm{isInstanceVariable} instance method @idxclscite{Object}
@item @mnm{isInstanceVariable} (@code{char *}@var{instanceVariableName})
Return @code{TRUE} if the receiver has an instance variable named
@var{instanceVariableName}, @code{FALSE} otherwise.

@cindex @mnm{instanceMethod} instance method @idxclscite{Object}
@item @mnm{instanceMethod} (@code{char *}@var{alias}, @code{char *}@var{name}, (@var{args})
Declare a method of the receiver's class with the name @var{name}, 
with the arguments @var{args}, and, optionally, with the alias
@var{alias}.  @xref{Methods}.

@cindex @mnm{isNull} instance method @idxclscite{Object}
@item @mnm{isNull} (@code{void})
Return @code{TRUE} if the receiver is a null result object,
@code{FALSE} otherwise.

@cindex @mnm{isNullValue} instance method @idxclscite{Object}
@item @mnm{isNullValue} (@code{void})
Return @code{TRUE} if the receiver's value is @code{NULL},
@samp{(null)}, or @samp{0}, @code{FALSE} otherwise.  Note that this
method is here for compatibility with older programs.  New programs
should not need it.

@cindex @mnm{isSubClassOf} instance method @idxclscite{Object}
@item @mnm{isSubClassOf} (@code{String} @var{classname})
Returns True if the reciever's is a member of @var{classname}
or one of its subclasses, False otherwise.

@cindex @mnm{libraryPath} instance method @idxclscite{Object}
@item @mnm{libraryPath} (@code{void})
Return the file path name of the receiver's class library.

@cindex @mnm{mapClassVariables} instance method @idxclscite{Object}
@item @mnm{mapClassVariables} (@code{OBJECT *(*}@var{fn}@code{)()})
Apply the argument, @var{fn} to each of the class variables
in the receiver's class object.  The argument may be either
a method or a code block.  Refer to the @cite{Ctalk
Tutorial} for examples of inline method messages using
methods like @mnm{map} and @mnm{mapInstanceVariables}.

@cindex @mnm{mapInstanceVariables} instance method @idxclscite{Object}
@item @mnm{mapInstanceVariables} (@code{OBJECT *(*}@var{fn}@code{)()})
Apply the argument, @var{fn}, to each of an object's
instance variables.  The argument may be either a method or
a code block.  Refer to the @cite{Ctalk Tutorial} for
examples of inline method messages using methods like
@mnm{map} and @mnm{mapInstanceVariables}.

@anchor{methodObjectMessage}
@cindex @mnm{methodObjectMessage} instance method @idxclscite{Object}
@item methodObjectMessage (@code{Method} @var{method_object})
@item methodObjectMessage (@code{Method} @var{method_object}, @code{Object} @var{arg1}, @code{Object} @var{arg2})
Perform a method call with a @code{Method} class object.  The
@var{method_object} argument and its own arguments must have been
previously defined.  @xref{Method}.

@cindex @mnm{withArg} instance method @idxclscite{Method}
With three arguments, the method uses the second and third arguments
as the method instance's arguments, without previous calls to
the @mnm{withArg} method (defined in @code{Method} class).

Method instances with two arguments are commonly used in graphical
event dispatchers.  They're found mostly in @code{X11PaneDispatcher}
class, and the three-parameter form of @mnm{methodObjectMessage}
allows the method instance calls to be more efficient.

The following examples of method calls shows how to call
method instances with and without using the @mnm{withArg}
method first.

This example is from @code{X11PaneDispatcher} class.

@example

  /* This example pushes the arguments separately. */
__subPane handleKbdInput withArg __subPane;
__subPane handleKbdInput withArg __event;
__subPane methodObjectMessage __subPane handleKbdInput;

  /* The three-argument form of methodObjectMessage allows
     passing two arguments to a method instance with only
     a single expression. */
__subPane methodObjectMessage __subPane handleKbdInput,
  __subPane, __event;

@end example

@cindex @flnm{sockproc.c} example program
@cindex Background method processes
This example is the @flnm{demos/ipc/sockproc.c} demonstration program,
which shows how to define and start a method instance as a separate
process.

@example

#define SOCK_BASENAME "testsocket.$$"

String new gSocketPath; /* The socket path is common to both
			   processes. */

Object instanceMethod startTimeServer (void) @{
  UNIXNetworkStreamReader new reader;
  String new utcTimeString;
  CalendarTime new timeNow;
  SystemErrnoException new ex;

  reader openOn gSocketPath;
  if (ex pending) @{
    ex handle;
    return ERROR;
  @}

  while (1) @{
    utcTimeString = reader sockRead;
    if (ex pending) @{
      ex handle;
      return ERROR;
    @}
    if (utcTimeString length > 0) @{
      timeNow = utcTimeString asInteger;
      timeNow localTime;
      printf ("%s\n", timeNow cTimeString);
    @}
  @}
@}

int main (int argc, char **argv) @{

  CTime new thisTime;
  CTime new prevTime;
  UNIXNetworkStream new strObject;
  UNIXNetworkStreamWriter new client;
  Method new timeServerInit;
  Integer new childPID;
  SystemErrnoException new ex;
  Object new procRcvr;

  gSocketPath = strObject makeSocketPath SOCK_BASENAME;

  timeServerInit definedInstanceMethod "Object", 
    "startTimeServer";
  childPID = 
    procRcvr backgroundMethodObjectMessage timeServerInit;

  client openOn gSocketPath;
  if (ex pending) @{
    ex handle;
    return ERROR;
  @}

  prevTime utcTime;

  while (1) @{

    thisTime utcTime;

    if (thisTime != prevTime) @{

      client sockWrite (thisTime asString);

      if (ex pending) @{
	ex handle;
	return ERROR;
      @}
      
      prevTime = thisTime;

    @}
    usleep (1000);
  @}
  exit (0);
@}

@end example

@cindex @mnm{methods} instance method @idxclscite{Object}
@item @mnm{methods} (@code{Boolean} @var{findClassMethods})
Return a string containing the methods defined by the receiver's
class, one method per line.  If @var{findClassMethods} is True, return
a list of class methods in the class.  If the argument is False,
return a list of the class's instance methods.

@cindex @mnm{name} instance method @idxclscite{Object}
@item @mnm{name} (@code{void})
Return the name of the receiver as a @code{String} object.

@cindex @mnm{new} instance method @idxclscite{Object}
@item @mnm{new} (@var{newObject1}, @var{newObject2}, @var{newObject3}...)
Create an object or object's of the receiver's class with the names
@var{newObject1}, etc.  For example:

@example

String new myString1, myString2, myString3;

@end example

@cindex @mnm{printSelfBasic} instance method @idxclscite{Object}
@item @mnm{printSelfBasic} (@code{void})
Print the contents of the receiver to the program's standard error
output. 

@cindex @mnm{setReferenceCount} instance method @idxclscite{Object}
@item @mnm{setReferenceCount} (@code{Integer} @var{refCnt})
Set the receiver's reference count to the value given as the argument.
Note, however, that the reference count given as the argument does
not include any changes in the reference count as this method is
executed.  If you're unsure about how to adjust the reference count
it's safer to use @mnm{incReferenceCount} and @mnm{decReferenceCount}
instead, or use the @cite{__objRefCntSet ()} library function directly.
@xref{objRefCntSet}.

@cindex @mnm{sizeof} instance method @idxclscite{Object}
@item @mnm{sizeof} (@var{Object})
Overloads the C @code{sizeof} operator when the argument is an
object.  If the argument is a C variable or a type expression, then
Ctalk uses the compiler's @code{sizeof} operator.

@cindex @mnm{superclassName} instance method @idxclscite{Object}
@item @mnm{superclassName} (@code{void})
Return a @code{String} that contains the name of the object's
superclass, or @samp{(null)} if the receiver is an instance of
@code{Object} class, which has no superclass.

@cindex @mnm{traceEnabled} instance method @idxclscite{Object}
@item @mnm{traceEnabled} (@code{void})
Return @code{TRUE} if exception walkback displays are enabled,
@code{FALSE} otherwise.

@cindex @mnm{value} instance method @idxclscite{Object}
@item @mnm{value} (@code{void})
Returns the value of the receiver object.  When you use an object
without a method, ctalk uses the @mnm{value} message to return the
object's value.  For example,

@example
  printf ("%s", stringObject);
@end example

is the same as,

@example
  printf ("%s", stringObject value);
@end example

@end table

@node Bitmap, DisplayFont, Object, Classes
@iftex
@section @code{Bitmap} class
@end iftex
@ifnottex
@subheading @code{Bitmap} Class
@end ifnottex
@cindex @code{Bitmap} class

@node DisplayFont, X11Font, Bitmap, Classes
@iftex
@section @code{DisplayFont} class
@end iftex
@ifnottex
@subheading @code{DisplayFont} Class
@end ifnottex
@cindex @code{DisplayFont} class

@node X11Font, X11Cursor, DisplayFont, Classes
@iftex
@section @code{X11Font} class
@end iftex
@ifnottex
@subheading @code{X11Font} Class
@end ifnottex
@cindex @code{X11Font} class

A @code{X11Font} object provides information about a X
Window System font, like its resource ID, width, height, and
X Logical Font Descriptor (XLFD) string.  Normally, a pane
or X window does not use font glyphs directly but uses Pane
methods to display text using the font
resource. @xref{X11Pane}. 

For variable width fonts, the @code{maxWidth} instance
variable provides the width of the widest character in the
set.  

For more information about X's font naming scheme, the
@cite{xfontsel(1)} manual page is a good place to begin.

@subheading Instance Variables
@table @code
@cindex @code{ascent} instance variable @idxclscite{X11Font}
@cindex @code{descent} instance variable @idxclscite{X11Font}
@item ascent
@item descent
@code{Integer} objects that contain the number of pixels the
character set extends above and below the baseline.  These
dimensions are typically used to determine interline
spacing.

@cindex @code{fontDesc} instance variable @idxclscite{X11Font}
@item fontDesc
A @code{String} containing the X Logical Font Descriptor of
the receiver's font.  After a call to @mnm{getFontInfo} (below), 
contains the XLFD of the actual font. 

@cindex @code{fontId} instance variable @idxclscite{X11Font}
@item fontId
An @code{Integer} that contains the X Window System's
resource ID of the font.

@cindex @code{height} instance variable @idxclscite{X11Font}
@item height
An @code{Integer} that contains the sum of the
maximum descent and ascent; that is, the height of the
font's tallest character.

@cindex @code{maxLBearing} instance variable @idxclscite{X11Font}
@item maxLBearing
An @code{Integer} that contains the maximum distance in pixels from a
character's drawing origin to its glyph.

@cindex @code{maxRBearing} instance variable @idxclscite{X11Font}
@item maxRBearing
An @code{Integer} that contains the maximum distance in pixels between
the right side of a font's character glyphs to the right-hand edge of
the character space.

@cindex @code{maxWidth} instance variable @idxclscite{X11Font}
@item maxWidth
An @code{Integer} that contains the width of the font's widest
character glyph.  Note that these metrics' uses differ for different
fonts, and can vary a lot, especially in foreign language character
sets.  Generally, though, for Western, monospaced fonts, the width in
pixels of a character plus its horizontal spacing is:

@example

myFont maxLBearing + myFont maxWidth;

@end example

@end table

@subsubheading Instance Methods
@table @code

@cindex @mnm{getFontInfo} instance method @idxclscite{X11Font}
@item @mnm{getFontInfo} (@code{String} @var{fontDesc})
Fills in the font metrics (height, maxWidth, ascent, descent, X font
ID) for the font named by @var{fontDesc}.  Also fills in the
receiver's @code{fontDesc} instance variable with the string
given as the argument.

@cindex @mnm{textWidth} instance method @idxclscite{X11Font}
@item @mnm{textWidth} (@code{String} @var{text})
Returns an @code{Integer} with the width of @var{text} in
pixels when rendered in the reciever's font.  The program
should call the @mnm{getFontInfo} method before calling
this method.

@end table

@node X11Cursor, X11FreeTypeFont, X11Font, Classes
@iftex
@section @code{X11Cursor} class
@end iftex
@ifnottex
@subheading @code{X11Cursor} Class
@end ifnottex
@cindex @code{X11Cursor} class

The @code{X11Cursor} class represents cursor objects and provides
wrapper methods that create X11 cursor resources.  A @code{X11Cursor}
object's value is the ID of the newly created cursor resource.

To display the cursor in a @code{X11Pane} object's window, see
the @mnm{useCursor} method in @code{X11Pane} class.  This
example shows the sequence of expressions. @xref{X11Pane}.

@example

X11Pane new xPane;        /* Create our objects. */
X11Cursor new waitCursor;

@emph{...}

waitCursor watch;         /* Get the resource ID of a wait cursor
                             (normally, a watch or a spinner). */
@emph{...}

xPane useCursor waitCursor;  /* Display the wait cursor on the xPane's
                                window. */
@end example

The @mnm{defaultCursor} method (class @code{X11Pane}) restores the
window's cursor to its parent window's cursor, which is the default
cursor for new windows.  @xref{X11Pane}.

@example

xPane defaultCursor;

@end example

@subsubheading Instance Methods
@table @code

@cindex @mnm{arrow} instance method @idxclscite{X11Cursor}
@item arrow (@code{void})
Sets the cursor to the upward-left pointing arrow that is the default
for most new windows.

@cindex @mnm{grabMove} instance method @idxclscite{X11Cursor}
@item grabMove (@code{void})
Creates a grab cursor.

@cindex @mnm{scrollArrow} instance method @idxclscite{X11Cursor}
@item scrollArrow (@code{void})
Creates a scrollbar vertical double arrow cursor.

@cindex @mnm{watch} instance method @idxclscite{X11Cursor}
@item watch (@code{void})
Creates a cursor that displays a small watch.

@end table

@node X11FreeTypeFont, X11Bitmap, X11Cursor, Classes
@iftex
@section @code{X11FreeTypeFont} class
@end iftex
@ifnottex
@subheading @code{X11FreeTypeFont} Class
@end ifnottex
@cindex @code{X11FreeTypeFont} class

This class contains the methods that handle FreeType fonts using the
Xft library specifically.  In classes and methods that use fonts,
FreeType fonts take priority if available and the program has
initialized the library with the @mnm{initFontLib} method.  Otherwise,
applications use the fonts provided by the window system's normal
libraries.

@cindex FreeType configuration
@cindex Xft configuration
@cindex XftConfig file
When looking for the machine's font configuration, Ctalk
checks for the following files.

@table @b
@item 1.
The file path named by the @samp{$XFT_CONFIG} environment variable.
@item 2.
@samp{$HOME/.fonts.conf}
@item 3.
@samp{$XDG_CONFIG_HOME/fontconfig/fonts.conf}
@item 4.
@flnm{/etc/fonts/fonts.conf}
@item 5.
The file @flnm{/usr/X11R6/lib/X11/XftConfig}

@end table

If you want to write your own font config file, the
@code{X11FreeTypeFont} class is mainly concerned with the directories
where TrueType and Type 1 fonts reside.  The directories need to be
listed in the @samp{XftConfig} file with the @samp{dir} directive.
For example:

@example

<fontconfig>
<dir>/usr/share/fonts/truetype/dejavu</dir>
<dir>/usr/share/fonts/truetype/freefont</dir>
<dir>/usr/share/fonts/type1/gsfonts</dir>
</fontconfig>

@end example

There is a more complete @samp{XftConfig} sample file in the Ctalk
source distribution, @flnm{doc/XftConfig.sample}.  The
@cite{fonts.conf (5)} manual page and the Xft user and developer
documentation provide even more information.

@cindex @code{X11TextPane} class
Classes like @code{X11TextPane} can use the FreeType fonts
transparently instead of the normal Xlib application programming
interface, as long as the Xft library is available and initialized.
Unlike the Xlib font resources, which need their Pane objects
initialized before the font resources, the Xft library works best when
the application initializes it as early as possible.  The example
program for the @code{X11TextPane} class shows how this can be
accomplished. @xref{X11TextPane}.


@subsubheading Instance Variables
@table @code
@cindex @mnm{family} instance variable @idxclscite{X11FreeTypeFont}
@item family
A @code{String} that contains the family of the currently selected font.
@xref{String}.
@cindex @mnm{fgRed} instance variable @idxclscite{X11FreeTypeFont}
@cindex @mnm{fgGreen} instance variable @idxclscite{X11FreeTypeFont}
@cindex @mnm{fgBlue} instance variable @idxclscite{X11FreeTypeFont}
@cindex @mnm{fgAlpha} instance variable @idxclscite{X11FreeTypeFont}
@item fgRed
@item fgGreen
@item fgBlue
@item fgAlpha
The parameters of the font's RGBA color.  The variables are @code{Integers}
and can have a range of 0 - 0xffff. @xref{Integer}.
@cindex @mnm{rotation} instance variable @idxclscite{X11FreeTypeFont}
@cindex @mnm{scaleX} instance variable @idxclscite{X11FreeTypeFont}
@cindex @mnm{scaleY} instance variable @idxclscite{X11FreeTypeFont}
@item rotation
@item scaleX
@item scaleY
@code{Float} instance variables that control the scaling and rotation
of the rendered fonts.
@cindex @mnm{slant} instance variable @idxclscite{X11FreeTypeFont}
@cindex @mnm{weight} instance variable @idxclscite{X11FreeTypeFont}
@cindex @mnm{dpi} instance variable @idxclscite{X11FreeTypeFont}
@item slant
@item weight
@item dpi
@code{Integers} that contain the slant, weight, and dpi resolution of
the receiver font.  For a description of the Xft library's constants,
refer to the @mnm{selectFont} method entry, below. @xref{Integer}.
@cindex @mnm{pointSize} instance variable @idxclscite{X11FreeTypeFont}
@item pointSize
A @code{Float} that contains the font's point size. @xref{Float}.
@cindex @mnm{ascent} instance variable @idxclscite{X11FreeTypeFont}
@item ascent
An @code{Integer} that contains the font's height in pixels above
the baseline.
@cindex @mnm{descent} instance variable @idxclscite{X11FreeTypeFont}
@item descent
An @code{Integer} that contains the font's height in pixels below
the baseline.
@cindex @mnm{height} instance variable @idxclscite{X11FreeTypeFont}
@item height
An @code{Integer} that contains the dimensions in pixels of the font's
total height, both above and below the baseline, and any extra vertical
spacing.
@cindex @mnm{maxAdvance} instance variable @idxclscite{X11FreeTypeFont}
@item maxAdvance
An @code{Integer} that contains the maximum width in pixels of a
font's characters horizontal dimensions.
@end table


@subsubheading Instance Methods
@table @code

@cindex @mnm{alpha} instance method @idxclscite{X11FreeTypeFont}
@item @mnm{alpha} (@code{Integer} @var{value})
Set the current Xft font's foreground alpha channel.  The argument
@var{value} must be an unsigned short int; i.e., in the
range 0 - 65535 (0xffff hex).

@cindex @mnm{blue} instance method @idxclscite{X11FreeTypeFont}
@item @mnm{blue} (@code{Integer} @var{value})
Set the current Xft font's foreground blue channel.  The argument
@var{value} must be an unsigned short int; i.e., in the
range 0 - 65535 (0xffff hex).

@cindex @mnm{green} instance method @idxclscite{X11FreeTypeFont}
@item @mnm{green} (@code{Integer} @var{value})
Set the current Xft font's foreground green channel.  The argument
@var{value} must be an unsigned short int; i.e., in the
range 0 - 65535 (0xffff hex).

@cindex @mnm{initFontLib} instance method @idxclscite{X11FreeTypeFont}
@item @mnm{initFontLib} (@code{void})
Initializes the font library and sets the reciever's instance
variables to the default selected font.  Apps need to use this method before
most of the other other methods in this class.

If the system is not configured to use outline fonts then the library
prints a message and exits the program with a non-zero value.
@xref{ctalkXftInitLib}.

@cindex @mnm{libIsInitialized} instance method @idxclscite{X11FreeTypeFont}
@item @mnm{libIsInitialized} (@code{void})
Returns a non-zero @code{Integer} value if the Xft libraries are
initialized and a font is selected.

@cindex @mnm{listFonts} instance method @idxclscite{X11FreeTypeFont}
@item @mnm{listFonts} (@code{String} @var{pattern})
List the font descriptors in the FreeType library that contain @var{pattern}.
If @var{pattern} is an empty string @samp{""} or a @samp{*}, match
every font descriptor.

@cindex @mnm{namedX11Color} instance method @idxclscite{X11FreeTypeFont}
@item @mnm{namedX11Color} (@code{String} @var{colorName})
Sets the selected font's red, green, and blue values from the
X11 color name given as the argument.

@emph{Note:} For a list of the colors that the X Window System
recognizes, consult the file @flnm{rgb.txt}, which is often stored
with the server's configuration files when the GUI is installed.

@cindex @mnm{qualifyName} instance method @idxclscite{X11FreeTypeFont}
@item @mnm{qualifyName} (@code{String} @var{xftpattern})
Returns a fully qualified @code{String} containing a fully qualified
Xft font descriptor that matches @var{xftpattern}.

@cindex @mnm{red} instance method @idxclscite{X11FreeTypeFont}
@item @mnm{red} (@code{Integer} @var{value})
Set the current Xft font's foreground red channel.  The argument
@var{value} must be an unsigned short int; i.e., in the
range 0 - 65535 (0xffff hex).

@cindex @mnm{saveSelectedFont} instance method @idxclscite{X11FreeTypeFont}
@item @mnm{saveSelectedFont} (@code{void})
This method does the work of setting the receiver's instance variables
to the values of the selected font.

@cindex @mnm{selectedFont} instance method @idxclscite{X11FreeTypeFont}
@item @mnm{selectedFont} (@code{void})
Returns the @code{String} with the descriptor of the selected font.
Because a complete font descriptor contains a lot of information, this
method can generate a lot of output.

@cindex @mnm{RGBAColor} instance method @idxclscite{X11FreeTypeFont}
@item @mnm{RGBAColor} (@code{void})
@item @mnm{RGBAColor} (@code{int} @var{red}, @code{int} @var{green}, @code{int} @var{blue}, @code{int} @var{alpha})
If given with no arguments, sets the current font's color to the values
of the receiver's @samp{ftRed, fgGreen, fgBlue,} and @samp{fgAlpha} values.
If the method is used with arguments, set's the current font's color to
their values.  The values are @code{Integers} and can have a range of 0-0xffff.

@anchor{X11FreeTypeFont-selectFont}
@cindex @mnm{selectFont} instance method @idxclscite{X11FreeTypeFont}
@item @mnm{selectFont} (@code{void})
@item @mnm{selectFont} (@code{String} @var{family}, @code{Integer} @var{slant}, @code{Integer} @var{weight}, @code{Integer} @var{dpi}, @code{Float} @var{pointSize})
If used without arguments, selects the font named by the receiver's
instance variables.  If the statement provides arguments, only the
@var{family} argument needs to describe an actual font family; that
is, it has no default value.  Defaults for the other arguments are
described below.  In this case, the method sets the receiver's instance
variables to the selected font.

For the @code{slant} and @code{weight} arguments, the Xft library
defines the constants and their meanings as the following.

@example
      SLANT
 0    Roman
 100  Italic
 110  Oblique

      WEIGHT
 0    Light
 100  Medium
 180  Demibold
 200  Bold
 210  Black
@end example

The @var{dpi} parameter should be set to the resolution of the display.

An easier way to describe a font may be to use the
@mnm{selectFontFromFontConfig} method, which takes a FontConfig
format font specification as its argument. @xref{selectFontFromFontConfig}.

@cindex @mnm{selectFontFromXLFD} instance method @idxclscite{X11FreeTypeFont}
@item @mnm{selectFontFromXLFD} (@code{String} @var{xlfd})
Similar to @mnm{selectFont}, above, except that its argument is
a string in XLFD format.  That is, the method translates the XLFD argument
into the Xft library's font metrics.  This makes possible font descriptions
like the following.

@example

-*-DejaVu Sans-medium-r-*-*-12-72-72-*-*-*-*-*

@end example

@anchor{selectFontFromFontConfig}
@cindex @mnm{selectFontFromFontConfig} instance method @idxclscite{X11FreeTypeFont}
@item @mnm{selectFontFromFontConfig} (@code{String} @var{font_config_string})
Selects a font using the FontConfig specification given as its argument.

@cindex @mnm{textHeight} instance method @idxclscite{X11FreeTypeFont}
@item @mnm{textHeight} (@code{String} @var{text})
Return an @code{Integer} with the height in pixels of @var{text} in the
currently selected FreeType font.  If the Xft library is not available
or not initialized, the method returns 0.

@cindex @mnm{textWidth} instance method @idxclscite{X11FreeTypeFont}
@item @mnm{textWidth} (@code{String} @var{text})
Return an @code{Integer} with the width in pixels of @var{text} in the
currently selected FreeType font.  If the Xft library is not available
or not initialized, the method returns 0.

@end table

@node X11Bitmap, Boolean, X11FreeTypeFont, Classes
@iftex
@section @code{X11Bitmap} class
@end iftex
@ifnottex
@subheading @code{X11Bitmap} Class
@end ifnottex
@cindex @code{X11Bitmap} class

A @code{X11Bitmap} object is similar to a Bitmap object - it
contains the address of a bitmap in memory.  In addition, a
@code{X11Bitmap} object has its own X11 graphics context for
graphics operations.

@subsubheading Instance Variables
@table @code
@cindex depth instance variable @idxclscite{X11Bitmap}
@item depth
An @code{Integer} that contains the depth of the bitmap.

@cindex displayPtr instance variable @idxclscite{X11Bitmap}
@item displayPtr
A @code{Symbol} that contains the address of the connection
to the X server that was returned by a call to @cite{XOpenDisplay}.
This is generally the address of the main window pane's @code{displayPtr}
instance variable, and in this class, it is expressly set in
the @mnm{create} method.

@cindex height instance variable @idxclscite{X11Bitmap}
@item height
An @code{Integer} that contains the height of the bitmap.

@cindex modal instance variable @idxclscite{X11Bitmap}
@item modal
A @code{Boolean} that helps determine how Ctalk draws graphics on the
X11Bitmap.  True for X11Bitmap objects that are displayed in popup
windows, false otherwise.

@cindex parentDrawable instance variable @idxclscite{X11Bitmap}
@item parentDrawable
An @code{Integer} that contains the window ID of the
bitmap's parent drawable.  Normally this is set by
the @mnm{create} method, below.

@cindex width instance variable @idxclscite{X11Bitmap}
@item width
An @code{Integer} that contains the width of the bitmap.

@cindex xGC instance variable @idxclscite{X11Bitmap}
@item xGC 
A @code{Symbol} object that contains the address of the X11
graphics context.  

@cindex xID instance variable @idxclscite{X11Bitmap}
@item xID
The X resource ID of the Pixmap associated with this object.
@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{background} instance method @idxclscite{X11Bitmap}
@item @mnm{background} (@code{String} @var{color})
Set the background color of the receiver to @var{color}.
@emph{Note:} When changing foreground and background color,
make sure that an application has is receiving and
processing events, using the @mnm{openEventStream} method in
class @code{X11Pane}.

@cindex @mnm{clear} instance method @idxclscite{X11Bitmap}
Clear the receiver to the background color.

@cindex @mnm{clearRectangle} instance method @idxclscite{X11Bitmap}
@item @mnm{clearRectangle} (@code{Integer} @var{x}, @code{Integer} @var{y}, @code{Integer} @var{width}, @code{Integer} @var{height})
Clear the specified area to the background color.

@cindex @mnm{copy} instance method @idxclscite{X11Bitmap}
@cindex copy (@code{X11Bitmap} @var{srcBitmap}, @code{Integer} @var{srcX}, @code{Integer} @var{srcY}, @code{Integer} @var{srcWidth}, @code{Integer} @var{srcHeight}, @code{Integer} @var{destX}, @code{Integer} @var{destY})
Copies the contents of @var{srcBitmap} to the receiver's drawing
surface.  The source dimensions are determined by @var{srcX},
@var{srcY}, @var{srcWidth}, and @var{srcHeight}.  The method draws the
source bitmap's contents with the source's upper left-hand corner at
@var{destX}, @var{destY}.

@cindex @mnm{create} instance method @idxclscite{X11Bitmap}
@item @mnm{initialize} (@code{void *}@code{displayPtr}, @code{int} @var{parentWindow}, @code{int} @var{width}, @code{int} @var{height}, @code{int} @var{depth})
Create a X11Bitmap object and its graphics data.

@cindex @mnm{delete} instance method @idxclscite{X11Bitmap}
@item @mnm{delete} (@code{void})
Delete a pixmap and its graphics data.

@cindex @mnm{drawLine} instance method @idxclscite{X11Bitmap}
@item @mnm{drawLine} (@code{Integer} @var{xStart}, @code{Integer} @var{yStart}, @code{Integer} @var{xEnd}, @code{Integer} @var{yEnd}, @code{Pen} @var{aPen})
@item @mnm{drawLine} (@code{Line} @var{aLine}, @code{Pen} @var{aPen})
Draw a point on the receiver's drawing surface between the points
@var{xStart},@var{yStart} and @var{xEnd},@var{yEnd} using the color,
width, and transparency defined by the argument @var{aPen}. @xref{Pen}.

If a program uses the two-argument form of the method, @var{aLine}
is a member of class @var{Line}.  @xref{Line}.

@cindex @mnm{drawPoint} instance method @idxclscite{X11Bitmap}
@item @mnm{drawPoint} (@code{Integer} @var{x}, @code{Integer} @var{y}, @code{Pen} @var{aPen})
Draw a point on the receiver's drawing surface at @var{x},@var{y} using
the color, width, and transparency defined by the argument @var{aPen}.
@xref{Pen}.

@cindex @mnm{faceRegular} instance method @idxclscite{X11Bitmap}
@cindex @mnm{faceBold} instance method @idxclscite{X11Bitmap}
@cindex @mnm{faceItalic} instance method @idxclscite{X11Bitmap}
@cindex @mnm{faceBoldItalic} instance method @idxclscite{X11Bitmap}
@item faceRegular (@code{void})
@item faceBold (@code{void})
@item faceItalic (@code{void})
@item faceBoldItalic (@code{void})
Selects the typeface of the currently selected font.  The font should
have been selected by a previous call to @mnm{font}, below, which
loads the regular, bold, italic (or oblique), and bold italic flavors
of the selected font if they are available.

@cindex @mnm{font} instance method @idxclscite{X11Bitmap}
@item @mnm{font} (@code{String} @var{font_desc})
Set the font of the receiver.

@cindex @mnm{foreground} instance method @idxclscite{X11Bitmap}
@item @mnm{foreground} (@code{String} @var{color})
Set the foreground color of the receiver.
@emph{Note:} When changing foreground and background color,
make sure that an application has is receiving and
processing events, using the @mnm{openEventStream} method in
class @code{X11Pane}.

@cindex Icon, dialog
@cindex Dialog icon
@idxlibfn{__ctalkX11XPMFromData}
@cindex @mnm{icon} instance method @idxclscite{X11Bitmap}
@cindex @mnm{iconStop} instance method @idxclscite{X11Bitmap}
@cindex @mnm{iconCaution} instance method @idxclscite{X11Bitmap}
@cindex @mnm{iconInfo} instance method @idxclscite{X11Bitmap}
@item @mnm{icon} (@code{int} @var{iconID})
@item @mnm{iconStop} (@code{void})
@item @mnm{iconCaution} (@code{void})
@item @mnm{iconInfo} (@code{void})
These methods draw a 64x64 dialog icon on the receiver's drawing
surface.  In the case of the @mnm{icon} method, the @var{iconID}
argument can be one of the following.

@example

ICON_NONE
ICON_STOP
ICON_CAUTION
ICON_INFO

@end example

All of these methods use the @cite{__ctalkX11XPMFromData} library
function to create the drawing.

@cindex @mnm{putStr} instance method @idxclscite{X11Bitmap}
@item @mnm{putStr} (@code{Integer} @var{x}, @code{Integer} @var{y}, @code{String} @var{text})
@item @mnm{putStr} (@code{Integer} @var{x}, @code{Integer} @var{y}, @code{String} @var{text}, @code{String} @var{font_desc})
@item @mnm{putStr} (@code{Integer} @var{x}, @code{Integer} @var{y}, @code{String} @var{text}, @code{String} @var{font_desc}, @code{String} @var{colorName})
Print @var{text} on the receiver's drawable X resource, at
@var{x},@var{y}.  If @var{font_desc}, a, X logical font descriptor, is
given, use that font to display the text. If @var{colorName} is also
given, render the text using that color.

@cindex @mnm{pixmapFromData} instance method @idxclscite{X11Bitmap}
@cindex @mnm{pixmapFromData} instance method @idxclscite{X11CanvasPane}
@item @mnm{pixmapFromData} (@code{int} @var{x_org}, @code{int} @var{y_org}, @code{char *}@var{xpm_data[]}) 
Draw the X pixmap defined by @var{xpm_data} with the upper left 
corner at @var{x_org},@var{y_org} on the receiver's pane buffer.

The @var{xpm_data} argument is the name of the array declared at the 
start of a @flnm{xpm} file's data array.

In Ctalk's standard libraries, the image will appear on a
@code{X11CanvasPane} object, and programs can use the
@mnm{pixmapFromData} method in @code{X11CanvasPane} instead of calling
this method directly. @xref{X11CanvasPane_pixmapFromData}.

@cindex @mnm{resize} instance method @idxclscite{X11Bitmap}
@item @mnm{resize} (@code{Integer} @var{parentVisual}, @code{Integer} @var{new_width}, @code{Integer} @var{new_height})
Resize the receiver Pixmap.  This method is normally called by an
event handler in a parent class (typically, that's a
@code{X11CanvasPane}).  If you need to resize a graphics pane's buffers,
then the program should also call @mnm{subPaneNotify} (class @code{X11Pane}),
which invokes the handler for a @code{RESIZENOTIFY} event.

Here is the @code{X11CanvasPane} classes' @code{RESIZENOTIFY}
event handler.

@example

X11CanvasPane instanceMethod subPaneResize (Object __subPane, 
					  InputEvent __event) @{
  "Resize the receiver pane.  This is the resize event
  handler called by the parent window's pane
  dispatcher."

  if (__ctalkX11ResizeWindow (__subPane, __event xEventData3,
			      __event xEventData4,
			      __subPane depth) > 0) @{
    /* refreshReframe uses viewWidth and viewHeight, refresh uses size x
       and size y */
    __subPane viewWidth = __event xEventData3;
    __subPane viewHeight = __event xEventData4;
    __subPane size x = __event xEventData3;
    __subPane size y = __event xEventData4;
    (X11Bitmap *)self paneBuffer resize self xWindowID,
      __event xEventData3, __event xEventData4;
    (X11Bitmap *)self paneBackingStore resize self xWindowID,
      __event xEventData3, __event xEventData4;
  @}

  return NULL;
@}

@end example

For an example of how a program can handle @code{RESIZENOTIFY} events,
refer to the examples in the @code{X11CanvasPane} section.
@xref{X11CanvasPane}.

@cindex @mnm{xpmInfoFromData} instance method @idxclscite{X11Bitmap}
@item @mnm{xpmInfoFromData} (@code{char **}@var{xpm_data}, @code{Array} @var{dataReturn})
Fills in the @code{Array} @var{dataReturn} with the information from the
X pixmap data referred  to by @var{xpm_data}: [width, height, colors, characters_per_color];

@cindex @mnm{xpmCharsPerColorFromData} instance method @idxclscite{X11Bitmap}
@item @mnm{xpmCharsPerColorFromData} (@code{char **}@var{xpm_data})
Returns an @code{Integer} with the number characters per color in the
X pixmap referred to by @var{xpm_data}.

@cindex @mnm{xpmColorsFromData} instance method @idxclscite{X11Bitmap}
@item @mnm{xpmColorsFromData} (@code{char **}@var{xpm_data})
Returns an @code{Integer} with the number of colors in the X pixmap referred to
by @var{xpm_data}.

@cindex @mnm{xpmHeightFromData} instance method @idxclscite{X11Bitmap}
@item @mnm{xpmHeightFromData} (@code{char **}@var{xpm_data})
Returns an @code{Integer} with the height of the X pixmap referred to
by @var{xpm_data}.

@cindex @mnm{xpmWidthFromData} instance method @idxclscite{X11Bitmap}
@item @mnm{xpmWidthFromData} (@code{char **}@var{xpm_data})
Returns an @code{Integer} with the width of the X pixmap referred to
by @var{xpm_data}.

@end table

@node Boolean, Collection, X11Bitmap, Classes
@iftex
@section @code{Boolean} Class
@end iftex
@ifnottex
@subheading @code{Boolean} Class
@end ifnottex
@cindex @code{Boolean} class

@code{Boolean} class objects are used mainly as the return values of
methods of various classes that test equality, like @code{<,}
@code{>,} @code{==,} @code{!=,} @code{&&,} and @code{||.}

An expression can treat @code{Boolean} methods differently than
methods that perform numerical calculations, which usually return
objects of @code{Magnitude} class and its subclasses.

@idxlibfn{__ctalkRegisterBoolReturn}
Methods can return one of the @code{Boolean} class variables,
@code{boolTrue} or @code{boolFalse}.  In addition, methods can also
define their own @code{Boolean} objects to return.  The API function
@cite{__ctalkRegisterBoolReturn ()} does this automatically when it
encounters a return statement in a method that has declared a
@code{Boolean} return value.

@subsubheading Class Variables

@table @code
@cindex @code{boolTrue} class variable @idxclscite{Boolean}
@cindex @code{boolFalse} class variable @idxclscite{Boolean}
@item boolFalse
@item boolTrue
Objects that represent the logical values true and false.  The objects
can be used as return values in methods that return boolean values and
in API functions like @cite{__ctalkRegisterBoolReturn ()}.
@xref{ctalkRegisterBoolReturn}.

@end table

@subsubheading Instance Methods

@table @code
@cindex @mnm{!=} instance method @idxclscite{Boolean}
@item @mnm{!=} (@code{Integer} @var{i})
Return a @code{Boolean} value of @samp{True} if the values of
the receiver and the argument are different, @samp{False} otherwise.

@cindex @mnm{&&} instance method @idxclscite{Boolean}
@item @mnm{&&} (@code{Boolean} @var{b})
Returns a @code{Boolean} value of @samp{True} if both the receiver and
the method's operand evaluate to true.

@cindex @mnm{=} instance method @idxclscite{Boolean}
@item @mnm{=} (@code{Integer} @var{i})
Sets the value of the receiver to True or False.  The method uses
the Ctalk library to perform the numeric conversion of the argument 
to a C @code{int}, then casts the result to True or False.


@cindex @mnm{==} instance method @idxclscite{Boolean}
@item @mnm{==} (@code{Integer} @var{i})
Return a @code{Boolean} value of @samp{True} if the values of
the receiver and the argument are the same, @samp{False} otherwise.

@cindex @mnm{||} instance method @idxclscite{Boolean}
@item @mnm{||} (@code{Boolean} @var{b})
Returns a @code{Boolean} value of @samp{True} if either the receiver or
the method's operand evaluate to true.


@end table

@node Collection, Array, Boolean, Classes
@iftex
@section @code{Collection} class
@end iftex
@ifnottex
@subheading @code{Collection} Class
@end ifnottex
@cindex @code{Collection} class

The @code{Collection} class is the superclass of all objects that
contain groups of objects.

Internally, a @code{Collection} is made up of a series of @code{Key}
objects.  @xref{Key}. The only function of @code{Key} has is to
maintain a reference to one of the collection's items.  The
@code{Key} objects have no other references, while the contents that
they refer to may be used elsewhere.

But programs can also refer to @code{Key} objects individually.  Most
of the math operators that are overloaded to work with @code{Collections}
actually work on @code{Key} objects.

If you write a method that adds objects to collections, it's important
to add the attribute OBJECT_IS_MEMBER_OF_PARENT_COLLECTION to each
@code{Key} object, which tells Ctalk that the @code{Key} object can be
referred to individually, and not just by its parent object. @xref{Attributes}.

@subsubheading Instance Methods

@table @code
@cindex @mnm{*} instance method @idxclscite{Collection}
@item @mnm{*} (@code{void})
When used as a unary operator to overload C's dereference (@samp{*})
prefix operator, returns the first element of the array or @code{Collection}.
This method is actually a shortcut for the method @mnm{head}, below.

@cindex @mnm{+} instance method @idxclscite{Collection}
@item @mnm{+} (@code{Integer} @var{n})
Returns the @var{nth} member of the receiver @code{Collection}.  This
method is actually a shortcut for the following expressions.

@example

Collection new myCollection;

.....  /* Add members to the collection. */

if (*(myCollection + 1)) @{
...
@}

Collection instanceMethod + nth (Integer new n) @{
  Key new k;

  k = *self;
  k += n;
  return k;
@}

@end example


@cindex @mnm{at} instance method @idxclscite{Collection}
@item @mnm{at} (@code{char *}@var{keyString})
Retrieve the element of the receiver Collection at @var{keyString}.

@cindex @mnm{atPut} instance method @idxclscite{Collection}
@item @mnm{atPut} (@code{char *} @var{keyString}, @code{OBJECT *}@var{elemObject})
Add @var{elemObject} to the receiver with the key @var{keyString}.

@cindex @mnm{delete} instance method @idxclscite{Collection}
@item @mnm{delete} (@code{void})
Remove all of the items in the receiver collection, leaving an empty
collection.  If any of the items are temporary (for example, a C
variable alias), delete the item also.

@cindex @mnm{getValue} instance method @idxclscite{Collection}
@item @mnm{getValue} (@code{void})
Return the value of the receiver, a @code{Key} object.

@cindex @mnm{isEmtpy} instance method @idxclscite{Collection}
@item @mnm{isEmtpy} (@code{void})
Return @code{TRUE} if the receiver collection is emtpy, @code{FALSE} otherwise.

@cindex @mnm{head} instance method @idxclscite{Collection}
@item @mnm{head} (@code{void})
Return the first @code{Key} in the receiver collection, or NULL if
the collection is empty.

@cindex @mnm{keyExists} instance method @idxclscite{Collection}
@item @mnm{keyExists} (@code{String} @var{keyName})
Return an @code{Integer} value of True if the key given as the
argument is present in the receiver collection, False otherwise.

@cindex @mnm{mapKeys} instance method @idxclscite{Collection}
@item @mnm{map} (@code{OBJECT *(*}@var{method}@code{)()})
Execute @var{method}, an instance method of class
@code{AssociativeArray,} for each key/value pair of the receiver
array.  The receiver of @var{method} is a @code{Key} object with
the parent class of @code{AssociativeArray}.  The return value of
@mnm{mapKeys} is NULL.

@cindex @mnm{removeAt} instance method @idxclscite{Collection}
@item @mnm{removeAt} (@code{String} @var{key_name})
Remove the object stored at @var{key_name} from the receiver
collection and return it.  Returns NULL if the entry isn't
present in the receiver collection.  In that case, the method
does not create a new entry, so programs should then call the
@mnm{atPut} method.

@cindex @mnm{replaceAt} instance method @idxclscite{Collection}
@item @mnm{replaceAt} (@code{String} @var{key_name}, @code{Object} @var{new_value})
Replace the value at @var{key_name} in the receiver collection.
Returns the old value object, or NULL if the key doesn't exist.  In
that case, the method does not create a new entry, so in that case
it's necessary to add the key/value entry to the receiver collection
using @mnm{atPut}.

@cindex @mnm{size} instance method @idxclscite{Collection}
@item @mnm{size} (@code{void})
Return an @code{Integer} with the number of items in the receiver
collection.

@cindex @mnm{tail} instance method @idxclscite{Collection}
@item @mnm{tail} (@code{void})
Return the last @code{Key} object that was added to the receiver
collection.


@end table


@node Array, List, Collection, Classes
@iftex
@section @code{Array} Class
@end iftex
@ifnottex
@subheading @code{Array} Class
@end ifnottex
@cindex @code{Array} class

The @code{Array} class contains objects ordered by index from
0... n.

Instances of @code{Array} objects store unique copies of objects,
so they can be added and deleted without worrying too much if
an @code{Array} member is referred to by another object (unless
the program later refers to the @code{Array} member; i.e., after
it's been stored with a method like @mnm{atPut}).

So most statements on @code{Array} members are safe, but you should be
careful when using multiple @code{Array} operations in the same
expression.  For example, the following expression is not safe.

@example

  myArray atPut 0, ((myArray at 0) - 3);

@end example

That's because the @mnm{atPut} method replaces the element at 0 while
the original element is still being used as an argument.  It's safer
to use another object to work on an @code{Array} element.

@example

  tmpInt = ((myArray at 0) - 3);
  myArray atPut 0, tmpInt;

@end example


@subsubheading Instance Variables

@table @code

@cindex @code{value} instance variable @idxclscite{Array}
@item value
The value is the name of the array.

@item 0... n
These instance variables refer to the elements of the array.

@end table

@subsubheading Instance Methods

@table @code

@cindex @mnm{=} instance method @idxclscite{Array}
@item @mnm{=} (@code{Array} @var{a})
Set the receiver array's elements equal to the argument array's
elements.

@cindex @mnm{asString} instance method @idxclscite{Array}
@item @mnm{asString} (@code{void})
Returns the contents of the receiver @code{Array} as a @code{String}
object.  If any member of the receiver is a @code{Character} object,
unquotes the @code{Character} object's value and concatenates the
character to the result string.  Otherwise the method concatenates
each of the receiver @code{Array}'s values into the result string.

@cindex @mnm{at} instance method @idxclscite{Array}
@item @mnm{at} (@code{int} @var{n})
Retrieve the @var{n}th element of the receiver array.

@cindex @mnm{atPut} instance method @idxclscite{Array}
@item @mnm{atPut} (@code{int} @var{index}, @code{OBJECT *}@var{item})
Add @var{item} to the receiver at @var{index}.

@cindex @mnm{map} instance method @idxclscite{Array}
@item @mnm{map} (@var{method})
Executes @var{method} with each element of the receiver.

The argument, @var{method}, is a method that should belong to the same
class as the receiver. When @var{method} is executed, its receiver is
each successive array element, and @var{method} can refer to it with
@code{self.}

@cindex @mnm{size} instance method @idxclscite{Array}
@item @mnm{size} (@code{void})
Return the number of elements in the receiver.

@end table

@node List, AssociativeArray, Array, Classes
@iftex
@section @code{List} Class
@end iftex
@ifnottex
@subheading @code{List} Class
@end ifnottex
@cindex @code{List} class

Objects of class @code{List} allow sets of objects to be sequentially
added, removed, and used as method receivers.

@subsubheading Instance Methods

@table @code
@cindex @mnm{+=} instance method @idxclscite{List}
@item @mnm{+=} (@code{Object} @var{obj1}, ...)
Add the items given in the argument to the receiver List.
For example:

@example
int main () @{
  List new l;

  l = "first", "second", "third", "fourth";
  l += "fifth", "sixth", "seventh", "eighth";

  l map @{
    printf ("%s\n", self);
v  @}
@}
@end example

@cindex @mnm{=} instance method @idxclscite{List}
@item @mnm{=} (@code{Object} @var{obj1}, ...)
Push the arguments on to the receiver List.  The arguments are a
comma separated list of objects.  For example:

@example
int main () @{
  List new l;

  l = "first", "second", "third", "fourth";

  l map @{
    printf ("%s\n", self);
  @}
@}
@end example

The @mnm{=} method initializes a list with only the objects that are
given as arguments.  The memthod deletes any previous list contents.

@cindex @mnm{append} instance method @idxclscite{List}
@item @mnm{append} (@code{Object} @var{obj1}, ...)
Add the objects given in the argument to the receiver List.
This is a synonym for the @mnm{+=} method, above.

@cindex @mnm{init} instance method @idxclscite{List}
@item @mnm{init} (@code{Object} @var{obj1}, ...)
This is a synonym for the @mnm{=} method, above.

@cindex @mnm{map} instance method @idxclscite{List}
@item @mnm{map} (@code{OBJECT *(*}@var{method}@code{)()})
@item @mnm{map} (@code{OBJECT *(*}@var{method}@code{)()}, @code{Object} @var{argument})
@item @mnm{map} (@code{OBJECT *(*}@var{method}@code{)()}, @code{Object} @var{argument1}, @code{Object} @var{argument2})
Execute @var{method}, an instance method of class @code{List,} for
each member of the receiver List.  Within @var{method}, @code{self}
refers to each successive list element.  Here is an example.

@c test/expect/examples/maplist1.c
@example

List instanceMethod printElement (void) @{
  printf ("%s\n", self);  /* Here, for each call to the printElement
                             method, "self" is each of myList's
                             successive members, which are String
                             objects. */
@}

int main () @{

  List new myList;

  myList = "item1", "item2", "item3";  /* Initialize the List with
                                          three String objects. */
  myList map printElement;

@}

@end example

The @mnm{map} method can also use a code block as its argument.
The example above, written with a code block, would look like
this.

@c test/expect/examples/maplist2.c
@example

int main () @{

  List new myList;

  myList = "item1", "item2", "item3";  /* Initialize the List with
                                          three String objects. */
  myList map @{
    printf ("%s\n", self);
  @}

@}

@end example

If given with two arguments, @var{method's} parameter list must have
one parameter.  The parameter's class is significant within @var{method};
that is, @mnm{map} can use any class of object for @var{argument}.
Here is the example above with one argument for the printElement
method;

@c test/expect/examples/maplist3.c
@example

List instanceMethod printElement (String leftMargin) @{
  printf ("%s%s\n", leftMargin, self);

@}

int main () @{

  List new myList;
  String new leftMargin;

  myList = "item1", "item2", "item3";  /* Initialize the List with
                                          three String objects. */
  leftMargin = "- ";

  myList map printElement, leftMargin;

@}

@end example

Calling @mnm{map} with three arguments works similarly.
The @mnm{map} methods in @code{List} class all return NULL.

@cindex @mnm{mapRev} instance method @idxclscite{List}
@item @mnm{mapRev} (@code{OBJECT *(*}@var{method}@code{)()})
Like @mnm{map}, except that it executes @var{method} for the last
member that was added to the receiver List, then the previous member,
and so on until the @mnm{mapRev} executes @var{method} for the first
member of the list before returning.

@cindex @mnm{new} instance method @idxclscite{List}
@item @mnm{new} (@var{list1}, @var{list2}, @var{list3}, ...;)
Create the @code{List} objects @var{list1}, etc.  For example:

@example

List new list1, list2, list3;

@end example

@cindex @mnm{pop} instance method @idxclscite{List}
@item @mnm{pop} (@code{void})
Remove the object from the end of the receiver's list and return the
object.

@cindex @mnm{popItemRef} instance method @idxclscite{List}
@item @mnm{popItemRef} (@code{void})
Here for backward compatibility; it is now the same as @mnm{pop.}

@cindex @mnm{push} instance method @idxclscite{List}
@item @mnm{push} (@code{OBJECT *(*}@var{object}@code{)(int)})
Add @var{object} to the end of the receiver's list contents.

@cindex @mnm{pushItemRef} instance method @idxclscite{List}
@item @mnm{pushItemRef} (@code{OBJECT *(*}@var{object}@code{)(int)})
Also here for backward compatibility, this method is now the same
as @mnm{push.}

@cindex @mnm{shift} instance method @idxclscite{List}
@item @mnm{shift} (@code{OBJECT *(*}@var{object}@code{)(int)})
Add @var{object} as the first element of the receiver's list contents.

@cindex @mnm{sortAscending} instance method @idxclscite{List}
@cindex @mnm{sortDescending} instance method @idxclscite{List}
@cindex @mnm{sortAscendingByName} instance method @idxclscite{List}
@cindex @mnm{sortDescendingByName} instance method @idxclscite{List}
@item @mnm{sortAscending} (@code{void})
@item @mnm{sortDescending} (@code{void})
@item @mnm{sortAscendingByName} (@code{void})
@item @mnm{sortDescendingByName} (@code{void})
Sorts the receiver list based on either the members' values or names,
in ascending or descending order.  The sort algorithm is very simple
minded, but due to the mechanics of determining earlier/later
@code{List} members, the methods are as fast for small and medium
@code{Lists} as more complex sort algorithms.

If possible, you should try to add members in order rather than try
to re-arrange a @code{List} later.  For this, refer to the
methods in @code{SortedList} class @xref{SortedList}.

@cindex @mnm{unshift} instance method @idxclscite{List}
@item @mnm{unshift} (@code{void})
Remove the first object from the receiver's list and return the
object.

@cindex @mnm{value} instance method @idxclscite{List}
@item @mnm{value} (@code{void})
Class @code{List} objects have no @code{value} instance variable.
Instead, return the @code{List} object's contents, or @code{NULL} if
the list is empty.
@end table

@node AssociativeArray, SortedList, List, Classes
@iftex
@section @code{AssociativeArray} Class
@end iftex
@ifnottex
@subheading @code{AssociativeArray} Class
@end ifnottex
@cindex @code{AssociativeArray} class

Objects of class @code{AssociativeArray} contain members that are
stored and retrieved using @code{Key} objects. @xref{Key}.  

@code{AssociativeArray} objects use the @mnm{atPut} and @mnm{at} methods
in @code{Collection} class to store and retrieve objects. @xref{Collection}.

The @mnm{keyAt} method returns the key/value pair of the array element named
as its argument.

The @mnm{map} method maps over each object stored in an
@code{AssociativeArray}, and provides that element as the receiver to
the method or code block given as the argument.

If you want to work with the object stored in the array and the key it
is stored with, the @mnm{mapKeys} method iterates over each key/value
pair of the @code{AssociativeArray}

The following example shows how to retreive the keys and values stored
in an @code{AssociativeArray}.  Each value that is stored in the array
is a @code{String} object, so the program does not need to check for
different classes of objects that are stored in the array.

@c test/assocarray.c
@example

AssociativeArray instanceMethod printValue (void) @{

  printf ("%s\t", self name);
  printf ("%s\n", self value);
  return NULL;
@}

AssociativeArray instanceMethod printKeyValue (void) @{

  String new valueObject;
  printf ("%s =>\t", self name);
  valueObject = self getValue;
  printf ("%s\n", valueObject);
  return NULL;
@}

int main () @{
  AssociativeArray new assocArray;
  String new s1;
  String new s2;
  String new s3;

  WriteFileStream classInit;
  
  s1 = "string1 value";
  s2 = "string2 value";
  s3 = "string3 value";

  assocArray atPut "string1", s1;
  assocArray atPut "string2", s2;
  assocArray atPut "string3", s3;

  stdoutStream printOn ("%s\n%s\n%s\n\n", (assocArray at "string1"),
			(assocArray at "string2"),
			(assocArray at "string3"));
  stdoutStream printOn "%s\n%s\n%s\n\n", (assocArray at "string1"),
    (assocArray at "string2"),
    (assocArray at "string3");
  stdoutStream printOn "%s\n%s\n%s\n\n", assocArray at "string1",
    assocArray at "string2",
    assocArray at "string3";

  assocArray map printValue;

  assocArray mapKeys printKeyValue;

  return 0;
@}

@end example


@subsubheading Instance Methods

@table @code
@cindex @mnm{at} instance method @idxclscite{AssociativeArray}
@item @mnm{at} (@code{char *}@var{key})
Retrieve the element of the receiver array stored at @var{key}.

@cindex @mnm{atPut} instance method @idxclscite{AssociativeArray}
@item @mnm{atPut} (@code{char *}@var{key}, @code{OBJECT *}@var{item})
Add @var{item} to the receiver at @var{key}.

@cindex @mnm{keyAt} instance method @idxclscite{AssociativeArray}
@item @mnm{keyAt} (@code{String} @var{keyName})
Returns the @code{Key} object named by @var{keyName}.

@cindex @mnm{map} instance method @idxclscite{AssociativeArray}
@item @mnm{map} (@code{OBJECT *(*}@var{method}@code{)()})
Execute @var{method}, an instance method of class
@code{AssociativeArray,} for each member of the receiver array.  Each
time @var{method} is executed, @code{self} refers to the object stored
in the associativeArray.  This method returns NULL.

@cindex @mnm{setValue} instance method @idxclscite{AssociativeArray}
@item @mnm{setValue} (@code{void})
A wrapper method for @mnm{getValue} in class @code{Key.} If received
by an instance of @code{Collection} or its subclasses instead of a
@code{Key} object, this method generates an exception.
@end table

@node SortedList, Stream, AssociativeArray, Classes
@iftex
@section @code{SortedList} Class
@end iftex
@ifnottex
@subheading @code{SortedList} Class
@end ifnottex
@cindex @code{SortedList} class

@subsubheading Instance Methods
@table @code
@cindex @mnm{+=} instance method @idxclscite{sortedList}
@item @mnm{+=} (@code{Object} @var{obj1}, ...)
Add the items given in the argument to the receiver list.
For example:

@example
int main () @{
  SortedList new l;

  l = "first", "second", "third", "fourth";
  l += "fifth", "sixth", "seventh", "eighth";

  l map @{
    printf ("%s\n", self);
  @}
@}
@end example

@cindex @mnm{=} instance method @idxclscite{SortedList}
@item @mnm{=} (@code{Object} @var{obj1}, ...)
Push the arguments on to the receiver list.  The arguments are a
comma separated list of objects.  For example:

@example
int main () @{
  SortedList new l;

  l = "first", "second", "third", "fourth";

  l map @{
    printf ("%s\n", self);
  @}
@}
@end example

The @mnm{=} method initializes a list with only the objects that are
given as arguments.  The memthod deletes any previous list contents.

@cindex @mnm{append} instance method @idxclscite{SortedList}
@item @mnm{append} (@code{Object} @var{obj1}, ...)
Add the objects given in the argument to the receiver list.
This is a synonym for the @mnm{+=} method, above.

@cindex @mnm{init} instance method @idxclscite{SortedList}
@item @mnm{init} (@code{Object} @var{obj1}, ...)
This is a synonym for the @mnm{=} method, above.

@cindex @mnm{pushAscending} instance method @idxclscite{SortedList}
@cindex @mnm{pushDescending} instance method @idxclscite{SortedList}
@item pushAscending (@code{Object} @var{new_item})
@item pushDescending (@code{Object} @var{new_item})
Adds @var{new_item} to the receiver list at the point where its value
maintains the receiver list items' ascending or descending sort order.
@end table

@node Stream, FileStream, SortedList, Classes
@iftex
@section @code{Stream} Class
@end iftex
@ifnottex
@subheading @code{Stream} Class
@end ifnottex
@cindex @code{Stream} class

@code{Stream} class is the superclass of classes that provide
sequential read and write access to objects and I/O devices.

The subclasses of @code{Stream} class are listed here.  This manual
describes each class in its own section.

@example

  Stream
   FileStream
    DirectoryStream
    ReadFileStream
    WriteFileStream
   TerminalStream
    ANSITerminalStream
    Win32TerminalStream
    X11TerminalStream
   NetworkStream
    UNIXNetworkStream
     UNIXNetworkStreamReader
     UNIXNetworkStreamWriter
    TCPIPV6NetworkStream
     TCPIPV6NetworkStreamReader
     TCPIPV6NetworkStreamWriter
    TCPIPNetworkStream
     TCPIPNetworkStreamReader
     TCPIPNetworkStreamWriter

@end example

@node FileStream, , Stream, Classes

@iftex
@section @code{FileStream} Class
@end iftex
@ifnottex
@subheading @code{FileStream} Class
@end ifnottex
@cindex @code{FileStream} class

@code{FileStream} and its subclasses contain methods and variables
that read and write to files and other I/O devices.

@subheading Instance Variables

@table @code
@item streamMode (Class Integer)
File permissions mode.
@item streamDev   (Class Integer)
Device ID of a file.
@item streamRdev  (Class Integer)
Device ID if a special file.
@item streamSize  (Class LongInteger)
File size in bytes.
@item streamAtime (Class LongInteger)
Time of last file access.
@item streamMtime (Class LongInteger)
Time of last file modification.
@item streamCtime (Class LongInteger)
Time of last file status change.
@item streamPos   (Class LongInteger)
Offset of read or write operation in the file,
if a regular file.
@item streamErrno
System error number of the last file operation, 
EOF at the end of the file, or 0 on success.
@item streamPath
A @code{String} object, containing the path name of a 
regular file.
@end table

@subheading Class Variables

None.

@subsubheading Instance Methods

@table @code
@cindex @mnm{=} instance method @idxclscite{FileStream}
@item @mnm{=} (@var{arg})
Assign the value of the file stream in the argument to the receiver.  
This method does not duplicate the file handle.

@cindex closeStream instance method @idxclscite{FileStream}
@item @mnm{closeStream} (void)
Close the receiver's input file stream.  Note that @code{closeStream} does 
@emph{not} delete the receiver object.  You must call @code{delete} 
(Class Object) to delete the object explicitly.  Deleting global 
and local objects is still not complete - you must check the receiver
and argument stacks, and the local variables of the function or
method, to make sure that the object is removed from its dictionary.

@cindex  @mnm{deleteFile} instance method @idxclscite{FileStream}
@item deleteFile (@code{String} @var{file_path})
Deletes the file given as the argument.  If the deletion is not
successful, the method raises a @code{SystemErrnoException} which
an application can check for.

@cindex @mnm{exists} instance method @idxclscite{FileStream}
@item @mnm{exists} (@code{char *}@var{__path_name})
Return @code{TRUE} if the file exists, @code{FALSE} otherwise.

@cindex @mnm{isDir} instance method @idxclscite{FileStream}
@item @mnm{isDir} (@code{void})
Return an @code{Integer} object that evaluates to @code{TRUE} if the
receiver is a directory, @code{FALSE} otherwise.

@cindex @mnm{renameFile} instance method @idxclscite{FileStream}
@item @mnm{renameFile} (@code{String} @var{oldname}, @code{String} @var{newname})
Renames the file named by @var{oldname} to @var{newname}.  Raises
a @code{SystemErrnoException} if renaming the file causes an error.

@cindex @mnm{seekTo} instance method @idxclscite{FileStream}
@item seekTo (@code{Integer} @var{file_pos})
Reposition the file's reading and writing position indicator at
@var{file_pos}.  If the request is unsuccessful, the method raises a
@code{SystemErrnoException} that a program can check for.

@cindex @mnm{seekToBeginning} instance method @idxclscite{FileStream}
@item seekToBeginning (@code{void})
Reposition the file's reading and writing position indicator at the 
beginning of a file.  If the request is unsuccessful, the method
raises a @code{SystemErrnoException} that a program can check for.

@cindex @mnm{seekToEnd} instance method @idxclscite{FileStream}
@item seekToEnd (@code{void})
Reposition the file's reading and writing position indicator at the 
end of a file.  If unsuccessful, the method
raises a @code{SystemErrnoException} that programs can check for.

@cindex @mnm{size} instance method @idxclscite{FileStream}
@item @mnm{size} (@code{void})
Returns the size of the receiver's file as a @code{LongInteger}.

@cindex @mnm{statFile} instance method @idxclscite{FileStream}
@item @mnm{statFile} (@code{String} @var{file_path})
A wrapper method for the C @code{stat(2)} function.  This method fills
in the receiver stream's @code{streamMode}, @code{streamDev},
@code{StreamRdev}, @code{streamSize}, @code{streamAtime},
@code{streamMtime}, and @code{streamCtime} instance variables.
The stream does not need to be opened on the file given by
@var{file_path}.

The method returns an @code{Integer} with a value of @samp{0} on
success, or if an error occurs, returns @samp{-1} and raises a
@code{SystemErrnoException}.

@cindex @mnm{statStream} instance method @idxclscite{FileStream}
@item @mnm{statStream} (@code{void})
Another wrapper method for the C @code{stat(2)} function.  The method
fills in the @code{streamMode}, @code{streamDev}, @code{StreamRdev},
@code{streamSize}, @code{streamAtime}, @code{streamMtime}, and
@code{streamCtime} instance variables of the receiver, an open file
stream.

The method returns an @code{Integer} with a value of @samp{0} on
success, or if an error occurs, returns @samp{-1} and raises a
@code{SystemErrnoException}.

@cindex @mnm{streamEof} instance method @idxclscite{FileStream}
@item streamEof (@code{void})
Returns a non-zero @code{Integer} object if at the end of the receiver's
file stream, a zero-value @code{Integer} otherwise.

@end table

@subheading Class Methods

None.

@node DirectoryStream, ReadFileStream, , Classes
@iftex
@section @code{DirectoryStream} Class
@end iftex
@ifnottex
@subheading @code{DirectoryStream} Class
@end ifnottex
@cindex @code{DirectoryStream} class

The @code{DirectoryStream} class contains methods 
for creating and deleting directories, and for reading
files in directories.

On machines which have library support for file globbing,
@code{DirectoryStream} provides methods that read directories and
files that match patterns which contain metacharacters like @samp{*},
@samp{?}, and @samp{[}.  This is in addition to whatever file pattern
expansion the shell performs on file patterns provided on the command
line.  See below for more details.

@subsubheading Metacharacter Expansion.

If a command provides a file specification that contains a metacharacter,
often the shell expands the pattern into a list of files that the
program receives in the function @code{main's} @code{argv} array.

If the command line provides a quoted metacharacter as one of the
program's arguments, however, the program can use the
@code{DirectoryStream} methods @mnm{globPattern} and @mnm{globCwd} to
expand the pattern into a list of filenames.

@example

$ myfileprog some_arg *    # The shell expands '*' into a list of files.

$ myfileprog some_arg '*'  # The shell adds a literal '*' to the app's
                           # arguments.
@end example

Not all shells provide metacharacter expansion before the program
executes @code{main}, however, and so the app should check for
metacharacters as arguments also.  The following example shows one way
to do this.

@example

List new fileNames;

String instanceMethod globFile (void) @{

  DirectoryStream new d;
  List new globFiles;

  if (d hasMeta self) @{  /* The argv entry contains a wildcard character. */
    d globPattern self, globFiles;
    globFiles map @{
      fileNames push self;
    @}
  @} else @{             /* The argv entry is an unambiguous file name. */
    fileNames push self;
  @}

@}

int main (int argc, char *argv[]) @{
  
  int i;

  for (i = 1; i < argc; ++i) @{
    argv[i] globFile;
  @}
  
  fileNames map @{
    printf ("%s\n", self);
  @}
@}

@end example

@cindex Directory mode
@subsubheading Directory Modes
@cindex @code{CTALK_DIRECTORY_MODE} macro
The default mode for new directories is @code{0755}
(@samp{drwxr-xr-x}) modified by the user's @code{UMASK}.  Programs can
change the default directory permissions by redefining the macro
@code{CTALK_DIRECTORY_MODE}.

@subsubheading Error Handling

The methods @code{chDir}, @code{mkDir}, and @code{rmDir} raise a
@code{SystemErrnoException} on error and return an @code{Integer} with
the value @code{-1}.

@subsubheading Instance Methods
@table @code

@cindex @mnm{chDir} instance method @idxclscite{DirectoryStream}
@item chDir (@code{char *}@var{dir})
Change to the directory @var{dir}.

@cindex @mnm{directoryList} instance method @idxclscite{DirectoryStream}
@item directoryList (@code{char *}@var{dirname}, @code{List} @var{dirlist})
List directory @var{dirname}, and store it in the @code{List} @var{dirlist}.
The order of the elements in the list depends on the operating system.
To expressly create a sorted directory listing, see the
@mnm{sortedDirectoryList} method.

@cindex @mnm{getCwd} instance method @idxclscite{DirectoryStream}
@item getCwd (@code{void})
Return the current directory as a @code{String} object.

@cindex @mnm{globPattern} instance method @idxclscite{DirectoryStream}
@item globPattern (@code{String} @var{file_name_pattern}, @code{List} @var{matching_file_names})
Adds the file names that match @var{file_name_pattern} to
@var{matching_file_names}.  This method uses the machine's @cite{glob}
library call, if it is available, to do the pattern matching.  If the
system doesn't support filename pattern matching in its C library, the
method prints a warning message and returns.  For more information
about how the machine expands file globbing patterns into file names,
refer to the @cite{glob(3)} and @cite{glob(7)} manual pages.

@cindex @mnm{hasMeta} instance method @idxclscite{DirectoryStream}
@item hasMeta (@code{String} @var{file_name_pattern})
Returns a @code{Boolean} value of True if @var{file_name_pattern}
contains one of the opening metacharacters @samp{*}, @samp{?},
or @samp{[}, False otherwise.

@cindex @mnm{mkDir} instance method @idxclscite{DirectoryStream}
@item mkDir (@code{char *}@var{directoryname})
Create the directory @var{directoryname}.

@cindex @mnm{rmDir} instance method @idxclscite{DirectoryStream}
@item rmDir (@code{char *}@var{directoryname})
Delete the directory @var{directoryname}.

@cindex @mnm{sortedDirectoryList} instance method @idxclscite{DirectoryStream}
@item sortedDirectoryList (@code{char *}@var{dirname}, @code{SortedList} @var{dirlist})
List directory @var{dirname}, and store it in the @code{SortedList} @var{dirlist}.
The members of the directory listing are stored in ascending order.

@end table

@node ReadFileStream, WriteFileStream, DirectoryStream, Classes

@iftex
@section @code{ReadFileStream} Class
@end iftex
@ifnottex
@subheading @code{ReadFileStream} Class
@end ifnottex
@cindex @code{ReadFileStream} class

The @code{ReadFileStream} class contains methods and objects
for reading files.

@subheading Instance Variables

None

@subheading Class Variables

@table @code
@cindex @code{stdinStream} @idxclscite{ReadFileStream}
@cindex @code{stdin}
@item stdinStream
The @code{stdinStream} object contains the value of the 
application's standard input channel.
@end table

@subsubheading Instance Methods

@table @code

@cindex @mnm{new} instance method @idxclscite{ReadFileStream}
@item @mnm{new} (@var{stream1}, @var{stream2}, @var{stream3},...)
Creates one or more new @code{ReadFileStream} objects with the
names given in the argument list; e.g.,

@example

ReadFileStream new stream1, stream2, stream3;

@end example


@cindex @mnm{openOn} instance method @idxclscite{ReadFileStream}
@item @mnm{openOn} (@code{String} @var{path})
Open file @var{path} with mode @samp{r} and set the receiver's 
value to the file input stream.

@cindex @mnm{readAll} instance method @idxclscite{ReadFileStream}
@item @mnm{readAll} (@code{void})
Returns a String with the contents of the receiver's file stream.

@cindex @mnm{readChar} instance method @idxclscite{ReadFileStream}
@item @mnm{readChar} (@code{void})
Returns a Character from the stream defined by the receiver, or 
@samp{EOF} at the end of the input.

@cindex @mnm{readFormat} instance method @idxclscite{ReadFileStream}
@item @mnm{readFormat} (@code{char *}@var{fmt}, ...)
Read formatted input from the receiver and store in the objects given
as arguments.

@cindex @mnm{readLine} instance method @idxclscite{ReadFileStream}
@item @mnm{readLine} (@code{void})
Returns a String of characters up to and including the next
newline of the stream defined by the receiver, or a String 
containing @samp{EOF} at the end of the input.

@cindex @mnm{readRec} instance method @idxclscite{ReadFileStream}
@item @mnm{readRec} (@code{Integer} @var{record_length})
Return a @code{String} that contains @var{record_length}
characters from the receiver's input stream.

@cindex @mnm{readVec} instance method @idxclscite{ReadFileStream}
@item @mnm{readVec} (@code{LongInteger} @var{data_length})
Reads @var{data_length} bytes from the receiver stream and returns a
new @code{Vector} object that points to the data.  This is useful for
reading binary data which may have embedded NULLs and other non-human
readable characters.  @xref{Vector}.

@cindex @mnm{value} instance method @idxclscite{ReadFileStream}
@item @mnm{value}
Returns the receiver's @code{value} instance variable.

@end table


@subheading Class Methods

@table @code 
@cindex @mnm{classInit} method @idxclscite{ReadFileStream}
@item classInit
Called automatically by @code{new} when the first
@code{ReadFileStream} object is created.  Initializes 
@code{stdinStream}.
@end table

@node WriteFileStream, , ReadFileStream, Classes
@iftex
@section @code{WriteFileStream} Class
@end iftex
@ifnottex
@subheading @code{WriteFileStream} Class
@end ifnottex
@cindex @code{WriteFileStream} class

Class @code{WriteFileStream} provides objects and methods for writing
to files, including the application's @code{stdout} and @code{stderr}
output channels.

Because the way UNIX and Linux file stream modes work, a
WriteFileStream opens file non-destructively; that is, for reading and
writing, which means that programs can actually perform both reads and
writes from a WriteFileStream.  

All of the methods for reading files are defined in ReadFileStream
class, however. @xref{ReadFileStream}.  It's safer to handle existing
files when they are opened for reading; i.e., as a
@code{ReadFileStream} object.

That means @mnm{openOn} won't truncate an existing file.  To start
with a new file, use @mnm{deleteFile} (class @code{FileStream}).
@xref{FileStream}.

In that case, and also any time that @mnm{openOn} doesn't find a file
with that path name, it creates the file first.

@example

  writeFile deleteFile "my/file/path";
  writeFile openOn "my/file/path";

@end example

To append to an existing file, use @mnm{seekToEnd} (also in
@code{FileStream} class).  @xref{FileStream}.

@example

  writeFile openOn "my/file/path";
  writeFile seekToEnd;
  writeFile writeStream appendLine;
  writeFile closeStream;

@end example

@subheading Instance Variables

None

@subheading Class Variables

@table @code
@cindex @code{stdoutStream} @idxclscite{WriteFileStream}
@cindex @code{stdout}
@item stdoutStream
The @code{stdoutStream} object contains the application's 
standard output channel.

@cindex @code{stderrStream} @idxclscite{WriteFileStream}
@cindex @code{stderr}
@item stderrStream
The @code{stderrStream} object contains the application's 
standard error channel.
@end table

@subsubheading Instance Methods

@table @code

@cindex @mnm{new} method @idxclscite{WriteFileStream}
@item @mnm{new} (@var{stream1}, @var{stream2}, @var{stream3}, ...;)
Creates one or more new @code{WriteFileStream} objects with
the names given in the argument list; e.g.,

@example

WriteFileStream new stream1, stream2, stream3;

@end example

@cindex @mnm{openOn} method @idxclscite{WriteFileStream}
@item @mnm{openOn} (@code{String} @var{path_name})
Open file @var{path} and set the receiver's value to the file output
stream.  The file is created if it does not exist.  Raises a
@code{systemErrnoException} if an error occurs.

@cindex @mnm{printOn} method @idxclscite{WriteFileStream}
@item @mnm{printOn} (@code{char *}@var{fmt}, ...)
Format and print the method's arguments to the receiver, which must be
a @code{WriteFileStream} object that has been opened with @mnm{openOn.}

@cindex @mnm{value} method @idxclscite{WriteFileStream}
@item @mnm{value}
Returns the receiver's @code{value} instance variable.

@cindex @mnm{writeChar} method @idxclscite{WriteFileStream}
@item @mnm{writeChar} @var{char}
Writes @var{char} to the receiver's output file stream.

@anchor{writeFormat--class WriteFileStream}
@cindex @mnm{writeFormat} method @idxclscite{WriteFileStream}
@item @mnm{writeFormat} (@code{char *}@var{fmt}, ...)
Writes its arguments to the receiver using format @var{fmt}.

@cindex @mnm{writeStream} method @idxclscite{WriteFileStream}
@item @mnm{writeStream} @var{string}
Write @var{string} to the receiver's output file stream.

@cindex @mnm{writeVec} instance method @idxclscite{WriteFileStream}
@item @mnm{writeVec} (@code{Vector} @var{vector_object})
Write the contents of @var{vector_object} to the receiver stream.
The length of the data written is determined by @var{vector_object's}
@code{length} instance variable.  This allows the method to write
binary data that may contain NULLs and other non-human readable
characters. @xref{Vector}.
@end table

@node TerminalStream, , , Classes
@iftex
@section @code{TerminalStream} Class
@end iftex
@ifnottex
@subheading @code{TerminalStream} Class
@end ifnottex
@cindex @code{TerminalStream} class

@code{TerminalStream} is the superclass of terminal classes that provide
terminal and console input and output capabilities.

This class implements the input queue for its subclasses.  The queue
is a @code{List} object whose members are @code{InputEvent} objects.
@xref{InputEvent}.

@subsubheading Instance Variables
@table @code
@cindex @code{inputQueue} instance variable @idxclscite{TerminalStream}
@item inputQueue
A @code{List} contains that contains @code{InputEvent} objects.
@cindex @code{inputQueueMax} instance variable @idxclscite{TerminalStream}
@item inputQueueMax
The maximum number of @code{InputEvent} objects in the @code{inputQueue}
@cindex @code{nIinputEvents} instance variable @idxclscite{TerminalStream}
@item nInputEvents;
The actual number of @code{InputEvent} objects in the @code{inputQueue}
@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{inputPending} method @idxclscite{TerminalStream}
@item @mnm{inputPending} (@code{void})
Returns @code{TRUE} if a terminal stream has pending input 
objects.

@cindex @mnm{isATty} method @idxclscite{TerminalStream}
@item @mnm{isATty} (@code{void})
Return @code{TRUE} if the receiver's stream is a tty device,
@code{FALSE} otherwise.

@cindex @mnm{nextInputEvent} method @idxclscite{TerminalStream}
@item @mnm{nextInputEvent} (@code{void})
Return the next @code{InputEvent} object from the stream's 
input queue.

@cindex @mnm{queueInput} method @idxclscite{TerminalStream}
@item @mnm{queueInput} (@code{void})
Turn on queueing of input events.      

@cindex @mnm{queueInputEvent} method @idxclscite{TerminalStream}
@item @mnm{queueInputEvent} (@code{void})
Queue this input event.
@end table

@node ANSITerminalStream, , , Classes
@iftex
@section @code{ANSITerminalStream} Class
@end iftex
@ifnottex
@subheading @code{ANSITerminalStream} Class
@end ifnottex
@cindex @code{ANSITerminalStream} class

@code{ANSITerminalStream} objects and their methods provides basic I/O
capabilities for consoles that use standard input and output input, as
well as serial terminals.

@code{ANSITerminalStream} also provides basic input translation and
output formatting for ANSI, VT100, XTerm, and similar terminal types.

@code{ANSITerminalStream} does not provide curses-like screen
buffering methods.  The class's output methods output characters
correctly whether the terminal is in canonical or raw mode.  

If a program sets the terminal to raw mode (either with the
@mnm{rawMode} or @mnm{getCh} methods), it should also output characters
with @mnm{printOn}, and restore the terminal before exiting, as this
example illustrates.
@c test/expect/examles/ansiterminalstream1.c
@example
int main () @{
  ANSITerminalStream new term;
  Character new c;

  term rawMode;
  term clear;
  term gotoXY 1, 1;

  while ((c = term getCh) != EOF)
    term printOn "%c", c;

  term restoreTerm;
@}
@end example

If a program needs to handle cursor and other non-alphanumeric keys,
then it must open the @code{TerminalStream} input queue (with the
@mnm{openInputQueue} method) and read input events.
@xref{TerminalStream}.  

At present, Ctalk recognizes the following input event classes.
@example
KBDCHAR        # ASCII Characters
KBDCUR         # Cursor Keys.  
@end example

When reading an @code{InputEvent} (with @mnm{nextInputEvent} in
@code{TerminalStream} class), the event class is stored in the
@code{eventClass} instance variable of the @code{InputEvent} object.

Here is an example of a program that opens a terminal input queue and 
reads characters by retrieving input event objects from the queue.
@c test/expect/examples/ansiterminalstream2.c
@example
int main () @{
  ANSITerminalStream new term;
  Character new c;
  InputEvent new iEvent;

  term rawMode;
  term clear;
  term cursorPos 1, 1;
  term openInputQueue;

  while ((c = term getCh) != EOF) @{
    iEvent become (term nextInputEvent);
    if (iEvent eventClass == KBDCHAR) @{
      term printOn "<KEY>%c", iEvent eventData;
    @}
    if (iEvent eventClass == KBDCUR) @{
      term printOn "<CURSOR>%c", iEvent eventData;
    @}
  @}
@}
@end example
Because @code{ANSITerminalStream} objects wait until the user has
typed a key, programs can read input events synchronously, but
programs that use other input stream classes may read the input queue
asynchronously.

Newly created ANSITerminalStream objects use standard input and
standard output as their file streams.  Programs that read and write
to serial terminals can open the terminal's serial line with
@mnm{openOn}, and set the communication parameters with @mnm{setTty},
as in this example.
@c test/expect/examples/ansiterminalstream3.c
@example
int main () @{
  ANSITerminalStream new term;
  SystemErrnoException new s;

  term openOn "/dev/ttyS1";
  if (s pending)
    s handle;

  term setTty 9600, 8, N, 1;
  term printOn "Hello, world!\r\nHello, world!\r\n";
  term closeStream;
@}
@end example

However, programs also need to take note of the differences between
xterms, console displays, and serial terminals. For example, some
serial terminals won't send an @samp{ESC} (@code{0x1b} hex) character
until another character is typed at the terminal to flush the
terminal's output.  Also, programs should not depend on a particular
terminal's newline translation protocol, and some terminals echo tab
characters without special configuration.  Some terminal parameters
are tunable in the @code{ANSITerminalStrea} class, but if a program
needs special character handling, you may need to write a subclass of
@code{ANSITerminalStream} for a particular terminal.

@subsubheading Instance Variables
@table @code
@cindex @code{inputHandle} instance variable @idxclscite{ANSITerminalStream}
@item inputHandle
A @code{ReadFileStream} object that contains the terminal's input 
stream.  The handle is initialized to standard input when the
@code{ANSITerminalStream} object is created.  Also refer to the
information for @code{outputHandle}, below.

@cindex @code{outputHandle} instance variable @idxclscite{ANSITerminalStream}
@item outputHandle
A @code{WriteFileStream} object that contains the terminal's output
stream.  The handle is initialized to standard output when the
@code{ANSITerminalStream} object is created.  Programs can use the
methods @mnm{openOn} and @mnm{setTty} (below), to open and configure
handles for serial terminals.

In practice, objects that are instances of @code{ANSITerminalPane} and
its subclasses use the @code{inputHandle} stream for both input and
output with serial terminals, but programs can configure
@code{ouputHandle} independenly if necessary.

@cindex @code{queueInput} instance variable @idxclscite{ANSITerminalStream}
@item queueInput
True if queueing input events.

@cindex @code{rawModeFlag} instance variable @idxclscite{ANSITerminalStream}
@item rawModeFlag
True if the terminal stream parameters are set to raw mode.

@cindex @code{termioCIFlag} instance variable @idxclscite{ANSITerminalStream}
@cindex @code{termioCOFlag} instance variable @idxclscite{ANSITerminalStream}
@cindex @code{termioCLFlag} instance variable @idxclscite{ANSITerminalStream}
@cindex @code{termioCCFlag} instance variable @idxclscite{ANSITerminalStream}
@item termioCIFlag
@item termioCOFlag
@item termioCLFlag
@item termioCCFlag
Terminal settings.  These variables are set with the current terminal
parameters when creating an
@code{ANSITerminalStream} object with @mnm{new}, and restored by the 
@mnm{restoreTerm} method.
@cindex @code{ttyDevice} instance variable @idxclscite{ANSITerminalStream}
@item ttyDevice
A @code{String} containing the path terminal's device file, if
different than @code{stdinStream} and @code{stdoutStream}.  This
variable is currently unused.
@end table

@subsubheading Instance Methods

@table @code
@cindex @mnm{clear} method @idxclscite{ANSITerminalStream}
@item @mnm{clear} (@code{void})
Clear the terminal stream.

@cindex @mnm{closeStream} method @idxclscite{ANSITerminalStream}
@item @mnm{closeStream} (@code{void})
Close a terminal stream that was previously opened with @mnm{openOn},
below. 

@cindex @mnm{cursorPos} method @idxclscite{ANSITerminalStream}
@item @mnm{cursorPos} (@code{int} @var{row}, @code{int} @var{column})
Set the cursor position to @var{row}, @var{column}.  The upper
left-hand corner of screen is @code{1,1}.

@cindex @mnm{getCh} method @idxclscite{ANSITerminalStream}
@item @mnm{getCh} (@code{void})
Get a character from the terminal without echoing it.  This method
handles @kbd{C-c}, @kbd{C-d}, and @kbd{C-z} control characters by
exiting.  This method calls @mnm{rawMode}, so the application must
call @mnm{restoreTerm} before exiting.

@cindex @mnm{gotoXY} method @idxclscite{ANSITerminalStream}
@item @mnm{gotoXY} (@code{int} @var{row}, @code{int} @var{column})
Set the cursor position to @var{row}, @var{column}.  The upper
left-hand corner of screen is @code{1,1}.  This method is a synonym for 
@mnm{cursorPos}, above.

@cindex @mnm{new} method @idxclscite{ANSITerminalStream}
@item @mnm{new} (@var{stream1}, @var{stream2}, ... @var{streamN}; )
Create one or more new @code{ANSITerminalStream} objects and initialize
their input and output handles to @code{stdinStream}.
@xref{ReadFileStream}, and @code{stdoutStream}. @xref{WriteFileStream}.
For example,

@example

ANSITerminalStream new stream1, stream2;

@end example

@cindex @mnm{openInputQueue} method @idxclscite{ANSITerminalStream}
@item @mnm{openInputQueue} (@code{void})
Begin queueing input events.  @xref{InputEvent}.

@cindex @mnm{openOn} method @idxclscite{ANSITerminalStream}
@item @mnm{openOn} (@code{char *}@var{tty_device_name})
Open a tty device for the receiver.

@cindex @mnm{printOn} method @idxclscite{ANSITerminalStream}
@item @mnm{printOn} (@code{char *}@var{fmt}, ...)
Print the formatted output to the receiver's output stream.

@cindex @mnm{rawMode} method @idxclscite{ANSITerminalStream}
@item @mnm{rawMode} (@code{void})
Set the terminal input and output streams to raw mode.  

@cindex @mnm{readChar} method @idxclscite{ANSITerminalStream}
@item @mnm{readChar} (@code{void})
Read a character from the receiver's input stream.

@cindex @mnm{readLine} method @idxclscite{ANSITerminalStream}
@item @mnm{readLine} (@code{void})
Read a line of text from the receiver's input stream and return
a @code{String} object with the text.

@cindex @mnm{restoreTerm} method @idxclscite{ANSITerminalStream}
@item restoreTerm (@code{void})
Restore the terminal parameters to the values when the
@code{ANSITerminalStream} object was created.  Applications must call this
method after using the @mnm{getCh} and @mnm{rawMode} methods, or the
terminal may be unusable after the the application exits.

@cindex @mnm{setGraphics} method @idxclscite{ANSITerminalStream}
@item @mnm{setGraphics} (@code{char} @var{attribute})
Set the graphics attribute for the following characters.  The 
@var{attribute} argument can be one of the following characters.
@example
0       Attributes Off
1       Bold
4       Underscore
5       Blink
7       Reverse
@end example

@cindex @mnm{setTty} method @idxclscite{ANSITerminalStream}
@item @mnm{setTty} (@code{int} @var{speed}, @code{int} @var{data_bits}, @code{char} @var{parity}, @code{int} @var{stop_bits})
Set the communication parameters of a terminal device opened with 
@mnm{openOn}, above.

@end table

@node Win32TerminalStream, , , Classes
@iftex
@section @code{Win32TerminalStream} Class
@end iftex
@ifnottex
@subheading @code{Win32TerminalStream} Class
@end ifnottex
@cindex @code{Win32TerminalStream} class

The @code{Win32TerminalStream} class provides keyboard input
capabilities for Win32 @code{cmd.exe} consoles.  It also provides
basic output formatting capabilities using DJGPP's @file{conio.h}
functions.  This class does not provide curses-style output buffering.

This class is not strictly a stream, and is likely to remain limited
to displays in the @code{cmd.exe} window until Ctalk can implement a
genuine @cite{fork(3)} system call for non-POSIX systems.

@code{Win32TerminalStream} simulates raw terminal I/O using BDOS and C
library function calls.  If the program needs to handle extended keys
like cursor and keypad keys, it should open the @code{TerminalStream}
input queue (with the @mnm{openInputQueue} method) and read input
events.  @xref{TerminalStream}.  

At present, Ctalk recognizes the following input event classes.  In
@code{Win32TerminalStream} class, the @mnm{getCh} method generates a
@code{KBDCUR} input events for all extended keys.
@example
KBDCHAR        # ASCII Characters
KBDCUR         # Extended keys (first character read returns 0).
@end example

For examples of how to read characters from the keyboard, see the
program listings in the @code{ANSITerminalStream} class section of the
manual.  @xref{ANSITerminalStream}.

@subsubheading Instance Variables
@table @code
@cindex @code{queueInput} instance variable @idxclscite{Win32TerminalStream}
@item queueInput
True if queueing input events.
@cindex @code{shiftState} instance variable @idxclscite{Win32TerminalStream}
The current state of the keyboard's modifier keys.  Set by 
the @mnm{biosKey} and @mnm{getShiftState} methods, below.
@end table

@subsubheading Instance Methods

@table @code
@cindex @mnm{biosKey} method @idxclscite{Win32TerminalStream}
Waits for a key and returns the scan code of a BIOS Int 16h, function
0 call.  Also sets the shift state in the receiver's @code{shiftState}
instance variable.  See the @mnm{getShiftState} method, below.

@cindex @mnm{cGetStr} method @idxclscite{Win32TerminalStream}
@item cGetStr (void)
Returns a @code{String} object that contains input typed by
the user.  The input is echoed to the console.

@cindex @mnm{clear} method @idxclscite{Win32TerminalStream}
@item clear (void)
Clears the terminal window and moves the cursor to the upper 
left-hand corner.

@cindex @mnm{cPutStr} method @idxclscite{Win32TerminalStream}
@item cPutStr (@code{char *}@var{str}
Prints @var{str} to the console at the current cursor position.

@cindex @mnm{cusorPosY} method @idxclscite{Win32TerminalStream}
@item cusorPos (@code{int} @var{x}, @code{int}@var{y})
Positions the cursor at character position @var{x}, @var{y}.  
The upper left-hand corner of the screen is row 1, column 1.
This is a synonym for @mnm{gotoXY,} below.

@cindex @mnm{getCh} method @idxclscite{Win32TerminalStream}
@item @mnm{getCh} (@code{void})
Essentially a wrapper for the BDOS character input without echo
function.  This method handles @kbd{C-c}, @kbd{C-d}, and @kbd{C-z} by
exiting the application.

@cindex @mnm{getShiftState} method @idxclscite{Win32TerminalStream}
@item getShiftState (@code{void})
Get the state of the keyboard's modifier keys with by calling
BIOS Int 0x16, function 12h.  Stores the result in the receiver's 
@code{shiftState} instance variable.

@cindex @mnm{gotoXY} method @idxclscite{Win32TerminalStream}
@item gotoXY (@code{int} @var{x}, @code{int}@var{y})
Positions the cursor at character position @var{x}, @var{y}.  
The upper left-hand corner of the screen is row 1, column 1.

@cindex @mnm{openInputQueue} method @idxclscite{Win32TerminalStream}
@item @mnm{openInputQueue} (@code{void})
Begin queueing input events.  @xref{InputEvent}.

@cindex @mnm{printOn} method @idxclscite{Win32TerminalStream}
@item @mnm{printOn} (@code{char *}@var{fmt}, ...)
Print the formatted output to the receiver's output stream.

@cindex @mnm{screenColor} @idxclscite{Win32TerminalStream}
@item screenColor (@code{char *}@var{fgcolor}, @code{char*}@var{bgcolor})
Sets the window's foreground and background colors for following 
writes using @mnm{cPutStr,} above.  The arguments are class
@code{String,} and may have the following values.
@example
black
blue
green
cyan
red
magenta
brown
lightgray
darkgray
lightblue
lightgreen
lightcyan
lightred
yellow
white
@end example

@end table

@node X11TerminalStream, NetworkStream, , Classes
@iftex
@section @code{X11TerminalStream} Class
@end iftex
@ifnottex
@subheading @code{X11TerminalStream} Class
@end ifnottex

@code{X11TerminalStream} objects and methods handle input
events from X Window System displays.  Ctalk's X11 support
focuses on the windows themselves, so this class should
almost always be used with a @code{X11Pane} object.  
@xref{X11Pane}.

Here is an example program that uses @code{InputEvent} objects created
by the window's input stream, @code{xPane}, to configure the
dimensions of the pane's window.  The @code{X11TerminalStream} object
is contained in the @code{X11Pane}'s @code{inputStream} instance
variable.
@example
int main () @{

  X11Pane new xPane;
  InputEvent new e;

  xPane initialize 25, 30, 100, 100;
  xPane map;
  xPane raiseWindow;
  xPane openEventStream;

  WriteFileStream classInit;

  while (TRUE) @{
    xPane inputStream queueInput;
    if (xPane inputStream eventPending) @{
      e become xPane inputStream inputQueue unshift;
      switch (e eventClass value) 
	@{
	case CONFIGURENOTIFY:
	  stdoutStream printOn "ConfigureNotify\t%d\t%d\t%d\t%d\n",
	    e xEventData1, 
	    e xEventData2, 
	    e xEventData3, 
	    e xEventData4;
	  stdoutStream printOn "Window\t\t%d\t%d\t%d\t%d\n",
	    xPane origin x, 
	    xPane origin y, 
	    xPane size x,
	    xPane size y;
	  break;
	case WINDELETE:
	  xPane deleteAndClose;
	  exit (0);
	  break;
	default:
	  break;
	@}
    @}
  @}
@}
@end example

When compiling this program, you might also need to add the directory
that contains the X include files to the include search path. For
example:
@example
$ ctcc -I /usr/include/X11 windemo.c -o windemo       # Recent Linux
@end example
Ctalk's libraries are linked with the system's X libraries during
installation if they are present, but applications may also need to
link with X libraries directly in some cases.

@subsubheading Event Classes
A @code{X11TerminalStream} object recognizes the following
input event classes, and returns the following information
in the @code{xEventData} instance variables, which are
defined in @code{InputEvent} class. @xref{InputEvent}.
@smallexample
Event Class     xEventData1 xEventData2 xEventData3 xEventData4 xEventData5
BUTTONPRESS     x           y           state       button      -
BUTTONRELEASE   x           y           state       button      -
KEYPRESS        x           y           state       keycode     x_keycode[1]
KEYRELEASE      x           y           state       keycode     x_keycode[1]
CONFIGURENOTIFY x           y           height      width       border
MOVENOTIFY      x           y           height      width       border
RESIZENOTIFY    x           y           height      width       border
MOTIONNOTIFY    x           y           state       is_hint     -
MAPNOTIFY       event       window      -           -           -
EXPOSE          x           y           width       height      count
SELECTIONREQUEST -          -           -           -           -
SELECTIONCLEAR  -           -           -           -           -
WINDELETE       -           -           -           -           -
@end smallexample
[1] The values of X keycodes are defined in X11/keysymdefs.h.

The @code{x} and @code{y} coordinates of the key and button
events are relative to the window's origin.  The @code{x}
and @code{y} coordinates of a @code{CONFIGURENOTIFY} event
are relative to the origin of the root window, normally the upper
left-hand corner of the display.

The @code{MOVENOTIFY} and @code{RESIZENOTIFY} events are
both derived from @code{CONFIGURENOTIFY} events, depending
on whether the receiver's window was moved or resized. 

@subsubheading Instance Variables
@table @code
@cindex @code{inputPID} instance variable @idxclscite{X11TerminalStream}
@item inputPID
The process ID of the @code{X11TerminalStream} event
handler.
@cindex @code{clientFD} instance variable @idxclscite{X11TerminalStream}
@item clientFD
The file descriptor that the @code{X11TerminalStream} event handler
uses when communicating with the main window's process.
@cindex @code{eventMask} instance variable @idxclscite{X11TerminalStream}
@item eventMask
An @code{Integer} that contains the OR'd values of the window system
events that the program wants to be notified of.  The window system
events are listed in the table above.  If @code{eventMask's} value is
zero, then the event handler assumes that the program wants to
receiver all window system events.  Any non-zero value, however,
causes the program to receive only those events; for example:

@example

myMainWindow inputStream eventMask = WINDELETE|KEYPRESS;

@end example

In this case the program only receives notice of key presses
(@code{KEYPRESS} events) and requests from the GUI desktop to close
the window (@code{WINDELETE} events) and exit the program.

@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{openInputClient} method @idxclscite{X11TerminalStream}
@item openInputClient (@code{void})
Open the X input handler.  This method is normally used by
@code{X11Pane} class's @mnm{openEventStream} method. @xref{X11Pane}.

@cindex @mnm{parentPane} method @idxclscite{X11TerminalStream}
@item parentPane (@code{void})
Return the receiver's @code{X11Pane} parent object if present.

@cindex @mnm{queueInput} method @idxclscite{X11TerminalStream}
@item queueInput (@code{void})
Queue window system events as @code{InputEvent}
objects in the receiver's @code{inputQueue} instance
variable.  The @code{inputQueue} instance variable is
inherited from @code{TerminalStream} class. @xref{TerminalStream}.
@end table

@node NetworkStream, TCPIPNetworkStream, X11TerminalStream, Classes
@iftex
@section @code{NetworkStream} Class
@end iftex
@ifnottex
@subheading @code{NetworkStream} Class
@end ifnottex
@cindex @code{NetworkStream} class

@code{NetworkStream} is the superclass of objects that use socket
connections to send and receive data.  The subclasses of
@code{NetworkStream} provide support for connections between processes
within a program, between programs on the same machine or a local
network, or between Internet sites.

Each of @code{NetworkStream's} subclasses, listed here, has its own
section.

@example

  TCPIPNetworkStream
    TCPIPNetworkStreamReader
    TCPIPNetworkStreamWriter
  TCPIPV6NetworkStream
    TCPIPV6NetworkStreamReader
    TCPIPV6NetworkStreamWriter
  UNIXNetworkStream
    UNIXNetworkStreamReader
    UNIXNetworkStreamWriter

@end example

@node TCPIPNetworkStream, TCPIPNetworkStreamReader, NetworkStream, Classes
@iftex
@section @code{TCPIPNetworkStream} Class
@end iftex
@ifnottex
@subheading @code{TCPIPNetworkStream} Class
@end ifnottex
@cindex @code{TCPIPNetworkStream} class

@code{TCPIPNetworkStream} class contains methods for sockets
that are used for both writing and reading.

Methods that are specific to programs that read from sockets are
defined in @code{TCPIPNetworkStreamReader} class,
@xref{TCPIPNetworkStreamReader}, and methods that work with programs
that write to network connections are defined in
@code{TCPIPNetworkStreamWriter} class @xref{TCPIPNetworkStreamWriter}.

Here is a program that writes data to a network connection.

@c demos/net/ip4writer.ca
@example

static char *msg = "First connect.\n";

int main (int argc, char **argv) @{
  SystemErrnoException new ex;
  TCPIPNetworkStreamWriter new client;

  if (argc != 2) @{
    printf ("Usage: ip6writer <server_hostname>\n");
  @}
  client openOn argv[1];
  client writeText msg;
  if (ex pending) @{
    ex handle;
  @}

  client closeSock;
@}

@end example

And here is the corresponding program that reads the data
from the network connection and displays it.

@c demos/net/ip4reader.ca
@example

int main () @{
  TCPIPNetworkStreamReader new server;
  Exception new ex;
  String new output;
  int newsocket;

  server openOn;

  newsocket = server acceptSock;

  if (newsocket > 0) @{
    output = server readText newsocket;
    if (ex pending) @{
      ex handle;
    @}
    printf ("%s\n", output);
    server closeSock newsocket;
  @} else if (ex pending) @{
    ex handle;
  @} else @{
    printf ("Connection timed out.\n");
  @}
  
  server closeSock;
@}

@end example

@subsubheading Instance Variables
@table @code
@item sock
@cindex @code{sock} instance variable @idxclscite{TCPIPNetworkStream}
An @code{Integer} that contains the file handle number of the
socket created when a network connection is opened.
@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{addrInfo} instance method @idxclscite{TCPIPNetworkStream}
@item @mnm{addrInfo} (@code{String} @var{hostName}, @code{String} @var{canonicalNameOut}, @code{List} @var{addrsOut}
Performs a lookup of @var{hostName's} IP addresses.  If the lookup is
successful, returns the host's canonical name in @var{canonNameOut}
and each of the host's addresses as a string in @var{addrsOut}.  The
method's return value is an @code{Integer} with the number of
addresses found.

If the lookup causes an error, the method raises an @code{Exception}
(@emph{not} a @code{SystemErrnoException}) and returns 0.


@cindex @mnm{closeSock} instance method @idxclscite{TCPIPNetworkStream}
@item @mnm{closeSock} (@code{void})
@item @mnm{closeSock} (@code{Integer} @var{sock_fh})
With no arguments, closes the receiver's socket.  With one
argument, closes the socket given as the argument.  If
closing a socket causes an error, the method raises a
@code{SystemErrnoException}.

@cindex @mnm{createSocketBasic} instance method @idxclscite{TCPIPNetworkStream}
@item @mnm{createSocketBasic} (@code{void})
Creates a socket with the domain AF_INET and the protocol SOCK_STREAM,
and sets the receiver's sock instance variable to the new socket's
file handle number, an Integer, and then returns the socket's file
handle number.  If not successful, the method raises a
SystemErrnoException and returns 0.

@cindex @mnm{hostToAddress} instance method @idxclscite{TCPIPNetworkStream}
@item @mnm{hostToAddress} (@code{String} @var{hostname})
Given the name of a network host as the argument, the method returns
a @code{String} containing the host's dotted quad Internet address.

If the hostname lookup doesn't return any results, the method raises
an @code{Exception} (@emph{not} a @code{SystemErrnoException}) and
returns an empty @code{String}.

@example

#include <stdio.h>   /* contains printf prototype */

int main () @{
  TCPIPNetworkStream new net;
  String new address;

  address = net hostToAddress "MyHostName"; /* Substitute your host's name. */

  printf ("%s\n", address);
@}

@end example


@cindex @mnm{readText} instance method @idxclscite{TCPIPNetworkStream}
@item @mnm{readText} (@code{void})
@item @mnm{readText} (@code{Integer} @var{sock_fh})
Reads a socket's input and returns the input as a @code{String} object.
With no arguments, the method uses the receiver's socket file handle,
which is normally assigned by @mnm{createSocketBasic}, above.

If a socket file handle is given as the argument, then the method
performs the read on that handle.  This is useful when performing
reads after a call to @mnm{acceptSock} or a similar
method. @xref{TCPIPNetworkStreamReader}.

If an error occurs while reading, the methods raise a
@code{SystemErrnoException}.

@cindex @mnm{readVec} instance method @idxclscite{TCPIPNetworkStream}
@item @mnm{readVec} (@code{Integer} @var{sock_fh}, @code{Vector} @var{data_vec_out})
Reads binary data from the socket given as the first argument and
returns the data in the @code{Vector} object give as the second
argument.

The method raise a @code{SystemErrnoException} if an error occurs
while reading.

This example is a simple server that receives image data and writes
it to a file.

@example

int main () @{
  TCPIPNetworkStreamReader new server;
  SystemErrnoException new ex;
  Vector new output;
  WriteFileStream new writeF;
  int newsocket;
  char *socket_out;

  server openOn;

  newsocket = server acceptSock;  /* INADDR_ANY */

  if (newsocket > 0) @{
    server readVec newsocket, output;
    if (ex pending) @{
      ex handle;
    @}
    server closeSock newsocket;
  @} else if (ex pending) @{
    ex handle;
  @} else @{
    printf ("Connection timed out.\n");
  @}

  server closeSock;

  writeF openOn "image-copy.jpeg";
  writeF writeVec output;
  writeF closeStream;
@}

@end example

Here is the corresponding client program that transmits the image
data.

@example

int main () @{
  SystemErrnoException new ex;
  TCPIPNetworkStreamWriter new client;
  ReadFileStream new readF;
  Vector new photo;
  LongInteger new imageSize;

  readF openOn "image.jpeg";

  readF statStream;
  imageSize = readF streamSize;

  photo = readF readVec imageSize;

  readF closeStream;

  client openOn "127.0.0.1"; /* Edit with the reciever's actual network
                                address. */

  client writeVec photo;
  if (ex pending) @{
    ex handle;
  @}

  client closeSock;
@}
@end example

@cindex @mnm{writeText} instance method @idxclscite{TCPIPNetworkStream}
@item @mnm{readText} (@code{String} @var{text})
Writes the @var{text} given as the argument to the reciever's socket.
If the number of bytes actually written isn't equal to the length
of @var{text}, then the method raises a @code{SystemErrnoException}.

@cindex @mnm{writeVec} instance method @idxclscite{TCPIPNetworkStream}
@item @mnm{readText} (@code{Vector} @var{data})
Writes the data contained in the argument to the receiver's socket.
The method raises an Exception if the argument is not a @code{Vector},
or a @code{SystemErrnoException} if an error occurs while writing.

Examples of client and server programs which handle binary data
are given in the entry for @mnm{readVec}, above.

@end table

@node TCPIPNetworkStreamReader, TCPIPNetworkStreamWriter, TCPIPNetworkStream, Classes
@iftex
@section @code{TCPIPNetworkStreamReader} Class
@end iftex
@ifnottex
@subheading @code{TCPIPNetworkStreamReader} Class
@end ifnottex
@cindex @code{TCPIPNetworkStreamReader} class

@code{TCPIPNetworkStreamReader} class defines methods and
instance variables that are used specifically for reading
data from network connections.

For example programs, refer to the @code{TCPIPNetworkStream} class
@xref{TCPIPNetworkStream}.

@subsubheading Instance Variables
@table @code
@cindex @code{timeout} instance variable @idxclscite{TCPIPNetworkStreamReader}
@item timeout
An @code{Integer} that contains the number of seconds to wait for
incoming connections.
@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{acceptSock} instance method @idxclscite{TCPIPNetworkStreamReader}
@item @mnm{acceptSock} (@code{void})
Waits for an incoming connection on the receiver's socket, and if
a connection is pending, returns the number of the socket that
communications will take place on.

If the connection times out, then the method returns 0.  The length
of time the method should wait for incoming connections is given
by the receiver's @code{timeout} instance variable.

If an error occurs, the method returns 0 and also raises a
@code{SystemErrnoException}.

@b{Note:} The method can handle peer connections if the operating
system supports it - binding listening sockets to specific addresses
is not uniformly supported among operating systems.  In these cases,
the method can also wait for connections using the constant
INADDR_ANY.

This is done by using the @mnm{openOn} method (below) with no network
address.

@example

  mySock openOn "127.0.0.1";   /* bind the socket to the
                                  local network connection. */
     
  mySock openOn;               /* bind a socket to listen for
                                  connections from any network
                                  address. */

@end example

In the second case, the @code{acceptSock} method can also function as
the core of a more conventional network server.

@cindex @mnm{openOn} instance method @idxclscite{TCPIPNetworkStreamReader}
@item @mnm{openOn} (@code{void})
@item @mnm{openOn} (@code{String} @var{address})
@item @mnm{openOn} (@code{String} @var{address}, @code{Integer} @var{port})
Creates the receiver's socket and binds it to receive messages from
the network @var{address} given as the argument.  If no network
address is given, the receiver's socket is bound to the constant
INADDR_ANY.

If no @var{port} argument is given, the socket is bound to
DEFAULT_TCPIP_PORT, which is defined in @flnm{classes/ctalkdefs.h},
and which you can set depending on the the systems' needs.

These methods raise an @code{Exception} if any of the networking
functions return an error.

@end table


@node TCPIPNetworkStreamWriter, TCPIPV6NetworkStream, TCPIPNetworkStreamReader, Classes
@iftex
@section @code{TCPIPNetworkStreamWriter} Class
@end iftex
@ifnottex
@subheading @code{TCPIPNetworkStreamWriter} Class
@end ifnottex
@cindex @code{TCPIPNetworkStreamWriter} class

The @code{TCPIPNetworkStreamWriter} class defines supporting methods
for programs that write to network connections.

For example programs, refer to the @code{TCPIPNetworkStream} class;
@xref{TCPIPNetworkStream}.

@subsubheading Instance Methods
@table @code
@cindex @mnm{openOn} instance method @idxclscite{TCPIPNetworkStreamWriter}
@item @mnm{openOn} (@code{String} @var{address})
@item @mnm{openOn} (@code{String} @var{address}, @code{Integer} @var{port})
Creates a socket and connects it to the network @var{address} given as
the argument.

If a @var{port} argument is given, the socket connects over that port;
otherwise, the socket connects via DEFAULT_TCPIP_PORT, which is defined
in @flnm{classes/ctalkdefs.h}, which you can adjust to suit the network's
needs.

These methods raise a @code{SystemErrnoException} if any of
the networking functions return an error.

@end table

@node TCPIPV6NetworkStream, TCPIPV6NetworkStreamReader, TCPIPNetworkStreamWriter, Classes
@iftex
@section @code{TCPIPV6NetworkStream} Class
@end iftex
@ifnottex
@subheading @code{TCPIPV6UNIXNetworkStream} Class
@end ifnottex
@cindex @code{TCPIPV6UNIXNetworkStream} class

The @code{TCPIPV6NetworkStream} class manages TCPIP version 6 stream
objects.  The class is a superclass of the
@code{TCPIPV6NetworkStreamReader} and
@code{TCPIPV6NetworkStreamWriter} classes, and the methods and
instance variables that are defined by this class are common to both
client and server programs.

Here is an example of simple IPv6 reader program.

@c demos/net/ip6reader.ca
@example

int main () @{
  SystemErrnoException new ex;
  TCPIPV6NetworkStreamReader new server, connection;
  String new data;

  server openOn;
  if (ex pending) @{
    ex handle;
  @}

  connection = server acceptSock;
  if (ex pending) @{
    ex handle;
  @}
  data = server readText connection;
  printf ("%s\n", data);

  server closeSock;
@}

@end example

And here is a simple program that writes a message to a
TCPIP v6 connection.

@c demos/net/ip6writer.ca
@example

static char *msg = "First connect.\n";

#include <ctalk/ctalkdefs.h>

int main (int argc, char **argv) @{
  SystemErrnoException new ex;
  TCPIPV6NetworkStreamWriter new client;

  if (argc != 2) @{
    printf ("Usage: ip6writer <server_hostname>\n");
  @}

  client openOn argv[1];
  if (ex pending) @{
    ex handle;
  @}

  client writeText msg;
  
  client closeSock;
@}

@end example


@subsubheading Instance Variables

@table @code
@cindex @code{sock} instance variable @idxclscite{TCPIPV6NetworkStream}
@item sock
An @code{Integer} that contains the system-assigned file handle number
of @code{TCPIPV6NetworkStreamReader} and
@code{TCPIPV6NetworkStreamWriter} objects.

@end table

@subsubheading Instance Methods

@table @code
@cindex @mnm{addrInfo} instance method @idxclscite{TCPIPV6NetworkStream}
@item addrInfo (@code{String} @var{hostname}, @code{String} @var{canonnameout}, @code{List} @var{addrsOut})
Performs a lookup of @var{hostname's} IPv6 addresses.  If the lookup
is successful, returns the host's canonical name in @var{canonnameout}
and each of the host's addresses as a string in @var{addrsOut}.  The
method's return value is an @code{Integer} with the number of
addresses found.

If the lookup causes an error, the method raises an @code{Exception}
(@emph{not} a @code{SystemErrnoException}) and returns 0.

@cindex @mnm{closeSock} instance method @idxclscite{TCPIPV6NetworkStream}
@item @mnm{closeSock} (@code{void})
@item @mnm{closeSock} (@code{Integer} @var{sockNum})
With no arguments, closes the receiver's socket.  If a socket file
handle number is given as the argument, closes that socket. If closing
the socket causes an error, the method raises a
@code{SystemErrnoException}.

@cindex @mnm{createSocketBasic} instance method @idxclscite{TCPIPV6NetworkStream}
@item @mnm{createSocketBasic}
Creates a new IPv6 socket and sets the receiver's @code{sock} instance
variable, an @code{Integer}, to the system-assigned file number, and
returns the @code{sock} instance variable. If an error occurs while
creating a socket, the method raises a @code{SystemErrnoException}
and returns 0.

@item readText (void)
@item readText (@code{Integer} @var{sock_fn})
@cindex @mnm{readText} instance method @idxclscite{TCPIPV6NetworkStream}
Read text from a network connection.  With no arguments, the value
of the receiver's @code{sock} instance variable provides the socket
file handle.  If one argument is given, the argument, an @code{Integer},
provides the file handle number.

These methods return a @code{String} with the contents of the received
message.  If an error occurs while reading, the methods raise a
@code{SystemErrnoException} and return @code{NULL}.

@item readVec (@code{Integer} @var{sock_fn}, @code{Vector} @var{resultVec})
@cindex @mnm{readVec} instance method @idxclscite{TCPIPV6NetworkStream}
Reads binary data from the socket handle @var{sock_fn} into
@var{resultVec}, and returns @var{resultVec}.  The method raises
a @code{SystemErrnoException} if an error occurs.

@item writeText (@code{String} @var{textArg})
@cindex @mnm{writeText} instance method @idxclscite{TCPIPV6NetworkStream}
Writes the @code{String} given as the argument to the
receiver's socket.  If the number of bytes written does not
match the length of @var{textArg}, the method raises a
@code{SystemErrnoException}.

@item writeVec (@code{Vector} @var{dataVec})
@cindex @mnm{writeVec} instance method @idxclscite{TCPIPV6NetworkStream}
Writes the contents of @var{DATAVEC} to the receiver's socket.  If
the number of bytes written does not match the length of the data,
the method raises a @code{SystemErrnoException}.

@end table

@node TCPIPV6NetworkStreamReader, TCPIPV6NetworkStreamWriter, TCPIPV6NetworkStream, Classes
@iftex
@section @code{TCPIPV6NetworkStreamReader} Class
@end iftex
@ifnottex
@subheading @code{TCPIPV6UNIXNetworkStreamReader} Class
@end ifnottex
@cindex @code{TCPIPV6UNIXNetworkStreamReader} class

@subsubheading Instance Variables
@table @code
@cindex @code{timeout} instance variable @idxclscite{TCPIPV6NetworkStreamReader}
@item timeout
An @code{Integer} that contains the number of seconds that the
@mnm{acceptSock} method (below) should wait for a connection.  The
default is 10 seconds.
@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{acceptSock} instance method @idxclscite{TCPIPV6NetworkStreamReader}
@item acceptSock (@code{void})
Listens for incoming connections on the socket that is bound to
a network address and port by a previous call to @mnm{openOn}.

If the program receives an incoming connection, @mnm{acceptSock}
creates a new socket to read data from the connection and returns the
socket number, an @code{Integer}, to the calling program.

If the method times out, it returns 0 to the calling program.  The
@code{timeout} instance variable determines the number of seconds
the method should wait for incoming connections.  The default is
10 seconds.

If an error occurs, the method returns -1 and raises a
@code{SystemErrnoException}.

@cindex @mnm{openOn} instance method @idxclscite{TCPIPV6NetworkStreamReader}
@item openOn (@code{void})
@item openOn (@code{Integer} @var{port})
@item openOn (@code{String} @var{hostName}, @code{Integer} @var{port})
Binds a @code{TCPIPV6NetworkStreamReader} object to the hostname and
port given as the arguments, if any.  The return value is the socket
handle number of the receiver, an @code{Integer}.

If no hostname or port is given, the method binds the socket to the
system constant @code{in6addr_any}, and the port defined by
DEFAULT_TCPIP_PORT, defined by the Ctalk library in the ctalkdefs.h
header file.

If an error occurs, these methods raise an @code{Exception}
and return 0.
@end table

@node TCPIPV6NetworkStreamWriter, UNIXNetworkStream, TCPIPV6NetworkStreamReader, Classes
@iftex
@section @code{TCPIPV6NetworkStreamWriter} Class
@end iftex
@ifnottex
@subheading @code{TCPIPV6UNIXNetworkStreamWriter} Class
@end ifnottex
@cindex @code{TCPIPV6UNIXNetworkStreamWriter} class

@subsubheading Instance methods
@table @code
@cindex @mnm{openOn} instance method @idxclscite{TCPIPV6NetworkStreamWriter}
@item openOn (@code{String} @var{hostName})
@item openOn (@code{String} @var{hostName}, @code{Integer} @var{port})
Open a socket connection to @var{hostName} for writing, optionally using
@var{port} as the network port for the connection.  If successful, the
method returns the filehandle number of the socket object that made the
connection as an @code{Integer}

@cindex @code{DEFAULT_TCPIP_PORT}
@cindex Port, TCPIP
If no @var{port} is given, the method uses the definition of
@code{DEFAULT_TCPIP_PORT}, which is defined in @flnm{ctalkdefs.h},
as the port number.  To include these definitions, you can add
the following line to a program.

@example

#include <ctalk/ctalkdefs.h>

@end example

The argument @var{hostName} must be the name of an IPv6 capable host,
or the method raises an @code{Exception} and returns 0.  The method
also raises an @code{Exception} and returns 0 if an error occurs while
trying to connect the socket.

@end table

@node UNIXNetworkStream, UNIXNetworkStreamReader, TCPIPV6NetworkStreamWriter, Classes
@iftex
@section @code{UNIXNetworkStream} Class
@end iftex
@ifnottex
@subheading @code{UNIXNetworkStream} Class
@end ifnottex
@cindex @code{UNIXNetworkStream} class

@code{UNIXNetworkStream} and its subclasses define instance and class
variables and methods to communicate over UNIX domain sockets between
processes and programs operating on the same machine.

As a type of interprocess communication, UNIX domain sockets are more
flexible than named pipes - programs create and manage one or more
sets of reader and writer objects independently of each other.

The section @cite{UNIXNetworkStreamReader} describes the methods and
instance data for creating and managing reader objects
@xref{UNIXNetworkStreamReader}, and the section
@cite{UNIXNetworkStreamWriter} describes the details of writer objects
@xref{UNIXNetworkStreamWriter}.

@subsubheading Class Variables
@table  @code
@cindex socketPrefix class variable @idxclscite{UNIXNetworkStream}
@item socketPrefix
A @code{String} that defaults to the machine-specific directory
name where the system stores its temporary files (e.g.,
@flnm{/tmp}, @flnm{/var/tmp}, etc.).

@end table

@subsubheading Instance Variables
@table @code
@cindex @mnm{sock} instance variable @idxclscite{UNIXNetworkStream}
@item sock
An @code{Integer} that contains the file handle number the receiver's
socket.  
@cindex @mnm{socketBaseName} instance variable @idxclscite{UNIXNetworkStream}
@item socketBaseName
A @code{String} that contains the base name of the socket's path
name.  The string may contain escape characters.  Refer to the
@mnm{makeSocketPath} method, below.
@cindex @mnm{socketPath} instance variable @idxclscite{UNIXNetworkStream}
@item socketPath
A @code{String} that contains the fully qualified path name of
a program's UNIX domain socket.
@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{closeSocket} instance method @idxclscite{UNIXNetworkStream}
@item @mnm{closeSocket} (@code{void})
Shuts down the receiver's socket (defined in the @code{sock} instance
variable) and deletes the socket's file entry (which is defined in the
@code{socketPath} instance variable), if present.

@cindex @mnm{makeSocketPath} instance method @idxclscite{UNIXNetworkStream}
@item @mnm{makeSocketPath} (@code{String} @var{basename})
Constructs a fully qualified socket path from @var{basename} and
the prefix given by @code{socketPrefix} (described above).
If @var{basename} contains the characters @samp{$$}, the method
replaces the character with the program's process ID.

After constructing the fully qualified name, the method
fills in the receiver's @code{socketBaseName} and
@code{socketPath} instance variables, and returns
the value of the @code{socketPath} instance variable.

The small program here constructs and prints the file pathname of a
program's UNIX socket, which includes the process ID of the program.

@example

int main () @{
  UNIXNetworkStream new un;
  String new sockName;

  sockName = "myprogsocket.$$";

  un makeSocketPath sockName;
  printf ("%s\n", un socketPath);
@}

@end example

@cindex @mnm{removeSocket} instance method @idxclscite{UNIXNetworkStream}
@item @mnm{removeSocket} (@code{void})
Deletes the socket's file entry by its name, which is defined by
@mnm{makeSocketPath}, above.


@end table

@node UNIXNetworkStreamReader, UNIXNetworkStreamWriter, UNIXNetworkStream,  Classes
@iftex
@section @code{UNIXNetworkStreamReader} Class
@end iftex
@ifnottex
@subheading @code{UNIXNetworkStreamReader} Class
@end ifnottex
@cindex @code{UNIXNetworkStreamReader} class

@code{UNIXNetworkStreamReader} objects receive data using
UNIX domain sockets on a single machine.  The class defines
methods to create a connection and check the connection
for incoming data, and read any data for the application.

Here are slightly abreviated versions of the @flnm{sockread.c} and
@flnm{sockwrite.c} example programs.  This is the source code of
@flnm{sockread.c}.

@c demos/ipc/sockread.c
@example

int main () @{
  UNIXNetworkStreamReader new reader;
  SystemErrnoException new ex;
  FileStream new f;
  String new sockName;
  String new data;

  sockName = "testsocket";

  reader makeSocketPath sockName;
  printf ("reader socket:  %s\n", reader socketPath);

  /* Delete a socket from a previous connection if necessary. */
  if (f exists reader socketPath) @{
    f deleteFile reader socketPath;
  @}

  reader open;
  if (ex pending) @{
    ex handle;
    unlink (reader socketPath);
    return -1;
  @}

  while (1) @{
    data = reader sockRead;

    if (data length > 0) @{
      printf ("%s\n", data);
    @}
    if (ex pending) @{
      ex handle;
      break;
    @}
    usleep (1000);
  @}

  return 0;
@}

@end example

And here is @flnm{sockwrite.c}.  For details about its
operation, refer to the @code{UNIXNetworkStreamWriter} section.
@xref{UNIXNetworkStreamWriter}.

@c demos/ipc/sockwrite.c
@example

int main (int argc, char **argv) @{
  UNIXNetworkStreamWriter new writer;
  SystemErrnoException new ex;
  String new sockName;
  String new data;

  sockName = "testsocket";

  writer makeSocketPath sockName;
  printf ("writer socket:  %s\n", writer socketPath);

  writer open;
  if (ex pending) @{
    ex handle;
  @}

  writer sockWrite argv[1];

  if (ex pending) @{
    ex handle;
  @}

  exit (0);
@}

@end example

The programs communicate if started from different shells used by
different virtual terminals or different windows on a graphical
desktop, or if the reader program is started in the background and the
writer started in the foreground.

@subsubheading Instance Variables
@table @code
@cindex charsRead instance variable @idxclscite{UNIXNetworkStreamReader}
@item charsRead
An @code{Integer} that contains the number of characters read by the
last reception of data from a connection, or zero if there is no data
waiting.  Refer to the method @mnm{sockRead}, below.
@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{open} instance method @idxclscite{UNIXNetworkStreamReader}
@item @mnm{open} (@code{void})
Creates a socket to read data from the socket name by the
receiver's @code{socketPath} instance variable, which is
defined in @code{UNIXNetworkStream} class. @xref{UNIXNetworkStream}.

The method returns the file number of the socket, or -1 if there
is an error, and raises a @code{SystemErrnoException} if an error
occurred in the network library routines.

@cindex @mnm{openOn} instance method @idxclscite{UNIXNetworkStreamReader}
@item @mnm{openOn} (@code{String} @var{socketpath})
Creates a new reader socket and binds it to @var{socketpath}.  Sets
the receiver's @code{socketPath} instance variable to the argument.
Returns an @code{Integer} with the file number of the newly created
socket.

@cindex @mnm{sockRead} instance method @idxclscite{UNIXNetworkStreamReader}
@item @mnm{sockRead} (@code{void})
Returns a @code{String} containing data received from the socket
previously created by the @mnm{open} method, above, and sets
the @code{charsRead} instance variable to the number
of characters read.

If no data is waiting, the method returns an empty string and sets the
receiver's @code{charsRead} instance variable to 0.

If an error occurs during one of the system calls, the method
raises a @code{SystemErrnoException}.

@end table

@node UNIXNetworkStreamWriter, TreeNode, UNIXNetworkStreamReader,  Classes
@iftex
@section @code{UNIXNetworkStreamWriter} Class
@end iftex
@ifnottex
@subheading @code{UNIXNetworkStreamWriter} Class
@end ifnottex
@cindex @code{UNIXNetworkStreamWriter} class

@code{UNIXNetworkStreamWriter} objects send data over machine-
local UNIX domain sockets.  The class contains methods to
open sockets and send data over the network connection.

For an example of how to use @code{UNIXNetworkStreamWriter} objects,
refer to the programs in the @code{UNIXNetworkStreamReader}
section. @xref{UNIXNetworkStreamReader}.

@subsubheading Instance Variables
@table @code
@cindex charsWritten instance variable @idxclscite{UNIXNetworkStreamWriter}
@item charsWritten
An @code{Integer} that contains the number of bytes written by the
previous call to the @mnm{sockWrite} method, which is described
below.
@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{open} instance method @idxclscite{UNIXNetworkStreamWriter}
@item @mnm{open} (@code{void})
Creates a machine-local UNIX socket connection with the socket
name given by the @code{socketPath} instance variable, which
is defined in @code{UNIXNetworkStream} class. @xref{UNIXNetworkStream}.

If successful, the method returns the file handle number of the
new socket.  If an error occurs, the method returns -1 and raises
a @code{SystemErrnoException} if the error occured in a library
call.

@cindex @mnm{openOn} instance method @idxclscite{UNIXNetworkStreamWriter}
@item @mnm{openOn} (@code{String} @var{socketpath})
Creates a new writer socket and binds it to @var{socketpath}.  Sets
the receiver's @code{socketPath} instance variable to the argument.
Returns an @code{Integer} with the file number of the newly created
socket.

@cindex @mnm{sockWrite} instance method @idxclscite{UNIXNetworkStreamWriter}
@item @mnm{sockWrite} (@code{String} @var{data})
Writes @var{data} to the socket created by a previous call to
the @mnm{open} method, above.  Sets the receiver's @code{charsWritten}
instance variable to the number of characters written.  If
successful, returns 0, or if an error occured, returns -1 and
raises a @code{SystemErrnoException}.
@end table

@node TreeNode, Event, UNIXNetworkStreamWriter, Classes
@iftex
@section @code{TreeNode} Class
@end iftex
@ifnottex
@subheading @code{TreeNode} Class
@end ifnottex
@cindex @code{TreeNode} class

@code{TreeNode} objects and methods maintain links to other
@code{TreeNode} objects (@emph{siblings}), and to sets of objects
(@emph{children}).  The methods can add sibling and child @code{TreeNodes},
traverse the tree, and set the content of each @code{TreeNode}.

The class provides basic methods for adding sibling and child nodes,
adding content to each node (which is a @code{String} object), and
to traverse the tree.  The methods that visit each node in a tree--
@mnm{print, format,} and @mnm{search}--are fairly generic.  They
perform a depth-first traversal which should work equally well with
balanced and non-balanced trees.

@subsubheading Instance Variables
@table @code

@cindex @code{children} instance variable @idxclscite{TreeNode}
@item children
A @code{List} of @code{TreeNode} objects, which are accessible
only through the parent node. @xref{List}.
@cindex @code{content} instance variable @idxclscite{TreeNode}
@item content
A @code{String} that contains the node's displayable text.
@cindex @code{levelMargin} instance variable @idxclscite{TreeNode}
@item levelMargin
A @code{String,} normally consisting of all spaces, that is
the additional left margin for each level of the tree. @xref{String}.
@cindex @code{levelMarginLength} instance variable @idxclscite{TreeNode}
@item levelMarginLength
An @code{Integer} that is the length of the @code{levelMargin} string.
@cindex @code{siblings} instance variable @idxclscite{TreeNode}
@item siblings
Another @code{List} of @code{TreeNode} objects that occur at the same level.
@xref{List}.
@end table

@subsubheading Instance Methods
@table @code
@cindex @code{addChild} instance method @idxclscite{TreeNode}
@item @mnm{addChild} (@code{TreeNode} @var{child})
Add @var{child} to the end of the receiver's @code{children} list.

@cindex @code{format} instance method @idxclscite{TreeNode}
@item @mnm{format} (@code{void})
Print the receiver tree to a @code{String} object.  This method uses
two other methods, @mnm{__formatChildren} and @mnm{__formatSiblings}
to traverse each @code{TreeNode} object in the receiver tree.  Returns
a @code{String} object.

@cindex @code{makeSibling} instance method @idxclscite{TreeNode}
@item @mnm{makeSibling} (@code{TreeNode} @var{sib})
Add @var{sib} to the end of the receiver's @code{sibling} list.

@cindex @code{map} instance method @idxclscite{TreeNode}
@item @mnm{map} (@code{OBJECT *(@var{method})()})
Execute @var{method} over each member of the receiver tree.  As
with @mnm{map} methods in other classes, @var{method} must also
belong to @code{TreeNode} class and takes no arguments.

@cindex @code{print} instance method @idxclscite{TreeNode}
@item @mnm{print} (@code{void})
Print the receiver tree to the terminal.  This method uses
two other methods, @mnm{__printChildren} and @mnm{__printSiblings}
to traverse each @code{TreeNode} object in the receiver tree.

@cindex @code{search} instance method @idxclscite{TreeNode}
@item @mnm{search} (@code{String} @var{searchString})
Return the first node in the receiver tree whose content
matches @var{searchString}.  Returns only the first node
that contains @var{searchString}.  Does not look for multiple
matches.

@cindex @code{setContent} instance method @idxclscite{TreeNode}
@item @mnm{setContent} (@code{String} @var{str})
Sets the receiver @code{TreeNode's} @code{content} instance variable
to @var{str}, a @code{String} object. @xref{String}.

@end table

@node Event, Expr, TreeNode, Classes
@iftex
@section @code{Event} Class
@end iftex
@ifnottex
@subheading @code{Event} Class
@end ifnottex
@cindex @code{Event} class

@code{Event} and its subclasses represent system and language events
like applications, errors, input, and signals, and these classes
provide the methods that receive and handle the events.

@node Application, , , Classes
@iftex
@section @code{Application} Class
@end iftex
@ifnottex
@subheading @code{Application} Class
@end ifnottex
@cindex @code{Application} class

Objects of @code{Application} class represent programs.  This class
provides basic methods for initializing and exiting programs, handling
window size and placement for graphical programs, and starting subprograms,
as well as other tasks.

@subsubheading Instance Variables
@table @code
@cindex @code{cmdLineArgc} instance variable @idxclscite{Application}
@item @code{cmdLineArgc} 
An @code{Integer} that contains the value of the @code{argc} argument
to @cite{main ()}. The value is normally set by the @mnm{parseArgs}
method, below.

@cindex @code{cmdLineArgs} instance variable @idxclscite{Application}
@cindex Command line arguments
@cindex Arguments, command line
@item @code{cmdLineArgs} 
An @code{Array} of @code{Strings} that contains each element of the
@code{argv} parameter to @code{main ()}.  This is normally filled
in by the @mnm{parseArgs} method, below.

@cindex @code{exitHandler} instance variable @idxclscite{Application}
@item @code{exitHandler}
A @code{SignalHandler} object that contains a user-installable 
signal handler.  @xref{SignalHandler}.

@cindex @code{geomFlags} instance variable @idxclscite{Application}
@cindex @code{winXOrg} instance variable @idxclscite{Application}
@cindex @code{winYOrg} instance variable @idxclscite{Application}
@cindex @code{winWidth} instance variable @idxclscite{Application}
@cindex @code{winHeight} instance variable @idxclscite{Application}
@item @code{geomFlags}
@item @code{winXOrg}
@item @code{winYOrg}
@item @code{winWidth}
@item @code{winHeight}
Variables that specify the appication window's dimensions, if any.
These can be set by the @mnm{parseX11Geometry} method, below.

@end table

@subsubheading Instance Methods

@table @code
@cindex @mnm{__handleAppExit} instance method @idxclscite{Application}
@item @mnm{__handleAppExit} (@code{__c_arg__} @code{int} @var{signo})
A standard, user installable SIGINT (@kbd{Ctrl-C}) signal handler.  If
the application has enabled exception traces, print a stack trace and
then call the default SIGINT handler.  The @var{signo} argument
contains the number of the signal that calls the method.

The application must first call the @mnm{installExitHandler} method
(below) to define this method as a signal handler - then this method
is called when the application receives a SIGINT, which is normally
generated when the user presses Control-C.

This method does not return.

@cindex @mnm{__handleSigAbrt} instance method @idxclscite{Application}
@item @mnm{__handleSigAbrt} (@code{__c_arg__} @code{int} @var{signo})
A standard, user installable SIGABRT handler.  The application must first
call @mnm{installAbortHandler}, below.  If the application has enabled
exception traces, print a stack trace before exiting.  This method does
not return.

@cindex @mnm{classSearchPath} instance method @idxclscite{Application}
@cindex Class library search path
@cindex Search path, classes
@cindex @samp{CLASSLIBDIRS} environment variable
@item @mnm{classSearchPath} (@code{void})
Returns a @code{String} that contains Ctalk's class library search
path, with each directory separated by a colon (@samp{:}).  The
default is usually @flnm{/usr/local/include/ctalk.}  

If there are any directories given as arguments to the @samp{-I}
command line option, and any directories named in the
@samp{CLASSLIBDIRS} environment variable, Ctalk includes those
directories as well, and searches them first.

@cindex @mnm{execC} instance method @idxclscite{Application}
@item @mnm{execC} (@code{String} @var{commandLine})
@item @mnm{execC} (@code{String} @var{commandLine}, @code{String} @var{commandOutput})
Execute the command and arguments given by @var{commandLine} and wait
for the program to finish.  The method displays the standard
output of the subprocess.

If a second argument is given, the program's standard output
is saved in the @var{commandOutput} object, which should normally
be a @code{String} object.  Here is a simple example program.

@c test/expect/examples/execbin1.c
@example

int main () @{
  Application new myApp;
  String new str, output;
  
  str = "/bin/ls -l";
  myApp execC str, output;
  printf ("%s\n", output);
@}

@end example

For any number of arguments, if the command redirects the
standard outut, then the output is sent to the file that
is the operand of a @samp{>} or @samp{>>} redirection operator.

If @var{commandLine} is the name of a shell script, the shell script
is executed by a sub-shell using the @cite{system(3)} library call.

@cindex  @mnm{getPID}  instance method @idxclscite{Application}
@item @mnm{getPID} (@code{void})
Returns an @code{Integer} with the program's process ID.

@cindex @mnm{installAbortHandlerBasic} instance method @idxclscite{Application}
@item @mnm{installAbortHandlerBasic} (@code{void})
Installs a C handler for @code{SIGABRT} signals.  The C
handlers are more reliable, though less
flexible, than handlers that use @code{SignalHandler} class.

This method catches a SIGABRT, and prints a walkback trace if tracing
is enabled, before the application exits.

@cindex @mnm{installExitHandler} instance method @idxclscite{Application}
@item @mnm{installExitHandler} (@code{void})
Install a @code{SIGINT} (@kbd{C-c}) handler in a Ctalk program that
performs cleanup before exiting the application.

@cindex @mnm{installExitHandlerBasic} instance method @idxclscite{Application}
@item @mnm{installExitHandlerBasic} (@code{void})
Installs a C handler for @code{SIGINT} signals (@kbd{C-c} or
@kbd{C-break} for DJGPP) that is slightly more robust and
reliable, though less flexible, than the
@code{SignalHandler} classes.

This method causes the application to exit when receiving a signal,
and prints a walkback trace if tracing is enabled.

@cindex @mnm{installPrefix} instance method @idxclscite{Application}
@item @mnm{installPrefix} (@code{void})
Returns a @code{String} with the name of the top-level directory
where Ctalk's various component subdirectories are located.  For
example, in relative terms, this is where Ctalk's various components
get installed.

@example

Executables:            @emph{prefixdir}@code{/bin}
Libraries:              @emph{prefixdir}@code{/lib}
Class Libraries:        @emph{prefixdir}@code{/include/ctalk}
Texinfo Manuals:        @emph{prefixdir}@code{share/info}
Manual Pages:           @emph{prefixdir}@code{/share/man}
Searchable Docs:        @emph{prefixdir}@code{/share/ctalk}

@end example

@cindex membervars instance method @idxclscite{Application}
@item @mnm{membervars} (void)
Returns a @code{String} with the member variable declarations
of the class named by the receiver.  If the receiver is a @code{String}
object, @mnm{membervars} returns the variables for the class given
by the @code{String's} value.  If the receiver is a class object,
@mnm{membervars} returns the member variables for that class.  For
nany other type of object, @mnm{membervars} returns the variables
declared in the object's class. @xref{ClassVariableKeyword}.

@mnm{Membervars} returns the complete documentation of the instance or
class variable, if the declaration also contains a documentation string.
@xref{VariableDocStrings}.

@cindex @mnm{methodDocString} instance method @idxclscite{Application}
@item @mnm{methodDocString} (@code{String} @var{method-source})
Returns the documentation string from the source of the method
given as the argument. @xref{MethodDocStrings}.

@cindex @mnm{methodPrototypes} instance method @idxclscite{Application}
@item @mnm{methodPrototypes} (@code{String} @var{input})
If @var{input} is a method's source or a class library, returns a @code{String}
containing the prototypes of the methods; that is, the declaration and the
argument list.

@cindex @mnm{methodSource} instance method @idxclscite{Application}
@item @mnm{methodSource} (@code{String} @var{className}, @code{String} @var{methodName})
Returns a @code{String} object with the source code of the method(s)
that match the declarations, The @mnm{methodSource} method does not
distinguish methods by the number of arguments, so it returns the code
of any method in a class that matches the @var{methodName} arguement.

@example

@var{className} instanceMethod @var{methodName}
@var{className} classMethod @var{methodName}

@end example

The method generates a @code{SystemErrnoException} if it can't find
the class file. 

The @mnm{methodSource} method is built to be as fast as possible and
has a rather simple minded view of what constitutes a method
declaration.

The method only recognizes declarations that appear on a single line,
in order to keep the regular expressions that do the matching as
simple as possible, and it only matches spaces between tokens, and not
tabs, at least at the moment.  It can also be fooled by things that
even @emph{look} like a method declaration within the method body.
For example, a phrase like,

@example

@var{className} instanceMethod <some-method-name>

@end example

in the method's documentation, causes @mnm{methodSource} to signal the
start of the next method.

@cindex @mnm{parseArgs} instance method @idxclscite{Application}
@cindex Arguments, command line
@cindex Command line arguments
@item @mnm{parseArgs} (@code{Integer} @var{argc}, @code{Array} @var{argv})
Takes the @var{argv} and @var{argc} parameters to @code{main ()} and 
sets each element of the @code{cmdLineArgs} instance variable (above)
to a @code{String} that contains each element of the system's @code{argv}
array.

@anchor{parseX11Geometry}
@cindex @mnm{parseX11Geometry} instance method @idxclscite{Application}
@cindex Geometry, X window
@cindex parseX11Geometry
@item @mnm{parseX11Geometry} (@code{String} @var{geometryString})
Parses a X Window System geometry string.  If the string specifies
any of the x, y, width, or height values for a window, the method
sets the @code{winXOrg}, @code{winYOrg}, @code{winWidth}, or 
@code{winHeight} instance variables.  If the geometry string omits
any of the values, the method sets the corresponding instance variable
to zero.  The method sets the @code{geomFlags} instance variable to
the geometry flags provided by the window system.

This method only parses the geometry string.  It does not make any
adjustments for the display dimensions, or the window dimensions or
placement.

For information about the format of a X geometry string, refer to the
@cite{XParseGeometry(3)} manual page.

@cindex @mnm{spawnC} instance method @idxclscite{Application}
@item @mnm{spawnC} (@code{String} @var{command}, @code{Integer} @var{restrict})
Starts the program given by the argument @var{command}, and resumes
execution of the main program.  The method returns an @code{Integer}
with the process ID of the child process.

The child process becomes a daemon process, which means it has no
interaction with the parent process.  If you want the parent process
to handle the child processes' output, refer to the @mnm{execC}
method, above.  Otherwise, communication between the parent and child
process should be handled by UNIX's interprocess communication
facilities.

If the @var{restrict} argument is non-zero, the method also changes
the child processes' working directory to @samp{/} and its umask to
@samp{0}.

The @mnm{spawnC} method does not use a shell when executing the child
process, which means that the method doesn't handle shell facilities
like IO redirection or file globbing.  It's also necessary to provide
the full path name of the program to be launched in the background.

The process that handles the session management when the daemon
process is launched remains executing until the parent process
exits.  This means there can be @emph{three} entries in the
system's process table, but it helps minimize creating zombie
processes in case any part of the program quits unexpectedly.

@cindex @mnm{uSleep} instance method @idxclscite{Application}
@item @mnm{uSleep} (@code{long long int} @var{usecs})
Sleep for @var{usecs} microseconds.

@cindex @mnm{useXRender} instance method @idxclscite{Application}
@cindex X Render Extension
@item @mnm{useXRender} (@code{Boolean} @var{b})
If @var{b} is true, draw graphics using the X Render extension
if it is available. If @var{b} is false, use Xlib for graphics
drawing.  The default is to draw using the X Render extension
if it is available.

@cindex @mnm{usingXRender} instance Method @idxclscite{Application}
@item @mnm{usingXRender} (@code{void})
Returns a @code{Boolean} value of True if the program is
using the X Render extension for drawing, False otherwise.

@end table

@node ClassLibraryTree, , , Classes
@iftex
@section @code{ClassLibraryTree} Class
@end iftex
@ifnottex
@subheading @code{ClassLibraryTree} Class
@end ifnottex
@cindex @code{ClassLibraryTree} class

A @code{ClassLibraryTree} application is a utility program that
formats a tree of the available Ctalk class hierarchy.

The class lists the libraries in Ctalk's default installation
directory, and in any directories named by the @samp{CLASSLIBDIRS}
environment variable.

The class contains one method, @mnm{init}, which collects the class
and superclass information into a set @code{TreeNode} objects.  The
prototype of init is:

@example

TreeNode instanceMethod init (TreeNode classTree, Boolean verbose);

@end example

After the method finishes the @code{classTree} object contains the
classes and subclasses.  You can then print or format the with the
@code{TreeNode} methods @mnm{format} and @mnm{print}.

The @code{verbose} argument, if True, tells the method to print dots
to indicate its progress.

Here is an example program that displays the class hierarchy on a
terminal.

@c test/expect/examples/classes.c
@example

Boolean new verbose;

int main (int argc, char **argv) @{

  TreeNode new tree;
  ClassLibraryTree new classTree;
  Integer new nParams;
  Integer new i;
  String new param;

  verbose = True;

  classTree parseArgs argc, argv;
  nParams = classTree cmdLineArgs size;

  for (i = 1; i < nParams; i++) @{

    param = classTree cmdLineArgs at i;

    if (param == "-q") @{
      verbose = False;
      continue;
    @}

    if (param == "-h" || param == "--help") @{
      printf ("Usage: classes [-q] [-h]\n");
      exit (0);
    @}

  @}

  classTree init tree, verbose;
  tree print;

  exit (0);
@}

@end example

@subsubheading Instance Methods
@table @code
@cindex init instance method @idxclscite{ClassLibraryTree}
@item init instance method (@code{TreeNode} @var{tree}, @code{Boolean} @var{printDots})
Creates a a tree of the class library with @var{tree} as the root node
of the tree.  If @var{printDots} is true, prints the method's progress
on the terminal.
@end table

@node GLUTApplication, , , Classes
@iftex
@section @code{GLUTApplication} Class
@end iftex
@ifnottex
@subheading @code{GLUTApplication} Class
@end ifnottex
@cindex @code{GLUTApplication} class

The @code{GLUTApplication} class provides a class library interface to
the GLUT application programming interface, which is a
platform-independent window API for OpenGL programs.

The GLUT API uses C functions to handle window system events.  This is
the simplest approach to adding event handlers.  Ctalk does not,
itself, use any GLUT or OpenGL functions, so it is normally safe to
use Ctalk methods within a window callback, as in this example.

@example
#include <ctalk/ctalkGLUTdefs.h>

GLUTApplication new teapotApp;

float angle = 0.0f;

void mydisplay (void) @{       /* This callback updates the display. */
  glEnable (GL_NORMALIZE);
  glEnable(GL_DEPTH_TEST);
  glClearColor(0.0, 0.0, 0.0, 1.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
  glLineWidth (1.0f);

  glLoadIdentity ();
  glColor4f (0.0f, 0.0f, 1.0f, 1.0f);

  glRotatef (angle, 0.0f, 1.0f, 0.0f);
  glRotatef (10.0f, 1.0f, 0.0f, 0.0f);

  teapotApp teapot 3.0, 0;    /* Method call within the callback. */

  glutSwapBuffers ();
@}

void animation (void) @{  /* Callback to update the animation state. */
  angle += 0.2f;
  if (angle >= 360.0f)
    angle = 0.0f;
  glutPostRedisplay();
@}

int main (int argc, char **argv) @{

  teapotApp initGLUT(argc, argv);
  teapotApp initWindow (640, 480);
  teapotApp createMainWindow ("teapotApp -- GLUTApplication Class");
  teapotApp defineDisplayFn mydisplay;
  teapotApp defineIdleFn animation;
  teapotApp installCallbackFns;
  teapotApp run;
  
@}

@end example

If you save the example in a file called teapotApp.ca, you can build
this program with the following command on Linux/UNIX systems.

@example

  $ ctcc -x teapotApp.ca -o teapotApp

@end example

To build the example on Apple OS X machines, you need to link it
with the GLUT application framework.  Refer to the discussion below
for more information.

You can also use the OpenGL API within methods.  This lets programs
use C functions, methods, and the GLUT and OpenGL APIs together with
few restrictions.  The @code{GLUTApplication} class does not, at least
at this time, support all of the functions that the GLUT API provides,
but the API is flexible enough that you can extend it if necessary

@subsubheading Apple OS X Machines

OS X machines include GLUT as an application framework, which Ctalk
does not support directly.  Ctalk provides the platform independent
@file{ctalkGLUTdefs.h} include file, which you can use to add the GLUT
definitions to programs, by adding a statement like this one to the
program.

@example

#include <ctalk/ctalkGLUTdefs.h>

@end example

Then you need to link the program with the framework to produce an
executable.  Normally you would use a series of commands like these.

@example

  $ ctalk -I /usr/X11R6/include teapotApp.ca -o teapotApp.i
  $ gcc -framework GLUT teapotApp.i -o teapotApp -lctalk -lreadline \
        -L/usr/X11R6/lib -lGL -lGLU

@end example

This example isn't meant to be definitive.  You might need to
experiment to find the right build configuration for a particular OS X
machine.

There is more platform specific information in the
example programs and @file{README} file in the @file{demos/glut}
subdirectory.  

The @code{GLUTApplication} class doesn't provide a guide to the very
involved subject of programming with the GLUT and OpenGL APIs.  There
are many references and tutorials available on the Internet and in
bookstores that teach OpenGL programming.

@subsubheading Instance Methods

@table @code

@cindex createMainWindow instance method @idxclscite{GLUTApplication}
@item createMainWindow (@code{String} @var{title})
Create the main window.  The argument, a @code{String} contains
the window's title.

@cindex cone instance method @idxclscite{GLUTApplication}
@item cone (@code{Float} @var{base}, @code{Float}  @var{height}, @code{Integer} @var{slices}, @code{Integer}  @var{stacks}, @code{Integer} @var{fill})
Draw a cone with a base of size @var{base}, height @var{height}, with
@var{slices} longitudinal slices and @var{stacks} lateral slices.  If
@var{fill} is True, draw a filled cone; otherwise, draw a wireframe cone.

@cindex cube instance method @idxclscite{GLUTApplication}
@item cube (@code{Float} @var{size}, @code{Integer} @var{fill})
Draw a cube with sides of @var{size} length.  If @var{fill} is True,
draw a filled cube; otherwise draw a wirefame cube.

@cindex GLUT callbacks, defining
@cindex defineAnimationFn instance method @idxclscite{GLUTApplication}
@item defineAnimationFn (@code{Symbol} @var{fn})
@cindex defineButtonBoxFn instance method @idxclscite{GLUTApplication}
@item defineButtonBoxFn (@code{Symbol} @var{fn})
@cindex defineDialsFn instance method @idxclscite{GLUTApplication}
@item defineDialsFn (@code{Symbol} @var{fn})
@cindex defineDisplayFn instance method @idxclscite{GLUTApplication}
@item defineDisplayFn (@code{Symbol} @var{fn})
@cindex defineEntryFn instance method @idxclscite{GLUTApplication}
@item defineEntryFn (@code{Symbol} @var{fn})
@cindex defineIdleFn instance method @idxclscite{GLUTApplication}
@item defineIdleFn (@code{Symbol} @var{fn})
@cindex defineKeyboardFn instance method @idxclscite{GLUTApplication}
@item defineKeyboardFn (@code{Symbol} @var{fn})
@cindex defineMenuStateFn instance method @idxclscite{GLUTApplication}
@item defineMenuStateFn (@code{Symbol} @var{fn})
@cindex defineMenuStatusFn instance method @idxclscite{GLUTApplication}
@item defineMenuStatusFn (@code{Symbol} @var{fn})
@cindex defineMotionFn instance method @idxclscite{GLUTApplication}
@item defineMotionFn (@code{Symbol} @var{fn})
@cindex defineMouseFn instance method @idxclscite{GLUTApplication}
@item defineMouseFn (@code{Symbol} @var{fn})
@cindex defineOverlayDisplayFn instance method @idxclscite{GLUTApplication}
@item defineOverlayDisplayFn (@code{Symbol} @var{fn})
@cindex definePassiveMotionFn instance method @idxclscite{GLUTApplication}
@item definePassiveMotionFn (@code{Symbol} @var{fn})
@cindex defineSpaceballMotionFn instance method @idxclscite{GLUTApplication}
@item defineSpaceballMotionFn (@code{Symbol} @var{fn})
@cindex defineSpaceballRotateFn instance method @idxclscite{GLUTApplication}
@item defineSpaceballRotateFn (@code{Symbol} @var{fn})
@cindex defineSpecialFn instance method @idxclscite{GLUTApplication}
@item defineSpecialFn (@code{Symbol} @var{fn})
@cindex defineTabletButtonFn instance method @idxclscite{GLUTApplication}
@item defineTabletButtonFn (@code{Symbol} @var{fn})
@cindex defineTabletMotionFn instance method @idxclscite{GLUTApplication}
@item defineTabletMotionFn (@code{Symbol} @var{fn})
@cindex defineVisiblityFn instance method @idxclscite{GLUTApplication}
@item defineVisibilityFn (@code{Symbol} @var{fn})
@cindex defineTimerFn instance method @idxclscite{GLUTApplication}
@item defineTimerFn (@code{Integer} @var{msec}, @code{Symbol} @var{fn}, @code{Integer} @var{argValue})
Define callback functions for window system events.  The argument is
the name of the C function that handles the event.  Refer to the
method's documentation and the GLUT API's documentation for information
about each callback function's parameters.

@emph{Note:} @mnm{defineAnimationFn} and @mnm{defineTimerFn} both use
the @code{glutTimerFunc ()} callback, so the actual callback is the
last function defined (before calling @mnm{installCallBackFns}).

The difference is that @mnm{defineAnimationFn} executes its callback
24 times per second, while @mnm{defineTimerFn} uses an application
defined interval, and takes three arguments: the timer interval in
milliseconds, the name of the callback function, and an integer that
is passed to the callback function as an argument.

@cindex defineReshapeFn instance method @idxclscite{GLUTApplication}
@item defineReshapeFn (@code{Symbol} @var{fn})
Defines the function used to reshape the window's 3D viewing space.
The default is an orthographic projection, 5 grid units wide on each
axis.  If you need to duplicate the default viewing area in a
program, here is the code that defines it.  The variables
@samp{width} and @samp{height} are provided by the GLUT application
as arguments to the reshape function.

@example

void defualt_reshape_fn (int width, int height) @{
  float ar = (float)width / (float)height;
  glViewport(0, 0, w, h);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glOrtho (-5.0 * ar, 5.0 * ar, -5.0, 5.0, 5.0, -5.0);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
@}

@end example

@cindex dodecahedron instance method @idxclscite{GLUTApplication}
@item dodecahedron (@code{Integer} @var{fill})
Draw a dodecahedron.  If @code{fill} is True, draw a solid dodecahedron;
otherwise draw a wireframe dodecahedron.

@cindex fullScreen instance method @idxclscite{GLUTApplication}
@item fullScreen (@code{void})
Resize the main window so that it occupies the entire screen.  A call
to @mnm{reshape} (the method, not the callback) or @mnm{position}
returns the window to its normal state.

@cindex icosahedron instance method @idxclscite{GLUTApplication}
@item icosahedron (@code{Integer} @var{fill})
Draw a icosahedron.  If @code{fill} is True, draw a solid icosahedron;
otherwise draw a wireframe icosahedron.

@cindex initGlut instance method @idxclscite{GLUTApplication}
@cindex parseArgs instance method @idxclscite{Application}
@item initGlut (@code{Integer} @var{argc}, @code{Array} @var{argv})
Initialize the GLUT window system.  If there are any GLUT specific
command line arguments, this method parses them and uses then uses the
options to configure the window system.  This method also calls
@code{Application} method @mnm{parseArgs}, so the command line
arguments are available in the @code{cmdLineArg} instance variable (an
@code{Array}). @xref{Application}.

@cindex initWindow instance method @idxclscite{GLUTApplication}
@item initWindow (@code{Integer} @var{width}, @code{Integer}  @var{height})
@item initWindow (@code{Integer} @var{xOrg}, @code{Integer} @var{yOrg}, @code{Integer} @var{width}, @code{Integer}  @var{height})
Initialize the main window's size or, with four arguments, its size
and position.

@cindex installCallBackFns instance method @idxclscite{GLUTApplication}
@item installCallBackFns (@code{void})
Install the callback functions defined by previous calls to @code{define*Fn}
methods.

@cindex octahedron instance method @idxclscite{GLUTApplication}
@item octahedron (@code{Integer} @var{fill})
Draw a octahedron.  If @code{fill} is True, draw a solid octahedron;
otherwise draw a wireframe octahedron.

@cindex tetrahedron instance method @idxclscite{GLUTApplication}
@item tetrahedron (@code{Integer} @var{fill})
Draw a tetrahedron.  If @code{fill} is True, draw a solid tetrahedron;
otherwise draw a wireframe tetrahedron.

@cindex run instance method @idxclscite{GLUTApplication}
@item run (@code{void})
Enter the GLUT API's main event loop.  When this method returns, the
program typically exits.  @emph{Note:} GLUT does not provide any
events to terminate program.  To exit a program normally, use C's
@cite{exit (3)} function and @cite{on_exit(3)} (or @cite{onexit(3)})
to handle any program specific exit processing.

@cindex sphere instance method @idxclscite{GLUTApplication}
@item sphere (@code{Float} @var{radius}, @code{Integer} @var{slices}, @code{Integer} @var{stacks}, @var{Integer} @var{fill})
Draw a sphere with @var{radius} with @var{slices} longitudinal
sections and @var{stacks} lateral sections.  If @var{fill} is True, draw
a filled sphere; otherwise draw a wireframe sphere.

@cindex teapot instance method @idxclscite{GLUTApplication}
@item teapot (@code{Integer} @var{fill})
Draw the classic teapot demonstration.  If @var{fill} is True, draw
a solid teapot; otherwise draw a wireframe teapot.

@cindex torus instance method @idxclscite{GLUTApplication}
@item torus (@code{Float} @var{inner_radius}, @code{Float} @var{outer_radius}, @code{Integer} @var{size}, @code{Integer} @var{rings}, @var{Integer} @var{fill})
Draw a torus with the inner and outer radii given by the arguments, with a section @var{size} and rendered in @var{rings} sections.  If @var{fill} is True, draw a solid torus; otherwise draw a wireframe torus.

@cindex windowID instance method @idxclscite{GLUTApplication}
@item windowID (@code{String} @var{window_title})
Return an @code{Integer} with the X window ID of the window with the title
@var{window_title}. @emph{Note:} Some OS's, like  OSX/Darwin, don't
use Xlib to draw windows; in that case, this method won't be able
to provide a lower level window ID.

@cindex xpmToTexture method @idxclscite{GLUTApplication}
@item xpmToTexture (@code{char **}@var{xpm_data}, @code{Integer} @var{width_out}, @code{Integer} @var{height_out}, @code{Symbol} @var{texture_data_out})
@item xpmToTexture (@code{char **}@var{xpm_data}, @code{Integer} @var{alpha}, @code{Integer} @var{width_out}, @code{Integer} @var{height_out}, @code{Symbol} @var{texture_data_out})
Translates a XPM pixmap into an OpenGL texture.  The argument
@var{xpm_data} is the pixmap's @code{char *pixmap_name[]} declaration.
If no @var{alpha} argument is given, then @samp{1.0} is used to
create an opaque texture.  Alpha values can range from 0.0 (completely
transparent) - 1.0 (completely opaque).

The method sets the arguments @var{width_out}, @var{height_out}, and @var{texel_data_out} with the height, width and data of the texture.

The resulting texture has the format GL_RGBA and the data type GL_UNSIGNED_INT_8_8_8_8, so you can create a 2D texture from a pixmap with statements like these.

@example

Integer new xpmWidth;
Integer new xpmHeight;
Symbol new texData;

/*
 *  Note that the xpm_data argument should not normally need a
 *  translation from C.
 */
myGLUTApp xpmToTexture xpm_data, xpmWidth, xpmHeight, texData;
glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, xpmWidth, xpmHeight, 0,
              GL_RGBA, GL_UNSIGNED_INT_8_8_8_8, texData);

@end example

The @mnm{xpmToTexture} method does not do any setup of the OpenGL texture
environment.  For basic textures, OpenGL works better with textures
that have a geometry that is an even multiple of 2; e.g., 128x128 or
256x256 pixels.  

Individual applications can add parameters for interpolation,
blending, mipmap creation, and material rendering based on the
program's requirements, though.

The Ctalk library only stores the data for one texture at a time, so
if a program uses multiple textures, it should save the texture data
to a separate @code{Symbol}, in orderq to avoid regenerating the texture each
time it's used.

For an example of how to draw with textures, refer to the
@file{texture.ca} and @file{texblend.ca} programs in the Ctalk
distribution's @file{demos/glut} subdirectory.

@end table

@node ObjectInspector, , , Classes
@iftex
@section @code{ObjectInspector} Class
@end iftex
@ifnottex
@subheading @code{ObjectInspector} Class
@end ifnottex
@cindex @code{ObjectInspector} class
The @code{ObjectInspector} class provides basic methods for
examining the contents of objects.  

The central method of this class is @mnm{formatObject,}
which returns the contents of an object and its instance
variables as a @code{String} object.  However, applications
can also use the @mnm{formatInstanceVariable} and
@mnm{formatClassVariable} methods.  

@cindex @mnm{mapInstanceVariables} instance method @idxclscite{Object}
@cindex @mnm{mapClassVariables} instance method @idxclscite{Object}
These methods use the @mnm{mapInstanceVariables} and
@mnm{mapClassVariables} methods, defined in @code{Object}
class. @xref{Object}.

Other classes provide convenience methods that call
@mnm{formatObject;} for example, @mnm{dump} in @code{Object}
class.

@subsubheading Instance Variables
@table @code
@cindex @mnm{promptString} instance variable @idxclscite{ObjectInspector}
@item promptString
A @code{String} object that contains the text of the inspector's
command prompt. @xref{String}.
@cindex @mnm{verbose} instance variable @idxclscite{ObjectInspector}
@item verbose
A @code{Boolean} value that causes the inspector to print a verbose
listing of objects when set to True. @xref{Boolean}.
@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{formatClassVariable} instance method @idxclscite{ObjectInspector}
@item formatClassVariable (@code{Symbol} @var{objectRef})
Return a @code{String} containing the contents of an object
and its instance variables.  The argument is a reference to 
the object to be formatted.  Both @mnm{formatClassVariable}
and @mnm{formatInstanceVariable} are used by
@mnm{formatObject,} below.

@cindex @mnm{formatInstanceVariable} instance method @idxclscite{ObjectInspector}
@item formatInstanceVariable (@code{Symbol} @var{objectRef})
Return a @code{String} containing the contents of an object
and its instance variables.  The argument is a reference to 
the object to be formatted.

@cindex @mnm{formatObject} instance method @idxclscite{ObjectInspector}
@item formatObject (@code{Symbol} @var{objectRef})
Return a @code{String} containing the contents of an object
and its instance variables.  The argument is a reference to 
the object to be formatted.

@anchor{ObjectInspector_inspect}
@cindex @mnm{inspect} instance method @idxclscite{ObjectInspector}
@item inspect (@code{Symbol} @var{objectRef})
@item inspect (@code{Symbol} @var{objectRef}, @code{String} @var{promptStr})
Suspends execution of the program and enters the Object inspector.
This allows you to examine the object pointed to by @var{objRef},
continue execution, or exit the program.  Typing @samp{?} or @samp{help}
at the prompt prints a list of the inspector's commands.  With a
@code{String} object as the second argument, the inspector displays
the string as its command prompt.

The manual page, @cite{inspect(3ctalk)}, contains a description the
inspector's commands and a brief tutorial.

@end table

@node LibrarySearch, , , Classes
@iftex
@section @code{LibrarySearch} Class
@end iftex
@ifnottex
@subheading @code{LibrarySearch} Class
@end ifnottex
@cindex @code{LibrarySearch} class

The methods in @code{LibrarySearch} class perform searches on the
Ctalk reference documentation.  The documentation is derived
from this reference and is formatted to be easily searchable.
Ctalk installs the documentation files during the installation
process.

These methods are also used in the @code{searchlib} program to
search the documentation.

Note that these methods raise an exception if they can't open the
documentation file, in which case they return an empty string and
leave it up to the calling function or method to handle the exception.

The @code{searchlib} program is described in the @cite{searchlib(1)}
man page and the @flnm{ctalktools} Texinfo documentation.

@subsubheading Instance Methods
@table @code
@cindex @mnm{cAPIFunctionSearch} instance method @idxclscite{LibrarySearch}
@item @mnm{cAPIFunctionSearch} (@code{String} @var{docPath}, @code{String} @var{search_pattern})
Returns a @code{String} that contains the results of a search for the
C API function or functions that match @var{search_pattern}.

@cindex @mnm{methodSearch} instance method @idxclscite{LibrarySearch}
@item @mnm{methodSearch} (@code{String} @var{docPath}, @code{String} @var{search_pattern})
Search the class library's method prototypes for @var{search_pattern}.
Returns a @code{String} object with the results.  Note that this
function is designed to be rather inclusive; it searches the
@emph{entire} method prototype for a pattern, which may include the
receiver class's name or any parameter name(s).  So including the
receiver class name is a search is perfectly valid - the syntax of a
method prototype in the documentation is:

@example

@emph{<receiver_class>}::@emph{<method_selector>} (@emph{param_list})

@end example

@end table




@node Exception, , , Classes
@iftex
@section @code{Exception} Class
@end iftex
@ifnottex
@subheading @code{Exception} Class
@end ifnottex
@cindex @code{Exception} class
@cindex @code{SystemErrnoException} class

@code{Exception} and its subclasses handle system and language
errors.  These classes provide default and
user-defined handlers to respond to the Exceptions;

If a program calls @mnm{enableExceptionTrace} (class @code{Object}),
then the @mnm{handle} method, below, and other exception handlers 
print a walkback of the program's method stack. @xref{Object}.

Here is an example of how to handle an exception when trying
to open a file.
@example
Exception new e;
...
e enableExceptionTrace;
...
inputStream openOn fileArg;
if (e pending) @{
  e handle;
  exit (1);
@}
@end example
The @mnm{pending} method returns @code{TRUE} or @code{FALSE}
depending on whether an exception is waiting to be
processed.  The @code{handle} method processes the exception.

The class's default method handlers format and print the
text provided when a program calls @code{raiseException}.
Here is the code from @mnm{openOn} (class
@code{ReadFileStream}) that creates the exception.
@example
SystemErrnoException new e;
...
if ((f = fopen (__streamPath, "r")) != NULL) @{
  __ctalkObjValPtr (selfval, f);
  self streamPath = __streamPath;
  self statStream;
@} else @{
  e raiseCriticalException __streamPath;
  strcpy (selfval -> __o_value, "");
@}
@end example
The object @code{e} is a @code{SystemErrnoException}.  The
@code{SystemErrnoException} class translates the operating
system's errors into Ctalk exceptions.  In the example
above, the type of the exception is provided by the
operating system.

The @code{Exception} class also provides the
@mnm{installHandler} method to allow programs to use their
own handlers.  Here is an example.
@example
Exception instanceMethod myHandler (void) @{
  printf ("My exception handler: %s.\n",
	  __ctalkGetRunTimeException ());
  return NULL;
@}

int main () @{
  Exception new e;
  e installHandler "myHandler";
  e raiseException USER_EXCEPTION_X, "my program's exception";
  e handle;
@}
@end example

@subsubheading Some notes about exceptions:

1. The receiver class of an exception handler is the the
same as the exception object; e.g., @mnm{myHandler} in the
example above is the same as the class of @code{e}; that is,
@code{Exception}.  In addition, exception handlers take no
arguments and rely on information at the time the exception
is raised.

2. Programs must take care that they handle any exceptions that
they raise as soon as possible.  If not handled by the
application, the run-time library API might then handle the
exception, which could lead to confusing results.

3. Ctalk uses @emph{critical exceptions} internally.  At the
application level, however, all exceptions are treated with
the same priority.  The application needs to take the
appropriate action, depending on the type of exception.

4. Exception classes should not, as much as possible, depend
on other classes being evaluated.  This is because even
basic classes use exceptions, and if the exceptions in turn
use the basic classes, it can lead to circular reference.
In fact, @code{Symbol} is one of the few classes that
@code{Exception} can use without generating circular method
and class references.  That is why the @code{handlerMethod}
instance variable (see below) is implmented as a
@code{Symbol}.

5. When writing exception handlers, you should use as much
as possible the following library API functions:
__ctalkGetRunTimeException, __ctalkHandleRunTimeException,
__ctalkPeekRunTimeException, __ctalkPeekExceptionTrace, and
__ctalkPendingException.  They are located in
@flnm{lib/except.c} and described in a later
section. @xref{Ctalk library}.

6. The only way to distinguish between different exceptions
within a handler is to compare the text returned by a
function like __ctalkGetRunTimeException.  The exception
information is generated at the time the exception is
raised, which is the information that the program should be
interested in.  Handling exceptions as soon as possible also
helps avoid confusion if one exception then causes other
exceptions.  Also, different operating systems map errors
codes differently, so Ctalk uses the operating systems'
interpretations of the errors.

7. Exception handlers in calling methods take priority over
handlers in the methods they call.  You need to be careful
that exception handlers within the scope of a caller do not
supercede each other.  This is especially true if an
application tries to use a global Exception object.  You
should try to keep Exception objects as local as possible.

@subsubheading Exception Codes

Exceptions have a corresponding integer code.  The following macros
correspond to the actual exceptions.

@cindex @code{SUCCESS_X} exception
@cindex @code{CPLUSPLUS_HEADER_X} exception
@cindex @code{MISMATCHED_PAREN_X} exception
@cindex @code{FALSE_ASSERTION_X} exception
@cindex @code{FILE_IS_DIRECTORY_X} exception
@cindex @code{FILE_ALREADY_OPEN_X} exception
@cindex @code{UNDEFINED_PARAM_CLASS_X} exception
@cindex @code{PARSE_ERROR_X} exception
@cindex @code{INVALID_OPERAND_X} exception
@cindex @code{PTR_CONVERSION_X} exception
@cindex @code{UNDEFINED_CLASS_X} exception
@cindex @code{UNDEFINED_METHOD_X} exception
@cindex @code{METHOD_USED_BEFORE_DEFINE_X} exception
@cindex @code{SELF_WITHOUT_RECEIVER_X} exception
@cindex @code{UNDEFINED_LABEL_X} exception
@cindex @code{UNDEFINED_TYPE_X} exception
@cindex @code{UNDEFINED_RECEIVER_X} exception
@cindex @code{UNKNOWN_FILE_MODE_X} exception
@cindex @code{INVALID_VARIABLE_DECLARATION_X} exception
@cindex @code{WRONG_NUMBER_OF_ARGUMENTS_X} exception
@cindex @code{SIGNAL_EVENT_X} exception
@cindex @code{INVALID_RECEIVER_X} exception
@cindex @code{NOT_A_TTY_X} exception
@cindex @code{USER_EXCEPTION_X} exception
@example
SUCCESS_X
CPLUSPLUS_HEADER_X
MISMATCHED_PAREN_X
FALSE_ASSERTION_X
FILE_IS_DIRECTORY_X
FILE_ALREADY_OPEN_X
UNDEFINED_PARAM_CLASS_X
PARSE_ERROR_X
INVALID_OPERAND_X
PTR_CONVERSION_X
UNDEFINED_CLASS_X
UNDEFINED_METHOD_X
METHOD_USED_BEFORE_DEFINE_X
SELF_WITHOUT_RECEIVER_X
UNDEFINED_LABEL_X
UNDEFINED_TYPE_X
UNDEFINED_RECEIVER_X
UNKNOWN_FILE_MODE_X
INVALID_VARIABLE_DECLARATION_X
WRONG_NUMBER_OF_ARGUMENTS_X
SIGNAL_EVENT_X
INVALID_RECEIVER_X
NOT_A_TTY_X
USER_EXCEPTION_X
@end example

@subsubheading Instance Variables
@table @code
@cindex @code{handlerMethod} instance variable @idxclscite{Exception}
@item handlerMethod
A @code{Symbol} object that contains the address of a
user defined method to handle exceptions.
@end table

@subsubheading Instance Methods

@table @code
@cindex @mnm{deleteLastException} instance method @idxclscite{Exception}
@item deleteLastException (@code{void})
Delete the last generated exception from Ctalk's internal exception list.

@cindex @mnm{handle} instance method @idxclscite{Exception}
@item handle (@code{void})
Execute the exception handler for the next pending method.
If a program calls @mnm{enableExceptionTrace} (class @code{Object}),
then @mnm{handle} also displays a walkback of the exception's copy of
the program call stack.  @xref{Object}.

@cindex @mnm{exceptionHandler} instance method @idxclscite{Exception}
@item @mnm{exceptionHandler} (@code{void})
Handle an exception either with Ctalk's default exception
handler or a user defined handler.  If the program has
called the @mnm{traceEnabled} method (class @code{Object}), 
print a stack trace also. 

@cindex @mnm{installHandler} instance method @idxclscite{Exception}
@item @mnm{installHandler} (@code{char *}@var{handler_method_name})
Install a user-defined method to handle exceptions.  The
method's receiver class must be of the same class as the exception; i.e.,
either @code{Exception} or @code{SystemErrnoException}.

@cindex @mnm{peek} instance method @idxclscite{Exception}
@item peek (@code{void})
Returns a @code{String} containing the text of the first pending
exception, if any.

@cindex @mnm{pending} instance method @idxclscite{Exception}
@item pending (@code{void})
Return @code{TRUE} if any exceptions are pending, @code{FALSE} otherwise.

@cindex @mnm{raiseCriticalException} instance method @idxclscite{Exception}
@item raiseCriticalException (@code{EXCEPTION }@var{ex}, @code{char *}@var{text})
Raise a critical exception.  A critical exception is similar to a
normal exception, below, except that it is not caught internally.  The
application must catch the exception with @code{pending} and @code{handle.}

You should use one of the @code{EXCEPTION} macros defined above
as the argument @var{ex}.

@cindex @mnm{printExceptionTrace} instance method @idxclscite{Exception}
Print a trace of the methods in the current exception's copy of 
the program's call stack.

@cindex @mnm{raiseException} instance method @idxclscite{Exception}
@item raiseException (@code{EXCEPTION }@var{ex}, @code{char *}@var{text})
Raise an exception.  You should use one of the @code{EXCEPTION} macros
defined above as the argument @var{ex}.
@end table

@node SystemErrnoException, , , Classes
@iftex
@section @code{SystemErrnoException} class
@end iftex
@ifnottex
@subheading @code{SystemErrnoException} Class
@end ifnottex
@cindex @code{SystemErrnoException} Class
@cindex @code{errno} build-in variable

The @code{SystemErrnoException} class translates operating
system errors into Ctalk exceptions.  The exceptions, which
are specific to each operating system, correspond to the
interpretation of the system's @code{errno} global
variable and allows Ctalk to work with system errors even if
the system implements its error codes via a built-in
variable, a macro, or function.

There is an example of a system error handler in the
@code{Exception} class section.  @xref{Exception}.

@subsubheading Class Variables

@table @code
@cindex @code{sysErrno} @idxclscite{SystemErrnoException}
@cindex @code{errno}
@item sysErrno
The @code{sysErrno} object contains the value of the C library's 
@code{errno} variable or macro.
@end table

@subsubheading Instance Methods

@table @code
@cindex @mnm{raiseException} method @idxclscite{SystemErrnoException}
@item raiseException (@code{char *}@var{data})
Sets the value of the @code{sysErrno} class variable and raises an
exception if the C library's @code{errno} variable or macro returns a
nonzero value.
@end table

@node InputEvent, , , Classes
@iftex
@section @code{InputEvent} Class
@end iftex
@ifnottex
@subheading @code{InputEvent} Class
@end ifnottex
@cindex @code{InputEvent} class

@subsubheading Instance Variables
@table @code
@cindex @code{eventClass} instanceVariable @idxclscite{InputEvent}
@item eventClass
An @code{Integer} that defines the class of the input event.  Ctalk 
defines the following input event classes.
@example
KBDCHAR        # ASCII Characters
KBDCUR         # Cursor Keys.  
@end example
@cindex @code{eventData} instanceVariable @idxclscite{InputEvent}
@item eventData
An @code{Integer} that contains the data specific to an input event.

For example, when used with subclasses of @code{ANSITerminalPane,}
@code{eventData} holds the ASCII value of a keypress.

When used with subclasses of X11Pane (actually, any subclass or
program that uses X11TerminalStream : queueInput), @code{eventData}
generally holds the ID of the window that received the event.

@cindex @code{xEventData1} instanceVariable @idxclscite{InputEvent}
@cindex @code{xEventData2} instanceVariable @idxclscite{InputEvent}
@cindex @code{xEventData3} instanceVariable @idxclscite{InputEvent}
@cindex @code{xEventData4} instanceVariable @idxclscite{InputEvent}
@cindex @code{xEventData5} instanceVariable @idxclscite{InputEvent}
@item xEventData1
@item xEventData2
@item xEventData3
@item xEventData4
@item xEventData5
Data provided by the @code{X11TerminalStream} input
handler.  @xref{X11TerminalStream}.
@end table

@node SignalEvent, , , Classes
@iftex
@section @code{SignalEvent} Class
@end iftex
@ifnottex
@subheading @code{SignalEvent} Class
@end ifnottex
@cindex @code{SignalEvent} class

The @code{SignalEvent} class provides methods and variable definitions
for Ctalk programs to handle signal events.

Signal handler (@ref{SignalHandler}) methods act like C functions
when a program installs them to handle signals.  The signal handler
methods cannot, in most cases, create objects.  Ctalk provides the
C function @code{__ctalkNewSignalEventInternal} to create and queue
@code{SignalEvent} objects from the handler.  

Here is an example of a signal handler method that creates
@code{SignalEvent} objects.
@example
#include <time.h>

SignalHandler instanceMethod handleSignal (__c_arg__ int signo) @{
  time_t t;
  char buf[MAXLABEL];
  noMethodInit;
  t = time (NULL);
  /* Format the system time, then create a new SignalEvent object,
     and add the time data to the new object's text instance variable. */
  __ctalkDecimalIntegerToASCII (t, buf);
  __ctalkNewSignalEventInternal (signo, getpid (), buf);
  return NULL;
@}
@end example

For more information, @ref{Method functions}, and @ref{__ctalkNewSignalEventInternal}.

@subsubheading Class Variables

@table @code
@cindex @code{pendingEvents} @idxclscite{SignalEvent}
@item pendingEvents
A @code{List} of pending signal events.
@end table

@subsubheading Instance Variables

@table @code
@cindex @code{processID} @idxclscite{SignalHandler}
@item processID
An @code{Integer} that contains the process ID of the program that
received the signal.

@cindex @code{sigNo} @idxclscite{SignalHandler}
@item sigNo
An @code{Integer} that contains the signal number of the handler.

@cindex @code{text} @idxclscite{SignalHandler}
@item data
A @code{String} object that contains data from the signal handler.
@end table

@subsubheading Instance Methods

@table @code
@cindex @mnm{getPID} method @idxclscite{SignalEvent}
@item @mnm{getPID} (@code{void})
Set the @code{SignalEvent} object's @code{pid} instance variable to
the program's process ID.

@cindex @mnm{new} method @idxclscite{SignalEvent}
@item @mnm{new} (@var{event1}, @var{event2}, ... @var{event3};)
Create one or more new @code{SignalEvent} objects with the names
given in the argument lists.

@example

SignalEvent new event1;
SignalEvent new event1, event2;

@end example

@cindex @mnm{nextEvent} method @idxclscite{SignalEvent}
@item @mnm{nextEvent} (@code{void})
Return the next @code{signalEvent} object from the class'
@code{pendingEvents} queue.

@cindex @mnm{pending} method @idxclscite{SignalEvent}
@item @mnm{pending} (@code{void})
Return @code{TRUE} if the class' @code{pendingEvents} queue contains
@code{SignalEvent} event objects, @code{FALSE} otherwise.

@cindex @mnm{queueEvent} method @idxclscite{SignalEvent}
@item @mnm{queueEvent} (@code{void})
Add the receiver to the class' @code{pendingEvents} queue.

@end table

@node SignalHandler, , , Classes
@iftex
@section @code{SignalHandler} Class
@end iftex
@ifnottex
@subheading @code{SignalHandler} Class
@end ifnottex
@cindex @code{SignalHandler} class

Class @code{SignalHandler} provides the methods that install handlers
for signals from the operating system.  

Applications can also define signal handlers with this class.  Signal
handler methods need to use the calling conventions of C functions.
@xref{Method functions}.

For POSIX signals, you can use a method to set the signal number.
@cindex @mnm{setSigHup} method @idxclscite{SignalHandler}
@cindex @mnm{setSigInt} method @idxclscite{SignalHandler}
@cindex @mnm{setSigQuit} method @idxclscite{SignalHandler}
@cindex @mnm{setSigIll} method @idxclscite{SignalHandler}
@cindex @mnm{setSigAbrt} method @idxclscite{SignalHandler}
@cindex @mnm{setSigFpe} method @idxclscite{SignalHandler}
@cindex @mnm{setSigSegv} method @idxclscite{SignalHandler}
@cindex @mnm{setSigPipe} method @idxclscite{SignalHandler}
@cindex @mnm{setSigAlrm} method @idxclscite{SignalHandler}
@cindex @mnm{setSigTerm} method @idxclscite{SignalHandler}
@cindex @mnm{setSigUsr1} method @idxclscite{SignalHandler}
@cindex @mnm{setSigUsr2} method @idxclscite{SignalHandler}
@cindex @mnm{setSigChld} method @idxclscite{SignalHandler}
@cindex @mnm{setSigCont} method @idxclscite{SignalHandler}
@cindex @mnm{setSigTstp} method @idxclscite{SignalHandler}
@cindex @mnm{setSigTtin} method @idxclscite{SignalHandler}
@cindex @mnm{setSigTtou} method @idxclscite{SignalHandler}
@example
Signal    Method       Signal
------    ------       ------
SIGHUP    setSigHup    Termination of terminal process.
SIGINT    setSigInt    Interrupt from keyboard.
SIGQUIT   setSigQuit   Quit from keyboard.
SIGILL    setSigIll    Illegal instruction.
SIGABRT   setSigAbrt   Abort from C library abort(3).
SIGFPE    setSigFpe    Floating point exception.
SIGKILL   -            Kill process - non-catchable.
SIGSEGV   setSigSegv   Invalid memory address.
SIGPIPE   setSigPipe   Broken pipe or write to pipe with no reader.
SIGALRM   setSigAlrm   Timer signal from C library alarm(2).
SIGTERM   setSigTerm   Process termination.
SIGUSR1   setSigUsr1   User defined.
SIGUSR2   setSigUsr2   User defined.
SIGCHLD   setSigChld   Child process stopped or terminated.
SIGCONT   setSigCont   Continue stopped process.
SIGSTOP   -            Stop process - non-catchable.
SIGTSTP   setSigTstp   Stop from tty.
SIGTTIN   setSigTtin   Terminal input for background process.
SIGTTOU   setSigTtou   Terminal output from background process.
@end example

@cindex @mnm{setSigNo} method @idxclscite{SignalHandler}
You can also set system-specific signals by number with
@mnm{setSigNo.}  

@code{SignalHandler} methods can also send @code{SignalEvent}
objects to Ctalk programs.  Refer to @ref{Method functions},
@ref{SignalEvent}, and @ref{__ctalkNewSignalEventInternal}. 

@cindex @idxfncite{__ctalkIgnoreSignal ()}
@cindex @idxfncite{__ctalkDefaultSignalHandler ()}
@cindex @idxfncite{__ctalkInstallHandler ()}
@cindex @idxfncite{__ctalkSystemSignalNumber ()}
Internally, methods in @code{SignalHandler} class use the
library functions @code{__ctalkIgnoreSignal ()},
@code{__ctalkDefaultSignalHandler ()},
@code{__ctalkInstallHandler ()}, and
@code{__ctalkSystemSignalNumber.}  Signal handlers need to
be reset after each usage.  Refer to the @flnm{timeclient.c}
example program.

@subsubheading Instance Variables

@table @code
@cindex @code{attributes} instance variable @idxclscite{SignalHandler}
@item attributes
The value of @code{attributes} can be one of the following.
@table @code
@item SIG_DEFAULT
The application uses the operating system's default signal handler for
the signal.  The operating system's documentation describes how it
handles signals.
@item SIG_IGNORE
The application ignores the signal.
@item SIG_METHOD
The application provides a method to handle the signal.
@end table

@cindex @code{handler} instance variable @idxclscite{SignalHandler}
@item handler
The value is an instance method of class @code{SignalHandler} that is 
provided by the application.
@end table

@subsubheading Instance Methods

@table @code
@cindex @mnm{defaultHandler} instance method @idxclscite{SignalHandler}
@item @mnm{defaultHandler} (@code{void})
Install the operating system's default handler for the receiver's 
signal number @code{sigNo.}  The operating system's documentation
describes how it handles signals.

@cindex @mnm{ignoreSignal} instance method @idxclscite{SignalHandler}
@item @mnm{ignoreSignal} (@code{void})
Set the receiver signal handler to ignore a signal.

@cindex @mnm{installHandler} instance method @idxclscite{SignalHandler}
@item @mnm{installHandler} (@code{OBJECT *(*}@var{method}@code{)(int)})
Install @var{method} as the receiver's signal handler.  The method
must be callable as a C function.  @xref{Method functions}.

@cindex @mnm{new} instance method @idxclscite{SignalHandler}
@item @mnm{new} (@code{char *}@var{name})
Create new @code{SignalHandler} objects with the name(s)
given in the argument list.

@cindex @mnm{raiseSignal} instance method @idxclscite{SignalHandler}
@item @mnm{raiseSignal} (@code{void})
Send the signal of the receiver's @code{sigNo} variable to the 
current program.

@cindex @mnm{setSigAbrt} instance method @idxclscite{SignalHandler}
@item @mnm{setSigAbrt} (@code{void})
Set the signal of the receiver's handler to @code{SIGABRT.}

@cindex @mnm{setSigAlrm} instance method @idxclscite{SignalHandler}
@item @mnm{setSigAlrm} (@code{void})
Set the signal of the receiver's handler to @code{SIGALRM.}

@cindex @mnm{setSigChld} instance method @idxclscite{SignalHandler}
@item @mnm{setSigChld} (@code{void})
Set the signal of the receiver's handler to @code{SIGCHLD.}

@cindex @mnm{setSigCont} instance method @idxclscite{SignalHandler}
@item @mnm{setSigCont} (@code{void})
Set the signal of the receiver's handler to @code{SIGCONT.}

@cindex @mnm{setSigFpe} instance method @idxclscite{SignalHandler}
@item @mnm{setSigFpe} (@code{void})
Set the signal of the receiver's handler to @code{SIGFPE.}

@cindex @mnm{setSigHup} instance method @idxclscite{SignalHandler}
@item @mnm{setSigHup} (@code{void})
Set the signal of the receiver's handler to @code{SIGHUP.}

@cindex @mnm{setSigIll} instance method @idxclscite{SignalHandler}
@item @mnm{setSigIll} (@code{void})
Set the signal of the receiver's handler to @code{SIGILL.}

@cindex @mnm{setSigInt} instance method @idxclscite{SignalHandler}
@item @mnm{setSigInt} (@code{void})
Set the signal of the receiver's handler to @code{SIGINT.}

@cindex @mnm{setSigNo} instance method @idxclscite{SignalHandler}
@item @mnm{setSigNo} (@code{int }@var{signum})
Set the signal number of the receiver to @var{signum}.

@cindex @mnm{setSigPipe} instance method @idxclscite{SignalHandler}
@item @mnm{setSigPipe} (@code{void})
Set the signal of the receiver's handler to @code{SIGPIPE.}

@cindex @mnm{setSigQuit} instance method @idxclscite{SignalHandler}
@item @mnm{setSigQuit} (@code{void})
Set the signal of the receiver's handler to @code{SIGQUIT.}

@cindex @mnm{setSigSegv} instance method @idxclscite{SignalHandler}
@item @mnm{setSigSegv} (@code{void})
Set the signal of the receiver's handler to @code{SIGSEGV.}

@cindex @mnm{setSigTerm} instance method @idxclscite{SignalHandler}
@item @mnm{setSigTerm} (@code{void})
Set the signal of the receiver's handler to @code{SIGTERM.}

@cindex @mnm{setSigTstp} instance method @idxclscite{SignalHandler}
@item @mnm{setSigTstp} (@code{void})
Set the signal of the receiver's handler to @code{SIGTSTP.}

@cindex @mnm{setSigTtin} instance method @idxclscite{SignalHandler}
@item @mnm{setSigTtin} (@code{void})
Set the signal of the receiver's handler to @code{SIGTTIN.}

@cindex @mnm{setSigTtou} instance method @idxclscite{SignalHandler}
@item @mnm{setSigTtou} (@code{void})
Set the signal of the receiver's handler to @code{SIGTTOU.}

@cindex @mnm{setSigUsr1} instance method @idxclscite{SignalHandler}
@item @mnm{setSigUsr1} (@code{void})
Set the signal of the receiver's handler to @code{SIGUSR1.}

@cindex @mnm{setSigUsr2} instance method @idxclscite{SignalHandler}
@item @mnm{setSigUsr2} (@code{void})
Set the signal of the receiver's handler to @code{SIGUSR2.}

@cindex @mnm{signalProcessID} method @idxclscite{SignalHandler}
@item @mnm{signalProcessID} (@code{int} @var{processid})
Send the signal @code{sigNo} of the receiver to process @var{processid}.

@cindex @mnm{sigName} instance method @idxclscite{SignalHandler}
@item @mnm{sigName} (@code{Integer} @var{signal_number})
Return a @code{String} with the name of the signal whose
number is given as the argument.

@cindex @mnm{sigNum} instance method @idxclscite{SignalHandler}
@item @mnm{sigNum} (@code{String} @var{signal_name})
Return an @code{Integer} with the value of the signal whose
name is given as the argument.

@cindex @mnm{waitStatus} instance method @idxclscite{SignalHandler}
@item @mnm{waitStatus} (@code{Integer} @var{child_pid}, @code{Integer}@var{child_return_val}, @code{Integer} @var{child_signal}, @code{Integer} @var{errno})
Checks for a change in the status of the child process given by
@var{child_pid}.

The return value is an @code{Integer} with the value 0, which
indicates that the child process has not changed status, an @code{Integer}
equal to @var{child_pid}, or -1.

If the return value is equal to @var{child_pid}, then the processes'
return code is returned in @var{child_return_val} if the process exited
normally.  If the child process was terminated by an uncaught signal,
the signal's number is returned in @var{child_signal}.

If the return value is -1, the system @var{errno} is returned in
@var{errno}, which indicates an error when the parent process called
@mnm{waitStatus}.

Here is an example.

@example

SignalHandler new s;
Integer new r, childProcessID, child_retval, child_sig,
        child_errno;

 @emph{... do stuff ...}

 r = s waitStatus childProcessID,
	child_retval, child_sig, child_errno;

 if (r == childProcessID) @{
    if (child_sig) @{
       printf ("Child received signal %s - exiting.\n",
		  s sigName child_sig);
	  exit (1);
    @}
 @}

 @emph{... do more stuff ...}

 exit (0);
 
@end example


@end table

@node Expr, Magnitude, Event, Classes
@iftex
@section @code{Expr} Class
@end iftex
@ifnottex
@subheading @code{Expr} Class
@end ifnottex
@cindex @code{Expr} class

Ctalk uses objects of class @code{Expr} and its subclasses internally
to represent C expressions, functions, and variables.

@node CFunction, , , Classes
@iftex
@section @code{CFunction} Class
@end iftex
@ifnottex
@subheading @code{CFunction} Class
@end ifnottex
@cindex @code{CFunction} class

Ctalk uses the @code{CFunction} class internally to represent C
function calls.  Ctalk installs the @code{CFunction} methods library
templates in @code{CLASSLIBDIR/libc} and @code{CLASSLIBDIR/libctalk}.

Note that this class does not, at this time, provide methods for all
C99 library function calls.  If you want to add C library templates,
look at the templates in @flnm{classes/libc} and at the API
documentation.  @xref{Templates}.  Refer to the @flnm{README} file in
the Ctalk distribution for instructions on submitting source code
contributions.


@subsubheading Class Methods

@table @code
@cindex @mnm{cAbs} method @idxclscite{CFunction}
@cindex @idxfncite{abs(3)}
@item @mnm{cAbs} (@code{int} @var{i})
Return the result object of an @cite{abs(3)} library call.

@cindex @mnm{cAcos} method @idxclscite{CFunction}
@cindex @idxfncite{acos(3)}
@item @mnm{cAcos} (@code{double} @var{d})
Return the result object of an @cite{acos(3)} library call.

@cindex @mnm{cAcosh} method @idxclscite{CFunction}
@cindex @idxfncite{acosh(3)}
@item @mnm{cAcosh} (@code{double} @var{d})
Return the result object of an @cite{acosh(3)} library call.

@cindex @mnm{cAscTime} method @idxclscite{CFunction}
@cindex @idxfncite{asctime(3)}
@item @mnm{cAscTime} (@code{struct tm *}@var{tm})
Return the result object of an @cite{asctime(3)} library call. The
value of @var{tm} is the result of a @cite{gmtime(3)} or
@cite{localtime(3)} call.

@cindex @mnm{cAsin} method @idxclscite{CFunction}
@cindex @idxfncite{asin(3)}
@item @mnm{cAsin} (@code{double} @var{d})
Return the result object of an @cite{asin(3)} library call.

@cindex @mnm{cAsinh} method @idxclscite{CFunction}
@cindex @idxfncite{asinh(3)}
@item @mnm{cAsinh} (@code{double} @var{d})
Return the result object of an @cite{asinh(3)} library call.

@cindex @mnm{cAtof} method @idxclscite{CFunction}
@cindex @idxfncite{atof(3)}
@item @mnm{cAtof} (@code{char *}@var{s})
Return the result object of an @cite{atof(3)} library call.

@cindex @mnm{cAtoi} method @idxclscite{CFunction}
@cindex @idxfncite{atoi(3)}
@item @mnm{cAtoi} (@code{char *}@var{s})
Return the result object of an @cite{atoi(3)} library call.

@cindex @mnm{cAtol} method @idxclscite{CFunction}
@cindex @idxfncite{atol(3)}
@item @mnm{cAtol} (@code{char *}@var{s})
Return the result object of an @cite{atol(3)} library call.

@cindex @mnm{cAtoll} method @idxclscite{CFunction}
@cindex @idxfncite{atoll(3)}
@item @mnm{cAtoll} (@code{char *}@var{s})
Return the result object of an @cite{atoll(3)} library call.

@cindex @mnm{cCbrt} method @idxclscite{CFunction}
@cindex @idxfncite{cbrt(3)}
@item @mnm{cCbrt} (@code{double} @var{d})
Return the result object of a @cite{cbrt(3)} library call.

@cindex @mnm{cCeil} method @idxclscite{CFunction}
@cindex @idxfncite{ceil(3)}
@item @mnm{cCeil} (@code{double} @var{d})
Return the result object of a @cite{ceil(3)} library call.

@cindex @mnm{cChdir} method @idxclscite{CFunction}
@cindex @idxfncite{chdir(3)}
@item @mnm{cChdir} (@code{char *}@var{s})
Change the working directory to @var{s}.  Returns @code{0}
on success, @code{-1} on error, and sets the system error
number.

@cindex @mnm{cClearErr} method @idxclscite{CFunction}
@cindex @idxfncite{clearerr(3)}
@item @mnm{cClearErr} (@code{OBJECT *} @var{FILECLASSOBJECT})
Perform a @cite{clearerr(3)} library call on the file stream of the 
argument.

@cindex @mnm{cClock} method @idxclscite{CFunction}
@cindex @idxfncite{clock(3)}
@item @mnm{cClock} (@code{void})
Return the result object of a @cite{clock(3)} library call.

@cindex @mnm{cCopySign} method @idxclscite{CFunction}
@cindex @idxfncite{copysign(3)}
@item @mnm{cCopySign} (@code{double} @var{d}@code{, double} @var{s})
Return the result object of a @cite{copysign(3)} library call.

@cindex @mnm{cCos} method @idxclscite{CFunction}
@cindex @idxfncite{cos(3)}
@item @mnm{cCos} (@code{double} @var{d})
Return the result object of a @cite{cos(3)} library call.

@cindex @mnm{cCosh} method @idxclscite{CFunction}
@cindex @idxfncite{cosh(3)}
@item @mnm{cCosh} (@code{double} @var{d})
Return the result object of a @cite{cosh(3)} library call.

@cindex @mnm{cCTime} method @idxclscite{CFunction}
@cindex @idxfncite{ctime(3)}
@item @mnm{cCTime} (@code{int *}@var{t})
Return the result object of a @cite{ctime(3)} library call.

@emph{Note:} Because @cite{ctime(3)} uses a pointer to @code{int} as
its argument, arguments to @mnm{cCTime} should be of class
@code{Symbol.}  @xref{Objects in Function Arguments}.

@cindex @mnm{cDiffTime} method @idxclscite{CFunction}
@cindex @idxfncite{difftime(3)}
@item @mnm{cDiffTime} (@code{int} @var{time1}@code{, int} @var{time2})
Return the result object of a @cite{difftime(3)} library call.

@cindex @mnm{cErf} method @idxclscite{CFunction}
@cindex @idxfncite{erf(3)}
@item @mnm{cErf} (@code{double} @var{d})
Return the result object of an @cite{erf(3)} library call.

@cindex @mnm{cErfc} method @idxclscite{CFunction}
@cindex @idxfncite{erfc(3)}
@item @mnm{cErfc} (@code{double} @var{d})
Return the result object of an @cite{erfc(3)} library call.

@cindex @mnm{cExp} method @idxclscite{CFunction}
@cindex @idxfncite{exp(3)}
@item @mnm{cExp} (@code{double} @var{d})
Return the result object of an @cite{exp(3)} library call.

@cindex @mnm{cExpm1} method @idxclscite{CFunction}
@cindex @idxfncite{expm1(3)}
@item @mnm{cExpm1} (@code{double} @var{d})
Return the result object of an @cite{expm1(3)} library call.

@cindex @mnm{cFabs} method @idxclscite{CFunction}
@cindex @idxfncite{fabs(3)}
@cindex @idxfncite{fabsf(3)}
@cindex @idxfncite{fabsl(3)}
@item @mnm{cFabs} (@code{double} @var{d})
Return the result object of a @cite{fabs(3)} library call.

@emph{Note:} The functions @cite{fabsf(3)} and @cite{fabsl(3)}
functions are not supported on Solaris systems that don't have
@flnm{math_c99.h}.  Use @cite{fabs(3)} or @mnm{cFabs} instead.

@cindex @mnm{cGetchar} method @idxclscite{CFunction}
@cindex @idxfncite{getchar(3)}
@item @mnm{cGetchar} (@code{void})
Return an object of class @code{Integer} from the standard input.

@cindex @mnm{cGetCwd} method @idxclscite{CFunction}
@cindex @idxfncite{getcwd(3)}
@item @mnm{cGetCwd} (@code{void})
Return the current directory as a @code{String} object.

@cindex @mnm{cGetEnv} method @idxclscite{CFunction}
@cindex @idxfncite{getenv(3)}
Return a @code{String} object with the result of a 
@cite{getenv(3)} C library function call.

@cindex @mnm{cGetPID} method @idxclscite{CFunction}
@cindex @idxfncite{getpid(3)}
@item @mnm{cGetPID} (@code{void})
Return an @code{Integer} object with the result of a 
@cite{getpid(3)} C library function call.

@cindex @mnm{cLrint} method @idxclscite{CFunction}
@cindex @idxfncite{lrint(3)}
@item @mnm{cLrint} (@var{double})
@cindex @mnm{cLrintf} method @idxclscite{CFunction}
@cindex @idxfncite{lrintf(3)}
@item @mnm{cLrintf} (@var{float})
@cindex @mnm{cLrintl} method @idxclscite{CFunction}
@cindex @idxfncite{lrintl(3)}
@item @mnm{cLrintl} (@var{long double})
@cindex @mnm{cLlrint} method @idxclscite{CFunction}
@cindex @idxfncite{llrint(3)}
@item @mnm{cLlrint} (@var{double})
@cindex @mnm{cLlrintf} method @idxclscite{CFunction}
@cindex @idxfncite{llrintf(3)}
@item @mnm{cLlrint} (@var{float})
@cindex @mnm{cLlrintl} method @idxclscite{CFunction}
@cindex @idxfncite{llrintl(3)}
@item @mnm{cLlrint} (@var{long double})
Return an @code{Integer} or @code{LongInteger} object that is the
result of a @cite{lrint(3)}, @cite{lrintf(3)}, @cite{lrintl(3)},
@cite{llrint(3)}, @cite{llrintf(3)}, or @cite{llrintf(3)} library
call.

@cindex @mnm{cStrcat} method @idxclscite{CFunction}
@cindex @idxfncite{strcat(3)}
@item @mnm{cStrcat} (@code{char *}@var{s1}, @code{char *}@var{s2})
Return the result of a @cite{strcat(3)} library function call.
@cindex @mnm{cStrcasecmp} method @idxclscite{CFunction}
@cindex @idxfncite{strcasecmp(3)}
@item @mnm{cStrcasecmp} (@code{char *}@var{s1}, @code{char *}@var{s2})
Return the result of a @cite{strcasecmp(3)} library call.

@cindex @mnm{cStrcmp} method @idxclscite{CFunction}
@cindex @idxfncite{strcmp(3)}
@item @mnm{cStrcmp} (@code{char *}@var{s1}, @code{char *}@var{s2})
Return the result of a @cite{strcmp(3)} library call.

@cindex @mnm{cStrlen} method @idxclscite{CFunction}
@cindex @idxfncite{strlen(3)}
@item @mnm{cStrlen} (@code{char *}@var{s})
Return the result of a @cite{strlen(3)} library call.

@cindex @mnm{cStrncat} method @idxclscite{CFunction}
@cindex @idxfncite{strncat(3)}
@item @mnm{cStrncat} (@code{char *}@var{s1}, @code{char *}@var{s2}, @code{int} @var{n})
Return the result of a @cite{strncat(3)} library call.

@cindex @mnm{cStrncasecmp} method @idxclscite{CFunction}
@cindex @idxfncite{strncasecmp(3)}
@item @mnm{cStrncasecmp} (@code{char *}@var{s1}, @code{char *}@var{s2}, @code{int} @var{n})
Return the result of a @cite{strncasecmp(3)} library call.

@cindex @mnm{cStrncmp} method @idxclscite{CFunction}
@cindex @idxfncite{strncmp(3)}
@item @mnm{cStrncmp} (@code{char *}@var{s1}, @code{char *}@var{s2}, @code{int} @var{n})
Return the result of a @cite{strncmp(3)} library call.

@cindex @mnm{cStrncpy} method @idxclscite{CFunction}
@cindex @idxfncite{strncpy(3)}
@item @mnm{cStrncpy} (@code{char *}@var{s1}, @code{char *}@var{s2}, @code{int} @var{n})
Return the result of a @cite{strncpy(3)} library call.

@cindex @mnm{cRand} method @idxclscite{CFunction}
@cindex @idxfncite{rand(3)}
@item @mnm{cRand} (@code{void})
Return the result of a @cite{rand(3)} library call.

@end table

This class is not complete.  The use of C library
functions is described later in this manual. @xref{C library
functions}.

@node Magnitude, Method, Expr, Classes
@iftex
@section @code{Magnitude} Class
@end iftex
@ifnottex
@subheading @code{Magnitude} Class
@end ifnottex
@cindex @code{Magnitude} class

@code{Magnitude} is the superclass of all object classes that contain
quantities.

@subsubheading Instance Methods

@table @code
@cindex @mnm{!} instance method @idxclscite{Magnitude}
@item @mnm{!} (@code{void})
When used as a prefix operator, overloads C's @samp{!} operator in 
expressions that contain objects.  

@cindex @mnm{*} instance method @idxclscite{Magnitude}
@item @mnm{*} (@code{void})
When used as a prefix operator, overloads C's @samp{*} dereference
operator and returns the first element of an @code{int}, @code{long
int,} @code{long long int,} or @code{double} array as an @code{Integer,}
@code{LongInteger,} or @code{Float} object.

@cindex @mnm{-} instance method @idxclscite{Magnitude}
@item @mnm{-} (@code{void})
Overloads the unary @samp{-} prefix operator.  Returns the 
negated value of an @code{Integer,} @code{LongInteger,} or @code{Float,}
receivers.

@cindex @mnm{asCharacter} instance method @idxclscite{Magnitude}
@item @mnm{asCharacter} (@code{void})
Return an object with the receiver's value as a @code{Character} object.

@cindex @mnm{asFloat} instance method @idxclscite{Magnitude}
@item @mnm{asFloat} (@code{void})
Return the value of an @code{Integer} or @code{LongInteger} receiver
as a @code{Float} object.  If the receiver is a @code{Float} object,
returns the receiver.  For all other classes, prints a warning
and returns @code{0.0f}.

@cindex @mnm{asInteger} instance method @idxclscite{Magnitude}
@item @mnm{asInteger} (@code{void})
Return an object with the receiver's value as an @code{Integer} object.

@cindex @mnm{asLongInteger} instance method @idxclscite{Magnitude}
@item @mnm{asLongInteger} (@code{void})
Return an object with the receiver's value as a @code{LongInteger} object.
@end table

@node Character, Float, , Classes
@iftex
@section @code{Character} Class
@end iftex
@ifnottex
@subheading @code{Character} Class
@end ifnottex
@cindex @code{Character} class

The value of @code{Character} class objects is (on most hardware 
platforms) an 8-bit integer corresponding to the ISO-8859-1 character
set.  

@subsubheading Character Constants
@cindex Character constants
@cindex Constants, character
@cindex Escape sequences, character

Ctalk recognizes the following escape sequences as character constants.

@example

\a      Alert
\b      Bell
\e      Escape
\f      Form Feed
\n      New line
\r      Carraige return
\t      Horizontal tab
\v      Vertical tab
\0      NUL
\"      Literal double quote.
\'      Literal single quote.

@end example

The @samp{\e} escape sequence is an extension to the C language
standard.

Ctalk itself doesn't interpret the character constants, though - it
simply recognizes that the character or escaped character can be part
of a literal string or character.  However, if a method encounters a
constant, it should interpret the character constant based on the
method's function.

@cindex @code{TRIM_CHAR} macro
Very often a character constant's value is enclosed in single quotes
if they are part of the token's name.  Again it's up to the method to
interpret the character's value.  The Ctalk library includes the
macros @code{TRIM_CHAR()} and @code{TRIM_CHAR_BUF()} that can remove
the quotes from the character sequences if necessary.

@emph{Note:} Ctalk does not support negative @code{Characters} (i.e.,
@code{ch} < 0) universally, even though C @code{char} types are
``signed'' by default.  This is due to the uneven support in the Ctalk
and C libraries for negative characters.  So if you need negative values,
it's generally safer to use @code{Integers}.

@cindex @code{CHAR_CONSTANT_VALUE} macro
Additionally, if an expression doesn't need a separate buffer for
function arguments, it can also use the @code{CHAR_CONSTANT_VALUE}
macro, which returns a string with the first character pointing to the
Character constant's actual value.  The argument to the macro is a C
@code{char *}.  Here is an example of how to store the value of a
Character object in a C @code{char}.

@example

char c;
OBJECT *self_value;

self_value = self value;

sscanf (CHAR_CONSTANT_VALUE(self_value -> __o_value), "%c", &c);

@end example

@subheading Instance Variables

@table @code

@cindex @mnm{value} instance variable @idxclscite{Character}
@item value
The value of an 8-bit character in the ISO-8859-1 character set.

@end table

@subsubheading Instance Methods

@table @code

@cindex @mnm{!} instance method @idxclscite{Character}
@item @mnm{!} (@code{void})
Return a character value of true if the receiver evaluates
to zero, false otherwise.

@cindex @mnm{!=} instance method @idxclscite{Character}
@item @mnm{!=} (@code{char} @var{character})
Returns true if the receiver is not equal to @var{character}.

@cindex @mnm{&} instance method @idxclscite{Character}
@item @mnm{&} (@code{char} @var{character})
Returns a bitwise AND of the receiver and the argument.

@cindex @mnm{&&} instance method @idxclscite{Character}
@item @mnm{&&} (@code{char} @var{character})
Returns @code{TRUE} if both operands are @code{TRUE,} @code{FALSE} otherwise.

@cindex @mnm{*} instance method @idxclscite{Character}
@item @mnm{*} (@code{char} @var{c})
Multiply the receiver and the operand.  The result is a @code{Character}
object. 

@cindex @mnm{*=} instance method @idxclscite{Character}
@item @mnm{*=} (@code{char} @var{c})
Multiply the receiver by the operand, and return the receiver.

@cindex @mnm{+} instance method @idxclscite{Character}
@item @mnm{+} (@code{char} @var{c})
Add the receiver and the operand.  The result is a @code{Character}
object. 

@cindex @mnm{++} instance method @idxclscite{Character}
@item @mnm{++} (@code{void})
The prefix and postfix increment operators for @code{Character} objects.

@cindex @mnm{+=} instance method @idxclscite{Character}
@item @mnm{+=} (@code{char} @var{c})
Add the operand to the receiver and the operand and return the
receiver.

@cindex @mnm{-} instance method @idxclscite{Character}
@item @mnm{-} (@code{char} @var{c})
Subtract the receiver and the operand.  The result is a @code{Character}
object. 

@cindex @mnm{--} instance method @idxclscite{Character}
@item @mnm{--} (@code{void})
The prefix and postfix decrement operators for @code{Character}
objects.

@cindex @mnm{-=} instance method @idxclscite{Character}
@item @mnm{-=} (@code{char} @var{c})
Subtract the operand from the receiver and return the receiver.

@cindex @mnm{/} instance method @idxclscite{Character}
@item @mnm{/} (@code{char} @var{c})
Divide the receiver and the operand.  The result is a @code{Character}
object. 

@cindex @mnm{/=} instance method @idxclscite{Character}
@item @mnm{/=} (@code{char} @var{c})
Divide the receiver by the operand and return the receiver.

@cindex @mnm{<} instance method @idxclscite{Character}
@item @mnm{<} (@code{char} @var{character})
Returns @code{TRUE} if the receiver is less than the operand, @code{FALSE}
otherwise.

@cindex @mnm{<<} instance method @idxclscite{Character}
@item @mnm{<<} (@code{int} @var{i})
Shift the receiver left by the number of bits in the operand, which
must be an @code{Integer}.

@cindex @mnm{<=} instance method @idxclscite{Character}
@item @mnm{<=} (@code{char} @var{character})
Returns @code{TRUE} if the receiver is less than or equal to the operand,
FALSE otherwise.

@cindex @mnm{=} instance method @idxclscite{Character}
@item @mnm{=} (@code{char} @var{character})
Set the value of the receiver object to @var{character}.

@cindex @mnm{>} instance method @idxclscite{Character}
@item @mnm{>} (@code{char} @var{character})
Returns @code{TRUE} if the receiver is greater than the operand, @code{FALSE}
otherwise.

@cindex @mnm{>>} instance method @idxclscite{Character}
@item @mnm{>>} (@code{int} @var{i})
Shift the receiver right by the number of bits in the operand, which
must be an @code{Integer}.

@cindex @mnm{>=} instance method @idxclscite{Character}
@item @mnm{>=} (@code{char} @var{character})
Returns @code{TRUE} if the receiver is greater than or equal to the operand,
FALSE otherwise.

@cindex @mnm{==} instance method @idxclscite{Character}
@item @mnm{==} (@code{char} @var{character})
Returns true if the receiver is equal to @var{character}.

@cindex @mnm{^} instance method @idxclscite{Character}
@item @mnm{^} (@code{char} @var{character})
Returns a bitwise XOR of the receiver and the argument.

@cindex @mnm{~} instance method @idxclscite{Character}
Returns a @code{Character} object that is the bitwise
complement of the receiver.  This method simply
calls @mnm{bitComp}, below.

@cindex @mnm{bitComp} instance method @idxclscite{Character}
@item @mnm{bitComp} (@code{void})
Perform a bitwise complement of the receiver.

@cindex @mnm{invert} instance method @idxclscite{Character}
@item @mnm{invert} (@code{void})
Returns @code{TRUE} if the receiver evaluates to @code{FALSE,}
@code{FALSE} if the receiver evaluates to @code{TRUE.}

@cindex @mnm{isASCII} instance method @idxclscite{Character}
@item @mnm{isASCII} (@code{void})
Returns @code{TRUE} if the receiver is a 7-bit ASCII character @samp{0-127},
FALSE otherwise.

@cindex @mnm{isAlNum} instance method @idxclscite{Character}
@item @mnm{isAlNum} (@code{void})
Returns @code{TRUE} if the receiver is an alphanumeric character @samp{0-9},
@samp{A-Z}, @samp{a-z}, @code{FALSE} otherwise.

@cindex @mnm{isAlpha} instance method @idxclscite{Character}
@item @mnm{isAlpha} (@code{void})
Returns @code{TRUE} if the receiver is an alphabetic character
@samp{A-Z}, @samp{a-z}, @code{FALSE} otherwise.

@cindex @mnm{isBlank} instance method @idxclscite{Character}
@item @mnm{isBlank} (@code{void})
Returns @code{TRUE} if the receiver is a space @samp{ } or horizontal
tab @samp{\t} character, @code{FALSE} otherwise.

@cindex @mnm{isCntrl} instance method @idxclscite{Character}
@item @mnm{isCntrl} (@code{void})
Returns @code{TRUE} if the receiver is a control character, @code{FALSE} otherwise.

@cindex @mnm{isDigit} instance method @idxclscite{Character}
@item @mnm{isDigit} (@code{void})
Returns @code{TRUE} if the receiver is a character @samp{0-9}, @code{FALSE} otherwise.

@cindex @mnm{isGraph} instance method @idxclscite{Character}
@item @mnm{isGraph}(@code{void})
Returns @code{TRUE} if the receiver is any character except a space, @code{FALSE}
otherwise.

@cindex @mnm{isLower} instance method @idxclscite{Character}
@item @mnm{isLower} (@code{void})
Returns @code{TRUE} if the receiver is a lower case character, @code{FALSE}
otherwise.

@cindex @mnm{isPrint} instance method @idxclscite{Character}
@item @mnm{isPrint} (@code{void})
Returns @code{TRUE} if the receiver is a printable character, @code{FALSE}
otherwise.

@cindex @mnm{isPunct} instance method @idxclscite{Character}
@item @mnm{isPunct} (@code{void})
Returns @code{TRUE} if the receiver is a printable non-alphanumeric
character, @code{FALSE} otherwise. 

@cindex @mnm{isSpace} instance method @idxclscite{Character}
@item @mnm{isSpace} (@code{void})
Returns @code{TRUE} if the receiver is a space, horizontal tab (@code{\t}),
newline (@code{\n}), vertical tab (@code{\v}), form feed (@code{\f}),
or carriage return (@code{\r}) character, @code{FALSE} otherwise.

@cindex @mnm{isUpper} instance method @idxclscite{Character}
@item @mnm{isUpper} (@code{void})
Returns @code{TRUE} if the receiver is an upper case letter, @code{FALSE} otherwise.

@cindex @mnm{isXDigit} instance method @idxclscite{Character}
@item @mnm{isXDigit} (@code{void})
Returns @code{TRUE} if the receiver is a character @samp{0-9},
@samp{a-f}, or @samp{A-F}, @code{FALSE} otherwise.

@cindex @mnm{toLower} instance method @idxclscite{Character}
@item @mnm{toLower} (@code{void})
If the receiver is an upper case letter, returns the lower case
version. 

@cindex @mnm{toUpper} instance method @idxclscite{Character}
@item @mnm{toUpper} (@code{void})
If the receiver is a lower case letter, returns the upper case 
version.

@cindex @mnm{|} instance method @idxclscite{Character}
@item @mnm{|} (@code{char} @var{character})
Returns a bitwise OR of the receiver and the argument.

@cindex @mnm{||} instance method @idxclscite{Character}
@item @mnm{||} (@code{char} @var{character})
Returns @code{TRUE} if either operand is @code{TRUE,} @code{FALSE} otherwise.

@end table

@node String, , , Classes
@iftex
@section @code{String} Class
@end iftex
@ifnottex
@subheading @code{String} Class
@end ifnottex
@cindex @code{String} class

Objects of @code{String} class contain arrays of ASCII characters.
The value of a @code{String} object is similar to the C language
organization of strings as a NUL terminated array of @code{char}
values.

In most cases, @code{String} objects can be used like a collection of
@code{Character} objects.  The overloaded operators @mnm{++},
@mnm{--}, @mnm{+}, and @mnm{-}, all work similarly to the operators in
@code{List} or @code{AssociativeArray} objects.

Some of @code{String} classes' methods add semantics to operators,
like the @mnm{+=} method, which behaves differently depending on
whether its argument is another @code{String} object, or an
@code{Integer} object.

@example

myString = "Hello, ";    /* The resulting value is, */
myString += "world!";    /* "Hello, world!"         */

myString = "Hello, ";    /* The resulting value is, */
myString += 3;           /* "lo, "                  */

@end example

The main exception to this is the @mnm{map} method, which doesn't
allow incrementing @code{self} within an argument block.  This is
because @code{String} objects don't use @code{Key} objects internally
to order a @code{String} object's individual @code{Character} objects.
If it's necessary to treat a @code{String} object as a collection, the
@code{asList} method will organize the receiver @code{String} into a
@code{List} of @code{Character} objects.

@cindex @mnm{asString} instance method @idxclscite{List}
@cindex @mnm{asString} instance method @idxclscite{Array}
Conversely, @code{Array} and @code{List} classes contain the
@code{asString} method, which translates an @code{Array} or @code{List}
into a String object.

@cindex @mnm{matchRegex} instance method @idxclscite{String}
@cindex @mnm{=~} instance method @idxclscite{String}
@cindex @mnm{!~} instance method @idxclscite{String}
In addition, methods like @mnm{matchRegex}, @mnm{=~}, and @mnm{!~} can
accept as arguments strings that contain regular expression
metacharacters and use them to perform regular expression matches on
the receiver @code{String}. @xref{Pattern Matching}.

@subsubheading Instance Variables

@table @code

@cindex @code{value} instance variable @idxclscite{String}
@item value
The value is a pointer to the character string.

@end table

@subsubheading Instance Methods

@table @code

@cindex @mnm{*} instance method @idxclscite{String}
@item @mnm{*} (@code{void})
When used as a prefix operator, overloads C's @samp{*} dereference
operator and returns the first element of the receiver, a
@code{Character} object.

@cindex @mnm{=} instance method @idxclscite{String}
@item @mnm{=} (@code{char *}@var{s})
Set the value of the receiver object to @var{s.}

@cindex @mnm{==} instance method @idxclscite{String}
@item @mnm{==} (@code{char *}@var{s})
Return @code{TRUE} if @var{s} and the receiver are identical, 
@code{FALSE} otherwise.

@cindex @mnm{=~} instance method @idxclscite{String}
@item @mnm{=~} (@code{char *}@var{pattern})
Returns a @code{Boolean} value of @code{true} if the receiver contains
the regular expression @var{pattern}, false otherwise.
@xref{Pattern Matching}.

@cindex @mnm{!~} instance method @idxclscite{String}
@item @mnm{!~} (@code{char *}@var{pattern})
Returns a @code{Boolean} value of @code{false} if the receiver
does not contain the argument, @var{pattern}, which may
contain regular expression metacharacters.  
@xref{Pattern Matching}.

@cindex @mnm{!=} instance method @idxclscite{String}
@item @mnm{!=} (@code{char *}@var{s})
Return @code{FALSE} if @var{s} and the receiver are not identical, 
@code{TRUE} otherwise.

@cindex @mnm{!=} instance method @idxclscite{String}
@item @mnm{!=} (@code{char *}@var{s})
Return @code{FALSE} if @var{s} and the receiver are not identical, 
@code{TRUE} otherwise.

@cindex @mnm{+} instance method @idxclscite{String}
@item @mnm{+} (@code{String} @var{s})
@item @mnm{+} (@code{Integer} @var{i})
If the argument is a @code{String}, concatenate the receiver and
@var{s} and return the new @code{String.}  If the argument is an
@code{Integer}, return a reference to the receiver plus @var{i}.

@cindex @idxfncite{__ctalkIncStringRef ()} 
@cindex @mnm{++} instance method @idxclscite{String}
@item @mnm{++} (@code{void})
Increment the value of the receiver as a @code{char *}.  This method
uses @cite{__ctalkIncStringRef ()} to handle the pointer math.  

In other words, this method effectively sets the receiver
@code{String's} value from, for example, @samp{Hello, world!} to
@samp{ello, world!}.  If the receiver is incremented to the end of its
contents, then its value is @code{NULL}.

@cindex @mnm{+=} instance method @idxclscite{String}
@item @mnm{+=} (@code{String} @var{s})
@item @mnm{+=} (@code{Integer} @var{i})
If the argument is an @code{Integer}, increment the reference to the
receiver by that amount.  If the argument is a @code{String} or any
other class, concatenate the argument to the receiver and return the
receiver, formatting it as a string first if necessary.

@cindex @idxfncite{__ctalkIncStringRef ()} 
@cindex @mnm{-} instance method @idxclscite{String}
@item @mnm{-} (@code{Integer} @var{i})
Return a reference to the receiver @code{String} minus @var{i}.
If the reference is before the start of the string, return NULL.
That means the method is only effective after a call to @mnm{++}
or a similar method.

@example

String new str;

str = "Hello, world!";

str += 1;

printf ("%s\n", str);    /* Prints, "ello, world!" */

--str;

printf ("%s\n", str);    /* Prints, "Hello, world!" */


@end example
@cindex @idxfncite{__ctalkIncStringRef ()} 
@cindex @mnm{--} instance method @idxclscite{String}
@item @mnm{--} (@code{void})
Decrement the value of the receiver as a @code{char *}.  The effect is
the converse of @mnm{++}, above.  The method doesn't decrement the
reference so that it points before the beginning of the @code{String}
object's contents.  That means, like @mnm{-} above, the method only
returns a pointer to somewhere in the receiver's value after a
previous call to @mnm{++} or a similar method.  For example,

@example

String new str;

str = "Hello, world!";

++str;

printf ("%s\n", str);    /* Prints, "ello, world!" */

--str;

printf ("%s\n", str);    /* Prints, "Hello, world!" */


@end example

@item @mnm{-=} (@code{Integer} @var{i})
If the argument is an @code{Integer}, decrement the reference
to the receiver's value by the amount given as the argument, 
an @code{Integer}.  Like the other methods that decrement 
the reference to the receiver's value, the program must first
have incremented it further than the start of the string.

@cindex @mnm{asInteger} instance method @idxclscite{String}
@item @mnm{asInteger} (@code{void})
Return an @code{Integer} object with the value of the receiver.

@cindex @mnm{asList} instance method @idxclscite{String}
@item @mnm{asList} (@code{List} @var{newList})
Store each character of the receiver @code{String} as
@code{Character} object members of @var{newList}.

@cindex @mnm{at} instance method @idxclscite{String}
@item @mnm{at} (@code{int} @var{index})
Return the character at @var{index}.  The first character of the 
string is at index 0.  If @var{index} is greater than the length
of the string, return @samp{NULL}.

@cindex @mnm{atPut} instance method @idxclscite{String}
@item @mnm{atPut} (@code{int} @var{n}, @code{char} c)
Replace the @var{n}'th character of the receiver with @var{c}.  
Has no effect and returns @code{NULL} if n is greater than the length
of the receiver.  

The @mnm{atPut} method interprets the following character sequences
(with their ASCII values)

@example

Sequence   ASCII Value
\0         0
\a         7
\b         7
\n         10
\e         27
\f         10
\r         13
\t         9
\v         11

@end example

The @samp{\e} escape sequence is an extension to the C language
standard.

The method returns the receiver (with the new value) if successful.

You should note that the method does not do any conversion of the argument;
that is, if @var{c} isn't a @code{Character} object, then the results
are probably not going to be what you want.  For example, if you try
to store an @code{Integer} in a @code{String}, like this:

@example

myInt = 1;

myString atPut 0, myInt + '0';

@end example

@cindex @mnm{asCharacter} instance method @idxclscite{Magnitude}
The results aren't going to be what you want; adding ASCII @samp{'0'}
@emph{doesn't} convert @code{myInt} to a @code{Character} object.  You
still need to use the @mnm{asCharacter} method from @code{Magnitude}
class to create a @code{Character} object, as in this example.

@example

myInt = 1;

myString atPut 0, (myInt + '0') asCharacter;

@end example

The parentheses in the second argument are necessary; otherwise,
@code{asCharacter} would use @samp{'0'} as its receiver because
@code{asCharacter}, which is a method message, has a higher precedence
than @samp{+}.  Instead, @code{asCharacter's} receiver should be the
value of @samp{myInt + '0'}, so we enclose the first part expression
in parentheses so it gets evaluated first.

@cindex @mnm{callStackTrace} instance method @idxclscite{String}
@item @mnm{callStackTrace} (@code{void})
Print a call stack trace.

@cindex @mnm{charPos} instance method @idxclscite{String}
@item @mnm{charPos} (@code{char} @var{c})
Return an @code{Integer} with the position of @var{c} in the receiver.
Returns an @code{Integer} between 0 (the first character) and the
receiver's length, minus one (the last character).  If the receiver
does not contain @var{c}, returns -1.

@cindex @mnm{charPosR} instance method @idxclscite{String}
@item @mnm{charPosR} (@code{char} @var{c})
Return an @code{Integer} with the position of the last occurence of 
@var{c} in the receiver. Returns an @code{Integer} between 0 
(the first character) and the receiver's length, minus one 
(the last character).  If the receiver does not contain @var{c}, 
returns -1.

@cindex @mnm{chomp} instance method @idxclscite{String}
@item @mnm{chomp} (@code{void})
Removes a trailing newline character (@samp{\n}) if the receiver
contains one.  Named after Perl's very useful string trimming function.

@cindex @mnm{consoleReadLine} instance method @idxclscite{String}
@item @mnm{consoleReadLine} (@code{String} @var{promptStr})
Print the @var{promptStr} on the terminal and wait for the user to
enter a line of text.  If Ctalk is built with the GNU readline
libraries, adds readline's standard line editing and command history
facilities.  In that case, Ctalk also defines the
@code{HAVE_GNU_READLINE} preprocessor definition to @samp{1}.  You can
build Ctalk with or without readline; see the options to
@code{./configure} for further information.

Here is a sample program that shows how to use @mnm{consoleReadLine}.
@example
int main (int argc, char **argv) @
  String new s;
  String new promptStr;

  if (argc > 1)
    promptStr = argv[1];
  else
    promptStr = "Prompt ";

  printf ("Readline test.  Type ^C or, \"quit,\" to exit.\n");
#if HAVE_GNU_READLINE
  printf ("Ctalk built with GNU Readline Support.\n");
#else
  printf ("Ctalk built without GNU Readline Support.\n");
#endif
  while (1) @
    s consoleReadLine promptStr;
    printf ("You typed (or recalled), \"%s.\"\n", s);
    /*
     *  Matches both, "quit," and, "quit\n."
     */
    if (s match "quit")
      break;
  @}
@}
@end example

@cindex @mnm{contains} instance method @idxclscite{String}
@item @mnm{contains} (@code{String} @var{pattern})
@item @mnm{contains} (@code{String} @var{pattern}, @code{Integer} @var{starting_offset})
Returns a @code{Boolean} value of True if the receiver string contains
an exact match of the text in @var{pattern}, False otherwise.

With a second argument @var{n}, an @code{Integer}, the method begins its
search from the @var{n}'th character in the receiver string.

@cindex @mnm{envVarExists} instance method @idxclscite{String}
@item @mnm{envVarExists} (@code{char *}@var{envVarName})
Test for the presence of an environment variable.  Return
@code{TRUE} if the variable exists, @code{FALSE} otherwise.

@cindex @mnm{getEnv} instance method @idxclscite{String}
@item @mnm{getEnv} (@code{char *}@var{envVarName})
Return the value of environment variable @var{envVarName} as
the value of the receiver, or @code{(null).}  Note that this
method generates an internal exception of the environment
variable does not exist.  To test for the presence of an
environment variable without generation an exception, see
@mnm{envVarExists}, above.

@anchor{RecordSeparator}
@cindex Record separator character
@cindex @mnm{getRS} instance method @idxclscite{String}
@item @mnm{getRS} (@code{void})
Returns a @code{Character} with the current record separator.

The record separator determines whether the regular expression
metacharacters @samp{^} and @samp{$} recognize line endings.
The default value of the record separator is a newline @samp{\n}
character, which means that a @samp{^} character will match
an expression at the start of a string, or starting at
the beginning of a text line.  Likewise, a @samp{$} metacharacter
matches both the end of a line and the end of the string.

To match only at the beginning and end of the string, set
the record separator to a NUL character (@samp{\0}).
@xref{Pattern Matching}.

@cindex XLFD, determining
@cindex Font specification, determining
@cindex @mnm{isXLFD} instance method @idxclscite{String}
@item @mnm{isXLFD} (@code{void})
Returns a Boolean value of True if the receiver is
a XLFD font descriptor, False otherwise.  For more information
about font selection, refer to the @code{X11Font} class @xref{X11Font},
and the @code{X11FreeTypeFont} class @xref{X11FreeTypeFont}.

@cindex @mnm{length} instance method @idxclscite{String}
@item @mnm{length} (@code{void})
Return an object of class @code{Integer} with the length of the 
receiver in characters.

@cindex @mnm{map} instance method @idxclscite{String}
@item @mnm{map} (@code{OBJECT *(*}@var{method}@code{)()})
Execute @var{method}, an instance method of class @code{String,} for
each character of the receiver object.  For example,
@c test/expect/examples/mapstring1.c
@example

String instanceMethod printSpaceChar (void) @{
  printf (" %c", self);  /* Here, for each call to the printSpaceChar
                             method, "self" is each of myString's
                             successive characters. */
@}

int main () @{

  String new myString;

  myString = "Hello, world!";

  myString map printSpaceChar;

  printf ("\n");
@}

@end example

The argument to @mnm{map} can also be a code block:

@c test/expect/examples/mapstring2.c
@example

int main () @{

  String new myString;

  myString = "Hello, world!";

  myString map @{
    printf (" %c", self);
  @}

  printf ("\n");
@}

@end example


@cindex @mnm{match} instance method @idxclscite{String}
@item @mnm{match} (@code{char *}@var{pattern})
Returns @code{TRUE} if @var{pattern} matches the receiver
@code{String} regardless of case, false otherwise.  Both
@mnm{match} and @mnm{matchCase}, below, are being superceded
by @mnm{matchRegex} and @mnm{quickSearch}, also below.

@cindex @mnm{matchAt} instance method @idxclscite{String}
@item @mnm{matchAt} (@code{Integer} @var{idx})
Returns the text of the @var{idx'th} parenthesized match
resulting from a previous call to @mnm{matchRegex}, @mnm{=~},
or @mnm{!~}. @xref{Pattern Matching}.

@cindex @mnm{matchCase} instance method @idxclscite{String}
@item @mnm{matchCase} (@code{char *}@var{pattern})
Returns @code{TRUE} if @var{pattern} matches the receiver
case- sensitively, false otherwise.  Like @mnm{match},
above, @mnm{matchCase} is being superceded by @mnm{matchRegex}
and @mnm{quickSearch}, below.

@cindex @mnm{matchIndexAt} instance method @idxclscite{String}
@item @mnm{matchIndexAt} (@code{Integer} @var{idx})
Returns the character position in the receiver @code{String} of the
@var{idx'th} parenthesized match resulting from a previous call to
@mnm{matchRegex}, @mnm{=~}, or @mnm{!~}. @xref{Pattern Matching}.

@cindex @mnm{matchLength} instance method @idxclscite{String}
@item @mnm{matchLength} (@code{void})
Returns the length of a regular expression match from the
previous call to the @mnm{matchRegex} method, below.

@cindex @mnm{matchRegex} instance method @idxclscite{String}
@item @mnm{matchRegex} (@code{String} @var{pattern}, @code{Array} @var{offsets})
Searches the receiver, a @code{String} object, for all occurrences of
@var{pattern}.  The @mnm{matchRegex} method places the positions
of the matches in the @var{offsets} array, and returns an
@code{Integer} that contains the number of matches. @xref{Pattern
Matching}.

The @mnm{quickSearch} method, below, matches exact text
only, but it uses a much faster search algorithm.

@cindex @mnm{nMatches} instance method @idxclscite{String}
@item @mnm{nMatches} (@code{void})
Returns an @code{Integer} with the number matches from
the last call to the @mnm{matchRegex} method.

@cindex printMatchToks instance method @idxclscite{String}
@item printMatchToks (@code{Integer} @var{yesNo})
If the argument is non-zero, print the tokens of regular expression
patterns and the matching text after each regular expression match.
This can be useful when debugging regular expressions. @xref{DebugPattern}.

@cindex @mnm{printOn} instance method @idxclscite{String}
@item @mnm{printOn} (@code{char *}@var{fmt}, ...)
Format and print the method's arguments to the receiver.

@cindex @mnm{quickSearch} instance method @idxclscite{String}
@item @mnm{quickSearch} (@code{String} @var{pattern}, @code{Array} @var{offsets})
Searches the receiver, a @code{String} object, for all occurrences of
@var{pattern}.  The @mnm{quickSearch} method places the positions
of the matches in the @var{offsets} array, and returns an
@code{Integer} that contains the number of matches.

Unlike @mnm{matchRegex}, above, @mnm{quickSearch} matches exact
text only, but it uses a much faster search algorithm.

@cindex @mnm{readFormat} instance method @idxclscite{String}
@item @mnm{readFormat} (@code{char *}@var{fmt}, ...)
Scan the receiver into the arguments, using @var{fmt}.  

@cindex @mnm{search} instance method @idxclscite{String}
@item @mnm{search} (@code{String} @var{pattern}, @code{Array} @var{offsets})
This method is a synonym for @mnm{matchRegex}, above, and is here for
backward compatibility.

@cindex Record separator character
@cindex @mnm{setRS} instance method @idxclscite{String}
@item @mnm{setRS} (@code{char} @code{record_separator_char})
Sets the current application's record separator character, which
determines how regular expression metacharacters match line endings,
among other uses. @xref{RecordSeparator}. @xref{Pattern Matching}.

@cindex @mnm{split} instance method @idxclscite{String}
@item @mnm{split} (@code{char} @var{delimiter}, @code{char **} @var{resultArray})
Split the receiver at each occurrence of @var{delimiter}, and save the
result in @var{resultArray}.  The @var{delimiter} argument can be
either a @code{Character} object or a @var{String} object.  If
@var{delimiter} is a @code{String,} it uses Ctalk's pattern matching
library to match the delimiter string.  @xref{Pattern Matching}.

However, the pattern matching library only records the length of the
last match, so if you use a pattern like @samp{" *"} then the results
may be inaccurate if all of the delimiters are not the same length.

@cindex @mnm{subString} instance method @idxclscite{String}
@item @mnm{subString} (@code{int} @var{index}, @code{int} @var{length})
Return the substring of the receiver of @var{length} characters
beginning at @var{index}.  String indexes start at 0.  If @var{index}
+ @var{length} is greater than the length of the receiver, return 
the substring from @var{index} to the end of the receiver.

@cindex @mnm{sysErrnoStr} instance method @idxclscite{String}
@item @mnm{sysErrnoStr} (@code{void})
Sets the receiver's value to the text message of the last
system error (the value of @cite{errno(3)}).

@cindex @mnm{tokenize} instance method @idxclscite{String}
@item @mnm{tokenize} (@code{List} @var{tokens})
Splits the receiver @code{String} at each whitespace character
or characters (spaces, horizontal and vertical tabs, or newlines)
and pushes each non-whitespace set of characters (words, numbers,
and miscellaneous punctuation) onto the @code{List} given as the
argument.  The method uses @cite{ispunct(3)} to separate punctuation,
except for @samp{_} characters, which are used in labels.

Note that this method can generate lists with hundreds or even
thousands of tokens, so you need to take care with large (or
even medium sized) input @code{Strings} as receivers.

@cindex @mnm{tokenizeLine} instance method @idxclscite{String}
@item @mnm{tokenizeLine} (@code{List} @var{tokens})
Similar to tokenize, above.  This method also treats newline
characters as tokens, which makes it easier to parse input that relies
on newlines (for example, C++ style comments, preprocessor directives,
and some types of text files).

@anchor{vPrintOn--class String}
@cindex @mnm{vPrintOn} instance method @idxclscite{String}
@item @mnm{vPrintOn} (@code{String}@var{calling_methods_fmt_arg})
This function formats the variable arguments of its calling method
on the receiver @code{String} object.

The argument is the format argument of the calling method.  When
@mnm{vPrintOn} is called, it uses the argument as the start of the
caller's variable argument list.

Here is an example of @mnm{vPrintOn's} use.

@c test/expect/examples/vprinton1.c 
@example

Object instanceMethod myPrint (String fmt, ...) @{
  String new s;
  s vPrintOn fmt;
  return s;
@}

int main () @{
  Object new obj;
  Integer new i;
  String new str;

  i = 5;

  str = obj myPrint "Hello, world no. %d", i;

  printf ("%s\n", str);
@}

@end example

@anchor{writeFormat--class String}
@cindex @mnm{writeFormat} instance method @idxclscite{String}
@item @mnm{writeFormat} (@code{char *}@var{fmt},...)
Write the formatted arguments using @var{fmt} to the receiver.
Note that Ctalk stores scalar types as formatted strings.
@xref{Variable arguments}.
@end table

@iftex
@subsection String Searching and Pattern Matching
@end iftex
@ifnottex
@subsubheading String Searching and Pattern Matching
@end ifnottex
@anchor{Pattern Matching}

@cindex @mnm{matchRegex} instance method @idxclscite{String}
@cindex @mnm{quickSearch} instance method @idxclscite{String}
@code{String} class defines a number of methods for searching and
matching @code{String} objects.  The @mnm{matchRegex} method
recognizes some basic metacharacters to provide regular expression
search capabilities.  The @mnm{quickSearch} method searches
@code{String} objects for exact text patterns, but it uses a much
faster search algorithm.

The operators, @mnm{=~} and @mnm{!~} return true or false depending on
whether the receiver contains the pattern given as the argument.  If
the argument contains metacharacters, then Ctalk conducts a regular
expression search; otherwise, it tries to match (or not match, in the
case of @mnm{!~}) the receiver and the pattern exactly.

If you want more thorough information about the search, the
@mnm{matchRegex} and @mnm{quickSearch} methods allow an additional
argument after the text pattern: an @code{Array} object that the
methods use to return the character positions of the matches within
the receiver.  After the method is finished searching, the second
argument contains the position of the first character wherever the text
pattern matched text in the receiver.  The last offset is @samp{-1},
indicating that there are no further matches.  The methods also return
an @code{Integer} object that contains the number of matches.

Here is an example from @code{LibrarySearch} class that contains
the additional @samp{offsets} argument.

@example

if ((inputLine match KEYPAT) && 
       (inputLine matchRegex (pattern, offsets) != 0)) @{

...

@}

@end example

Searches can provide even more information than this, however.
Pattern strings may contain @cite{backreferences}, which save the text
and position of any of the receiver string's matched text that the
program needs.  The sections just below describe backreferences in
detail.

@cindex Metacharacters
@cindex Regular expression metacharacters
All of these methods (except @mnm{quickSearch}) recognize a few
regular expression metacharacters.  They are:

@table @samp
@cindex @code{.} metacharacter
@item .
Matches any single character.
@cindex @code{^} metacharacter
@item ^
Matches text at the beginning of the receiver
@code{String's} text.
@cindex @code{$} metacharacter
@item $
Matches text at the end of the receiver @code{String's} text, or
the end of a line (that is, the character before a @samp{\n} or @samp{\r}
newline character).
@cindex @code{*} metacharacter
@item *
Matches zero or more occurrences of the character or expression it follows.
@cindex @code{+} metacharacter
@item +
Matches one or more occurences of the character or expression it follows.

@cindex @code{?} metacharacter
@item ?
Matches zero or one occurrence of the character or expression it follows.

@cindex @code{\} metacharacter
@item \
Escapes the next character so it is interpreted literally; e.g., the
sequence @samp{\*} is interpreted as a literal asterisk.  Because
Ctalk's lexical analysis also performs the same task, so if you want a
backslash to appear in a pattern, you need to type, @samp{\\}, for
example,

@example

myPat = "\\*";   /* The '\\' tells Ctalk's lexer that we really
                    want a '\' to appear in the pattern string,
                    so it will still be there when we use myPat
                    as a regular expression. */

@end example

However, Ctalk also recognizes patterns, which only need to be
evaluated by the regular expression parser.  Patterns do not get
checked immediately for things like for balanced quotes and ASCII
escape sequences; instead, they get evaluated by the regular expression
parser when the program actually tries to perform some pattern
matching.  Otherwise, patterns are identical to @code{Strings}.
Expressed as a pattern, @code{myPat} in the example above would look
like this.

@example

myPat = /\*/;

@end example

Pattern strings are described in their own section, below.
@xref{Pattern Strings}.

@cindex @code{(} metacharacter
@cindex @code{)} metacharacter
@item (
@item )
Begin and end a match reference (i.e., a
@cite{backreference}). Matched text between @samp{(} and @samp{)} is
saved, along with its position in the receiver @code{String}, and can
be retrieved with subsequent calls to the @mnm{matchAt} and
@mnm{matchIndexAt} methods.  The match information is saved until the
program performs another pattern match.

@cindex Character classes
@item \W
@item \d
@item \p
@item \w
@item \l
In patterns, these escape sequences match characters of different
types.  The escape sequences have the following meanings.

@smallexample

Character Class      Matches
---------------      ------
\W                   'Word' Characters (A-Z, a-z)
\d                   Decimal Digits (0-9)
\w                   White Space (space, \t, \n, \f, \v)
\p                   Punctuation (Any other character.)
\l                   'Label' Characters (A-Z, a-z, 0-9, and _)
\x                   Hexadecimal Digits (0-9, a-f, A-F, x, and X)

@end smallexample

The following program contains a pattern that looks for
alphabetic characters, punctuation, and whitespace.

@example

int main (int argc, char **argv) @{
  String new str;

  str = "Hello, world!";

  if (str =~ /e(\W*\p\w*\W)/) @{
    printf ("match - %s\n", str matchAt 0);
  @}
@}

@end example

When run, the expression,

@example

str =~ /e(\W*\p\w*\W)/

@end example

Produces the following output.

@example

match - llo, w

@end example

@cindex @code{|} metacharacter
@item |
Matches either of the expressions on each side of the @samp{|}.
The expressions may be either a character expression, or a
set of characters enclosed in parentheses.  Here are some examples
of alternate patterns.

@example
a|b
a*|b*
a+|b+
\W+|\d+
(ab)|(cd)

@end example

When matching alternate expressions, using @samp{*} in the
expressions can produce unexpected results because a @samp{*}
can provide a zero-length match, and the @samp{|} metacharacter
is most useful when there is some text to be matched.

@cindex @mnm{matchAt} instance method @idxclscite{String}
@cindex @mnm{matchIndexAt} instance method @idxclscite{String}
If one or both expressions are enclosed in parentheses, then
the expression that matches is treated as a backreference, and
the program can retrieve the match information with the @mnm{matchAt}
and @mnm{matchIndexAt} methods.

@end table

The following example shows how to use some of the matching featues in
an actual program.  This program saves the first non-label character
(either a space or parenthesis) of a function declaration, and its
position, so we can retrieve the function name and display it
separately.

@c test/expect/examples/matchref1.c
@example

int main (argc, argv) @{
  String new text, pattern, fn_name;
  List new fn_list;

  fn_list = "strlen ()", "strcat(char *)", "strncpy (char *)",
    "stat (char *, struct stat *)";

  /* Match the first non-label character: either a space or a
     parenthesis.  The double backslashes cause the content of
     'pattern' (after the normal lexical analysis for the string) to
     be,
     
       "( *)\("

     So the regular expression parser can check for a backslashed
     opening parenthesis (i.e., a literal '(', not another
     backreference delimiter).
  */

  pattern = "( *)\\(";

  fn_list map @{
    if (self =~ pattern) @{
      printf ("Matched text: \"%s\" at index: %d\n",
	      self matchAt 0, self matchIndexAt 0);
      fn_name = self subString 0, self matchIndexAt 0;
      printf ("Function name: %s\n", fn_name);
    @}
  @}

  return 0;
@}

@end example

When run, the program should produce results like this.

@example

Matched text: " " at index: 6
Function name: strlen
Matched text: "" at index: 6
Function name: strcat
Matched text: " " at index: 7
Function name: strncpy
Matched text: " " at index: 4
Function name: stat

@end example

Note that the first backreference is numbered @samp{0}, in the
expression @samp{self matchAt 0}.  If there were another set of
(unescaped) parentheses in @code{pattern}, then its text would be
refered to as @samp{self matchAt 1}.

You should also note that the second function match saved an empty
string.  That's because the text that the backreferenced pattern
referred to resulted in a zero-length match. That's because @samp{*}
metacharacters can refer to @emph{zero} or more occurrences of the
character that precedes it.

The program could also use the @mnm{charPos} method to look for the
@samp{ } and/or @samp{(} characters, but using a regular expression
gives us information about which non-label character appears first
more efficiently.

Here's another example.  The pattern contains only one set of
parentheses, but Ctalk saves a match reference every time the pattern
matches characters in the target string.

@c test/expect/examples/matchref2.c
@example

int main () @{
  String new string, pattern;
  Array new offsets;
  Integer new nMatches, i;

  pattern = "(l*o)";
  string = "Hello, world! Hello, world, Hello, world!";
  
  nMatches = string matchRegex pattern, offsets;

  printf ("nMatches: %d\n", nMatches);
  offsets map @{
    printf ("%d\n", self);
  @}
  for (i = 0; i < nMatches; ++i) @{
    printf ("%s\n", string matchAt i);
  @}
@}

@end example

When run, the program produces output like this.

@example

nMatches: 6
2
8
16
22
30
36
-1
llo
o
llo
o
llo
o

@end example

The character classes match anywhere they find text in a
target string, including control characters like @samp{\n}
and @samp{\f}, regardless of the record separator character.
For a brief example, refer to the section, @cite{The Record
Separator Character,} below.

This example matches one of two patterns joined by a @samp{|}
metacharacter.

@c text/expect/examples/matchref3.c
@example

int main () @{
  String new s, pat;
  Array new matches;
  Integer new n_matches, n_th_match;

  pat = "-(mo)|(ho)use";

  s = "-mouse-house-";

  n_matches = s matchRegex pat, matches;

  for (n_th_match = 0; n_th_match < n_matches; ++n_th_match) @{
    printf ("Match %d. Matched %s at character index %ld.\n",
	    n_th_match, s matchAt n_th_match, s matchIndexAt n_th_match);
  @}

  matches delete;

@}

@end example

When run, the program should produce output like this.

@example

Match 0. Matched mo at character index 0.
Match 1. Matched ho at character index 6.

@end example

You should note that if a pattern in a backreference results in a zero
length match, then that backreference contains a zero length
string. While not incorrect, it can produce confusing results when
examining matched text.  The following program shows one way to
indicate a zero-length backreference.  It prints the string @samp{(null)}
whenever a backreference contains a zero-length string.

@c test/expect/examples/backref1.c
@example

int main () @{
  String new s;
  String new pat;
  Integer new n_matches;
  Array new offsets;
  Integer new i;

  s = "1.mobile 2mobile mobile";
  pat = "(\\d\\p)?m";
  
  n_matches = s matchRegex pat, offsets;
  
  for (i = 0; i < n_matches; ++i) @{
    printf ("%Ld\n", offsets at i);
  @}

  for (i = 0; i < n_matches; ++i) @{
    if ((s matchAt i) length == 0) @{
      printf ("%d: %s\n", s matchIndexAt i, "(null)");
    @} else @{
      printf ("%d: %s\n", s matchIndexAt i, s matchAt i);
    @}
  @}
@}

@end example

When run, the program should produce output that looks like this.

@example

0
10
17
0: 1.
17: (null)
22: (null)

@end example

@iftex
@subsubsection Pattern Strings
@end iftex
@ifnottex
@subsubheading Pattern Strings
@end ifnottex
@cindex Pattern strings
@anchor{Pattern Strings}

When writing a regular expression, it's necessary to take into account
all of the processing that String objects encounter when they
are evaluated, before they reach the Ctalk library's regular
expression parser.  To help facilitate lexical analysis and parsing,
Ctalk also provides @cite{pattern strings}, which allow Ctalk to
defer the evaluation of a pattern until the regular expression parser
actually performs the text matching.

Ctalk also provides operators that provide shorthand methods to match
patterns with text, the =~ and !~ operators.

Pattern constants at this time may only follow the =~ and !~
operators, but you can use the @mnm{matchAt} and @mnm{matchIndexAt},
and @mnm{nMatches} methods to retrieve the match information.  You
must, as with @code{Strings} that are used as patterns, enclose the
pattern in @samp{(} and @samp{)} metacharacters in order to create
a backreference.

Here is a simple string matching program that matches text against
a pattern constant.

@c test/expect/examples/patmatch1.c
@example

int main () @{

  String new s;
  Integer new n_offsets;
  Integer new i;
  
  s = "Hello?";

  if (s =~ /(o\?)/) @{
    printf ("match\n");
    i = 0;
    n_offsets = s nMatches;
    while (i < n_offsets) @{
      printf ("%d: %s\n", s matchIndexAt i, s matchAt i);
      ++i;
    @}
  @}
@}

@end example

The most obvious example of how a pattern provides an advantage for
text matching is when writing backslash escapes.  To make a backslash
appear in a pattern string, you need to write at least two backslashes
in order for a backslash to appear when it's needed to escape the
following character.  If you want to match an escaped backslash, then
you need to write at least @emph{four} backslashes.

@example

String         Pattern
"\\*"          /\*/        # Matches a literal '*'.
"\\\\*"        /\\*/       # Matches the expression '\*'.

@end example

To create a pattern, you delimit the characters of the pattern with
slashes (@samp{//}) instead of double quotes.  Other delimiters can
signify patterns also if the pattern starts with a @samp{m} character,
followed by the delimiter character, which must be non-alphanumeric.

@example

String         Pattern     Alternate Pattern
"\\*"          /\*/        m|\*|
"\\\\*"        /\\*/       m|\\*|

@end example

There is no single rule that governs how often @code{String} objects
are evaluated when a program runs.  So writing patterns helps take
some of the work out of testing an application's pattern matching
routines.

@iftex
@subsubsection Debugging Pattern Matches
@end iftex
@ifnottex
@subsubheading Debugging Pattern Matches
@end ifnottex
@cindex Pattern matches, debugging
@anchor{DebugPattern}

@cindex @mnm{printMatchToks} instance method @idxclscite{String}
Ctalk allows you to view the parsed pattern tokens, and the
text that each token matches.  Token printing is enabled using the
@mnm{printMatchToks} method, like this.

@example

myString printMatchToks TRUE;

@end example

When token printing is enabled, then Ctalk's pattern matching routines
print the tokens of the pattern and the text that each token matches
after every pattern match attempt.

If we have a program like the following:

@c test/expect/examples/mypatprog.c
@example

int main () @{

  String new s;

  s printMatchToks TRUE;

  s = "192.168.0.1";

  if (s =~ /\d+\.(\d+)\.\d+\.\d+/) @{
    printf ("match!\n");
  @}

@}

@end example

Then, when this program is run with token printing enabled, the
output should look similar to this.

@smallexample

joeuser@@myhost:~$ ./mypatprogram 
PATTERN: /\d+\.(\d+)\.\d+\.\d+/         TEXT: "192.168.0.1"
TOK: d+         (character class)               MATCH: "192"
TOK: .          (literal character)             MATCH: "."
TOK: (          (backreference start)           MATCH: ""
TOK: d+         (character class)               MATCH: "168"
TOK: )          (backreference end)             MATCH: ""
TOK: .          (literal character)             MATCH: "."
TOK: d+         (character class)               MATCH: "0"
TOK: .          (literal character)             MATCH: "."
TOK: d+         (character class)               MATCH: "1"
match!
joeuser@@myhost:~$ 

@end smallexample

The processed token text is followed by any attributes that the
regular expression parser finds (for example, then a pattern like
@samp{\d+} becomes the token @samp{d+} with the attribute of a
character class identifier, or the @samp{(} and @samp{)} characters'
backreference attributes).  Then, finally, the library prints the text
that matches each token.

Successful matches have text matched by each token in the
pattern (except for zero-length metacharacters like @samp{(},
@samp{)}, @samp{^}, or @samp{$}).

Unsuccessful matches, however, may display text that matches where you
don't expect it.  That's because the regular expression parser scans
along the entire length of the text, trying to match the first pattern
token, then the second pattern token, and so on.

Although this doesn't always pinpoint the exact place that a match
first failed, it can provide a roadmap to help build a complex pattern
from simpler, perhaps single-metachar patterns, which shows what the
regular expression parser is doing internally.

@iftex
@subsubsection The Record Separator Character
@end iftex
@ifnottex
@subsubheading The Record Separator Character
@end ifnottex
@cindex Record separator character

Ctalk uses a record separator character to determine how the
metacharacters @samp{^} and @samp{$} match line endings, among other
uses.

The default record separator character is a newline (@samp{\n}).
In this case a @samp{^} metacharacter in an expression matches
the beginning of a string as well as the character(s) immediately
following a newline.  Similarly, a @samp{$} metacharacter anchors
a match to the characters at the end of a line and at the end
of a string.

Setting the record separator character to NUL (@samp{\0}) causes
@samp{^} and @samp{$} to match only the beginning and the end
of a string.

Here is an example that prints the string indexes of matches with the
default newline record separator and with a NUL record separator
character.  

When the record separator is @samp{'\n'}, the @samp{$} metacharacter
in our pattern matches the text immediately before a @samp{\n}
character, as well as the text at the end of the string.

@example

int main () @{

  String new s;
  Integer new n_indexes;
  Array new match_indexes;
  String new pattern;
  
  printf ("\tMatch Indexes\n");

  /* Begin with the default record separator ('\n'). */

  s = "Hello, world!\nHello, wo\nHello, wo";
  pattern = "wo$";
  n_indexes = s matchRegex pattern, match_indexes;

  printf ("With newline record separator:\n");
  match_indexes map @{
    printf ("%d\n", self);
  @}

  s setRS '\0';   /* Set the record separator to NUL ('\0'). */

  match_indexes delete; /* Remember to start with an empty Array again. */

  n_indexes = s matchRegex pattern, match_indexes;

  printf ("With NUL record separator:\n");
  match_indexes map @{
    printf ("%d\n", self);
  @}
@}

@end example

When run, the program should produce output like this.

@example

        Match Indexes
With newline record separator:
21
31
-1
With NUL record separator:
31
-1

@end example

Likewise, a @samp{^} metacharacter matches text immediately after
the @samp{\n} record separator, or at the beginning of a string.

It's also possible, though, to match newlines (and other ASCII escape
characters) in patterns, either with a character class match, or by
adding the escape sequence to the pattern. To do that, the program
should use a double backslash with the ASCII escape sequence, as with
the newline escape sequence in this example.

@example

int main () @{
  String new s;

  s = "Hello,\nworld!";

  if (s =~ /(\W\p\\n)/)
    printf ("%s\n", s matchAt 0);
  
@}

@end example

@node Float, Integer, Character, Classes
@iftex
@section @code{Float} Class
@end iftex
@ifnottex
@subheading @code{Float} Class
@end ifnottex
@cindex @code{Float} class

Objects of @code{Float} class represent double precision, floating
point numbers.

@subheading Instance Variables

@table @code

@cindex @code{value} instance variable @idxclscite{Float}
@item value
The value is the formatted representation of a double precision
floating point number.

@end table

@subsubheading Instance Methods

@table @code
@cindex @mnm{&&} instance method @idxclscite{Float}
@item @mnm{&&} (@code{double} @var{d})
Return an @code{Integer} that evaluates to @code{TRUE} if both operands are
@code{TRUE,} @code{FALSE} otherwise.

@cindex @mnm{=} instance method @idxclscite{Float}
@item @mnm{=} (@code{double} @var{d})
Set the value of the receiver object to @var{d}.

@cindex @mnm{+} instance method @idxclscite{Float}
@item @mnm{+} (@code{double} @var{d})
Add @var{d} to the receiver.

@cindex @mnm{+=} instance method @idxclscite{Float}
@item @mnm{+=} (@code{double} @var{d})
Add @var{d} to the receiver's value.  Set the receiver to
the new value, and return the receiver.

@cindex @mnm{-} instance method @idxclscite{Float}
@item @mnm{-} (@code{void})
@item @mnm{-} (@code{double} @var{d})
Subtract @var{d} from the receiver. When used as a prefix operator,
negate the receiver.

@cindex @mnm{-=} instance method @idxclscite{Float}
@item @mnm{-=} (@code{double} @var{d})
Subtract @var{d} from the receiver's value.  Set the receiver to
the new value, and return the receiver.

@cindex @mnm{*} instance method @idxclscite{Float}
@item @mnm{*} (@code{double} @var{d})
Multiply the receiver by @var{d}.

@cindex @mnm{*=} instance method @idxclscite{Float}
@item @mnm{*=} (@code{double} @var{d})
Multiply @var{d} by the receiver's value.  Set the receiver to
the new value, and return the receiver.

@cindex @mnm{/} instance method @idxclscite{Float}
@item @mnm{*} (@code{double} @var{d})
Divide the receiver by @var{d}.

@cindex @mnm{/=} instance method @idxclscite{Float}
@item @mnm{/=} (@code{double} @var{d})
Divide @var{d} by the receiver's value.  Set the receiver to
the new value, and return the receiver.

@cindex @mnm{<} instance method @idxclscite{Float}
@item @mnm{<} (@code{double} @var{d})
Return an @code{Integer} that evaluates to @code{TRUE} if the receiver is
less than the argument, @code{FALSE} otherwise.

@cindex @mnm{<=} instance method @idxclscite{Float}
@item @mnm{<=} (@code{double} @var{d})
Return an @code{Integer} that evaluates to @code{TRUE} if the receiver is
less than or equal to the argument, @code{FALSE} otherwise.

@cindex @mnm{>} instance method @idxclscite{Float}
@item @mnm{>} (@code{double} @var{d})
Return an @code{Integer} that evaluates to @code{TRUE} if the receiver is
greater than the argument, @code{FALSE} otherwise.

@cindex @mnm{>=} instance method @idxclscite{Float}
@item @mnm{>=} (@code{double} @var{d})
Return an @code{Integer} that evaluates to @code{TRUE} if the receiver is
greater than or equal to the argument, @code{FALSE} otherwise.

@cindex @mnm{asInteger} instance method @idxclscite{Float}
@item @mnm{asInteger} (@code{void})
Return the integer portion of the receiver.

@cindex @mnm{||} instance method @idxclscite{Float}
@item @mnm{||} (@code{double} @var{d})
Return an @code{Integer} that evaluates to @code{TRUE} if either operand is
@code{TRUE,} @code{FALSE} otherwise.

@end table

@node Integer, CTime, Float, Classes
@iftex
@section @code{Integer} Class
@end iftex
@ifnottex
@subheading @code{Integer} Class
@end ifnottex
@cindex @code{Integer} class

Objects of @code{Integer} class represent signed and unsigned
integers of the C types @code{int} and @code{long int}.

@subheading Instance Variables

@table @code

@cindex @code{value} instance variable @idxclscite{Integer}
@item value
The value is the formatted representation of the receiver.

@end table

@subsubheading Instance Methods

@table @code
@cindex @mnm{!=} instance method @idxclscite{Integer}
@item @mnm{!=} (@code{int} @var{i})
Return @code{TRUE} if the receiver and the argument are not equal, @code{FALSE}
otherwise.

@cindex @mnm{&} instance method @idxclscite{Object}
@cindex @mnm{&} instance method @idxclscite{Integer}
@item @mnm{&} (@code{int} @var{i})
As a binary operator, perform a bitwise and of the receiver
and the argument.  The @code{Object} class's @mnm{&} method
overloads C's unary ``address of'' prefix operator.  @xref{Object}.

@cindex @mnm{%} instance method @idxclscite{Integer}
@item @mnm{%} (@code{int }@var{i})
Return an @code{Integer} that is the modulus of the receiver and the
argument. 

@cindex @mnm{%=} instance method @idxclscite{Integer}
@item @mnm{%=} (@code{int} @var{i})
Perform a modulus of the receiver and its argument,
and store the result in the receiver.  Returns  the
receiver.

@cindex @mnm{&&} instance method @idxclscite{Integer}
@item @mnm{&&} (@code{int} @var{i})
Return @code{TRUE} if the receiver and the argument evaluate to @code{TRUE.}

@cindex @mnm{&=} instance method @idxclscite{Integer}
@item @mnm{&=} (@code{Integer} @var{i})
Perform a bitwise and of the receiver and the argument, and assign
the result to the receiver.

@cindex @mnm{+} instance method @idxclscite{Integer}
@item @mnm{+} (@code{int} @var{i})
Add @var{i} and the receiver, as in this example.

@cindex @mnm{++} instance method @idxclscite{Integer}
@item @mnm{++} (@code{void})
Postfix and prefix increment operators for @code{Integer} objects.

@cindex @mnm{+=} instance method @idxclscite{Integer}
@item @mnm{+=} (@code{int} @var{arg})
Add the value of @var{arg} to the receiver.

@cindex @mnm{-} instance method @idxclscite{Integer}
@item @mnm{-} (@code{int} @var{i})
Subtract @var{i} from the receiver.

@cindex @mnm{-} instance method @idxclscite{Integer}
@item @mnm{-} (@code{void})
When used as a unary minus prefix operator, negate the
expression.

@cindex @mnm{--} instance method @idxclscite{Integer}
@item @mnm{--} (@code{void})
Postfix and prefix decrement operators for @code{Integer} objects.

@cindex @mnm{-=} instance method @idxclscite{Integer}
@item @mnm{-=} (@code{Integer} @var{arg})
Subtract the value of @var{arg} from the receiver.

@cindex @mnm{*} instance method @idxclscite{Integer}
@item @mnm{*} (@code{int} @var{i})
Multiply the receiver by @var{i}.

@cindex @mnm{*=} instance method @idxclscite{Integer}
@item @mnm{*=} (@code{int} @var{arg})
Multiply the receiver by @var{arg}.

@cindex @mnm{/} instance method @idxclscite{Integer}
@item @mnm{/} (@code{int} @var{i})
Divide the receiver by @var{i}.

@cindex @mnm{/=} instance method @idxclscite{Integer}
@item @mnm{/=} (@code{int} @var{arg})
Divide the receiver by @var{arg}.

@cindex @mnm{<} instance method @idxclscite{Integer}
@item @mnm{<} (@code{int} @var{i})
Return @code{TRUE} if the receiver is less than the argument, @code{FALSE}
otherwise.

@cindex @mnm{<<} instance method @idxclscite{Integer}
@item @mnm{<<} (@code{int} @var{i})
Perform an arithmetic left shift on the receiver by the number of 
bits in the argument.

@cindex @mnm{<=} instance method @idxclscite{Integer}
@item @mnm{<=} (@code{int} @var{i})
Return @code{TRUE} if the receiver is less than or equal to the argument,
@code{FALSE} otherwise.

@cindex @mnm{=} instance method @idxclscite{Integer}
@item @mnm{=} (@code{int} @var{i})
Set the value of the receiver object to @var{i}.  Also checks for
@code{Symbol} pointer contexts and other aliases.

@example
intObject = 2;

resultInt = intObject + intObject;
@end example

@cindex @mnm{==} instance method @idxclscite{Integer}
@item @mnm{==} (@code{int} @var{i})
Return @code{TRUE} if the receiver and the argument are equal, @code{FALSE}
otherwise.

@cindex @mnm{>} instance method @idxclscite{Integer}
@item @mnm{>} (@code{int} @var{i})
Return @code{TRUE} if the receiver is greater than the argument, @code{FALSE}
otherwise.

@cindex @mnm{>=} instance method @idxclscite{Integer}
@item @mnm{>=} (@code{int} @var{i})
Return @code{TRUE} if the receiver is greater than or equal to the argument,
@code{FALSE} otherwise.

@cindex @mnm{>>} instance method @idxclscite{Integer}
@item @mnm{>>} (@code{int} @var{i})
Perform an arithmetic right shift on the receiver by the number of
bits in the argument.

@cindex @mnm{^} instance method @idxclscite{Integer}
@item @mnm{^} (@code{int} @var{i})
Return the result of a bitwise xor of the receiver and
its argument.

@cindex @mnm{^=} instance method @idxclscite{Integer}
@item @mnm{^=} (@code{int} @var{i})
Preform a bitwise xor of the receiver with its argument, and
assign the value to the receiver.  Returns the receiver.

@cindex @mnm{bitComp} instance method @idxclscite{Integer}
@item @mnm{bitComp} (@code{int} @var{i})
Return the bitwise complement of the receiver.

@cindex @mnm{invert} instance method @idxclscite{Integer}
@item @mnm{invert} (@code{void})
Return @code{TRUE} if the receiver evaluates to @code{FALSE,} @code{FALSE} if the receiver
evaluates to @code{TRUE.}

@cindex @mnm{|} instance method @idxclscite{Integer}
@item @mnm{|} (@code{int} @var{i})
Perform a bitwise or of the receiver and the argument.

@cindex @mnm{|=} instance method @idxclscite{Integer}
@item @mnm{|=} (@code{Integer} @var{i})
Perform a bitwise or of the receiver and the argument, and
assign the result to the receiver.

@cindex @mnm{||} instance method @idxclscite{Integer}
@item @mnm{||} (@code{int} @var{i})
Return @code{TRUE} if either the receiver or the argument, or both,
evaluate to @code{TRUE.}

@cindex @mnm{^} instance method @idxclscite{Integer}
@item @mnm{^} (@code{int} @var{i})
Perform a bitwise exclusive or of the receiver and the argument.

@cindex @mnm{asDecimalString} instance method @idxclscite{Integer}
@cindex @mnm{asHexString} instance method @idxclscite{Integer}
@cindex @mnm{asString} instance method @idxclscite{Integer}
Returns a @code{String} formatted as a decimal or hexadecimal integer.
The @mnm{asString} method is a synonym for @mnm{asDecimalString}.

@cindex @mnm{~} instance method @idxclscite{Integer}
@item @mnm{~} (@code{void})
When used to overload C's @samp{~} operator, is synonymous
with the @mnm{bitComp} method, above.

@end table

@node CTime, CalendarTime, Integer, Classes
@iftex
@section @code{CTime} Class
@end iftex
@ifnottex
@subheading @code{CTime} Class
@end ifnottex
@cindex @code{Time} class

Objects of @code{CTime} class represent the system's UTC clock which
measures time in seconds since 1900.  This class also implements the
methods that convert UTC time into calendar time.

The return value of the methods @mnm{gmTime} and @mnm{localTime} is an
@code{Array} that contains the following values.
@example
returnArray at 0    Seconds (0... 59)
returnArray at 1    Minutes (0... 59)
returnArray at 2    Hours (0... 23)
returnArray at 3    Day of the Month (1... 31)
returnArray at 4    Month (0... 11)
returnArray at 5    Year (Number of years since 1900.)
returnArray at 6    Day of the Week (0 = Sunday ... 6 = Saturday)
returnArray at 7    Day of the Year (1... 365)
returnArray at 8    > 0 = Daylight Savings Time; 0 = Standard Time; 
                    < 0 = Not Available
@end example

@subsubheading Instance Methods
@table @code

@c Removed - it's the same as Integer : = now.
@c
@c @cindex @mnm{=} instance method @idxclscite{CTime}
@c @item @mnm{=} (@code{CTime} @var{t})
@c Sets the receiver's value to the operand.  The receiver must be
@c either a @code{CTime} or @code{Integer} object.
@c

@cindex @mnm{cTime} instance method @idxclscite{CTime}
@item @mnm{cTime} (@code{void})
Returns a formatted @code{String} with the date and time of the 
receiver.

The return @code{String} of a @code{cTime} call is formatted as in
this example.
@example
"Sun Jan 6 13:04:00 2008\n" 
@end example

@cindex @mnm{gmTime} instance method @idxclscite{CTime}
@item @mnm{gmTime} (@code{void})
Returns an @code{Array} with the values described above for the
current Greenwich Mean Time.

@cindex @mnm{haveDST} instance method @idxclscite{CTime}
@item @mnm{haveDST} (@code{void})
Return an @code{Integer} that evaluates to True if the system provides
daylight savings time information, False otherwise.

@cindex @mnm{isAM} instance method @idxclscite{CTime}
@item @mnm{isAM} (@code{void})
Returns an @code{Integer} that evaluates to True or False depending
on whether the local time is a.m. or p.m.

@cindex @mnm{localTime} instance method @idxclscite{CTime}
@item @mnm{localTime} (@code{void})
Returns an @code{Array} with the values described above for the
current local time.

@cindex @mnm{timeZoneName} instance method @idxclscite{CTime}
@item @mnm{timeZoneName} (@code{void})
Return a @code{String} with the name of the time zone provided by the
system.

@cindex @mnm{timeZoneOffset} instance method @idxclscite{CTime}
@item @mnm{timeZoneOffset} (@code{void})
Return an @code{Integer} with the time zone offset in seconds from
GMT.  Not all systems provide this information.

@cindex @mnm{utcTime} instance method @idxclscite{CTime}
@item @mnm{utcTime} (@code{void})
Return an @code{Integer} object containing the current UTC time.

@end table

@node CalendarTime, LongInteger, CTime, Classes
@iftex
@section @code{CalendarTime} class
@end iftex
@ifnottex
@subheading @code{CalendarTime} Class
@end ifnottex
@cindex @code{CalendarTime} Class

@code{CalendarTime} class provides instance variables for elements of
a broken-down clock and calendar UTC time: seconds, minutes, hours,
day of the month, and so on.  The methods in this class might be more
convenient in many cases than their functional equivalents in
@code{CTime} class.

@cindex @mnm{getUTCTime} instance method @idxclscite{CTime}
All of the methods in this class expect that the receiver has made a
previous call to @mnm{getUTCTime} (which is defined in @code{CTime}
class).  The @mnm{getUTCTime} method fills in the receiver's value
with the UTC seconds since the epoch. @xref{CTime}.

The @mnm{localTime} and @mnm{gmTime} methods contain calls
to the system's @cite{localtime(3)} and @cite{gmtime(3)}
library functions (or localtime_r and gmtime_r).  These
manual pages provide more information about how the system
translates seconds since 1900 into a local time zone's calendar
time, or UTC calendar time.

This brief example prints an ISO-format date and time string.

@c test/expect/examples/isotime.c
@example

int main () @{
  CalendarTime new ct;

  ct utcTime;
  ct localTime;
  printf ("%s\n", ct isoTimeString);
@}

@end example

@subsubheading Instance Variables

@table @code

@cindex @code{seconds} instance variable @idxclscite{CalendarTime}
@cindex @code{minutes} instance variable @idxclscite{CalendarTime}
@cindex @code{hours} instance variable @idxclscite{CalendarTime}
@cindex @code{dom} instance variable @idxclscite{CalendarTime}
@cindex @code{month} instance variable @idxclscite{CalendarTime}
@cindex @code{year} instance variable @idxclscite{CalendarTime}
@cindex @code{dow} instance variable @idxclscite{CalendarTime}
@cindex @code{doy} instance variable @idxclscite{CalendarTime}
@item seconds
@item minutes
@item hours
@item dom
@item month
@item year
@item dow
@item doy
@code{Integers} that contain the clock time and calendar date
represented by the receiver's UTC time.  The values are translated
using the local time zone information if necessary.


@example

Instance Variable                   Range
-----------------                   -----
seconds                             0 - 59
minutes                             0 - 59
hours                               0 - 23
dom  (day of the month)             1 - 31
month                               0 - 11 (0 = January)
year                                Years since 1900.
dow  (day of the week)              0 - 6  (0 = Sunday)
doy  (day of the year)              0 - 365
isdst                               > 0 : true
                                      0 : false
                                    < 0 : not available

@end example

@cindex @code{isdst} instance variable @idxclscite{CalendarTime}
@item isdst
An @code{Integer} value that indicates whether Daylight Savings Time
is in effect on systems that support it.  If the value is positive,
Daylight Savings Time is in effect, zero indicates that DST is
not in effect, and a value less than zero indicates that the information
is not available.

@cindex @code{timeZone} instance variable @idxclscite{CalendarTime}
@cindex @code{tzStd} instance variable @idxclscite{CalendarTime}
@cindex @code{tzDst} instance variable @idxclscite{CalendarTime}
@cindex @code{gmtOff} instance variable @idxclscite{CalendarTime}
@cindex @code{haveDst} instance variable @idxclscite{CalendarTime}
@item timeZone
An @code{Integer} that contains the seconds west of GMT of the
local time zone.
@item tzStd
@item tzDst
@item gmtOff
@code{String} objects that contain the abbreviation of the standard
local time zone, the local daylight savings time zone, and the hours
from GMT, usually expressed as a four digit number; e.g., @samp{-0700}
for the MST time zone.  The value of @code{gmtOff} is the result of
dividing the value of the @code{timeZone} instance variable by -3600,
them multiplying the result by 100.  The @code{haveDst} instance variable
is @code{true} if the timezone supports daylight savings time, but not
all systems support this.  To find out whether daylight savings time
is in effect, the @code{isdst} instance variable above, can provide
that information if the machine supports it.

Calling the @mnm{localTime} and @mnm{zoneInfo} methods fill in the
time zone information.

@end table

@subsubheading Instance Methods

@table @code

@cindex @mnm{cTimeString} instance method @idxclscite{CalendarTime}
@item @mnm{cTimeString} (@code{void})
Returns a formatted string with the date and time given
by the receiver.  

The returned String is formatted similarly to the output of the
@cite{ctime(3)} C function, except that the string does not include a
trailing newline.

Programs should call the @code{utcTime} method to get the current
UTC time, and then either the @mnm{localTime} or @code{gmTime} method to
convert the UTC time into calendar day and date information, before
calling this method.

@cindex @mnm{dayName} instance method @idxclscite{CalendarTime}
@item @mnm{dayName} (@code{void})
Returns a @code{String} with the three-letter abbreviation of
the current day: @samp{Sun}, @samp{Mon}, @samp{Tue}, @samp{Wed},
@samp{Thu}, @samp{Fri}, and @samp{Sat}.

@cindex @mnm{gmTime} instance method @idxclscite{CalendarTime}
@item @mnm{gmTime} (@code{void})
Fills in the receiver's instance variables with the elements
of the UTC calendar time.

Programs should call the @code{utcTime} method to get the current
UTC time before calling this method.

@cindex @mnm{isoTimeString} instance method @idxclscite{CalendarTime}
@item @mnm{isoTimeString} (@code{void})
Returns a formatted string with the date and time given by the
receiver. The returned String has the format of an ISO date and time
string.

Programs should call the @code{utcTime} method to get the current
UTC time, and then either the @mnm{localTime} or @code{gmTime} methods to
convert the UTC time into calendar day and date information, before
calling this method.

@cindex @mnm{localTime} instance method @idxclscite{CalendarTime}
@item @mnm{localTime} (@code{void})
Fills in the receiver's instance variables with the elements
of the local calendar time, as determined by the system's
time zone setting.

Programs should call the @code{utcTime} method to get the current
UTC time before calling this method.

@cindex @mnm{monName} instance method @idxclscite{CalendarTime}
@item @mnm{monName} (@code{void})
Returns a @code{String} with the three-letter abbreviation
of the current time's month: @samp{Jan}, @samp{Feb}, @samp{Mar},
@samp{Apr}, @samp{May}, @samp{Jun}, @samp{Jul}, @samp{Aug},
@samp{Sep}, @samp{Oct}, @samp{Nov}, and @samp{Dec}.

@cindex @mnm{zoneInfo} instance method @idxclscite{CalendarTime}
@item @mnm{zoneInfo} (@code{void})
Fills in the receiver's @code{timeZone}, @code{tzStd}, @code{tzDst},
@code{gmtOff}, and @code{haveDst} with information about the machine's
current time zone.

@end table

@node LongInteger, Pen, CalendarTime, Classes
@iftex
@section @code{LongInteger} class
@end iftex
@ifnottex
@subheading @code{LongInteger} Class
@end ifnottex
@cindex @code{LongInteger} Class

Objects of @code{LongInteger} class represent signed and unsigned
integers of the C type @code{long long int}.

@subheading Instance Variables

@table @code

@cindex @code{value} instance variable @idxclscite{LongInteger}
@item value
The value is the formatted representation of a signed @code{long long int}.

@end table

@subsubheading Instance Methods

@table @code

@cindex @mnm{!=} instance method @idxclscite{LongInteger}
@item @mnm{!=} (@code{long long int} @var{l})
Return @code{TRUE} if the receiver is not equal to @var{l}.

@cindex @mnm{=} instance method @idxclscite{LongInteger}
@item @mnm{=} (@code{long long int} @var{l})
Set the value of the receiver to @var{l}.

@cindex @mnm{==} instance method @idxclscite{LongInteger}
@item @mnm{==} (@code{long long int} @var{l})
Return @code{TRUE} if the receiver is equal to @var{l}.

@cindex @mnm{+} instance method @idxclscite{LongInteger}
@item @mnm{+} (@code{long long int} @var{l})
Add @var{l} to the the receiver.

@cindex @mnm{++} instance method @idxclscite{LongInteger}
@item @mnm{++} (@code{void})
Implements both the C prefix and postfix increment operators for
@code{LongInteger} objects.  

@cindex @mnm{-} instance method @idxclscite{LongInteger}
@item @mnm{-} (@code{long long int} @var{l})
Subtract @var{l} from the receiver.

@cindex @mnm{-} instance method @idxclscite{LongInteger}
@item @mnm{-} (@code{void})
When used as a prefix operator, negate the argument.

@cindex @mnm{--} instance method @idxclscite{LongInteger}
@item @mnm{--} (@code{void})
The C decrement operator, both prefix and postfix, for
@code{LongInteger} objects.

@cindex @mnm{%} instance method @idxclscite{LongInteger}
@item @mnm{%} (@code{long long int }@var{l})
Return a @code{LongInteger} that is the modulus of the receiver and the
argument. 

@cindex @mnm{%=} instance method @idxclscite{LongInteger}
@item @mnm{%=} (@code{int }@var{i})
Perform a modulus of the receiver and its argument, and
store the result in the receiver.  Returns the receiver.

@cindex @mnm{&} instance method @idxclscite{Object}
@cindex @mnm{&} instance method @idxclscite{LongInteger}
@item @mnm{&} (@code{long long int} @var{l})
Perform a bitwise AND of the receiver and the operand.  The
@code{Object} class's @mnm{&} operator overloads C's unary
``address of'' prefix operator. @xref{Object}.


@cindex @mnm{&&} instance method @idxclscite{LongInteger}
@item @mnm{&&} (@code{long long int} @var{l})
Return @code{TRUE} if both the receiver and the operand evaluate to
@code{TRUE.} 

@cindex @mnm{&=} instance method @idxclscite{Object}
@cindex @mnm{&=} instance method @idxclscite{LongInteger}
@item @mnm{&} (@code{ int} @var{i})
Perform a bitwise AND of the receiver and the operand, and
store the result in the receiver.  Returns the receiver.

@cindex @mnm{*} instance method @idxclscite{LongInteger}
@item @mnm{*} (@code{long long int} @var{l})
Multiply the receiver by @var{l}.

@cindex @mnm{/} instance method @idxclscite{LongInteger}
@item @mnm{/} (@code{long long int} @var{l})
Divide the receiver by @var{l}.

@cindex @mnm{<} instance method @idxclscite{LongInteger}
@item @mnm{<} (@code{long long int} @var{l})
Return @code{TRUE} if the receiver is less than the operand,
@code{FALSE} otherwise.

@cindex @mnm{<=} instance method @idxclscite{LongInteger}
@item @mnm{<=} (@code{long long int} @var{l})
Return @code{TRUE} if the receiver is less than or equal to the
operand, @code{FALSE} otherwise.

@cindex @mnm{<<} instance method @idxclscite{LongInteger}
@item @mnm{<<} (@code{int} @var{i})
Shift the receiver left by the number of bits in the operand, an
@code{Integer.} 

@cindex @mnm{>} instance method @idxclscite{LongInteger}
@item @mnm{>} (@code{long long int} @var{l})
Return @code{TRUE} if the receiver is greater than the operand,
@code{FALSE} otherwise.

@cindex @mnm{>=} instance method @idxclscite{LongInteger}
@item @mnm{>=} (@code{long long int} @var{l})
Return @code{TRUE} if the receiver is greater than or equal to the
operand, @code{FALSE} otherwise.

@cindex @mnm{>>} instance method @idxclscite{LongInteger}
@item @mnm{>>} (@code{int} @var{l})
Shift the receiver right by the number of bits in the operand, an
@code{Integer.} 

@cindex @mnm{^} instance method @idxclscite{LongInteger}
@item @mnm{^} (@code{long long int} @var{l})
Perform a bitwise XOR of the receiver and the operand.

@cindex @mnm{^=} instance method @idxclscite{LongInteger}
@item @mnm{^=} (@code{int} @var{i})
Perform a bitwise XOR of the receiver and the operand, and
store the result in the receiver.  Returns the receiver.

@cindex @mnm{bitComp} instance method @idxclscite{LongInteger}
@item @mnm{bitComp} (@code{void})
Return a bitwise complement of the receiver.

@cindex @mnm{invert} instance method @idxclscite{LongInteger}
@item @mnm{invert} (@code{void})
Return @code{TRUE} if the receiver evaluates to @code{FALSE,} 
@code{FALSE} if the receiver evaluates to @code{TRUE.}

@cindex @mnm{|} instance method @idxclscite{LongInteger}
@item @mnm{|} (@code{long long int} @var{l})
Perform a bitwise OR of the receiver and the operand.

@cindex @mnm{|=} instance method @idxclscite{LongInteger}
@item @mnm{|=} (@code{int} @var{i})
Perform a bitwise OR of the receiver and the operand, and
store the result in the receiver.  Returns the receiver.

@cindex @mnm{||} instance method @idxclscite{LongInteger}
@item @mnm{|} (@code{long long int} @var{l})
Return @code{TRUE} if either the receiver or the operand evaluate to
@code{TRUE.} 

@cindex @mnm{~} instance method @idxclscite{LongInteger}
@item @mnm{~} (@code{void})
When overloading C's unary @samp{~} operator, is synonymous
with the @mnm{bitComp} method, above.

@end table

@node Pen, Point, LongInteger, Classes
@iftex
@section @code{Pen} class
@end iftex
@ifnottex
@subheading @code{Pen} Class
@end ifnottex
@cindex @code{Pen} Class

@code{Pen} class objects define drawing parameters for graphics
primitives when drawing points or lines.  Currently the only 
parameter that @code{Pen} implements with the @code{width} instance
variable, which controls the width of graphics shapes like points and
lines. 

The @code{Point} class section contains an example of how to use
@code{Pen} objects when drawing graphics. @xref{Point}.

@subheading Instance Variables
@table @code
@cindex @code{alpha} instance variable @idxclscite{Pen}
@item alpha
Defines an object's opacity when using drawing libraries that support
alpha channel blending (presently that is only the @code{Line} class
drawing library, which uses the X Render extension).  The value is an
Integer in the range, 0..65535 (0..0xffff hexadecimal). For graphics
library functions that do not support alpha blending, this value is not
used.
@cindex @code{colorName} instance variable @idxclscite{Pen}
@item colorName
A @code{String} containing the name of the @code{Pen} object's
color.  The X Window System's libraries use color names
defined in the server's @flnm{rgb.txt} file, which is normally
located a directory that contains the server's configuration files
(e.g., @emph{<prefix>}@flnm{/etc/X11} or similar).
@cindex @code{width} instance variable @idxclscite{Pen}
@item width
The width in pixels of a line when drawing non-filled shapes.  The
default is 1.
@end table

@node Point, Line, Pen, Classes
@iftex
@section @code{Point} class
@end iftex
@ifnottex
@subheading @code{Point} Class
@end ifnottex
@cindex @code{Point} Class

Objects of @code{Point} class describe a location with X- and Y-axis
coordinates.  These objects are commonly used to describe
locations on a display.

The @mnm{draw} and @mnm{drawWithPen} methods allow you to draw
@code{Point} objects on a @code{X11CanvasPane} object at the
coordinates given by the point's @code{x} and @code{y} instance
variables.  There is an example program at the end of this section.
@xref{point-example}.

If you use the @mnm{draw} method and don't provide a
@code{Pen} object, Ctalk draws the point with the default 
diameter of one pixel, and the default color is black.  

@subheading Instance Variables
@table @code
@cindex @code{x} instance variable @idxclscite{Point}
@item x
The x coordinate of the receiver object.
@cindex @code{y} instance variable @idxclscite{Point}
@item y
The y coordinate of the receiver object.
@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{draw} instance method @idxclscite{Point}
@item @mnm{draw} (@code{X11Pane} @var{pane_object})
Draw the receiver on @var{pane_object} at the coordinates
given by the receiver's @code{x} and @code{y} instance
variables.

This method draws to the @code{X11Pane} objects buffer.  To draw
offscreen to a separate @code{X11Bitmap}, object refer to the method
@mnm{drawPoint} in class @code{X11Bitmap}. @xref{X11Bitmap}.

@cindex @mnm{drawWithPen} instance method @idxclscite{Point}
@item @mnm{drawWithPein} (@code{X11Pane} @var{pane_object}, @code{Pen} @var{pen_object})
Draw the receiver on @var{pane_object} at the coordinates
given by the receiver's @code{x} and @code{y} instance
variables, with the diameter and color supplied by the
@var{pen_object} argument. @xref{Pen}.

This method also draws to the @code{X11Pane} object's buffer.  To draw
offscreen to a separate @code{X11Bitmap} object, refer to the method
@mnm{drawPoint} in class @code{X11Bitmap}. @xref{X11Bitmap}.

@end table

@anchor{point-example}
@example

int main () @{
  X11Pane new xPane;
  InputEvent new e;
  X11PaneDispatcher new xTopLevelPane;
  X11CanvasPane new xCanvasPane;
  Application new paneApp;

  paneApp enableExceptionTrace;
  paneApp installExitHandlerBasic;

  xPane initialize 10, 10, 250, 250;
  xPane inputStream eventMask =        /* Tell the main window's event */
    WINDELETE|EXPOSE;                  /* object, a X11InputStream,    */
                                       /* which types of events we     */
                                       /* plan to use.                 */
  
  xTopLevelPane attachTo xPane;        /* The attachTo methods also */
  xCanvasPane attachTo xTopLevelPane;  /* set the dimensions of the */
                                       /* subpanes before they are  */
                                       /* mapped and raised along   */
                                       /* with the top-level pane.  */

  xPane map;
  xPane raiseWindow;
  xPane openEventStream;               /* Before we can do any      */
                                       /* drawing on the window, we */
                                       /* need to start sending and */
                                       /* receiving events from the */
                                       /* X server.  That is what   */
                                       /* openEventStream does.     */

  xPane background "yellow";           /* Setting the background of */
  xPane clearWindow;                   /* an X11Pane object sets the*/
                                       /* background of the actual  */
                                       /* window.                   */

  xCanvasPane background "yellow";     /* Setting the background of */
                                       /* a buffered pane like a    */
                                       /* X11CanvasPane sets the    */
                                       /* background color of its   */
                                       /* buffer.                   */

  xCanvasPane clearRectangle 0, 0, 250, 250; /* In both cases, we   */
                                             /* need to update the  */
                                             /* pane before the new */
                                             /* color is visible,   */
                                             /* with either,        */
                                             /* "clearWindow," or,  */
                                             /* "clearRectangle."   */
  xCanvasPane pen width = 100;
  xCanvasPane pen colorName = "red";
  xCanvasPane drawPoint 40, 40;
  xCanvasPane pen colorName = "green";
  xCanvasPane drawPoint 120, 40;
  xCanvasPane pen colorName = "blue";
  xCanvasPane drawPoint 80, 90;

  while (TRUE) @{
    xPane inputStream queueInput;
    if (xPane inputStream eventPending) @{
      e become xPane inputStream inputQueue unshift;
      xPane subPaneNotify e;          /* We need to notify subPanes */
                                      /* e.g., xCanvasPane of the   */
                                      /* input events from the GUI. */
      switch (e eventClass value)
        @{
        case WINDELETE:
          xPane deleteAndClose;
          exit (0);
          break;
        case EXPOSE:
        case RESIZENOTIFY:
	  xCanvasPane pen width = 100;
	  xCanvasPane pen colorName = "red";
	  xCanvasPane drawPoint 40, 40;
	  xCanvasPane pen colorName = "green";
	  xCanvasPane drawPoint 120, 40;
	  xCanvasPane pen colorName = "blue";
	  xCanvasPane drawPoint 80, 90;
          break;
        default:
          break;
        @}
    @}
  @}
@}

@end example

@node Line, Rectangle, Point, Classes
@iftex
@section @code{Line} class
@end iftex
@ifnottex
@subheading @code{Line} Class
@end ifnottex
@cindex @code{Line} class

A @code{Line} object contains the coordinates for a line graphics
shape.  @code{Line} objects use @code{Pen} objects to
specify the width and color of the line.  If an application
doesn't specify a @code{Pen} object, the default width is
one pixel and the default color is black. @xref{Pen}.

Here is an example of how to draw a line on a @code{X11Pane}
window.
@c ctalk/test/expect/examples-x11/line-draw.c
@example
int main () @{
  X11Pane new xPane;
  InputEvent new e;
  Pen new bluePen;
  Line new basicLine;

  xPane initialize 10, 10, 100, 100;
  xPane map;
  xPane raiseWindow;
  xPane openEventStream;
  bluePen width = 10;
  bluePen colorName = "blue";
  while (TRUE) @{
    xPane inputStream queueInput;
    if (xPane inputStream eventPending) @{
      e become xPane inputStream inputQueue unshift;
      switch (e eventClass value)
	@{
	case WINDELETE:
	  xPane deleteAndClose;
	  exit (0);
	  break;
	case EXPOSE:
	case RESIZENOTIFY:
	  basicLine start x = 90;
	  basicLine start y = 10;
	  basicLine end x = 10;
	  basicLine end y = 90;
 	  basicLine drawWithPen xPane, bluePen;
	  break;
	default:
	  break;
	@}
    @}
  @}
@}
@end example

@subheading Instance Variables
@table @code
@cindex @code{start} instance variable @idxclscite{Line}
@item start
A @code{Point} object that contains the receiver's starting @code{x}
and @code{y} coordinates.
@cindex @code{end} instance variable @idxclscite{Line}
@item end
A @code{Point} object that contains the receiver's ending @code{x}
and @code{y} coordinates.
@end table

@subsubheading Instance Methods
@table @code

@cindex @code{draw} instance method @idxclscite{Line}
@item draw (@code{X11Pane} @var{paneObject})
Draw a line on the @var{paneObject}'s visible area at the receiver's
@code{start} and @code{end} coordinates, using a default pen
width of one pixel and default color of black.

@cindex @code{drawLine} instance method @idxclscite{X11Bitmap}
This method is mainly used for drawing on a buffer already attached to
a @code{X11Pane} object.  To draw offscreen to a separate
@code{X11Bitmap} object, use @mnm{drawLine} in class @code{X11Bitmap}.
@xref{X11Bitmap}.

@cindex @code{drawWithPen} instance method @idxclscite{Line}
@item drawWithPen (@code{X11Pane} @var{paneObject}, @code{Pen} @var{penObject})
Draw a line on the @var{paneObject}'s visible area at the receiver's
@code{start} and @code{end} coordinates.  The @var{penObject} argument
contains the width and color of the line. @xref{Pen}.

This method is also used mainly for drawing on a buffer already attached to
a @code{X11Pane} object.  To draw offscreen to a separate
@code{X11Bitmap} object, use @mnm{drawLine} in class @code{X11Bitmap}.
@xref{X11Bitmap}.

@end table


@node Rectangle, Circle, Line, Classes
@iftex
@section @code{Rectangle} class
@end iftex
@ifnottex
@subheading @code{Rectangle} Class
@end ifnottex
@cindex @code{Rectangle} class

Programs can use @code{Rectangle} objects to describe and draw four-sided 
square and rectangular shapes.  

Although the @code{Rectangle} objects are meant to be displayed on
X11Pane displays that require only the origin and extent of a
rectangle to display it, the class defines each side's line
separately, in case a program needs to work with all of the object's
dimensions.

The methods @mnm{drawWithPen} and @mnm{fillWithPen} draw
either the sides of a rectangle or a filled rectangle, using
the line width and color defined by a @code{Pen} object.
The methods @mnm{draw} and @mnm{fill} use a default line
width of one pixel and the color black.

Here is a simple example program.
@c ctalk/test/expect/examples-x11/draw-rectangle.c
@example
int main () @{
  X11Pane new xPane;
  InputEvent new e;
  Pen new bluePen;
  Rectangle new rectangle;

  xPane initialize 10, 10, 100, 100;
  xPane map;
  xPane raiseWindow;
  xPane openEventStream;

  /*  
   *  The rectangle's sides are four Line objects:
   *  top, bottom, left, and right.  There is also
   *  a "dimensions" method that fills in all of 
   *  the sides' dimensions.
   */
  rectangle top start x = 10;
  rectangle top start y = 10;
  rectangle right end x = 80;
  rectangle right end y = 80;

  bluePen width = 3;
  bluePen colorName = "blue";

  while (TRUE) @{
    xPane inputStream queueInput;
    if (xPane inputStream eventPending) @{
      e become xPane inputStream inputQueue unshift;
      switch (e eventClass value)
        @{
        case WINDELETE:
          xPane deleteAndClose;
          exit (0);
          break;
        case EXPOSE:
        case RESIZENOTIFY:
	  /*
	   *  To draw only the outline of the rectangle,
	   *  use the "draw" method instead.
	   */
	  rectangle fillWithPen xPane, bluePen;
          break;
        default:
          break;
        @}
    @}
  @}
@}
@end example

@subheading Instance Variables
@table @code
@cindex @code{top} instance variable @idxclscite{Rectangle}
@cindex @code{right} instance variable @idxclscite{Rectangle}
@cindex @code{bottom} instance variable @idxclscite{Rectangle}
@cindex @code{left} instance variable @idxclscite{Rectangle}
@item top
@item right
@item bottom
@item left
@code{Line} objects that contain the dimensions of each of the
rectangle's sides.  Each @code{Line} instance variable in turn
contains @code{Point} objects that contain the endpoints of 
each side.

@emph{Note:} Unlike @code{Line} objects, which specify endpoints as
absolute window coordinates, @code{Rectangle} objects specify the
endpoints of each side as relative to the origin of the
@code{Rectangle} object; that is, as height and width dimensions.
@xref{Line}.
@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{clear} instance method @idxclscite{Rectangle}
@item clear (@code{X11Pane} @var{paneObject})
Clear the rectangle defined by the receiver to the background color of
@var{paneObject}.  This method requires that the dimensions of the
rectangle be completely defined.  The easiest way to do this is with
the @mnm{dimensions} method, below.

@cindex @mnm{draw} instance method @idxclscite{Rectangle}
@item draw (@code{X11Pane} @var{paneObject})
Draw an outline of the receiver's rectangle dimensions on
@var{paneObject}'s display area, using a line width of one
pixel and the color black.

@cindex @mnm{drawWithPen} instance method @idxclscite{Rectangle}
@item drawWithPen (@code{X11Pane} @var{paneObject}, @code{Pen} @var{penObject})
pDraw an outline of the receiver's rectangle dimensions on
@var{paneObject}'s display area, using the line width and color given
by @var{penObject}.

@cindex @mnm{dimensions} instance method @idxclscite{Rectangle}
@item dimensions (@code{Integer} @var{xOrigin}, @code{Integer} @var{yOrigin}, @code{Integer} @var{xSize}, @code{Integer} @var{ySize})
A convenience method that fills in the dimensions of each of the
receiver's sides from the arguments, which specify the origin, height,
and width of the receiver.

@cindex @mnm{fill} instance method @idxclscite{Rectangle}
@item fill (@code{X11Pane} @var{paneObject})
Draw a solid rectangle on @var{paneObject}'s display area,
using a default line width of one pixel and the default
color, black.

@cindex @mnm{fillWithPen} instance method @idxclscite{Rectangle}
@item fillWithPen (@code{X11Pane} @var{paneObject}, @code{Pen} @var{penObject})
Draw a solid rectangle on @var{paneObject}'s display area, using the
color given by @var{penObject}.
@end table

@node Circle, , Rectangle, Classes
@iftex
@section @code{Circle} class
@end iftex
@ifnottex
@subheading @code{Circle} Class
@end ifnottex
@cindex @code{Circle} class

Objects of @code{Circle} class contain instance variables that define
the center and radius of a circle.  The class also defines methods
for drawing circles on X displays.  

The methods defined in this class can render circles on any
GUI drawable surface.   To work with the pane buffering mechanism,
however, @code{X11CanvasPane} class also defines drawing methods.
@xref{X11CanvasPane}.

Circle drawing methods also require an interior color argument.  This
is the name of the color within the circle.  To give the appearance of
drawing just the circle's rim, a program can set the interior color to
the window's background color.  If the fill argument is TRUE, then the
circle is filled with the rim color.  If the fill argument is FALSE,
the width and color of the rim are determined by the pen object used
to draw the circle, and the color inside the circle is determined by
the interior color argument.

@c test/expect/examples-x11/canvas-circle.c
@example

int main () @{
  X11Pane new xPane;
  InputEvent new e;
  X11PaneDispatcher new xTopLevelPane;
  X11CanvasPane new xCanvasPane;
  Application new paneApp;
  Circle new inner;
  Circle new outer;
  Circle new middle;
  Pen new innerPen;
  Pen new middlePen;
  Pen new outerPen;
  String new bgColor;

  paneApp enableExceptionTrace;
  paneApp installExitHandlerBasic;

  bgColor = "white";

  xPane initialize 10, 10, 300, 300;
  xTopLevelPane attachTo xPane; 
  xCanvasPane attachTo xTopLevelPane;
  xPane map;
  xPane raiseWindow;
  xPane openEventStream;
  xPane clearWindow;
  xCanvasPane background bgColor;

  inner center x = 150;
  inner center y = 150;
  inner radius = 30;

  innerPen colorName = "navy";
  innerPen width = 10;

  middle center x = 150;
  middle center y = 150;
  middle radius = 40;

  middlePen colorName = "blue";
  middlePen width = 10;

  outer center x = 150;
  outer center y = 150;
  outer radius = 50;

  outerPen colorName = "sky blue";
  outerPen width = 10;

  xCanvasPane pen width = 1;
  xCanvasPane pen colorName = "black";

  xCanvasPane drawCircle outer, outerPen, FALSE, bgColor;
  xCanvasPane drawCircle middle, middlePen, FALSE, bgColor;
  xCanvasPane drawCircle inner, innerPen, FALSE, bgColor;
  xCanvasPane drawLine 50, 150, 250, 150;
  xCanvasPane drawLine 150, 50, 150, 250;
  xCanvasPane refresh;

  while (TRUE) @{
    xPane inputStream queueInput;
    if (xPane inputStream eventPending) @{
      e become xPane inputStream inputQueue unshift;
      xPane subPaneNotify e;
      switch (e eventClass value)
        @{
        case WINDELETE:
          xPane deleteAndClose;
          exit (0);
          break;
        case EXPOSE:
        case RESIZENOTIFY:
	  xCanvasPane drawCircle outer, outerPen, TRUE, bgColor;
	  xCanvasPane drawCircle middle, middlePen, TRUE, bgColor;
	  xCanvasPane drawCircle inner, innerPen, TRUE, bgColor;
	  xCanvasPane drawLine 50, 150, 250, 150;
	  xCanvasPane drawLine 150, 50, 150, 250;
	  xCanvasPane refresh;
          break;
        default:
          break;
        @}
    @}
  @}
@}

@end example

@subsubheading Instance Variables
@table @code
@cindex center instance variable @idxclscite{Circle}
@item center
A @code{Point} object that defines the @code{x,y} coordinates
of the circle's center. If drawn on a X display the units
represent pixels on the display.  @xref{Point}.
@cindex radius instance variable @idxclscite{Circle}
@item radius
An @code{Integer} that defines the @code{Circle} object's
radius.
@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{draw} instance method @idxclscite{Circle}
@item @mnm{draw} (@code{Pane} @var{paneObject}, @code{Integer} @var{filled}, @code{String} @var{bgColor})
@item @mnm{draw} (@code{Pane} @var{paneObject}, @code{Pen} @var{penObject}, @code{Integer} @var{filled}, @code{String} @var{bgColor})
Draw the receiver circle on the display.  If a @code{Pen} argument is
given, use the @code{Pen} object's color and line width to draw the
circle. If a @code{Pen} argument is not given use a default @code{Pen},
and fill the interior of the circle with @var{bgColor} if @var{filled}
is false.
@end table

@node Method, Pane, Magnitude, Classes
@iftex
@section @code{Method} Class
@end iftex
@ifnottex
@subheading @code{Method} Class
@end ifnottex
@cindex @code{Method} class

The @code{Method} class provides a virtual mechanism for objects to
maintain references to methods and also to call the methods.

A @code{Method} instance variables can contain all of the
data of an actual method.  Much of the method's instance
data is used only by the Ctalk front end, and the instance
data may or may not be needed at run time when a
@code{Method} object is created or used.  This class defines
the instance variables anyway in case a program needs them.

Note that defining a @code{Method} object does not include
the method receiver's class library.  The program must
already have included a method's receiver class, either by
constructing an object of that class, or by including the
class with the @code{require} keyword.

Note also that, in this version, @code{Method} object calls
are only tested with a receiver, so you may want to use a
virtual method as part of an expression, you might want to
write a wrapper method for it, as in this example.  The
@mnm{methodObjectMessage} method is defined in class
@code{Object}. @xref{Object}.
@c test/expect/examples/mthdobj1.c
@example
String instanceMethod selfConcat (String __arg) @{
  self = self + __arg;
  return NULL;
@}

int main () @{
  Method new m;
  String new s;
  Exception new e;

  s = "Hello,";

  m definedInstanceMethod "String", "selfConcat";
  m withArg " world!";
  s methodObjectMessage m; /* methodObjectMessage is defined */
                           /* in Object class.               */
  if (e pending) @{
    e handle;
  @} else @{
    printf ("%s\n", s);
  @}
@}
@end example

@subheading Instance Variables
@table @code
@cindex @code{methodName} instance variable @idxclscite{Method}
@item methodName
A @code{String} object that contains the method's name.
@cindex @code{methodSelector} instance variable @idxclscite{Method}
@item methodSelector
A @code{String} object that contains the name of the method's
selector.
@cindex @code{returnClass} instance variable @idxclscite{Method}
@item returnClass
A @code{String} object that contains the name of the method's return
class. 
@cindex @code{rcvrClassObject} instance variable @idxclscite{Method}
@item rcvrClassObject
A @code{Symbol} that refers to the method's receiver class object.
@cindex @code{methodFn} instance variable @idxclscite{Method}
@item methodFn
A @code{Symbol} that contains the address of the method's function
call. 
@cindex @code{methodSource} instance variable @idxclscite{Method}
@item methodSource
A @code{String} that contains the method's source code.
@cindex @code{methodParameters} instance variable @idxclscite{Method}
@item methodParameters
A @code{List} that contains the method's paramter definitions.
@cindex @code{nParams} instance variable @idxclscite{Method}
@item nParams
An @code{Integer} that contains the number of parameters the method
requires. 
@cindex @code{varargs} instance variable @idxclscite{Method}
@item varargs
An @code{Integer} that is either @code{TRUE} or @code{FALSE} depending
on whether the method takes a variable number of arguments.
@cindex @code{nArgs} instance variable @idxclscite{Method}
@item nArgs
An @code{Integer} that contains the number of arguments the method is
called with.
@cindex @code{errorLine} instance variable @idxclscite{Method}
@item errorLine
An @code{Integer} that contains the first line of the method in a
class library or program input.
@cindex @code{errorColumn} instance variable @idxclscite{Method}
@item errorColumn
An @code{Integer} that contains the first column of the method in a
class library or program input.  
@cindex @code{argFrameTop} instance variable @idxclscite{Method}
@item argFrameTop
An @code{Integer} that contains the stack index of the method's first
argument. 
@cindex @code{rcvrFrameTop} instance variable @idxclscite{Method}
@item rcvrFrameTop
An @code{Integer} that contains the stack index of the method's receiver.
@cindex @code{imported} instance variable @idxclscite{Method}
@item imported
An @code{Integer} that is either @code{TRUE} or @code{FALSE} depending
on whether the method is imported from a class library.
@cindex @code{queued} instance variable @idxclscite{Method}
@item queued
An @code{Integer} that is either @code{TRUE} or @code{FALSE} depending
on whether a method is queued for output.
@cindex @code{methodArgs} instance variable @idxclscite{Method}
@item methodArgs
A @code{List} of references to the method's arguments.
@cindex @code{localObjects} instance variable @idxclscite{Method}
@item localObjects
A @code{List} of references to the method's local objects.
@cindex @code{userObjects} instance variable @idxclscite{Method}
@item userObjects
A @code{List} of references to objects created during the method's
execution. 
@cindex @code{localCVARs} instance variable @idxclscite{Method}
@item localCVARs
A @code{List} of references to the method's local C variables.
@cindex @code{isInitialized} instance variable @idxclscite{Method}
@cindex @mnm{definedInstanceMethod} instance method @idxclscite{Object}
@cindex @mnm{definedClassMethod} instance method @idxclscite{Object}
@item isInitialized
A @code{Boolean} that is True only if the @code{Method} object
has been initialized to refer to an actual method.  This variable
should only be set by the methods @mnm{definedInstanceMethod} and
@mnm{definedClassMethod} (in @code{Object} class).
@end table

@subsubheading Instance Methods
@table @code
@cindex @code{definedClassMethod} instance method @idxclscite{Method}
@item definedClassMethod (@code{String} @var{classname}, @code{String} @var{name})
Initialize the receiver with the class method named by the arguments.
@cindex @code{definedInstanceMethod} instance method @idxclscite{Method}
@item definedInstanceMethod (@code{String} @var{classname}, @code{String} @var{name})
Initialize the receiver with the instance method named by the arguments.
@cindex @code{withArg} instance method @idxclscite{Method}
@cindex @code{methodObjectMessage} instance method @idxclscite{Object}
@item withArg (@code{Object} @var{method_argument})
Define an argument for the receiver method.

This method normally precedes a @mnm{methodObjectMessage} call.  For
examples of its use, refer to the @mnm{methodObjectMessage} section.
@xref{methodObjectMessage}.

@cindex @mnm{setCallbackName} instance method @idxclscite{Method}
@cindex Callback methods
@anchor{CallbackSetup}
@item setCallbackName (@code{String} @var{name})
Sets the receiver object's name to the name of the callback, which
is generally set when the program is compiled.  This does not
change the name of the actual method, only the name by which the
Method object that represents it is referred to.

Here is a slightly hypothetical example of the steps that use
@mnm{setCallbackName} to set up a callback method.

@example

/*
 * 1. In MyClass, the callback here is defined as an instance
 * variable.
 */
MyClass instanceVariable myCallback Method NULL;

...

/*
 * 2. Also in MyClass, define a method to configure the callback.
 */
MyClass instanceMethod onEvent (String methodClassName,
                                String methodName) @{
  Method new callbackMethod;

  callbackMethod definedInstanceMethod methodClassName, methodName;

  /* This sets the class and name of callbackMethod to the name
      of the callback instance variable defined above, at the
      start of the class. */
  callbackMethod setCallbackName "myCallback";

  self addInstanceVariable "myCallback", callbackMethod;
@}

/*
 * 3. In the program's source file, define the callback method
 * itself.
 */
MyClass instanceMethod callbackMethod (void) @{
  @emph{... do something ...}
@}

@emph{...}

/*
 * 4. Also in the program's source file, set up the callback
 * method during program initialization.
 */
int main () @{
  MyClass new myProgram;

  @emph{...}

  myProgram onEvent "MyClass", "callbackMethod";

  @emph{...}
@}

@end example

For a working example, refer to the class @code{GLXCanvasPane}, which
uses this process to assign callbacks.

@end table

@node Pane, ANSITerminalPane, Method, Classes
@iftex
@section @code{Pane} Class
@end iftex
@ifnottex
@subheading @code{Pane} Class
@end ifnottex
@cindex @code{Pane} class

@code{Pane} is the superclass of all classes that handle graphical
displays.  

Subclasses need to provide their own constructor and destructor
methods for extra object construction and cleanup.  @code{Pane}
subclasses need to provide at least a @code{paneBuffer} (below)
allocated during object creation and freed during object deletion,
unless the subclass is very simple.

@subheading Instance Variables
@table @code

@cindex @code{children} instance variable @idxclscite{Pane}
@item children
A @code{List} of child panes.

@cindex @code{cursor} instance variable @idxclscite{Pane}
@item cursor
A @code{Point} object that contains the X and Y coordinates within the
pane where text writes will occur.  

@cindex @code{mapped} instance variable @idxclscite{Pane}
@item mapped
An @code{Integer.} If @code{TRUE,} display the pane when it, or its
parent pane, receives a @mnm{refresh} message.

@cindex @code{origin} instance variable @idxclscite{Pane}
@item origin
A @code{Point} object that contains the X and Y coordinates of the
upper left-hand corner of the pane within the parent pane, or the
terminal window or display if the pane is the parent pane.

@cindex @code{paneBackingStore} instance variable @idxclscite{Pane}
@cindex @idxfncite{__ctalkCreateWinBuffer()}
@cindex @idxfncite{__ctalkANSITerminalPaneMapWindow()}
@cindex @idxfncite{__ctalkANSITerminalPaneUnMapWindow()}
@item paneBackingStore
A @code{Symbol} object that contains the memory address of the pane's
backing store buffer.  Subclasses should provide constructors that
allocate this memory, using the @cite{__ctalkCreateWinBuffer} library
function.  The methods @mnm{map} or @mnm{unmap} handle the task of 
saving and restoring window contents, by calling functions like 
@cite{__ctalkANSITerminalPaneMapWindow} and
@cite{__ctalkANSITerminalPaneUnMapWindow.} Classes that
re-implement @mnm{map} and @mnm{unmap} need to handle these tasks also.

@cindex @code{paneBuffer} instance variable @idxclscite{Pane}
@cindex @idxfncite{__ctalkCreateWinBuffer()}
@item paneBuffer
A @code{Symbol} object that contains the memory address of the pane's
display buffer.  Subclasses should provide constructors that
allocate this memory, using the @cite{__ctalkCreateWinBuffer} library
function.

@cindex @code{size} instance variable @idxclscite{Pane}
@item size
A @code{Point} object that contains the width and height of the pane.

@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{attach} method @idxclscite{Pane}
@item @mnm{attach} (@code{Pane} @var{childPane})
Attach @var{childPane} to the receiver.  If mapped, then the child
pane is displayed the next time the parent pane and its children are
updated.  If @var{childPane} is an @code{ANSITerminalPane} object, the
child pane inherits the parent's input and output stream handles.

@cindex @mnm{deletePaneBuffer} method @idxclscite{Pane}
@item @mnm{deletePaneBuffer}
Deletes the @code{paneBuffer} backing store memory that constructors 
should allocate when creating subclass objects.  Subclasses
should also use this message in destructor or cleanup methods.

@end table

@node ANSITerminalPane, ANSIWidgetPane, Pane, Classes
@iftex
@section @code{ANSITerminalPane} Class
@end iftex
@ifnottex
@subheading @code{ANSITerminalPane} Class
@end ifnottex
@cindex @code{ANSITerminalPane} class

The @code{ANSITerminalPane} class allows applications to write output
to multiple panes or windows on ANSI terminals, consoles and
@code{xterm}s.

Printing output to a pane does not immediately update the display;
instead, the pane's contents are updated, and the pane is displayed
with the @mnm{refresh} message.

The @code{ANSITerminalPane} class supports the display multiple panes.
Each pane is a child of the initial, or parent, pane.  Child panes
attached to the parent pane (with the @code{Pane} : @mnm{attach}
method) inherit the input and output streams of the parent pane.

The @mnm{map} configures a child pane for display on top of its parent
pane, and the child pane is displayed on top of the parent pane at the
next @mnm{refresh} message.

Coordinates and dimensions are numbered from 1,1, which is the upper
left-hand corner of a terminal or a content region.

@code{ANSITerminalPanes} support bold, blinking, reverse, and
underline text attributes for its contents.  Some attributes, like
blinking and underlined text, or foreground and background colors, are
not universally supported.

The program listing shows how to display parent and child
@code{ANSITerminalPane} objects.
@example
int main () @{
  ANSITerminalPane new parentPane;
  ANSITerminalPane new childPane;

  /* 
   *  Use openOn with the terminal device 
   *  to open a remote serial terminal.
   */
/*   parentPane paneStream openOn "/dev/ttya"; */
  parentPane initialize 1, 1, 79, 24;
  parentPane withShadow;
  parentPane withBorder;
  parentPane refresh;

  parentPane gotoXY 29, 10;
  parentPane printOn "Parent Pane";
  parentPane gotoXY 25, 11;
  parentPane printOn "Please press [Enter].";
  parentPane refresh;

  getchar ();  /* Actual apps should use getCh, etc. */

  childPane initialize 10, 10, 40, 10;
  childPane withShadow;
  childPane withBorder;
  childPane boldOnOff;
  parentPane map childPane;
  parentPane attach childPane;
  
  childPane gotoXY 13, 2;
  childPane printOn "Child Pane";
  childPane gotoXY 10, 3;
  childPane printOn "Please press [Enter].";

  parentPane refresh;

  getchar ();

  parentPane unmap childPane;

  parentPane refresh;

  parentPane paneStream closeStream;
  
  childPane delete;
  parentPane delete;
@}
@end example

@subheading Instance Variables
@table @code
@cindex @code{paneStream} instance variable @idxclscite{ANSITerminalPane}
@item paneStream
An @code{ANSITerminalStream} object containing the input and output 
channels and parameters for the pane and its child panes.  When 
created with @mnm{new}, initializes input and output to the terminal's
standard input and standard output file handles.  Communication
settings, including TTY settings, can be set with methods from the
@code{ANSITerminalStream} class. @xref{ANSITerminalStream}.

@cindex @code{shadow} instance variable @idxclscite{ANSITerminalPane}
@item shadow
If @code{TRUE,} draw a shadow beneath the pane.  The shadow is drawn
over the background window and is not part of the pane's content
region. 

@cindex @code{border} instance variable @idxclscite{ANSITerminalPane}
@item border
If @code{TRUE,} draw a border around the edges of the pane.  The
border is within the pane's content region, and it can objscure text 
beneath it.

@cindex @code{parentOrigin} instance variable @idxclscite{ANSITerminalPane}
@item parentOrigin
A @code{Point} object containing the X and Y coordinates of the parent
pane's origin.

@cindex @code{parentClip} instance variable @idxclscite{ANSITerminalPane}
@item parentClip
A @code{Point} object containing the X and Y dimensions of the parent
pane's content area.  

@end table

@subsubheading Instance Methods
@table @code

@cindex @mnm{blinkOnOff} instance method @idxclscite{ANSITerminalPane}
@item blinkOnOff (@code{void})
Toggle the pane's blinking graphics attribute; if enabled, display
blinking text; if disabled, display normal text.  Blinking text is not
supported on all terminals.

@cindex @mnm{boldOnOff} instance method @idxclscite{ANSITerminalPane}
@item boldOnOff (@code{void})
Toggle the pane's bold graphics attribute; if enabled, display bold
text; if disabled, display normal text.

@cindex @mnm{childRefresh} instance method @idxclscite{ANSITerminalPane}
@item childRefresh (@code{void})
Refresh the receiver, a child pane.  This method is called by 
@mnm{refresh} for each of a parent pane's children.

@cindex @mnm{cursorPos} instance method @idxclscite{ANSITerminalPane}
@item cursorPos (@code{int} @var{x}, @code{int}@var{y})
Position the software cursor at coordinates @var{x}, @var{y} within
the pane's content area.  This method is a synonym for @mnm{gotoXY,}
below. 

@cindex @mnm{delete} instance method @idxclscite{ANSITerminalPane}
@item delete
The class destructor.  This method performs the extra 
cleanup that the @code{ANSITerminalPane} class requires.

@cindex @mnm{gotoXY} instance method @idxclscite{ANSITerminalPane}
@item gotoXY (@code{int} @var{x}, @code{int}@var{y})
Position the software cursor at coordinates @var{x}, @var{y} within
the pane's content area.

@cindex @mnm{initialize} instance method @idxclscite{ANSITerminaPane}
@item initialize (@code{int} @var{x_org}, @code{int} @var{y_org}, @code{int} @var{x_size}, @code{int} @var{y_size})
Initialize the receiver pane's coordinate instance variables, and
screen buffers.

@cindex @mnm{map} instance method @idxclscite{ANSITerminalPane}
@item map (@code{ANSITerminalPane} @var{__child})
Enable the display of a child pane, and buffer any screen contents.
The receiver should be a pane that completely encloses the child
pane's content region and shadow if any.  The pane is displayed when
the parent pane receives a @mnm{refresh} message.

@cindex @mnm{new} instance method @idxclscite{ANSITerminalPane}
@item new (@code{char *}@var{__paneName})
Create a new @code{ANSITerminalPane} object.  If more than one label
is given in the argument list, create new @code{ANSITerminalPane}
objects with those names.  This method also creates and initializes
the @code{paneStream} (class @code{ANSITerminalStream}) instance
variable.  @xref{ANSITerminalStream}.

@cindex @mnm{printOn} instance method @idxclscite{ANSITerminalPane}
@item printOn (@code{char *}@var{__fmt}, @code{...})
Print the arguments to the pane's content area at the software cursor
position.  The output is displayed after the receiver pane receives a
@mnm{refresh} message.

@cindex @mnm{putCharXY} instance method @idxclscite{ANSITerminalPane}
@item putCharXY (@code{int}@var{x}, @code{int}@var{y}, @code{char}@var{c})
Put character @var{c} at coordinates @var{x},@var{y} of the pane's
content area.  The character is displayed immediately using the pane's
current graphics mode.

@cindex @mnm{refresh} instance method @idxclscite{ANSITerminalPane}
@item refresh (@code{void})
Display the receiver pane content and decorations like borders and
shadows on the screen. This method also calls @mnm{childRefresh} for
each child pane that is attached (with @mnm{attach}, class
@code{Pane}) to the receiver pane.  @xref{Pane}.

@cindex @mnm{resetGraphics} instance method @idxclscite{ANSITerminalPane}
@item resetGraphics (@code{void})
Reset the pane's graphics attributes to normal text; i.e., bold,
underline, reverse, and blink attributes are turned off.

@cindex @mnm{reverseOnOff} instance method @idxclscite{ANSITerminalPane}
@item reverseOnOff (@code{void})
Toggle the pane's reverse graphics attribute; if enabled, display
text in inverse video; if disabled, display normal text.

@cindex @mnm{terminalHeight} instance method @idxclscite{ANSITerminalPane}
@item @mnm{terminalHeight}
Returns an @code{Integer} with the terminal's height in character rows.

@emph{Note:} If an operating system has a terminal interface that
Ctalk doesn't know about, then the method returns 0.

@cindex @mnm{terminalWidth} instance method @idxclscite{ANSITerminalPane}
@item @mnm{terminalWidth}
Returns an @code{Integer} with the terminal's width in character columns.

See the note about terminal compatibility in the @mnm{terminalHeight} entry,
above.

@cindex @mnm{underlineOnOff} instance method @idxclscite{ANSITerminalPane}
@item underlineOnOff (@code{void})
Toggle the pane's underline graphics attribute; if enabled, display
text underlined; if disabled, display normal text.  Underlined text is
not supported on all terminals.

@cindex @mnm{unmap} instance method @idxclscite{ANSITerminalPane}
@item unmap (@code{ANSITerminalPane} @var{__child})
Hide a child pane, and restore any screen contents that were obscured
when the child pane was displayed.  The child pane is withdrawn when
the parent pane receives the next @mnm{refresh} message.

@cindex @mnm{withBorder} instance method @idxclscite{ANSITerminalPane}
@item withBorder (@code{void})
Enable the display of a border around the edges of the pane's content
area, using ANSI line drawing characters.  The border is within the
pane's content area and can obscure text at the edges of the pane.

@cindex @mnm{withShadow} instance method @idxclscite{ANSITerminalPane}
@item withShadow (@code{void})
Enable the display of a shadow underneath the pane.  The shadow is
outside of the pane's content area, and should be within the clipping
area of the parent pane.
@end table

@node ANSIWidgetPane, ANSIButtonPane, ANSITerminalPane, Classes
@iftex
@section @code{ANSIWidgetPane} Class
@end iftex
@ifnottex
@subheading @code{ANSIWidgetPane} Class
@end ifnottex
@cindex @code{ANSIWidgetPane} class

@code{ANSIWidgetPane} contains methods and instance variables that are
useful when creating widgets, which are made up of one or more pane
objects for display on ANSI terminals.

Widgets should be designed so they can be displayed either
independently or above a main pane object.  That means a widget class
needs to provide its own methods for rendering the widget, handling
input, returning the input to the application program, and cleaning up
if necessary.

@cindex @mnm{handleInput} method @idxclscite{ANSIWidgetPane}
@cindex @mnm{handleInput} method @idxclscite{ANSITextEntryPane}
The @code{ANSIWidgetPane} class provides basic methods for these
tasks, but subclasses probably will need to implement their own
versions of these methods.  For example, the @code{ANSITextEntryPane}
class contains its own @mnm{handleInput} method.  

@cindex @mnm{withdraw} method @idxclscite{ANSITextEntryPane}
Or, for example, a subclass can provide a @mnm{withdraw} method, as in
this method from @code{ANSITextEntryPane}, which unmaps the widget
pane if it was popped up over another pane. @xref{ANSITextEntryPane}.
@example
ANSIWidgetPane instanceMethod withdraw (void) @{
  if (self parentPane) @{
    self unmap;
  @} else @{
    self paneStream clear;
  @}
  return NULL;
@}
@end example

@subsubheading A Note About Using Widgets with Serial Terminals.

The @code{ANSIWidgetPane} classes do not, at this time, provide any
methods for setting terminal parameters for a widget and all subpanes.
That means applications must see the terminal parameters of each
subwidget, and there does not yet exist a general mechanism for
handling the input and output of entire sets of widgets.  However,
classes can always implement convenience methods if necessary.  For an
example, see the @code{ANSIMessageBoxPane} section. 
@xref{ANSIMessageBoxPane}.

@subheading Instance Variables
@table @code
@cindex @code{hasFocus} instance variable @idxclscite{ANSIWidgetPane}
@item hasFocus
An @code{Integer} that is either @code{TRUE} or @code{FALSE} depending
on whether the subwidget has the input focus.  Methods should set and
check the @code{isInputPane} instance variable, below, to make sure
that a subwidget's class accepts user input.

@cindex @code{isInputPane} instance variable @idxclscite{ANSIWidgetPane}
@item isInputPane
An @code{Integer} that is either @code{TRUE} or @code{FALSE} depending
on whether the pane can take the input focus.

@cindex @code{paneID} instance variable @idxclscite{ANSIWidgetPane}
@item paneID
An @code{Integer} that contains an identifier of a widget pane or
subpane.

@cindex @code{parentPane} instance variable @idxclscite{ANSIWidgetPane}
@item parentPane
A @code{Key} object that contains the address of a parent pane, if 
the widget is displayed over a normal pane.  If this variable is set, 
then the widget needs to map and unmap itself from the parent pane 
as with a normal child pane.

@cindex @code{titleString} instance variable @idxclscite{ANSIWidgetPane}
@item titleString
An optional @code{String} object that can be displayed as the 
widget's title.

@cindex @code{withdraw} instance variable @idxclscite{ANSIWidgetPane}
@item withdraw
Delete the receiver from the display, by clearing the display if 
the widget is displayed independently, or by unmapping it from a 
parent widget.

@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{addBuffer} instance method @idxclscite{ANSIWidgetPane}
@item addBuffer (@code{Integer} @var{width}, @code{Integer} @var{height}, 
@code{Integer} @var{cellSize})
A convenience method that creates the receiver pane's buffers
with the width, height and character cell size given as the
arguments.  The @var{cellSize} argument should almost always be
@samp{1}.  If the pane has buffers created previously by another
method, @mnm{addBuffer} deletes the old buffers first.

@cindex @mnm{handleInput} method @idxclscite{ANSIWidgetPane}
@item handleInput
Process @code{InputEvent} objects from the receiver's
@code{paneStream} input handle.  This @mnm{handleInput} definition 
provides only basic functionality.  Subclasses should re-implement
this method with the additional functions that the widget needs.

@cindex @mnm{map} method @idxclscite{ANSIWidgetPane}
@item map (@code{void})
Maps the receiver widget pane over another pane that was
defined by a previous @mnm{parent} message (below).

@cindex @mnm{mapSubWidget} instance method @idxclscite{ANSIWidgetPane}
@item mapSubWidget (@code{ANSIWidgetPane} @var{subPane})
Maps the receiver widget pane over another pane that was defined by a
previous @mnm{parent} message (below), and sets the @var{subPane}'s
@code{mapped} instance variable to @code{TRUE}, and adds
@var{subWidgetPane}, to the parent pane's @code{children} list.
@var{subPane} may be any subclass of @code{ANSIWidgetPane}.

@cindex @mnm{new} method @idxclscite{ANSIWidgetPane}
@cindex @mnm{withShadow} method @idxclscite{ANSITerminalPane}
@cindex @mnm{withBorder} method @idxclscite{ANSITerminalPane}
@cindex @mnm{openInputQueue} method @idxclscite{ANSITerminalStream}
@item new (@var{paneName1}, @var{paneName2}, ... @var{paneNameN};)
Create one or more new @code{ANSIWidgetPane} objects.  The object
is similar to an @code{ANSITerminalPane} object, but it 
contains the additional instance variables listed in the previous 
section.  This method also relies on the @code{ANSITerminalPane}
methods @mnm{withShadow} and @mnm{withBorder}, and the
@code{ANSITerminalStream} method @mnm{openInputQueue}.

@cindex @mnm{parent} method @idxclscite{ANSIWidgetPane}
@item parent (@code{ANSITerminalPane} @var{parentPaneObject})
Sets the receiver's @code{parentPane} instance variable to the main
@code{ANSITerminalPane} (or subclass) object that the receiver is to
be mapped over.  This method also provides the subWidget with copies
of the parent's input and output stream handles.

@cindex @mnm{title} method @idxclscite{ANSIWidgetPane}
@item title (@code{String} @var{titleString})
Set the receiver's title string to the argument.

@cindex @mnm{unmap} method @idxclscite{ANSIWidgetPane}
@item unmap (@code{void})
Unmaps the receiver from its parent pane.  Used after previous
@mnm{parent} and @mnm{map} messages (above).

@end table

@node ANSIButtonPane, ANSILabelPane, ANSIWidgetPane, Classes
@iftex
@section @code{ANSIButtonPane} Class
@end iftex
@ifnottex
@subheading @code{ANSIButtonPane} Class
@end ifnottex
@cindex @code{ANSIButtonPane} class

@code{ANSIButtonPane} objects represent pushbutton widgets.
Generally, they are sub-panes of other widget classes.  For program
examples, see @xref{ANSIMessageBoxPane}, and the methods in the 
@code{ANSIButtonPane} and @code{ANSIMessageBoxPane} class libraries.

@subheading Instance Variables
@table @code
@cindex @code{buttonText} instance variable @idxclscite{ANSIButtonPane}
@item buttonText
The text that will appear within the button.

@cindex @code{outputBuffer} instance variable @idxclscite{ANSIButtonPane}
@item outputBuffer
The buffer that contains the ANSIButtonPane's return text.  Normally,
the ANSIButtonPane object is drawn by a parent widget, which uses
its @mnm{handleInput} and @mnm{show} methods to retrieve the button's
result.  

In cases where the ANSIButtonPane object is displayed on its own and
uses the ANSIButtonPane @mnm{handleInput} and @mnm{show} methods
listed in the next section, this variable contains an empty string
if the user presses @kbd{Escape}, or the button text if the user
presses @kbd{Return}, which is returned by the @mnm{show} method,
below.
@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{focusHighlightOnOff} instance method (@code{void})
@item focusHighlightOnOff
Toggle the button's highlight.  

@cindex @mnm{handleInput} instance method @idxclscite{ANSIButtonPane}
@item handleInput (@code{void})
Wait for input from the receiver's @code{paneStream} object.
Withdraws the receiver if the the user types an escape (@code{0x1b})
or carraige return (@code{0x0d}) character, or the @mnm{paneStream}
object receives these characters from another input source.

The @mnm{paneStream} instance variable (which is declared in
@code{ANSITerminalPane} class), contains a reference to an
@code{ANSITerminalStream} object. @xref{ANSITerminalStream}.

This method sets the value of the @code{outputBuffer} instance
variable, as described above.

@cindex @mnm{new} instance method @idxclscite{ANSIButtonPane}
@item new (@var{button1_name}, @var{button2_name}, ...;)
Create one or more new @code{ANSIButtonPane} object, with border and
shadow decorations, for each name given in the argument list.  The
buttons' exact sizes are determined by the @mnm{withText} method,
below.

@cindex @mnm{show} instance method @idxclscite{ANSIButtonPane}
@item show (@code{Integer} @var{x_origin}, @code{Integer} @var{y_origin})
Display the button or map it to a parent widget.  The @var{x_origin}
and @var{y_origin} are relative to the upper left of the display if
the button is displayed independently, or relative to the upper
left-hand corner of a parent pane.

This method returns the @code{outputBuffer} instance
variable, which contains the result of input from the user
or another source, as described above.

@cindex @mnm{withText} instance method @idxclscite{ANSIButtonPane}
@item withText (@code{String} @var{button_text})
Set the text that will appear inside the button.  The method adjusts
the button dimensions to fit the text.

@end table

@node ANSILabelPane, ANSIListBoxPane, ANSIButtonPane, Classes
@iftex
@section @code{ANSILabelPane} Class
@end iftex
@ifnottex
@subheading @code{ANSILabelPane} Class
@end ifnottex
@cindex @code{ANSILabelPane} class

The @code{ANSILabelPane} class draws text labels on a terminal, with
or without border and shadow decorations, and with the graphics
attributes provided by @code{ANSITerminalPane}
class. @xref{ANSITerminalPane}.

The default is to draw a single-line or multi-line label in a pane
with a border and drop shadow.  When drawing multi-line labels, it
is necessary to give the pane's dimensions to the @mnm{appendLine} method,
below.

To draw a single-line label in reverse video, without any decorations
and large enough to contain only the text, use a routine like the 
following.

@example

  ANSILabelPane new labelBox;

  labelBox borderLess = TRUE;   /* The decorations are specified with */
  labelBox border = FALSE;      /* instance variables.                */
  labelBox shadow = FALSE;
  labelBox reverseOnOff;        /* Defined in ANSITerminalPane class. */

  labelBox appendLine "LabelBox Text", 20, 0;

@end example

Note that when creating pane buffers, Ctalk numbers the lines from zero,
so it is safe to specify a pane's height as @samp{0}.

When drawing a label alone, pressing Escape or Enter withdraws the label
from the display.  

@subheading Instance Variables
@table @code
@cindex @code{borderLess} instance variable @idxclscite{ANSILabelPane}
@item borderLess
Specify that the label not contain extra space around the edges 
for a border.

@cindex @code{text} instance variable @idxclscite{ANSILabelPane}
@item text
nA @code{List} containing the label text, one item per line of text.

@cindex @code{viewHeight} instance variable @idxclscite{ANSILabelPane}
@item viewHeight
An @code{Integer} that contains the height of the label's viewable area
in character rows.

@cindex @code{viewWidth} instance variable @idxclscite{ANSILabelPane}
@item viewWidth
An @code{Integer} that contains the width of the label's viewable area
in character columns.

@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{appendLine} instance method @idxclscite{ANSILabelPane}
@item appendLine (@code{String} @var{text})
@item appendLine (@code{String} @var{text}, @code{Integer} @var{width}, @code{Integer} @var{height})
Add a line of text to the label's contents.  If given with a width and
height, specify the size of the label.  Otherwise, the label is drawn
large enough to display the contents.  

If the label contains multiple lines of text, then the dimensions given
(or calculated) for the last line determine the size of the label.

@cindex @mnm{cleanup} instance method @idxclscite{ANSILabelPane}
@item cleanup (@code{void})
Delete the buffers associated with the pane object.

@cindex @mnm{display} instance method @idxclscite{ANSILabelPane}
@item display (@code{Integer} @var{x}, @code{Integer} @var{y})
Display the pane at @var{x},@var{y} on the display or parent
pane.  Unlike @mnm{show}, below, does not wait for user input.

@cindex @mnm{handleInput} instance method @idxclscite{ANSILabelPane}
@item handleInput (@code{void})
Process input for the pane.  This method is normally called by the
@mnm{Show} method, below.  When the pane is displayed by itself, pressing
Escape or Enter returns from the method, and the @mnm{Show} method
withdraws the pane from the display.

@cindex @mnm{new} instance method @idxclscite{ANSILabelPane}
@item new (@var{label1}, @var{label2}, @var{label3},...;)
Create new @code{ANSILabelPane} objects for each member of the
argument list.  The arguments specify the names of the new object.

@cindex @mnm{refresh} instance method @idxclscite{ANSILabelPane}
@item refresh (@code{void})
Draw the pane's contents on the terminal.

@cindex @mnm{show} instance method @idxclscite{ANSILabelPane}
@item show (@code{Integer} @var{x}, @code{Integer} @var{y})
Display the pane at the position @var{x}, @var{y} on the terminal.
This method also calls the @mnm{handleInput} method, above, and
waits for the user's input before returning.

@cindex @mnm{sizePane} instance method @idxclscite{ANSILabelPane}
@item sizePane (@code{Integer} @var{width}, @code{Integer} @var{height})
Set the size of the pane object and its buffers.  This method is
normally called by the @mnm{appendLine} method, above.

@end table

@node ANSIListBoxPane, ANSIMessageBoxPane, ANSILabelPane, Classes
@iftex
@section @code{ANSIListBoxPane} Class
@end iftex
@ifnottex
@subheading @code{ANSIListBoxPane} Class
@end ifnottex
@cindex @code{ANSIListBoxPane} class

An @code{ANSIListBoxPane} object displays a list of items, and allows
the user to select one of the items in the list by using the cursor
motion keys. 

Each item in the list is an @code{ANSILabelPane}.  To modify the
appearance of the items, refer to the @code{ANSILabelPane} class.
@xref{ANSILabelPane}.

After exiting by pressing Escape or Enter, a program can retrieve the
text of the selected item.

Here is a simple program that displays a list of items, then prints 
the selected item's text before exiting.

@example

int main () @{
  ANSIListBoxPane new listBox;

  listBox appendLine "Item 1";
  listBox appendLine "Item 2";
  listBox appendLine "Item 3";
  listBox appendLine "Item 4";
  listBox appendLine "Item 5";

  listBox show 2, 2;   // Waits for the user to press Escape or Enter
                       // before returning.

  printf ("\nYou selected %s.\n", listBox selectedText);
  
  listBox cleanup;
@}

@end example

@subheading Instance Variables
@table @code
@cindex @code{items} instance variable @idxclscite{ANSIListBoxPane}
@item items
A @code{List} of @code{ANSILabelPane} items that contain the text
of the list selections.

@cindex @code{oldSelectedContent} instance variable @idxclscite{ANSIListBoxPane}
@item oldSelectedContent
An @code{ANSILabelPane} object that contains the content of the previous
selection.  Used for erasing the previous selection before drawing the
new selection.

@cindex @code{prevSelectedLine} instance variable @idxclscite{ANSIListBoxPane}
@item prevSelectedLine
An @code{Integer} that contains the index of the previously selected item.
The @code{ANSIListBoxPane} indexes items starting with 1 for the first item.

@cindex @code{selectedContent} instance variable @idxclscite{ANSIListBoxPane}
@item selectedContent
An @code{ANSILabelPane} object that contains  the contents of the currently
selected item.

@cindex @code{selectedLine} instance variable @idxclscite{ANSIListBoxPane}
@item selectedLine
An @code{Integer} that contains the index, counting from 1, of the currently
selected item.

@cindex @code{totalLines} instance variable @idxclscite{ANSIListBoxPane}
@item totalLines
An @code{Integer} that contains the number of items to be displayed.

@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{appendLine} instance method @idxclscite{ANSIListBoxPane}
@item appendLine (@code{String} @var{text})
Creates a new @code{ANSILabelBox} object with the contents @var{text},
then adds the @code{ANSILabelBox} to the @code{items} list.

@cindex @mnm{cleanup} instance method @idxclscite{ANSIListBoxPane}
@item cleanup (@code{void})
Deletes the buffers associated with the @code{ANSIListBoxPane} object
and its items.

@cindex @mnm{handleInput} instance method @idxclscite{ANSIListBoxPane}
@item handleInput (@code{void})
Waits for input from the user and processes it.  Pressing a cursor
key or an Emacs or vi next/previous line key shifts the selection.
Pressing Escape or Enter causes the method to return.

@cindex @mnm{new} instance method @idxclscite{ANSIListBoxPane}
@item new (@var{listPane1}, @var{listPane2}, ...;)
The @code{ANSIListBoxPane} constructor.  The argument contains the
names of one or more new @code{ANSIListBoxPane} objects.

@cindex @mnm{refresh} instance method @idxclscite{ANSIListBoxPane}
@item refresh (@code{void})
Draw the list pane and items on the terminal.

@cindex @mnm{refreshSelectionFirst} instance method @idxclscite{ANSIListBoxPane}
@item refreshSelectionFirst (@code{void})
Highlight the initially selected item.  Should only be called after
a call to @mnm{refresh}.

@cindex @mnm{refreshSelection} instance method @idxclscite{ANSIListBoxPane}
@item refreshSelection (@code{void})
Redraw the highlightd selected item, and un-highlight the previously
selected item.  Should only be called after a call to @mnm{selectNext}
or @mnm{selectPrev}

@cindex @mnm{selectedText} instance method @idxclscite{ANSIListBoxPane}
@item selectedText (@code{void})
Returns the text of the selected item as a @code{String} object.

@cindex @mnm{selectNext} instance method @idxclscite{ANSIListBoxPane}
@cindex @mnm{selectPrev} instance method @idxclscite{ANSIListBoxPane}
@item selectNext (@code{void})
@item selectPrev (@code{void})
Select the next or previous item of the list box's contents.  Also
saves the index and contents of the previously selected item.

@end table



@node ANSIMessageBoxPane, ANSIProgressBarPane, ANSIListBoxPane, Classes
@iftex
@section @code{ANSIMessageBoxPane} Class
@end iftex
@ifnottex
@subheading @code{ANSIMessageBoxPane} Class
@end ifnottex
@cindex @code{ANSIButtonPane} class

@code{ANSIMessageBox} objects present users with a pop-up dialog that
contains a messages, and an @code{ANSIButtonPane} @samp{Ok} button to
close the widget. 

Here is a simple example.
@example
int main () @{
  ANSIMessageBoxPane new messageBox;
  messageBox withText "Hello, world!";
  messageBox show 10, 10;
  messageBox cleanup;
@}
@end example

Subclasses can always implement convenience methods to set input and
output stream parameters if necessary. 

You should also take care of the differences between xterms, consoles,
and serial terminals.  In particular, even though the @mnm{parent}
method (class @code{ANSIWidgetPane}) @xref{ANSITerminalStream}.

@subheading Instance Variables
@table @code
@cindex @code{okButton} instance variable @idxclscite{ANSIMessageBoxPane}
@item okButton
An @code{ANSIButtonPane} object that contains the pane's @samp{Ok}
button.
@cindex @code{messageText}
@item messageText
A @code{String} object that contains the text that appears in 
the message box.
@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{cleanup} instance method @idxclscite{ANSIMessageBoxPane}
@item cleanup (@code{void})
Delete the receiver's extra data before deletion.  The receiver
objects themselves are deleted normally.

@cindex @mnm{new} instance method @idxclscite{ANSIMessageBoxPane}
@item new (@code{String} @var{message_box_name})
Create one or more new @code{ANSIMessageBox} objects.

@cindex @mnm{withText} instance method @idxclscite{ANSIMessageBoxPane}
@item withText (@code{String} @var{text})
The argument is the text that will appear in the message box.  The
method adjusts the pane's dimensions to fit the text.

@cindex @mnm{show} instance method @idxclscite{ANSIMessageBoxPane}
@item show (@code{int} @var{x_origin}, @code{int} @var{y_origin})
Display the receiver at @var{x_origin}, @var{y_origin}.  If the
receiver is displayed independently, the origin is relative to the
upper left-hand corner of the display, or if the receiver is to
be displayed over a parent pane, it is mapped to the parent pane 
with the origin relative the the parent pane's upper left-hand
corner. 

@end table

@node ANSIProgressBarPane, ANSIScrollingListBoxPane, ANSIMessageBoxPane, Classes
@iftex
@section @code{ANSIProgressBarPane} Class
@end iftex
@ifnottex
@subheading @code{ANSIProgressBarPane} Class
@end ifnottex
@cindex @code{ANSIProgressBarPane} class

An @code{ANSIProgressBarPane} object displays a horizontal progress
bar on a serial terminal or xterm.  If you display a progress bar pane
independently (using the @mnm{show} method), you can close the pane by
pressing @kbd{Enter} or @kbd{Esc}.

The @samp{progress} instance variable specifies how much of the
progress bar is highlighted.  It's better to use the @mnm{percent}
method, though, which calculates the progress bar's hightlighted area
and sets the percent legend.

As with all other ANSI pane widgets, you either display or omit the
border and shadow decorations.  Progress bars can also display a 
title string, which you can set using the @mnm{title} method, implemented
in @code{ANSIWidgetPane} class. @xref{ANSIWidgetPane}.

Here is an example program that displays an @code{ANSIProgressBarPane}
object.

@c test/expect/examples/progressbar.c
@example

int main () @{
  ANSIProgressBarPane new progressBar;


  progressBar shadow = 1;
  progressBar border = 1;

  progressBar title "Progress";

  progressBar percent 65.0;

  progressBar show 2, 2;

  progressBar cleanup;
@}

@end example


You can set the size of a progres bar using the @mnm{dimension} method.
In that case, setting the progress bar using the @mnm{percent} method
adjusts for the pane's width.  The widget's display area is always drawn
as one character row tall, however.

If you display the progress bar as a widget in an application, then
you can update the progress bar on the screen using the @mnm{display}
method instead of @mnm{show}, because @mnm{display} does not wait for
user input before returning.


@subheading Instance Variables

@table @code

@cindex @code{pctLabelMargin} instance variable @idxclscite{ANSIProgressBarPane}
@item pctLabelMargin
An @code{Integer} that specifies where to draw the percent legend 
in the progress bar's content area.

@cindex @code{percentInt} instance variable @idxclscite{ANSIProgressBarPane}
@item percentInt
An @code{Integer} that specifies percent of the progress bar's
internal area that is highlighted.  Setting this using the
@mnm{percent} method, below, also adjusts the hightlight's dimensions
for the progress bar's width.  This variable is also used to display
the text of the percent logo in the widget's content area.

@cindex @code{progress} instance variable @idxclscite{ANSIProgressBarPane}
@item progress
An @code{Integer} that specifies the number of character columns to
highlight in the progress bar's viewable area.

@cindex @code{viewHeight} instance variable @idxclscite{ANSIProgressBarPane}
@item viewHeight
An @code{Integer} that specifies the height in character rows of
the widget's viewable area.  The progress bar highlight is always
drawn as one character row in height.

@cindex @code{viewWidth} instance variable @idxclscite{ANSIProgressBarPane}
@item viewWidth
An @code{Integer} that specifies the width in character rows of the 
widget's viewable area.

@end table

@subsubheading Instance Methods

@table @code

@cindex @mnm{dimension} instance method @idxclscite{ANSIProgressBarPane}
@item @mnm{dimension} (@code{Integer} @var{width}, @code{Integer} @var{height})
Set the width and height of the pane in character columns.

@cindex @mnm{display} instance method @idxclscite{ANSIProgressBarPane}
@item @mnm{show} (@code{Integer} @var{x}, @code{Integer} @var{y})
Display the pane at row and column @var{x},@var{y}, and return
immediately.

@cindex @mnm{handleInput} instance method @idxclscite{ANSIProgressBarPane}
@item @mnm{handleInput} (@code{void})
Wait for the user's input.  Pressing @kbd{Esc} or @kbd{Enter} closes
the pane. and returns.

@cindex @mnm{new} instance method @idxclscite{ANSIProgressBarPane}
@item @mnm{new} (@code{String} @var{paneName})
Create new @code{ANSIProgressBarPane} objects, one for each label
given in the method's argument list.

@cindex @mnm{percent} instance method @idxclscite{ANSIProgressBarPane}
@item @mnm{percent} (@code{Float} @var{percent})
Set the percent of the progress bar's highlighted area.  This method
adjusts for the width of the progress bar and sets the text for the
percent logo.

@cindex @mnm{refresh} instance method @idxclscite{ANSIProgressBarPane}
@item @mnm{refresh} (@code{void})
Redraw the progress bar on the terminal.

@cindex @mnm{show} instance method @idxclscite{ANSIProgressBarPane}
@item @mnm{show} (@code{Integer} @var{x}, @code{Integer} @var{y})
Display the pane at row and column @var{x},@var{y}, and wait for
the user's input.

@end table

@node ANSIScrollingListBoxPane, ANSIScrollPane, ANSIProgressBarPane, Classes
@iftex
@section @code{ANSIScrollingListBoxPane} Class
@end iftex
@ifnottex
@subheading @code{ANSIScrollingListBoxPane} Class
@end ifnottex
@cindex @code{ANSIScrollingListBoxPane} class

@cindex @code{ANSIListBoxPane} class
An @code{ANSIScrollingListBoxPane} object is similar to an
@code{ANSIListBoxPane}; it displays a list of items in a text mode
terminal or @code{xterm} and allows the user to use the terminal's
@kbd{Cursor-Up}/@kbd{Cursor-Down} keys, Emacs compatible
@kbd{C-n}/@kbd{C-p} keys, or vi compatible @kbd{j}/@kbd{k} keys to
select an item in the list.

Pressing @kbd{Enter} or @kbd{Escape} closes the widget.  An application
can retrieve the selected item's text with the @mnm{selectedText}
method, which is described below.

In addition, an @code{ANSIScrollingListBoxPane} object can scroll the
list if the number of items is greater than the height of the widget's
viewable area, in order to keep the selected item visible.  The widget
also displays a read-only scroll bar that indicates which portion of
the list is visible.

@c test/expect/examples/ansilistbox.c
@example

int main () @{
  ANSIScrollingListBoxPane new sListBox;

  sListBox enableExceptionTrace;

  sListBox withShadow;
  sListBox noBorder;    /* Not all terminals support line 
                           drawing characters.            */

  sListBox appendLine "Item 1";
  sListBox appendLine "Item 2";
  sListBox appendLine "Item 3";
  sListBox appendLine "Item 4";
  sListBox appendLine "Item 5";
  sListBox appendLine "Item 6";
  sListBox appendLine "Item 7";
  sListBox appendLine "Item 8";
  sListBox appendLine "Item 9";
  sListBox appendLine "Item 10";
  sListBox appendLine "Item 11";
  sListBox appendLine "Item 12";
  sListBox appendLine "Item 13";
  sListBox appendLine "Item 14";
  sListBox appendLine "Item 15";
  sListBox appendLine "Item 16";
  sListBox appendLine "Item 17";
  sListBox appendLine "Item 18";
  sListBox appendLine "Item 19";
  sListBox appendLine "Item 20";
  sListBox appendLine "Item 21";
  sListBox appendLine "Item 22";
  sListBox appendLine "Item 23";
  sListBox appendLine "Item 24";
  sListBox appendLine "Item 25";
  sListBox appendLine "Item 26";
  sListBox appendLine "Item 27";
  sListBox appendLine "Item 28";
  sListBox appendLine "Item 29";
  sListBox appendLine "Item 30";
  sListBox appendLine "Item 31";
  sListBox appendLine "Item 32";

  sListBox show 5, 6;

  printf ("%s\n", sListBox selectedText);

  sListBox cleanup;
@}

@end example

@subheading Instance Variables
@table @code
@cindex @code{items} instance variable @idxclscite{ANSIScrollingListBoxPane}
@item items
A @code{List} of the items that the receiver displays. @xref{List}.

@cindex @code{oldSelectedContent} instance variable @idxclscite{ANSIScrollingListBoxPane}
@item oldSelectedContent
An @code{ANSILabelPane} object that contains previously selected item. @xref{ANSILabelPane}.

@cindex @code{prevSelectedLine} instance variable @idxclscite{ANSIScrollingListBoxPane}
@item prevSelectedLine
An @code{Integer} that contains the index of the previously selected item. 
@xref{Integer}.

@cindex @code{scrollBar} instance variable @idxclscite{ANSIScrollingListBoxPane}
@item selectedContent
An @code{ANSIScrollPane} object that draws the widget's scroll bar. 
@xref{ANSIScrollPane}.

@cindex @code{selectedContent} instance variable @idxclscite{ANSIScrollingListBoxPane}
@item selectedContent
An @code{ANSILabelPane} object that contains selected item. @xref{ANSILabelPane}.

@cindex @code{selectedLine} instance variable @idxclscite{ANSIScrollingListBoxPane}
@item selectedLine
An @code{Integer} that contains the index of the selected item. @xref{Integer}.

@cindex @code{totalLines} instance variable @idxclscite{ANSIScrollingListBoxPane}
@item totalLines
An @code{Integer} that contains total number of list items. @xref{Integer}.

@cindex @code{viewStartLine} instance variable @idxclscite{ANSIScrollingListBoxPane}
@item viewStartLine
An @code{Integer} that specifies which item begins the list's viewable 
portion. @xref{Integer}.

@cindex @code{viewHeight} instance variable @idxclscite{ANSIScrollingListBoxPane}
@item viewHeight
An @code{Integer} that contains the height in text lines of the
widget's visible area. @xref{Integer}.

@cindex @code{viewWidth} instance variable @idxclscite{ANSIScrollingListBoxPane}
@item viewWidth
An @code{Integer} that contains the height in character columns of the
widget's visible area. @xref{Integer}.

@end table

@subsubheading Instance Methods

@table @code

@cindex @mnm{appendLine} instance method @idxclscite{ANSIScrollingListBoxPane}
@item appendLine (@code{String} @var{item_text})
Adds @var{item_text} to the list's contents.

@cindex @mnm{cleanup} instance method @idxclscite{ANSIScrollingListBoxPane}
@item cleanup (@code{void})
Deletes the display buffers associated with the list box and scroll bar.

@cindex @mnm{handleInput} instance method @idxclscite{ANSIScrollingListBoxPane}
@item handleInput (@code{void})
Waits for the user's input.  Changes the selected item when the user
cursors through the list using the terminal's cursor keys, Emacs compatible
@kbd{C-n}/@kbd{C-p}, or vi compatible @kbd{j}/@kbd{k}.  Restores the
terminal and returns when the user presses @kbd{Enter} or @kbd{Escape}.

@cindex @mnm{noBorder} instance method @idxclscite{ANSIScrollingListBoxPane}
@cindex @mnm{withBorder} instance method @idxclscite{ANSIScrollingListBoxPane}
@item noBorder (@code{void})
@item withBorder (@code{void})
Set or unset the border for the main scroll pane and the scroll bar.  These
methods are equivalent to the following expressions.

@example

  /* To display borders. */
  listPane border = 1;
  listPane scrollBar border = 1;

  /* To hide the borders. */
  listPane border = 0;
  listPane scrollBar border = 0;

@end example

Note that not all terninals support line drawing characters.

@cindex @mnm{noShadow} instance method @idxclscite{ANSIScrollingListBoxPane}
@cindex @mnm{withShadow} instance method @idxclscite{ANSIScrollingListBoxPane}
@item noBorder (@code{void})
@item withBorder (@code{void})
Set or unset the shadow for the main scroll pane and the scroll bar.  The
methods are a shortcut for these statements.

@example

  /* To display shadows. */
  listPane shadow = 1;
  listPane scrollBar shadow = 1;

  /* To hide the shadows. */
  listPane shadow = 0;
  listPane scrollBar shadow = 0;

@end example

@cindex @mnm{new} instance method @idxclscite{ANSIScrollingListBoxPane}
@item new (@code{String} @var{object_name})
Constructs a new @code{ANSIScrollingListBoxPane} for each label given
in the argument list.  Sets the dimensions for the viewable
areas, decorations, and creates the display buffers for the list box
and the scroll bar.

@cindex @mnm{refresh} instance method @idxclscite{ANSIScrollingListBoxPane}
@item refresh (@code{void})
Redraws the list box.

@cindex @mnm{refreshSelection} instance method @idxclscite{ANSIScrollingListBoxPane}
@item refreshSelection (@code{void})
Un-highlights the previously selected item and highlights the currently
selected item.

@cindex @mnm{refreshSelectionFirst} instance method @idxclscite{ANSIScrollingListBoxPane}
@item refreshSelectionFirst (@code{void})
Highlights the currently selected item, which is normally the first item in the
list when first drawing the widget--i.e., when there is no previously
selected item.

@cindex @mnm{scrollThumbSize} instance method @idxclscite{ANSIScrollingListBoxPane}
@item scrollThumbSize (@code{void})
Sets the @code{scrollBar} instance variable's @code{thumbHeight} instance
variable based on which portion of the list is visible. @xref{ANSIScrollPane}.

@cindex @mnm{scrollThumbStart} instance method @idxclscite{ANSIScrollingListBoxPane}
@item scrollThumbStart (@code{void})
Sets the @code{scrollBar} instance variable's @code{thumbStartLine} instance
variable based on which portion of the list is visible. @xref{ANSIScrollPane}.

@cindex @mnm{selectedText} instance method @idxclscite{ANSIScrollingListBoxPane}
@item selectedText (@code{void})
Returns a @code{String} containing the text of the selected item. @xref{String}.

@cindex @mnm{selectNext} instance method @idxclscite{ANSIScrollingListBoxPane}
@item selectNext (@code{void})
Sets the next @code{selectedLine} and @code{selectedContent} instance 
variables to the next item in the list.  If the selected item is already
the last item in the list, the method does nothing.

@cindex @mnm{selectPrev} instance method @idxclscite{ANSIScrollingListBoxPane}
@item selectPrev (@code{void})
Sets the next @code{selectedLine} and @code{selectedContent} instance 
variables to the previous item in the list.  If the selected item is
already the first item in the list, the method does nothing.

@cindex @mnm{show} instance method @idxclscite{ANSIScrollingListBoxPane}
@item show (@code{Integer} @var{x}, @code{Integer} @var{y})
Displays the widget an character row and column @var{x},@var{y} on
the terminal display, then calls the @mnm{handleInput} method to
process user input.

@end table

@node ANSIScrollPane, ANSITextBoxPane, ANSIScrollingListBoxPane, Classes
@iftex
@section @code{ANSIScrollPane} Class
@end iftex
@ifnottex
@subheading @code{ANSIScrollPane} Class
@end ifnottex
@cindex @code{ANSIScrollPane} class

An @code{ANSIScrollPane} object draws a vertical scroll box on a
text-mode terminal or X terminal.  Applications can use the pane's
instance variables to set the position and height of the scroll thumb,
and the border and shadow decorations.

The class provides a @mnm{handleInput} method that allows users to
move the scroll thumb independently if the pane is used by itself.

This app draws a scroll pane independently.

@c test/expect/examples/scrollbar.c
@example

int main () @{
  ANSIScrollPane new scrollBox;

  scrollBox shadow = 0;
  scrollBox border = 1;

  scrollBox thumbHeight = 3;    // Sets the position and height
  scrollBox thumbStartLine = 1; // of the scroll thumb.

  scrollBox show 2, 2;          // The Up and Down arrow keys 
                                // move the scroll thumb while
                                // the pane is displayed.

  scrollBox cleanup;
@}


@end example


When used to indicate the position of other panes, applications should
set and read the scroll thumb's using the @code{thumbHeight} and
@code{thumbStartLine} instance variables.  If the application wants to
use the @code{ANSIScrollPane} object to set another pane's position,
it needs to handle the Up and Down cursor motion keys in the app's
@mnm{handleInput} method,

In that case, the app should use the classes' @mnm{display} method
instead of @mnm{show} to display the @code{ANSIScrollPane} object, because
@mnm{display} doesn't wait for user input on its own.

There's no terminal independent way, however, to indicate that the
@code{ANSIScrollPane} object has the input focus.  An app might
do this by either setting or omitting the pane's shadow, but
that can occupy an extra line of terminal space.

The class is simplified by keeping the width of the scroll thumb at 
one column.  Apps can draw a wider scroll pane, but that does not
affect the scroll thumb's width.

@subsubheading Instance Variables

@table @code

@cindex @code{viewHeight} instance variable @idxclscite{ANSIScrollPane}
@item viewHeight
An @code{Integer} that specifies the height of the scroll channel
in character rows.

@cindex @code{viewWidth} instance variable @idxclscite{ANSIScrollPane}
@item viewWidth
An @code{Integer} that specifies the width of the scroll channel
in character columns.

@cindex @code{thumbHeight} instance variable @idxclscite{ANSIScrollPane}
@item thumbHeight
An @code{Integer} that specifies the height of the scroll thumb in
character rows.

@cindex @code{thumbStartLine} instance variable @idxclscite{ANSIScrollPane}
@item thumbStartLine
An @code{Integer} that specifies the row of the top of the scroll thumb.
This should be less than the @code{viewHeight} instance variable for the
thumb to be visible.

@end table

@subsubheading Instance Methods

@table @code

@cindex @mnm{cleanup} instance method @idxclscite{ANSIScrollPane}
@item @mnm{cleanup} (@code{void})
Delete the buffers associated with the pane object.

@cindex @mnm{dimension} instance method @idxclscite{ANSIScrollPane}
@item @mnm{dimension} (@code{Integer} @var{width}, @code{Integer} @var{height})
Set the width and height of the receiver pane.  Also adjusts the width
of the @code{viewWidth} and @code{viewHeight} instance variables.

@cindex @code{display} instance method @idxclscite{ANSIScrollPane}
@item @mnm{display} (@code{Integer} @var{x}, @code{Integer} @var{y})
Draw the pane on the terminal at row and column @var{x},@var{y}, and
return immediately.

@cindex @mnm{handleInput} instance method @idxclscite{ANSIScrollPane}
@item @mnm{handleInput} (@code{void})
Waits for user input from the pane's @code{ANSITerminalStream} object.
Pressing Enter or Escape withdraws the pane from the display and returns.
Pressing the Up or Down arrow keys moves the scroll thumb.

@cindex @code{new} instance method @idxclscite{ANSIScrollPane}
@item @mnm{new} (@code{String} @var{paneName})
Create a new @code{ANSIScrollPane} object, with the name @var{paneName}.
If more than one name is given in the argument list, create new
@code{ANSIScrollPane} objects with the arguments' names.

@cindex @code{refresh} instance method @idxclscite{ANSIScrollPane}
@item @mnm{refresh} (@code{void})
Draw the pane on the terminal.

@cindex @code{show} instance method @idxclscite{ANSIScrollPane}
@item @mnm{show} (@code{Integer} @var{x}, @code{Integer} @var{y})
Draw the pane on the terminal at row and column @var{x},@var{y}, and
wait for the user's input.

@end table


@node ANSITextBoxPane, ANSITextEntryPane, ANSIScrollPane, Classes
@iftex
@section @code{ANSITextBoxPane} Class
@end iftex
@ifnottex
@subheading @code{ANSITextBoxPane} Class
@end ifnottex
@cindex @code{ANSITextBoxPane} class

An @code{ANSITextBoxPane} object displays a text-mode dialog box with
an application's text in the window, and a ``Dismiss'' button at the
bottom of the display area.  Like other widgets that are subclasses of
@code{ANSIWidgetPane,} you can close the window by pressing @kbd{Esc}
or @kbd{Enter}, and you can scroll through the text with the
terminal's up and down arrow keys, the @code{vi} keys @kbd{j} and
@kbd{k}, and the @code{emacs} keys @kbd{C-n} and @kbd{C-p}.

Here is a brief example of how to open and display text in an
@code{ANSITextBoxPane} object.
@example
int main () @{
  ANSITextBoxPane new textBox;

  textBox resize 75, 30;

  textBox appendLine "Hello, world!";
  textBox appendLine "This is another line of text.";
  textBox appendLine "More text to follow.";

  textBox show 1, 1;

  textBox cleanup;
@}
@end example

@subheading Instance Variables
@table @code
@cindex @code{dismissButton} instance variable @idxclscite{ANSITextBoxPane}
@item dismissButton
An @code{ANSIButtonPane} object that displays a ``Dismiss'' button at
the bottom of the pane's display area.
@cindex @code{text} instance variable @idxclscite{ANSITextBoxPane}
@item @code{text}
A @code{List} object that contains the text to be displayed in the
pane, one line per list element.
@cindex @code{viewStartLine} instance variable @idxclscite{ANSITextBoxPane}
@item @code{viewStartLine}
An @code{Integer} object that indicates the topmost line of text to be
displayed in the pane.
@cindex @code{viewHeight} instance variable @idxclscite{ANSITextBoxPane}
@item viewHeight
An @code{Integer} that contains the height of the pane's text display
area. The text display area is the width and height of the pane, not
including a window border if any, and not including the bottom five
lines of the pane, which is used to display the @code{dismissButton}
widget. 
@cindex @code{viewWidth} instance variable @idxclscite{ANSITextBoxPane}
@item viewWidth
An @code{Integer} that contains the width of the viewable text area.  As
mentioned above, the @code{viewWidth} dimension is the width of the
pane minus the window borders, if any.
@cindex @code{viewXOffset} instance variable @idxclscite{ANSITextBoxPane}
@item viewXOffSet
An @code{Integer} that contains the starting column of each line
within the window.
@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{appendLine} instance method @idxclscite{ANSITextBoxPane}
@item @mnm{appendLine} (@code{String} @var{text})
Append a line to the widget's @code{text} (class @code{List}) instance
variable.  The text will be visible after the next @mnm{refresh} message.

@cindex @mnm{cleanup} instance method @idxclscite{ANSITextBoxPane}
@item @mnm{cleanup} (@code{Integer} @var{lineNumber})
Delete the extra buffers that the receiver uses for screen data.  
The normal object cleanup routines delete the receiver pane itself.

@cindex @mnm{clearLine} instance method @idxclscite{ANSITextBoxPane}
@item @mnm{clearLine} (@code{Integer} @var{lineNumber})
Erase the line @var{lineNumber} in the pane's view area.

@cindex @mnm{handleInput} instance method @idxclscite{ANSITextBoxPane}
@item @mnm{handleInput} (@code{void})
Wait for the user's input from the keyboard and redisplay or withdraw
the receiver widget depending on which key the user presses.

@cindex @mnm{new} instance method @idxclscite{ANSITextBoxPane}
@item @mnm{new} (@code{String} @var{paneName})
Constructs a new @code{ANSITextBoxPane} object.  The object's
dimensions are 40 columns wide by 20 rows high, with a ``Dismiss''
button at the bottom of the window, and with a border and shadow.

If more that one name is given in the argument list, construct
new @code{ANSITextBoxPane} objects with the labels' names.

@cindex @mnm{refresh} instance method @idxclscite{ANSITextBoxPane}
@item @mnm{refresh} (@code{void})
Redraws the receiver object and any text to be displayed in the pane's
visible area.

@cindex @mnm{resize} instance method @idxclscite{ANSITextBoxPane}
@item @mnm{resize} (@code{Integer} @var{xSize}, @code{Integer} @var{ySize})
Resize the pane to the dimensions @var{xSize}, @var{ySize}.

@cindex @mnm{show} instance method @idxclscite{ANSITextBoxPane}
@item @mnm{show} (@code{Integer} @var{xOrigin}, @code{Integer} @var{yOrigin})
Pop up the pane's window at the terminal coordinates @var{xOrigin},
@var{yOrigin}, and wait for the user's input.

@end table

@node ANSITextEntryPane, ANSIYesNoBoxPane, ANSITextBoxPane, Classes
@iftex
@section @code{ANSITextEntryPane} Class
@end iftex
@ifnottex
@subheading @code{ANSITextEntryPane} Class
@end ifnottex
@cindex @code{ANSITextEntryPane} class

A @code{ANSITextEntryPane} object prompts the user for text input and returns
the input to the application program.  Like other subclasses of
@code{ANSIWidgetPane}, this class uses the methods of that class or
re-implements them as necessary. @xref{ANSIWidgetPane}.

The widget can be displayed independently; that is, it can be popped
up on its own, as in this example.
@example
int main () @{
  ANSITextEntryPane new textEntry;
  String new inputText;

  textEntry withPrompt "Please enter some text: ";
  inputText = textEntry show 10, 10;
  printf ("\nYou typed: %s\n", inputText);
  textEntry cleanup;
@}
@end example
To pop up an @code{ANSITextEntryPane} over another pane, the program
must also configure and define the widget's parent pane.  
@example
int main () @{
  ANSITerminalPane new mainPane;
  ANSITextEntryPane new textEntry;
  String new inputText;

  mainPane initialize 1, 1, 80, 24;
  mainPane refresh;

  mainPane gotoXY 29, 10;
  mainPane printOn "Parent Pane";
  mainPane gotoXY 25, 11;
  mainPane printOn "Please press [Enter].";
  mainPane refresh;

  getchar ();  /* Actual apps should use getCh, etc. */

  textEntry parent mainPane;
  textEntry withPrompt "Please enter some text: ";
  inputText = textEntry show 10, 10;
  mainPane refresh;
  
  printf ("\nYou typed: %s\n", inputText);

  getchar ();

  textEntry cleanup;
  mainPane cleanup;
@}
@end example

@subheading Instance Variables
@table @code
@cindex @code{promptText} instance variable @idxclscite{ANSITextEntryPane}
@item promptText
The text of the entry pane's prompt.  The default is an empty
@code{String} object.

@cindex @code{inputBuffer} instance variable @idxclscite{ANSITextEntryPane}
@item inputBuffer
A @code{String} object that contains the user's input.

@cindex @code{inputLength} instance variable @idxclscite{ANSITextEntryPane}
@item inputLength
The width in characters of the text entry.  The default is 20.
@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{handleInput} method @idxclscite{ANSITextEntryPane}
@item handleInput (@code{void})
Process @code{InputEvent} objects from the receiver's 
@code{paneStream} input handle.  

@cindex @mnm{inputWidth} method @idxclscite{ANSITextEntryPane}
@item inputWidth (@code{Integer} @var{width})
Set the width, in characters, of the input entry box.  The
default is 20.

@cindex @mnm{new} method @idxclscite{ANSITextEntryPane}
@item new (@code{String} @var{paneName})
Creates a new @code{ANSITextEntryPane} object.  Also uses the
@mnm{withShadow} and @mnm{withBorder} messages from
@code{ANSITerminalPane} class, and the @mnm{openInputQueue} message
from @code{ANSITerminalStream} class.

If more that one argument is given in the argument list, create
new @code{ANSITextEntryPane} objects with the arguments' names.

@cindex @mnm{show} method @idxclscite{ANSITextEntryPane}
@item show (@code{int} @var{x_origin}, @code{int} @var{y_origin})
Display the receiver pane and return input from the user.  

@cindex @mnm{withdraw} method @idxclscite{ANSITextEntryPane}
@item withdraw
Remove the receiver widget from the display.  If the widget is drawn
over another pane object, unmap the receiver from the parent pane.  If
the receiver is displayed independently, clear the display before
returning.

@cindex @mnm{withPrompt} method @idxclscite{ANSITextEntryPane}
@item withPrompt (@code{String} @var{promptText})
Set the receiver's prompt to @var{promptText}. 
@end table

@node ANSIYesNoBoxPane, X11Pane, ANSITextEntryPane, Classes
@iftex
@section @code{ANSIYesNoBoxPane} Class
@end iftex
@ifnottex
@subheading @code{ANSIYesNoBoxPane} Class
@end ifnottex
@cindex @code{ANSIYesNoBoxPane} class

An @code{ANSIYesNoBoxPane} object presents the user with a dialog that
contains a text message and waits for the user's @samp{Yes} or
@samp{No} response.

Here is an example of opening an @code{ANSIYesNoBoxPane} object using
standard input and output (e.g., when displaying the pane on a xterm).
@example
int main () @{
  ANSIYesNoBoxPane new messageBox;
  String new answer;

  messageBox withText "Do you want to quit?";
  answer = messageBox show 10, 10;
  messageBox cleanup;
  printf ("You answered, \"%s\"\n", answer);
@}
@end example

Here is an example of opening an @code{ANSIYesNoBoxPane} object in a
serial terminal (for a Linux serial device).  For other systems,
change the @samp{/dev/ttyS1} argument to the device node that connects
to the serial terminal.  It's necessary to adjust the arguments to
@mnm{setTty} to match the terminal's settings.

@c ctalk/test/expect/examples/ansiyesnobox.c
@example
int main () @{
  ANSIYesNoBoxPane new messageBox;
  String new answer;

  messageBox paneStream openOn "/dev/ttyS1";  /* Linux serial device. */
  messageBox paneStream setTty 9600, 1, 'n', 8;
 
  messageBox noBorder;  /* Not all terminals support line drawing characters. */

  messageBox withText "Are you sure you want to quit?";
  answer = messageBox show 10, 10;
  messageBox cleanup;
  printf ("You answered, \"%s\"\n", answer);
@}
@end example

As with any dialog widget, pressing @kbd{Esc} or @kbd{Return}
closes the @code{ANSIYesNoBoxPane} object.  The @kbd{Tab} key selects
between the ``Yes'' and ``No'' buttons, as do the @kbd{Y} and
@kbd{N} keys,

@subheading Instance Variables
@table @code
@cindex @code{button1} instance variable @idxclscite{ANSIYesNoBoxPane}
@item button1
The @code{ANSIButtonPane} widget that controls the @samp{Yes}
response.
@cindex @code{button2} instance variable @idxclscite{ANSIYesNoBoxPane}
@item button2
The @code{ANSIButtonPane} widget that controls the @samp{No}
response.
@cindex @code{messageText} instance variable
@idxclscite{ANSIYesNoBoxPane}
@item messageText
A @code{String} object that contains the text displayed in the 
pane.
@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{cleanup} instance method @idxclscite{ANSIYesNoBoxPane}
@item cleanup (@code{void})
Delete the widget's data before exiting.

@cindex @mnm{getFocusWidgetText} instance method @idxclscite{ANSIYesNoBoxPane}
@item getFocusWidgetText (@code{void})
Return the text associated with the button that has the input focus.

@cindex @mnm{handleInput} instance method @idxclscite{ANSIYesNoBoxPane}
@item handleInput (@code{void})
Wait for the user's input and return the response from the widget.

@cindex @mnm{new} instance method @idxclscite{ANSIYesNoBoxPane}
@item new (@var{newPaneName}
Create a new @code{ANSIYesNoBox} object with the name given as
an argument.  If the argument list contains more than one name,
create @code{ANSIYesNoBoxPane} objects for each argument.

@example

ANSIYesNoBoxPane new yesnobox1, yesnobox2;

@end example

@cindex @mnm{nextFocus} instance method @idxclscite{ANSIYesNoBoxPane}
@item nextFocus (@code{void})
Set the input focus to the next button widget.

@cindex @mnm{noBorder} instance method @idxclscite{ANSIYesNoBoxPane}
@cindex @mnm{withBorder} instance method @idxclscite{ANSIYesNoBoxPane}
@item noBorder (@code{void})
@item withBorder (@code{void})
Set or unset the border for the main pane and the button labels.  These
methods are equivalent to the following expressions.

@example

  /* To display borders. */
  yesnoBox border = 1;
  yesnoBox button1 border = 1;
  yesnoBox button2 border = 1;

  /* To hide the borders. */
  yesnoBox border = 0;
  yesnoBox button1 border = 0;
  yesnoBox button2 border = 0;

@end example

Note that not all terninals support line drawing characters.

@cindex @mnm{noShadow} instance method @idxclscite{ANSIYesNoBoxPane}
@cindex @mnm{withShadow} instance method @idxclscite{ANSIYesNoBoxPane}
@item noBorder (@code{void})
@item withBorder (@code{void})
Set or unset the shadow for the main pane and the buttons.  The
methods are a shortcut for these statements.

@example

  /* To display shadows. */
  yesnoBox shadow = 1;
  yesnoBox button1 shadow = 1;
  yesnoBox button2 shadow = 1;

  /* To hide the shadows. */
  yesnoBox shadow = 0;
  yesnoBox button1 shadow = 0;
  yesnoBox button2 shadow = 0;

@end example

@cindex @mnm{show} instance method @idxclscite{ANSIYesNoBoxPane}
@item show (@code{int} @var{x_origin}, @code{int} @var{y_origin}) 
Display the @code{ANSIYesNoBoxPane} object at @var{x_origin},
@var{y_origin}.  If displayed over another pane, the origin is
relative to the parent pane's origin.  If displayed independently, the
origin is relative the the upper left-hand corner of the terminal.

@cindex @mnm{withText} instance method @idxclscite{ANSIYesNoBoxPane}
@item withText (@code{char *}@var{text})
Defines the text that is to appear within the pane.  This method
adjust's the pane's size to fit the text.

@end table

@node X11Pane, GLXCanvasPane, ANSIYesNoBoxPane, Classes
@iftex
@section @code{X11Pane} Class
@end iftex
@ifnottex
@subheading @code{X11Pane} Class
@end ifnottex
@cindex @code{X11Pane} class

The @code{X11Pane} class provides the basic methods and instance
variables for creating and displaying a window on a X display. 

The @code{X11Pane} class does not, itself, provide methods
for moving, resizing, or handling input or changing focus.

The @code{X11TerminalStream} class handles X input events.
The @code{X11Pane} constructor @mnm{new} also creates a
@code{X11TerminalStream} object in the @code{X11Pane's}
@code{inputStream} instance variable.  There is a short example
program in the @code{X11TerminalStream} section.
@xref{X11TerminalStream}.

This class uses the default visual or a X window without
buffering, so applications need to be careful to handle
InputEvents correctly, or graphics drawing may result in
flicker, depending how the window manager handles X Window
System events.  See the @cite{Ctalk Tutorial} for
information about how to use @code{InputEvent} objects in
applications.  

However, @code{X11Pane} class provides the address of the
window's graphics context in the @code{xGC} instance
variable, so applications that use this class for graphical
displays can create and use their own visuals if necessary.

@subheading Instance Variables

@table @code
@cindex @code{backgroundColor} instance variable @idxclscite{X11Pane}
@item backgroundColor
A @code{String} object that contains the name of the window's
background color.  The value is the background color
of the window, independent of the background color of any
buffers used by subpanes.  Normally this value is set by the
@mnm{background} method, described below.

If unset, the default background color is black.

@cindex @code{borderWidth} instance variable @idxclscite{X11Pane}
@item borderWidth
An @code{Integer} object that contains the window's border width
in pixels.  The default is 1 pixel.

@cindex @code{container} instance variable @idxclscite{X11Pane}
@item container
A @code{Symbol} that refers to a pane's container (i.e., parent)
Pane object. For top-level @code{X11Pane} objects this value should
be @code{NULL}.

@cindex @code{depth} instance variable @idxclscite{X11Pane}
@item depth
An @code{Integer} that contains the default depth of the display
screen.  Ctalk sets this value when creating the window of a
@code{X11Pane} object or an instance of one of @code{X11Pane's}
subclasses.  Normally applications should not need to change this
value.

@cindex @code{displayPtr} instance variable @idxclscite{X11Pane}
@item displayPtr
A @code{Symbol} that holds the pointer to the display connection;
i.e., the @code{Display *} returned by @cite{XOpenDisplay(3)}.
Most windows use the display connection opened when the main
window is created. Dialogs, which create their own main windows,
open their own connection to the display.  Generally, programs
should not need to change this.

When using subpanes, it's convenient to set the subpane's
@code{displayPtr} variable to the value of the main window pane's
value.  This is generally done in the @mnm{attachTo} methods, with
a line that looks something like this.

@cindex @code{modal} instance variable @idxclscite{X11Pane}
@item modal
A @code{Boolean} that determines how Ctalk draws in the window.
True for popup windows, false otherwise.

@example

self displayPtr = self mainWindow displayPtr;

@end example

@cindex @code{fontVar} instance variable @idxclscite{X11Pane}
@item fontVar
A @code{X11Font} object that contains information about the
Window or Pane's current font.

@cindex @code{fontDescStr} instance variable @idxclscite{X11Pane}
@item fontDesc
A @code{String} that contains a X Logical Font Descriptor
for the font to be used by the window.  If the value is
@samp{(null)}, the window uses the system's fixed font.

@cindex @code{foregroundColor} instance variable @idxclscite{X11Pane}
@item foregroundColor
A @code{String} object that contains the name of the window's
foreground color.  If unset, the default foreground color is black.

@cindex @code{ftFontVar} instancevariable @idxclscite{X11TextEditorPane}
@item ftFontVar
An @code{X11FreeTypeFont} object that contains the pane's current
font, if the @code{X11TextEditorPane} object uses outline fonts.

@cindex @mnm{font} instance method @idxclscite{X11Pane}
If, on the other hand, the pane uses X11 bitmap fonts, the
Pane uses the @code{fontVar} instance variable.  Which
requires no additional initialization.

To determine whether a machine has outline fonts available, a program
could use a set of statements like this in its initialization.

@example

Boolean new useXFonts;
X11Pane new myPane;

...

if (myPane ftFontVar version >= 10) @{
  myPane ftFontVar initFontLib;
  useXFonts = false;
@} else @{
  useXFonts = true;
@}

@end example

@cindex @code{inputStream} instance variable @idxclscite{X11Pane}
@item inputStream
A @code{X11TerminalStream} object that provides @code{InputEvent}
objects to the application. @xref{X11TerminalStream}.

@cindex @code{resources} instance variable @idxclscite{X11Pane}
@item resources
This is an @code{AssociativeArray} that an object can use
to store any data that determine its run-time appearance, like
colors, dimensions, or options.  Generally a @code{Pane} class
sets default resources in its @code{new} method, which application
programs can then update with its own resources after the @code{Pane}
object has been constructed.

As a brief example, here's a sample initialization from the
@code{X11MessageBoxPane} : @code{new} method.

@example

paneName resources atPut "backgroundColor", "gray";
paneName resources atPut "pad", 10;
paneName resources atPut "messageText", "Your\nMessage\nHere";
paneName resources atPut "buttonText", "Ok";

@end example

Then, when an application program constructs the widgets when
it is run, it can use a line like this.

@example

l_label background self resources at "backgroundColor";
l_label multiLine self resources at "messageText";

@end example

Remember that the @code{Collection : atPut} method does not check for
an existing key, so be sure to remove the old value first.  This is
done with the @code{Collection : removeAt} method, or simply with
the @code{Collection : replaceAt} method.

@example

if (l_label resources keyExists "backgroundColor")
  l_label resources removeAt "backgroundColor";
l_label resources atPut "backgroundColor", "blue";

@end example

or,

@example

if (!l_label resources replaceAt "backgroundColor", "blue")
  l_label resources atPut "backgroundColor", "blue";

@end example

Refer to the @code{Collection} class section for more information
about the methods it defines.  @xref{Collection}.

@cindex @code{xGC} instance variable @idxclscite{X11Pane}
@item xGC
A @code{Symbol} that contains the address of the window's graphics
context.  The @code{X11Pane} class does not, at this time, provide
methods or instance data for drawables, so the application needs to
implement its own drawable for each window.

@cindex @code{xWindowID} instance variable @idxclscite{X11Pane}
@item xWindowID 
An @code{Integer} that contains the window's id that a program can use
with X library functions.

@end table

@subheading Class Variables
@table @code
@cindex @code{xColormap} class variable @idxclscite{X11Pane}
@item xColormap
An @code{Integer} that contains the resource ID of the 
default color map.
@end table

@subsubheading Instance Methods

@table @code

@cindex @mnm{attachTo} instance method @idxclscite{X11Pane}
@item @mnm{attachTo} (@code{Object} @var{parentPane})
Attach the receiver to @var{parentPane}.  The value of
@var{parentPane}'s @var{subWidget} instance variable is the receiver.

@cindex @mnm{background} instance method @idxclscite{X11Pane}
@item @mnm{background} (@code{String} @var{color_name})
Sets the background color of the pane object's window.  For buffered
Panes, programs need to set the background color of that Pane
independently.  This method also has the effect of clearing the
window.

If a program doesn't set a background color for the window, the
default background color is white.

@cindex @mnm{clearRectangle} instance method @idxclscite{X11Pane}
@item @mnm{clearRectangle} (@code{int} @var{x}, @code{int} @var{y}, @code{int} @var{width}, @code{int} @var{height})
Clear the area of the receiver's window with the dimensions 
given as the arguments.

@cindex @mnm{clearWindow} instance method @idxclscite{X11Pane}
@item @mnm{clearWindow} (@code{void})
Clear the receiver's window.  This method clears only the main window
and does not affect any image buffers associated with the pane object.
To also clear the pane object's image buffers, use
@mnm{clearRectangle}, above.

@cindex @mnm{defaultCursor} instance method @idxclscite{X11Pane}
@item defaultCursor (@code{void})
Restore the window's default cursor, which is normally the
cursor of the parent window.

@cindex @mnm{deleteAndClose} instance method @idxclscite{X11Pane}
@item deleteAndClose (@code{void})
Delete the receiver window and close the display.

@cindex @code{displayHeight} instance variable @idxclscite{X11Pane}
@item displayHeight (@code{void})
Returns an @code{Integer} with  the display's height in pixels.

@cindex @code{displayWidth} instance variable @idxclscite{X11Pane}
@item displayWidth (@code{void})
Returns an @code{Integer} with the display's width in pixels.

@cindex @mnm{faceRegular} instance method @idxclscite{X11Pane}
@cindex @mnm{faceBold} instance method @idxclscite{X11Pane}
@cindex @mnm{faceItalic} instance method @idxclscite{X11Pane}
@cindex @mnm{faceBoldItalic} instance method @idxclscite{X11Pane}
@cindex @mnm{initFontLib} instance method @idxclscite{X11FreeTypeFont}
@item @mnm{faceRegular} (@code{void})
@item @mnm{faceBold} (@code{void})
@item @mnm{faceItalic} (@code{void})
@item @mnm{faceBoldItalic} (@code{void})
These methods select which @code{X11FreeTypeFont} typeface a pane
should use.  These methods need the program to initialize the Xft
libraries (with the @mnm{initFontLib} method in @code{X11FreeTypeFont}
class), and the pane has established a connection to the X server
(with the @mnm{openEventStream} method).

@cindex @mnm{font} instance method @idxclscite{X11Pane}
@item @mnm{font} (@code{String} @var{font_desc})
Set the X font used for drawing on the window.  This font can
be set independently of the fonts used by subpanes.
@xref{X11TextPane}, and @xref{X11Bitmap}.

Because the Ctalk libraries use shared memory to manage font
information, it is generally necessary to call this method
after the @mnm{openEventStream} method, for the program to
calculate the character spacing of multiple typefaces correctly.

@cindex @mnm{foreground} instance method @idxclscite{X11Pane}
@item @mnm{foreground} (@code{String} @var{colorName})
Sets the window's foreground color (the default color for drawing
on the window) to @var{colorName}.  If a program doesn't set
the window's foreground color, the default color is black.

@cindex @mnm{ftFont} instance method @idxclscite{X11Pane}
@item @mnm{ftFont} (@code{String} @var{family}, @code{Integer} @var{slant},
@code{Integer} @var{weight} @code{Integer} @var{dpi}, @code{Float} @var{pointSize})
Selects an outline font for use by the @code{X11Pane} object.  The method
selects the font, and fills in the @code{ftFontVar} instance variable
with the font's information.  Programs should first determine if FreeType
fonts are available on the system, by using the @code{X11FreeTypeFont} method
@code{version} first, as in this example.

@example

Boolean new useXFonts;
X11Pane new myPane;

...

if (myPane ftFontVar version >= 10) @{
  myPane ftFontVar initFontLib;
  useXFonts = false;
@} else @{
  useXFonts = true;
@}

...

/* Selects the font DejaVu Sans Mono, regular slant, normal weight,
   72 dpi, 12 points. */
myPane ftFont "DejaVu Sans Mono", 0, 80, 72, 12.0;

@end example

The @code{X11FreeTypeFont} class also provides methods that use Xft
and X11 font descriptors to select fonts.  @xref{X11FreeTypeFont}.

@cindex @mnm{initialize} instance method @idxclscite{X11Pane}
@item @mnm{initialize} (@code{int} @var{width}, @code{int} @var{height})
@item @mnm{initialize} (@code{int} @var{x}, @code{int} @var{y}, @code{int} @var{width}, @code{int} @var{height})
Create the window and its graphics context with the width and height
given as the arguments.  This method also opens a connection to the X 
server if necessary.  This method uses the window system to set
the window's initial position.

@cindex @mnm{initialize} instance method @idxclscite{X11Pane}
Create the window and its graphics context with the dimensions given
as the arguments.  This method also opens the connection to the X
server if necessary.

This method is here for older programs, or programs that set the
window position directly.  Otherwise, use the form of
@mnm{initialize}, below, that takes the window's geometry flags as an
argument, and only set the window's position if the user provides one
on the command line and the program retrieves it with
@mnm{parseX11Geometry}.

Even more simply, a program can set @var{x_org} and @var{y_org} to
zero, and let the window system handle any positioning.  Or use
the form of @mnm{initialize} that uses only the @var{width} and 
@var{height} arguments.

@cindex @mnm{initialize} instance method @idxclscite{X11Pane}
@item @mnm{initialize} (@code{int} @var{x}, @code{int} @var{y}, @code{int} @var{width}, @code{int} @var{height}, @code{int} @var{geom_flags})
Create the window and its graphics context with the dimensions given
as the arguments.  Like the other forms of @mnm{initialize}, this
method also opens the connection to the X server if necessary.

The @var{geom_flags} argument provides placement hints for the
window's initial position.  It has the format provided by the
@mnm{parseX11Geometry} method in @code{Application} class.
@xref{parseX11Geometry}.  

The @var{x} and @var{y} parameters can also be given directly if the
program sets the window position itself.  If these arguments are zero,
then the window manager or the user supplied window geometry determine
the window placement.

@cindex @mnm{initialize} instance method @idxclscite{X11Pane}
@item @mnm{initialize} (@code{int} @var{x}, @code{int} @var{y}, @code{int} @var{width}, @code{int} @var{height}, @code{int} @var{geom_flags}, @code{char *}@var{win_title})
This method is similar to the five-argument form of @mnm{initialize},
and additionally sets the window's title using the contents of the
string @var{win_title}.

@cindex @mnm{isTopLevel} instance method @idxclscite{X11Pane}
@item isTopLevel (@code{void})
Return @code{TRUE} if the receiver's container pane is @code{NULL}.

@cindex @mnm{mainWindow} instance method @idxclscite{X11Pane}
@item mainWindow (@code{void})
Returns the @code{X11Pane} object that manages a program's
main window.  The method retrieves the main window object
by following the references of each subpane's @code{container}
instance variable.  If the top-level pane object is not a
@code{X11Pane}, the method prints a warning.

@cindex @mnm{map} instance method @idxclscite{X11Pane}
@item map (@code{void})
Map the receiver window onto the X display.

@cindex @mnm{openEventStream} instance method @idxclscite{X11Pane}
@item openEventStream (@code{void})
Open the window's input stream, a @code{X11TerminalStream}
object.  The @code{X11TerminalStream} section of the manual
describes X input event handling.  @xref{X11TerminalStream}.

@cindex @mnm{putStrXY} instance method @idxclscite{X11Pane}
@item putStrXY (@code{Integer} @var{xOrg}, @code{Integer} @var{yOrg}, @code{String} @var{str})
Draw the string on the receiver's drawable surface at @var{xOrg}, @var{yOrg},
using the selected font.

@cindex @mnm{putTransformedStrXY} instance method @idxclscite{X11Pane}
@item putStrXY (@code{Integer} @var{xOrg}, @code{Integer} @var{yOrg}, @code{String} @var{str})
Draw the string on the receiver's drawable surface at @var{xOrg}, @var{yOrg}.
Currently this method is the same as @mnm{putStrXY,} above.


@cindex @mnm{raiseWindow} instance method @idxclscite{X11Pane}
@item raiseWindow (@code{void})
Display the receiver window above other windows on the X
display.  Note that the method's name was changed from
@code{raise} to avoid warnings when including the C
@cite{raise(3)} function.

@cindex @mnm{setResources} instance method @idxclscite{X11Pane}
@cindex X resources
@cindex Resources, X windows
@item setResources (@code{String} @var{resourceName}, @code{String} @var{resourceClass})
Set the resource name and class of the main window.  Normally the resource
name is the name of the application, which may vary from the window title.
The resource class should be used to identify the window for X resources.

A program can call this method either before or after connecting to
the server with the @mnm{openEventStream} method.  Generally, if the
resources affect the appearance of decorations provided by the system,
like the window frame or icon, the window needs to be remapped for the
changes to be visible, but this may vary with the application and the
type of window manager.

@cindex @mnm{setWMTitle} instance method @idxclscite{X11Pane}
@item setWMTitle (@code{char *}@var{title})
Set the window's title.  Because setting a X window's title requires
communication between the window and the display server, this method
requires that the window is first mapped and raised (with the
@mnm{map} and @mnm{raiseWindow} methods, above), and has a connection
to the display server (which is done with the @mnm{openEventStream}
method, also above).  

In other words, when setting a window's title for the first time, this
method works best when used just before processing any other events.

@cindex @mnm{subPaneNotify} instance method @idxclscite{X11Pane}
@item subPaneNotify (@code{InputEvent} @var{event})
Called by applications that need to invoke sub-pane handlers in
response to window events.  For examples of its usage, refer to
the section for @code{X11CanvasPane}, @xref{X11CanvasPane}, and
other @code{X11Pane} subclasses.

@cindex @mnm{useCursor} instance method @idxclscite{X11Pane}
@item useCursor (@code{Cursor} @var{cursor_object})
Display the X11 cursor defined by @var{cursor_object}, a
@code{X11Cursor} object, in the receiver's window.  To
create cursors, @xref{X11Cursor}.

@cindex @mnm{useXRender} instance method @idxclscite{X11Pane}
@cindex X Render Extension
@item @mnm{useXRender} (@code{Boolean} @var{b})
If @var{b} is true, draw graphics using the X Render extension
if it is available. If @var{b} is false, use Xlib for graphics
drawing.  The default is to draw using the X Render extension
if it is available.

@cindex @mnm{usingXRender} instance Method @idxclscite{X11Pane}
@item @mnm{usingXRender} (@code{void})
Returns a @code{Boolean} value of True if the program is
using the X Render extension for drawing, False otherwise.

@end table

@node GLXCanvasPane, X11PaneDispatcher, X11Pane, Classes
@iftex
@section @code{GLXCanvasPane} Class
@end iftex
@ifnottex
@subheading @code{GLXCanvasPane} Class
@end ifnottex
@cindex @code{GLXCanvasPane} class

The @code{GLXCanvasPane} class displays 3 dimensional graphics drawn
with OpenGL in a X window.  The class requires that the display server
supports GLX visuals, which is the case with most modern X server
installations.

The class includes instance variables that select GLX visual properties,
methods that create and display the window, and provides a simple API
for the window's application program.

There is an example program that displays a @code{GLXCanvasPane}
window at the end of this section. @xref{GLXExampleProgram}.

@subheading GLXCanvasPane Applications

The @code{GLXCanvasPane} class provides a simple application framework
that is compatible with OpenGL's single threading model.  The
framework consists of a number of callback methods and a @mnm{run}
method, that are configured when the program starts.

The methods that install callbacks are:

@example

onButtonPress
onIdle
onKeyPress
onExpose
onPointerMotion
onResize
onTimerTick
onAnimation

@end example

There is a complete description of each of these methods in the
section, @cite{Instance Methods.}

Typically, a program installs its callback methods and initializes the
OpenGL system, and then calls the method @mnm{run} to begin the
program's event loop.  The example program given at the end of this
section follows this process.  The program's initialization and
startup, which is contained in @cite{main ()}, is shown here.

@example

int main () @{
  GLXCanvasPane new pane;

  pane initialize (1, 150, 500, 500);
  pane title "GLXCanvasPane Demonstration";
  pane map;
  pane raiseWindow;

  pane onKeyPress "myKeyPressMethod";
  pane onExpose "myExposeMethod";
  pane onTimerTick "myTimerTickHandler";
  pane onResize "myResizeMethod";

  pane initGL;
  
  pane run;

@}

@end example

@subheading Selecting GLX Visuals

@cindex @cite{glXChooseVisual(3)}
The @code{GLXCanvasPane} class selects visuals based on the
values of many of the instance variables.  These instance
variables correspond with the attributes recognized by the
@cite{glXChooseVisual(3)} library call.

The instance variables' default settings select a double buffered,
TrueColor or DirectColor visual, with 24 color bits per pixel, and a
stencil buffer with 8 bit planes, which is supported by many common
GLX servers.  The equivalent C code for these attributes, formatted as
an argument for @cite{glXChooseVisual(3)}, would be:

@example

static GLint att[] = @{GLX_RGBA, GLX_DEPTH_SIZE, 24, GLX_STENCIL_SIZE, 8,
                      GLX_DOUBLEBUFFER, None@};

@end example

@cindex @cite{glxinfo(3)}
These attributes also correspond to the available attributes output by
a program like @cite{glxinfo(1)}.  Refer to the
@cite{glXChooseVisual(3)} and @cite{glxinfo(1)} manual pages for more
information

@subheading Drawing with X Fonts

The @code{GLXCanvasPane} class defines three methods, @mnm{useXFont},
@mnm{drawText}, @mnm{drawTextW}, and @mnm{freeXFont} that facilitate
drawing text with X fonts.

Typically, a program calls @mnm{useXFont} with the name of the X font
when it initializes OpenGL (that is, after first creating the window
and mapping the GLX context to the display), then using @mnm{drawText}
to draw the text in the program's drawing routine. Finally, the
program calls @mnm{freeXFont} to release the font data before exiting,
or when changing fonts if the program uses multiple fonts for drawing.

@example

myPane useXFont "fixed";    /* Call during OpenGL initialization. */
                            /* The argument, "fixed," is the name */
                            /* of the font to be used.            */

...

                            /* Called from within the program's   */
                            /* drawing routine.                   */
myPane drawText "Text to appear in the window";


...

myPane freeXFont;           /* Called during program cleanup or   */
                            /* before calling useXFont again to   */
                            /* draw text in a different font.     */

@end example

The Ctalk distribution contains an example program in the
@flnm{demos/glx} subdirectory, @flnm{xfont.ca} that demonstrates this
drawing method.

@subheading Drawing with FreeType Fonts

The methods to draw text using the freetype libraries are similar to
those that render X bitmap fonts.  The Freetype libaries support text
rendering using Freetype, Truetype, and Postscript Type1 fonts.

The main differences are that, because of the way the fonts are
rendered on the screen, their measurements are given in the
coordinates of the current viewing and transformation matrices.

In addition, when loading a font using @mnm{useFTFont}, the method
uses the path name of the font file, not an identifier.  This is the
only interface that the Freetype libraries use.  To use the system's
font caching, refer to @xref{X11FreeTypeFont}.

There is a demo program that renders Freetype fonts in the
@flnm{demos/glx} subdirectory of the Ctalk source package,
@flnm{ftfont.ca}.

@subheading Display Synchronization

On OpenGL releases that support synchronization, @code{GLXCanvasPane}
applications can synchronize buffer swapping with the video display's
refresh rate.  @code{GLXCanvasPane} class provides the methods
@mnm{syncSwap,refreshRate,} and @mnm{frameRate} which allow programs
to adjust buffer swapping to match the video refresh rate.  The
demonstration program, @flnm{demos/glx/glxchaser.ca} provides an
example of how to use these methods.

To find out which GLX extensions the display server supports, the
@mnm{extensions} method, below, returns the extensions as a
@code{String} object.

Currently, video syncronization support is limited to MESA releases
that provide the @code{GLX_MESA_swap_control} and
@code{GLX_OML_sync_control} extensions.

@subsubheading Instance Variables

@table @code

@cindex @code{animationHandler} instance variable @idxclscite{GLXCanvasPane}
@item animationHandler
Defines the callback method that is called 24 times a second to
perform animation.

@cindex @code{buttonPressHandler} instance variable @idxclscite{GLXCanvasPane}
@item buttonPressHandler
A @code{Method} object that defines the callback method that is executed
when a mouse button is pressed.

@cindex @code{buttonState} instance variable @idxclscite{GLXCanvasPane}
@item buttonState
An @code{Integer} that records whether a mouse button is currently
pressed.  The class defines macro constants to record the states,
and you can include these definitions in your programs to interpret
the value of @code{buttonState}.

@example

#define buttonStateButton1 (1 << 0)
#define buttonStateButton2 (1 << 1)
#define buttonStateButton3 (1 << 2)
#define buttonStateButton4 (1 << 3)
#define buttonStateButton5 (1 << 4)

@end example

So to check if the mouse button 1 is pressed, the program could
contain an expression like the following.

@example

if (myPane buttonState & buttonStateButton1) @{
   printf ("Button 1 pressed.\n");
@}

@end example


@cindex @code{colormap} instance variable @idxclscite{GLXCanvasPane}
@item colormap
An @code{Integer} that contains the X resource ID of the default
colormap of the current display and screen.

@cindex @code{displayPtr} instance variable @idxclscite{GLXCanvasPane}
@item displayPtr
A @code{Symbol} that contains the address of the X server's display
handle as provided to the application.  The @code{displayPtr} instance
variable is filled in by the @mnm{initialize} methods.

@cindex @code{exposeHandler} instance variable @idxclscite{GLXCanvasPane}
@item exposeHandler
Defines the method that is called each time the program's window
receives an Expose event from the display.  This handler is essential
to displaying the window in coordination with other display events.
If this variable is not initialized, then the @mnm{run} method calls
the @mnm{swapBuffers} method.

@cindex @code{glxContextPtr} instance variable @idxclscite{GLXCanvasPane}
@item glxContextPtr
A @code{Symbol} that contains the address of the @code{GLXContext} that
is current for the @code{GLXCanvasPane's} window.  This variable is
normally filled in by the @mnm{map} method.

@cindex @code{idleHandler} instance variable @idxclscite{GLXCanvasPane}
@item idleHandler
A @code{Method} that contains the callback that the program
executes when not processing events from the display.

@cindex @code{keyPressHandler} instance variable @idxclscite{GLXCanvasPane}
@item keyPressHandler
A @code{Method} that handles the KeyPress events that the display
sends to the program's window.  This variable should be set during
program initialization using the @mnm{onKeyPress} method before the
program starts the @mnm{run} method.

@cindex @code{pointerMotionHandler} instance variable @idxclscite{GLXCanvasPane}
@item pointerMotionHandler
A @code{Method} that is called whenever the window receives a
MotionNotify event.

@cindex @code{resizeHandler} instance variable @idxclscite{GLXCanvasPane}
@item resizeHandler
A @code{Method} that is called whenever the window receives a
ConfigureNotify event.  The variable should be set using the
@mnm{onResize} method before the program starts the @mnm{run}
method.

@cindex @code{shiftState} instance variable @idxclscite{GLXCanvasPane}
@item shiftState
An @code{Integer} that records whether the any of the Shift, Control,
or Alt keys is currently pressed.  The class defines macro constants
to record the states, and you should also include the definitions in
your program if it needs to monitor the state of the modifier keys.

@example

#define shiftStateShift (1 << 0)
#define shiftStateCtrl  (1 << 1)
#define shiftStateAlt   (1 << 2)

@end example

So, for example, to test whether a Control key is pressed, you can use
an expression like the following.

@example

if (myPane shiftState & shiftStateCtrl) 
   printf ("Control key pressed.\n");

@end example

@cindex @code{timerMSec} instance variable @idxclscite{GLXCanvasPane}
@item timerMSec
An @code{Integer} that defines the time in milliseconds between
@mnm{onTimerTick} handler calls.  The default is 1 millisecond.

@cindex @code{timerTickHandler} instance variable @idxclscite{GLXCanvasPane}
@item timerTickHandler
A @code{Method} that defines the callback that is executed when the
classes' interval timer reaches 0.

@cindex @code{visualAuxBuffers} instance variable @idxclscite{GLXCanvasPane}
@item visualAuxBuffers
An @code{Integer} that, in combination with @code{visualSetAuxBuffers},
defines the minimum number of auxiliary buffers that the selected visual
must have.

@cindex @code{visualBufferSize} instance variable @idxclscite{GLXCanvasPane}
@item visualBufferSize
An @code{Integer} that defines the desired color index buffer size.  The
instance variable @code{visualSetBufferSize} must also be set to true.

@cindex @code{visualDepthSize} instance variable @idxclscite{GLXCanvasPane}
@item visualDepthSize
An @code{Integer} that contains the size of the visual's depth buffer.
The @code{visualSetDepthSize} instance variable must also be true for
this value to take effect.

@cindex @code{visualDoubleBuffer} instance variable @idxclscite{GLXCanvasPane}
@item visualDoubleBuffer
A @code{Boolean} that selects a double-buffered GLX visual if true,
or a single-buffered visual if false.

@cindex @code{visualInfoPtr} instance variable @idxclscite{GLXCanvasPane}
@item visualInfoPtr
A @code{Symbol} that contains the address of a X visual selected when
the pane's window is created, which normally happens when a program
calls one of the @mnm{initialize} methods described below.

@cindex @code{visualRedSize} instance variable @idxclscite{GLXCanvasPane}
@cindex @code{visualGreenSize} instance variable @idxclscite{GLXCanvasPane}
@cindex @code{visualBlueSize} instance variable @idxclscite{GLXCanvasPane}
@cindex @code{visualAlphaSize} instance variable @idxclscite{GLXCanvasPane}
@cindex @cite{glXChooseVisual(3)}
@item visualRedSize
@item visualGreenSize
@item visualBlueSize
@item visualAlphaSize
@code{Integer} values that, if greater than zero, try to select thea
largest buffer for that color channel of at least the specified size.
If one of the values is zero, then @cite{glXChooseVisual(3)} tries to
select the smallest available buffer for that color channel.

@cindex @code{visualRedAccumSize} instance variable @idxclscite{GLXCanvasPane}
@cindex @code{visualGreenAccumSize} instance variable @idxclscite{GLXCanvasPane}
@cindex @code{visualBlueAccumSize} instance variable @idxclscite{GLXCanvasPane}
@cindex @code{visualAlphaAccumSize} instance variable @idxclscite{GLXCanvasPane}
@item visualRedAccumSize
@item visualGreenAccumSize
@item visualBlueAccumSize
@item visualAlphaAccumSize
@code{Integer} values that, if greater than zero, try to select thea
largest accumulator buffer for that color channel of at least the
specified size.  If one of the values is zero, then
@cite{glXChooseVisual(3)} tries to select a visual with no accumulator
buffer for that color channel.

@cindex @code{visualRGBA} instance variable @idxclscite{GLXCanvasPane}
@item visualRGBA
A @code{Boolean} that selects a TrueColor or DirectColor visual if
true, or a PseudoColor or StaticColor visual if false.  Also, the
@code{visualSetBufferSize} and @code{visualBufferSize} instance
variables are ignored when this variable is true.

@cindex @code{visualStencilPlanes} instance variable @idxclscite{GLXCanvasPane}
@item visualStencilPlanes
An @code{Integer} the selects the number of stencil bitplanes if
greater than zero.  If zero, then a visual with no stencil buffer
is selected if possible.

@cindex @code{visualStereo} instance variable @idxclscite{GLXCanvasPane}
@item visualStereo
A @code{Boolean} value that selects a stereo visual if true.

@cindex @code{xLineHeight} instance variable @idxclscite{GLXCanvasPane}
@item xLineHeight
An @code{Integer} that contains the line height in pixels of a font
that has been selected by the @mnm{useXFont} method.  This variable is
read only.

@cindex @code{xMaxCharWidth} instance variable @idxclscite{GLXCanvasPane}
@item xMaxCharWidth
An @code{Integer} that contains the maximum width in pixels of a
character for a X font that has been selected by @mnm{useXFont}.  This
value is read only.

@end table

@subsubheading Instance Methods

@table @code

@cindex @mnm{alpha} instance method  @idxclscite{GLXCanvasPane}
@item alpha (@code{Float} @var{alpha})
Sets the alpha channel (opacity) when rendering outline fonts.  Values
should be between 0.0 (transparent) and 1.0 (opaque).  The Ctalk
library's default value is 1.0.  Calling this method also sets
the value of the receiver pane's @code{ftFontVar fgAlpha} instance
variable.

@cindex @mnm{deleteAndClose} instance method @idxclscite{GLXCanvasPane}
@item deleteAndClose (@code{void})
Releases the receiver pane's GLX context and deletes the X11 window,
and shuts down the application's X11 input client.

@cindex @mnm{displayHeight} instance method @idxclscite{GLXCanvasPane}
@cindex @mnm{displayWidth} instance method @idxclscite{GLXCanvasPane}

@item @mnm{displayHeigth} (@code{void})
@item @mnm{displayWidth} (@code{void})
These methods return an @code{Integer} with the display height and
width in pixels, respectively.

@cindex @mnm{drawFmtText} instance method @idxclscite{GLXCanvasPane}
@item @mnm{drawFmtText} (@code{Float} @var{xOrg}, @code{Float} @var{yOrg}, @code{String} @var{fmt}, ...)
Draws the text given by @var{fmt} and its arguments at the matrix
position given by @var{xOrg},@var{yOrg}.


@cindex @mnm{drawFmtTextFT} instance method @idxclscite{GLXCanvasPane}
@item @mnm{drawFmtTextFT} (@code{Float} @var{xOrg}, @code{Float} @var{yOrg}, @code{String} @var{fmt}, ...)
Display the string given by @var{fmt} and its arguments at the matrix
coordinates @var{xOrg}, @var{yOrg} in the currently selected Freetype
font.  This call, like all calls that render text, should be preceded
by a call to @mnm{useFTFont}.

@cindex @mnm{drawFmtTextW} instance method @idxclscite{GLXCanvasPane}
@item @mnm{drawFmtTextW} (@code{Integer} @var{xOrg}, @code{Integer} @var{yOrg}, @code{String} @var{fmt}, ...)
Draws the formatted text of @var{fmt} and its arguments at the pixel
position given by @var{xOrg}, @var{yOrg}.  OpenGL uses the lower
left-hand corner of the window as the origin for pixel coordinates.

@cindex @mnm{drawText} instance method @idxclscite{GLXCanvasPane}
@item drawText (@code{Float} @var{xOrg}, @code{Float} @var{yOrg}, @code{String} @var{text})
@item drawText (@code{Float} @var{xOrg}, @code{Float} @var{yOrg}, @code{Float} @var{red}, @code{Float} @var{green}, @code{Float} @var{blue}, @code{String} @var{text})
Draws @var{text} at the matrix position given by @var{xOrg},@var{yOrg}.

The program must have registered a X font for drawing with a previous
call to the @mnm{useXFont} method.

If the @var{red}, @var{green}, and @var{blue} arguments are given, the
method draws the text in that color.  Otherwise, the method (via OpenGL)
draws the text using the last OpenGL color setting.

@cindex @mnm{drawTextFT} instance method @idxclscite{GLXCanvasPane}
@item @mnm{drawTextFT} (@code{Float} @var{xOrg}, @code{Float} @var{yOrg}, @code{String} @var{text})
@item @mnm{drawTextFT} (@code{Float} @var{xOrg}, @code{Float} @var{yOrg}, @code{Float} @var{red}, @code{Float} @var{green}, @code{Float} @var{blue}, @code{Float} @var{alpha}, @code{String} @var{text})
Draws the string given by @var{text} at the matrix coordinates
@var{xOrg}, @var{yOrg}.

The @var{red, green, blue,} and @var{alpha} arguments, if used, should
be between the values of 0.0 and 1.0, so they can be passed along to
the OpenGL API directly, and also to set the receiver's
@code{ftFontVar} instance variable (a @code{X11FreeTypeFont} values
for its instance variables: @code{fgRed, fgGreen, fgBlue,} and
@code{fgAlpha} @xref{X11FreeTypeFont}.

@cindex @mnm{drawTextW} instance method @idxclscite{GLXCanvasPane}
@item drawTextW (@code{Float} @var{xOrg}, @code{Float} @var{yOrg}, @code{String} @var{text})
@item drawTextW (@code{Float} @var{xOrg}, @code{Float} @var{yOrg}, @code{Float} @var{red}, @code{Float} @var{green}, @code{Float} @var{blue}, @code{String} @var{text})
Draws @var{text} using the window's @var{xOrg},@var{yOrg} pixel as the
origin.

If the @var{red}, @var{green}, and @var{blue} arguments are given, the
method draws the text in that color.  Otherwise, the method (via OpenGL)
draws the text using the last OpenGL color setting.

This method allows text to be positioned relative to the window's
pixels, which avoids the need for programs to translate a matrix
position into a pixel position manually.  This allows a program to
position text more easily when it is necessary to measure spaces using
the dimensions of the text and font that are being displayed.

The coordinates' origin (0,0) is at the lower left-hand corner of
the window, and the pixel coordinates increase as the position moves
toward the top and right of the window.

The GL function @cite{glWindowPos2i}, which this method uses internally,
is an extension in many GL implementations.  Ctalk checks for the function
when building the Ctalk libraries.  If @cite{glWindowPos2i} is not
present in the machine's GL libraries, then programs that try to
use these methods display an error message on the terminal and exit.

@cindex @mnm{extensions} instance method @idxclscite{GLXCanvasPane}
@item @mnm{extensions} (@code{void})
Returns the supported GLX extensions from the display server as a
@code{String} object.

@cindex @mnm{frameRate} instance method @idxclscite{GLXCanvasPane}
@item @mnm{frameRate} (@code{void})
Returns the rate that the program updates the display, in frames
per second.  The algorithm that calculates the frame rate measures
frames over a five-second interval.

@cindex @mnm{freeFTFont} instance method @idxclscite{GLXCanvasPane}
@item @mnm{freeFTFont} (@code{void})
Releases the Freetype font in use.

@cindex @mnm{freeXFont} instance method @idxclscite{GLXCanvasPane}
@item @mnm{freeXFont} (@var{void})
Frees the font data that was allocated by a previous call to @mnm{useXFont}.
Programs should call this method when cleaning up before program exit,
or when switching fonts by a subsequent call to @mnm{useXFont}.

@cindex @mnm{initialize} instance method @idxclscite{GLXCanvasPane}
@item initialize (@code{Integer} @var{x}, @code{Integer} @var{y}, @code{Integer} @var{width}, @code{Integer} @var{height}, @code{Integer} @var{geomFlags})
@item initialize (@code{Integer} @var{x}, @code{Integer} @var{y}, @code{Integer} @var{width}, @code{Integer} @var{height})
@item initialize (@code{Integer} @var{width}, @code{Integer} @var{height}
Creates the receiver pane's window and configures the window for
display. The @mnm{initialize} method also fills in the receiver's
@code{visualInfoPtr} instance variable with a pointer the X visual
info structure specified by the receiver, which is provided by
the receiver's instance variables.

With two arguments, the method initializes the receiver window with
the width and height given as arguments.

With four arguments, the method initializes the receiver window with
the window's x and y origin and the width and height given as
arguments.

With five arguments, the @var{geom_flags} argument provides placement
hints for the window's initial position.  It has the format provided
by the @mnm{parseX11Geometry} method in @code{Application} class.
@xref{parseX11Geometry}.

When used, the @var{x} and @var{y} parameters can be given directly if
the program sets the window position itself.  If these arguments are
zero, then the window manager or the user supplied window geometry
determines the window placement.

@cindex @mnm{hasExtension} instance method @idxclscite{GLXCanvasPane}
@item hasExtension (@code{String} @var{extensionName})
Returns a @code{Boolean} value of true if the system's OpenGL
library supports the GLX extension @var{extensionName}, false
otherwise.

@cindex @mnm{map} instance method @idxclscite{GLXCanvasPane}
@item map (@code{void})
Maps the @code{GLXCanvasPane's} window to the display, and
internally creates a @code{GLXContext} for the window, and
makes the @code{GLXContext} current.

This method fills in the receiver's @code{glxContextPtr} instance
method.

@cindex @mnm{namedColorFT} instance method @idxclscite{GLXCanvasPane}
@item @mnm{namedColorFT} (@code{String} @var{colorName}, @code{Float} @var{redOut}, @code{Float} @var{greenOut}, @code{Float} @var{blueOut})
Return the GLX compatible color values for @var{colorName}; i.e., the
red, green, and blue values are @code{Floats} between 0.0 and 1.0.
The @var{colorName} argument can be any of the colors supported by the
X11 display server. Refer to @cite{showrgb(1)} for a list of colors.

@cindex @mnm{onAnimation} instance method @idxclscite{GLXCanvasPane}
@item @mnm{onAnimation} (@code{String} @var{animationHandlerName})
Installs the callback method that the program calls 24 times a second.
The method needs to have the prototype:

@example

GLXCanvasPane instanceMethod <methodName> (void);

@end example

@cindex @mnm{onButtonPress} instance method @idxclscite{GLXCanvasPane}
@item @mnm{onButtonPress} (@code{String} @var{buttonPressHandlerName})
Installs the callback method that handles ButtonPress events from the
display.  The callback method needs to have this prototype.

@example

GLXCanvasPane instanceMethod <methodName> (Integer winX, Integer winY,
                                           Integer screenX, Integer screenY,
                                           Integer buttonState,
                                           Integer eventTime);

@end example

The parameters @var{winX} and @var{winY} give the position of the
pointer relative to the window's origin.  The parameters @var{screenX}
and @var{screenY} give the pointer's position relative to the upper
left-hand corner of the root window.

Note this does not generally mean that the program can receive events
when a button is pressed outside of the program's window.  This
depends on how the desktop GUI interprets button presses; with many
desktop programs, the program doesn't receive events when a button is
clicked outside of the program's window.

The @var{buttonState} parameter's value records which buttons are
pressed at the time of the event.  Note that many systems interpret a
multiple button click (a ``chord'') as a unique button.  For example,
pressing the left and right buttons of a two-button mouse at the same
time results in a buttonState that indicates button 2 is pressed, not
that button 1 and button 3 are pressed simultaneously.

The @var{time} parameter is the time that the event occurred, so programs
can interpret a series of ButtonPress events as multiple mouse clicks
if necessary.

To install a buttonPress callback method, the program needs to
include an expression like this one in its initialization code.

@example

myGLXPane onButtonPress "myButtonPressHandler";

@end example

@cindex @mnm{onExpose} instance method @idxclscite{GLXCanvasPane}
@item @mnm{onExpose} (@code{String} @var{exposeHandlerName})
Installs the callback method to handle Expose events received from the
display.  The callback method should have the following prototype.

@example

GLXCanvasPane instanceMethod <methodName> (Integer nEvents);

@end example

To install the callback method, the program's initialization should
contain an expression like this one.

@example

myPane onExpose "myExposeHandler";

@end example

The parameter @var{nEvents} contains the number of Expose events
that the window is waiting to receive.  This allows programs
to execute the handler's statements once per group of Expose events;
that is, when @var{nEvents} reaches 0.

This handler is important because it updates the window in
coordination with other display events.  If a callback method is not
installed, then the @mnm{run} method calls the @mnm{swapBuffers}
method.

@cindex @mnm{onIdle} instance method @idxclscite{GLXCanvasPane}
@item @mnm{onIdle} (@code{String} @var{callbackMethodName})
Installs a callback method that the program executes when it is
not processing events from the display.

The callback method has the prototype:

@example

GLXCanvasPane instanceMethod <idleHandler> (void);

@end example

To install the handler, the program's initialization needs to
contain an expression like this.

@example

myPane onIdle "myIdleCallback";

@end example

@cindex @mnm{onKeyPress} instance method @idxclscite{GLXCanvasPane}
@item @mnm{onKeyPress} (@code{String} @var{callbackMethodName})
Configures the receiver's @code{keyPressHandler} instance variable
to refer to the application's actual KeyPress handler method, which
is called when the program's window receives a KeyPress event from
the display.

The actual callback method has the prototype:

@example

GLXCanvasPane instanceMethod <methodName> (Integer xKeySym,
                                           Integer keyCode,
                                           Integer shiftState);
@end example

This example shows a simple KeyPress handler that closes the window and exits
the program when the @kbd{Escape} key is pressed.

@example

/* This definition comes from the machine's X11/keysymdef.h file. */
#define XK_Escape 0xff1b

GLXCanvasPane instanceMethod myKeyPressMethod (Integer xKeySym,
					       Integer keyCode,
					       Integer shiftState) @{
  if (xKeySym == XK_Escape) @{
    self deleteAndClose;
    exit (0);
  @}
@}


@end example

The first parameter is the X Window System symbol for the key, which
is specific to the machine's keyboard configuration.  The complete
set of X key symbols is located in the machine's @flnm{X11/keysymdef.h}
file.

The second parameter is the ASCII value of alphanumeric keys and
punctuation keys. In the case of alphabetic characters, the value is
the same whether the keypress is shifted or unshifted.  That means
that pressing @kbd{A} and @kbd{a} both result in the @code{keyCode}
argument having the value 97.

The third parameter, shiftState, indicates whether a modifier key is
currently being pressed.  The parameter is the receiver's
@code{shiftState} instance variable.  The variable's description
describes how to interpret its value.

Then, during the program's initialization the program's code should
include an expression like the following.

@example

myProgram onKeyPress "myKeyPressMethod";

@end example

There is a more detailed description of how to configure callback
methods in section that discusses @code{Method}
class. @xref{CallbackSetup}.

@cindex @mnm{onPointerMotion} instance method @idxclscite{GLXCanvasPane}
@item onPointerMotion (@code{String} @var{callbackMethodName})
Installs the callback method that handles pointer motion events from
the display.  The callback method must have the prototype:

@example

GLXCanvasPane instanceMethod <methodName> (Integer winX,
                                           Integer winY,
                                           Integer screenX,
                                           Integer screenY);

@end example

The program's initialization should contain an expression like
this one:

@example

myPane onPointerMotion "myPointerMotionMethod";

@end example

@cindex @mnm{onResize} instance method @idxclscite{GLXCanvasPane}
@item onResize (@code{String} @var{callbackMethodName})
Installs the callback method that handles resize notifications from
the display.  The callback method needs to have the prototype:

@example

GLXCanvasPane instanceMethod <methodName> (Integer width,
                                           Integer height);

@end example

The program's initialization code should contain an expression like
this one.

@example

myPane onResize "myResizeMethod";

@end example

@cindex @mnm{onTimerTick} instance method @idxclscite{GLXCanvasPane}
@item onTimerTick (@code{String} @var{callbackMethodName})
Installs the callback method to be executed when the classes' interval
timer reaches zero.  The callback method needs to have the
following prototype.

@example

GLXCanvasPane instanceMethod <methodName> (void);

@end example

The interval in milliseconds between the callback method's execution
is set in the @code{timerMSec} instance variable,

@cindex @mnm{pixelHeightFT} instance method @idxclscite{GLXCanvasPane}
@item pixelHeightFT (@code{Integer} @var{pxHeight})
Set the pixel height of the selected font to the argument.  The default
height for rendering fonts with the Freetype libraries is 18 pixels.

@cindex @mnm{refreshRate} instance method @idxclscite{GLXCanvasPane}
@item refreshRate (@code{void})
Returns a @code{Float} with the display's refresh rate.  If the
machine's OpenGL does not support reporting the refresh rate, returns
-1.

@cindex @mnm{run} instance method @idxclscite{GLXCanvasPane}
@item run (@code{void})
Runs the event loop that receives X events from the display server,
and sends them to the callback methods that are configured for
the application.

Without any callback methods defined, the @mnm{run} method handles
only @samp{Expose} events (by calling @mnm{swapBuffers}), and
@samp{ClientMessage} events, which check for the
@code{WM_DELETE_WINDOW} Atom and if present, delete the pane's window
and GLX context, and exit the program.

@cindex @mnm{swapBuffers} instance method @idxclscite{GLXCanvasPane}
@item swapBuffers (@code{void})
Swaps the pane window's offscreen rendering buffer with the window's
visible buffer.

@cindex @mnm{syncSwap} instance method @idxclscite{GLXCanvasPane}
@item syncSwap (@code{Integer} @var{interval})
If @var{interval} > 0, sets the swap interval to 1/@var{interval},
which enables swap synchronization with the display's vertical refresh
rate if the machine's OpenGL installation supports the
@code{GLX_MESA_swap_control} extension.

An @var{interval} value of 0 disables swap synchronization.

Returns 0 on sucess, or -1 if the extension is not supported.

@cindex @mnm{textWidth} instance method @idxclscite{GLXCanvasPane}
@item textWidth (@code{String} @var{text})
Returns an @code{Integer} with the width of @var{text} in pixels
in the currently selected X font.  If no font is selected, the
method returns @samp{-1}.

@cindex @mnm{textWidthFT} instance method @idxclscite{GLXCanvasPane}
@item textWidthFT (@code{String} @var{text})
Returns a @code{Float} with the width of @var{text} in matrix
coordinates for the currently selected Freetype font.

@cindex @mnm{title} instance method @idxclscite{GLXCanvasPane}
@item title (@code{String} @var{title_string})
Set's the window's title.  This method should be called as soon
as possible after the program calls the @mnm{initialize} method.

@cindex @mnm{useFTFont} instance method @idxclscite{GLXCanvasPane}
@item useFTFont (@code{String} @var{fontFileName})
Load a TrueType, FreeType or Type 1 font.  Also initializes the font
and GLEW libraries if needed.

The method uses the font's file name as its argument.  To use a
system's font aliasing and lookup, refer to @xref{X11FreeTypeFont}.

@cindex @mnm{useXFont} instance method @idxclscite{GLXCanvasPane}
@item useXFont (@code{String} @var{fontName})
Register a X font for use with drawing text in the receiver
pane.  The argument, @var{fontname}, is th X Logical Font Descriptor
of a X font that is available on the system - refer to @cite{xlsfonts(1)}
or @cite{xfontsel(1)} for more information.

This method should be called during OpenGL initialization (that is,
after the @code{GLXCanvasPane} object has been created and the
GLX context established).

@cindex @mnm{xpmToTexture} instance method @idxclscite{GLXCanvasPane}
@item xpmToTexture (@code{Symbol} @var{xpmdata}, @code{Integer} @var{widthout}, @code{Integer} @var{heightout}, @code{Symbol} @var{texeldataout})
@item xpmToTexture (@code{Symbol} @var{xpmdata}, @code{Integer} @var{alpha} @code{Integer} @var{widthout}, @code{Integer} @var{heightout}, @code{Symbol} @var{texeldataout})

Translates a XPM pixmap into an OpenGL texture.  The argument
@var{xpm_data} is the pixmap's @code{char *pixmap_name[]} declaration.
If no @var{alpha} argument is given, then @samp{1.0} is used to
create an opaque texture.

Alpha values can range from 0 (completely transparent) - 0xffff
(completely opaque), although in practice, the alpha channel's effect
might not be apparent, because OpenGL has its own set of functions
that perform texture blending.

The method sets the arguments @var{width_out}, @var{height_out}, and
@var{texel_data_out} with the height, width and data of the texture.

 Mesa OpenGL textures, used with Linux systems, internally have the
format GL_RGBA and the data type GL_UNSIGNED_INT_8_8_8_8, so you can
create a 2D texture from a pixmap with statements like these.

@example

Integer new xpmWidth;
Integer new xpmHeight;
Symbol new texData;

/*
 *  Note that the xpm_data argument should not normally need a
 *  translation from C.
 */
myGLUTApp xpmToTexture xpm_data, xpmWidth, xpmHeight, texData;
glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, xpmWidth, xpmHeight, 0,
              GL_RGBA, GL_UNSIGNED_INT_8_8_8_8, texData);

@end example

Apple OpenGL implementations use a different internal format, so
a program would create the equivalent texture like this.

@example

Integer new xpmWidth;
Integer new xpmHeight;
Symbol new texData;

myGLUTApp xpmToTexture xpm_data, xpmWidth, xpmHeight, texData;
glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, xpmWidth, xpmHeight, 0,
              GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, texData);

@end example

The @mnm{xpmToTexture} method does not do any setup of the OpenGL texture
environment.  For basic textures, OpenGL works better with textures
that have a geometry that is an even multiple of 2; e.g., 128x128 or
256x256 pixels.  

Individual applications can add parameters for interpolation,
blending, mipmap creation, and material rendering based on the
program's requirements, though.

The Ctalk library only stores the data for one texture at a time, so
if a program uses multiple textures, it should save the texture data
to a separate @code{Symbol}, in orderq to avoid regenerating the texture each
time it's used.  Many OpenGL implementations also provide API functions
for texture caching.

For an example of how to draw with textures, refer to the
@file{glxtexture.ca} program in the Ctalk distribution's
@file{demos/glx} subdirectory.

@end table

@anchor{GLXExampleProgram}
@cindex GLX example program
@subheading Sample GLXCanvasPane Application

@example

#include <X11/Xlib.h>
#include <GL/glx.h>

#define DEFAULT_WIDTH 500
#define DEFAULT_HEIGHT 500

float face1[3][3] = @{@{0.0f, 2.0f, 0.0f@},
		     @{-2.0f, -2.0f, 2.0f@},
		     @{2.0f, -2.0f, 2.0f@}@};
float face2[3][3] = @{@{0.0f, 2.0f, 0.0f@},
		     @{2.0f, -2.0f, 2.0f@},
		     @{2.0f, -2.0f, -2.0f@}@};
float face3[3][3] = @{@{0.0f, 2.0f, 0.0f@},
		     @{2.0f, -2.0f, -2.0f@},
		     @{-2.0f, -2.0f, -2.0f@}@};
float face4[3][3] = @{@{0.0f, 2.0f, 0.0f@},
		     @{-2.0f, -2.0f, -2.0f@},
		     @{-2.0f, -2.0f, 2.0f@}@};

float base[4][3] = @{@{2.0f, -2.0f, 2.0f@},
		    @{2.0f, -2.0f, -2.0f@},
		    @{-2.0f, -2.0f, -2.0f@},
		    @{-2.0f, -2.0f, 2.0f@}@};

float angle = 20.0;

GLXCanvasPane instanceMethod draw (void) @{
  glEnable (GL_NORMALIZE);
  glEnable(GL_DEPTH_TEST);
  glClearColor(0.0, 0.0, 0.0, 1.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
  glLineWidth (1.0f);

  glLoadIdentity ();
  glColor4f (1.0f, 1.0f, 1.0f, 1.0f);

  glRotatef (angle, 0.0f, 1.0f, 0.0f);
  glRotatef (10.0f, 0.0f, 0.0f, 1.0f);

  glBegin (GL_TRIANGLES);
  glColor3f (1.0f, 0.0f, 0.0f);
  glVertex3fv (face1[0]);
  glColor3f (0.0f, 1.0f, 0.0f);
  glVertex3fv (face1[1]);
  glColor3f (0.0f, 0.0f, 1.0f);
  glVertex3fv (face1[2]);

  glColor3f (1.0f, 0.0f, 0.0f);
  glVertex3fv (face2[0]);
  glColor3f (0.0f, 1.0f, 0.0f);
  glVertex3fv (face2[1]);
  glColor3f (0.0f, 0.0f, 1.0f);
  glVertex3fv (face2[2]);
			
  glColor3f (1.0f, 0.0f, 0.0f);
  glVertex3fv (face3[0]);
  glColor3f (0.0f, 1.0f, 0.0f);
  glVertex3fv (face3[1]);
  glColor3f (0.0f, 0.0f, 1.0f);
  glVertex3fv (face3[2]);
			
  glColor3f (1.0f, 0.0f, 0.0f);
  glVertex3fv (face4[0]);
  glColor3f (0.0f, 1.0f, 0.0f);
  glVertex3fv (face4[1]);
  glColor3f (0.0f, 0.0f, 1.0f);
  glVertex3fv (face4[2]);
  glEnd ();

  glBegin (GL_QUADS);

  glColor3f (1.0f, 0.0f, 0.0f);
  glVertex3fv (base[0]);
  glColor3f (0.0f, 1.0f, 0.0f);
  glVertex3fv (base[1]);
  glColor3f (0.0f, 0.0f, 1.0f);
  glVertex3fv (base[2]);
  glColor3f (1.0f, 0.0f, 1.0f);
  glVertex3fv (base[3]);

  glEnd ();

  glRotatef (20.0, 0.0f, 0.0f, 1.0f);
  glRotatef (angle, 0.0f, 1.0f, 0.0f);

  self swapBuffers;
@}

GLXCanvasPane instanceMethod initGL (void) @{
  glViewport (0, 0, DEFAULT_WIDTH, DEFAULT_HEIGHT);
  glClearColor(0.0, 0.0, 0.0, 1.0);
  glLineWidth (1.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glEnable (GL_LINE_SMOOTH);
  glHint (GL_LINE_SMOOTH_HINT, GL_DONT_CARE);
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  if (DEFAULT_WIDTH <= DEFAULT_HEIGHT) @{
    glOrtho (-5.0, 5.0,
	     -5.0 * ((float)DEFAULT_HEIGHT / (float)DEFAULT_WIDTH),
	     5.0 * ((float)DEFAULT_HEIGHT / (float)DEFAULT_WIDTH),
	     -5.0, 5.0);
  @} else @{
    glOrtho (-5.0, 5.0,
	     -5.0 * ((float)DEFAULT_WIDTH / (float)DEFAULT_HEIGHT),
	     5.0 * ((float)DEFAULT_WIDTH / (float)DEFAULT_HEIGHT),
	     -5.0, 5.0);
  @}
  glMatrixMode (GL_MODELVIEW);
  glLoadIdentity ();
@}

GLXCanvasPane instanceMethod myTimerTickHandler (void) @{
  angle += 1.0;
  self draw;
@}

/* This definition comes from the machine's X11/keysymdef.h file. */
#define XK_Escape 0xff1b

GLXCanvasPane instanceMethod myKeyPressMethod (Integer xKeySym,
					       Integer keyCode,
					       Integer shiftState) @{
  if (xKeySym == XK_Escape) @{
    self deleteAndClose;
    exit (0);
  @}
@}

GLXCanvasPane instanceMethod myExposeMethod (Integer nEvents) @{
  if (nEvents == 0)
    self draw;
@}

GLXCanvasPane instanceMethod myResizeMethod (Integer width,
					     Integer height) @{
  float ar;

  glViewport (0, 0, width, height);
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  if (width <= height)
    ar = (float)height / (float)width;
  else
    ar = (float)width / (float)height;
  glOrtho (-5.0, 5.0, -5.0 * ar, 5.0 * ar, -5.0, 5.0);
  glMatrixMode (GL_MODELVIEW);
  glLoadIdentity ();
@}

int main () @{
  GLXCanvasPane new pane;

  pane initialize (1, 150, 500, 500);
  pane title "GLXCanvasPane Demonstration";
  pane map;
  pane raiseWindow;

  pane onKeyPress "myKeyPressMethod";
  pane onExpose "myExposeMethod";
  pane onTimerTick "myTimerTickHandler";
  pane onResize "myResizeMethod";

  pane initGL;
  
  pane run;

@}

@end example

@node X11PaneDispatcher, X11CanvasPane, GLXCanvasPane, Classes
@iftex
@section @code{X11PaneDispatcher} Class
@end iftex
@ifnottex
@subheading @code{X11PaneDispatcher} Class
@end ifnottex
@cindex @code{X11PaneDispatcher} class

@code{X11PaneDispatcher} objects manage events from the
system's display, control posititioning and rendering of
subpanes within the main pane, and help communicate events
between the main window's pane and the subwindows' panes.

@cindex Window geometry
@cindex Geometry, windows
The positioning of subwindows within the parent window is controlled
by the arguments to the @mnm{attachTo} methods; in particular, these
methods accept a geometry specification, as an argument, which has
the following format.

@example

width[%]xheight[%][+x[%]+y[%]]

@end example

If a dimension does not contain a percent (@samp{%}) sign, the dimensions
are in pixels.  With a percent sign, the dimensions are a fractional
percentage of the parent pane's width or height.

Also, for some @code{Pane} classes, like dialog windows, if the geometry
does not include the @emph{x} and @emph{y} dimensions, then the class
positions the window centered over its parent window.

The @code{X11PaneDispatcher} method @mnm{new} creates a X
window, although the window of the @code{X11PaneDispatcher}
itself is not normally visible, the window is provided for subclass
panes whose windows will appear within the main
@code{X11Pane} window.  

Subclasses can reimplement default methods like @mnm{new}
and the event handler methods if necessary.  It is also
possible for subclasses to implement event handlers with
other method messages than those given here.  The
@code{X11PaneDispatcher} object can use these subclasses'
methods if they are available.  

Subclasses, however, should use the @mnm{setMethodHandler}
method, described below, to register these callback methods.

@subsubheading Handler Classes
The following event handlers and the default names of the
callback method that handles the event, are available to
@code{X11PaneDispatcher} objects and its subclasses.
Handler methods need to take as arguments a reference to 
a subpane object, and the @code{InputEvent} object from
the system.  @xref{X11TerminalStream}.

@smallexample
Handler Class  Event Class    Description                     Default Handler Method
"resize"       RESIZENOTIFY   Called when the user            subPaneResize
                              resizes a window.

"move"         MOVENOTIFY     Called when a user              subPaneMove
                              moves a window.  
                              Depending on the 
                              window manager, an
                              application might also
                              need to make sure the
                              window is resized 
                              correctly.

"expose"       EXPOSE         Called whenever the display     subPaneExpose
                              server generates exposes a 
                              window due when raised, 
                              uncovered, resized, or other
                              change.

"kbdinput"     KEYPRESS       Called when the user presses    subPaneKbdInput
               KEYRELEASE     a key and the application's
                              window has the focus.

"pointerinput" BUTTONPRESS    Called when a mouse button      subPanePointerInput
               BUTTONRELEASE  is pressed or released.

"pointermotion" MOTIONNOTIFY  Called whe the pointer is       subPanePointerMotion
                              moved.

"selectionrequest"
             SELECTIONREQUEST Received when another program   subPaneSelectionRequest
                              requests the X selection.
                              This callback is here mainly
                              for completeness; presently, X
                              selection events are handled
                              internally, and only with the
                              library functions used by
                              X11TextEditorPane objects.

"selectionclear"        
               SELECTIONCLEAR Received when another program
                              requests the X selection. Currently,
                              on library functions used by
                              X11TextEditorPane objects use this
                              internally but applications can use this
                              event to update their status if
                              necessary.
"wmfocuschange" WMFOCUSCHANGENOTIFY
                              Received from the window manager when the
                              pointer enters or leaves a window, or when
                              the window manager raises a window.  The
                              xEventData1 instance variable contains the
                              type of X event, either FocusIn or FocusOut.

"enternotify" ENTERWINDOWNOTIFY
                              Received when the pointer enters a
                              window from another window.

"leavenotify" LEAVEWINDOWNOTIFY
                              Received when the pointer leaves a
                              window.

"focusin"     FOCUSIN         Received when the application signals
"focusout"    FOCUSOUT        a change of widget focus; for example,
                              when the user presses the @key{Tab}
                              key.

"destroy"      WINDELETE      Called when the user closes the
                              application window.

@end smallexample

@subsubheading Handler Methods
A handler typically takes as its arguments a reference to a
subpane, and the event.  Although the subpane reference
parameter can be declared as an @code{Object}, it is in
actual use a @code{Symbol} object, with the reference
defined by the @code{attachTo} method.  The handler should
be able to pass the event along to any subpanes of the
receiver pane if necessary, by checking whether subpanes
implement their own handlers.  Here, for example, is the
@code{X11PaneDispatcher} class's @mnm{subPaneResize} method.

@example

X11PaneDispatcher instanceMethod subPaneResize (Object __subPane, 
					      InputEvent __event) @{
  "Dispatch an Resize event to the subpanes of the
   receiver pane."
  X11Pane new containerPane;
  self size x = __event xEventData3;
  self size y = __event xEventData4;
  containerPane = *self container;
  XResizeWindow (containerPane xDisplay, containerPane xWindowID,
		 self size x, self size y);
  if (__subPane isInstanceMethod "subPaneResize") @{
    __subPane methodObjectMessage __subPane handleResize, __subPane,
      __event;
  @}
  return NULL;
@}

@end example

The internals of the subpane API are likely to change and be
expanded in future releases.  Using the methods described
here and in other sections should help insure that
applications are compatible with future Ctalk releases.

@subsubheading Instance Variables

@table @code

@cindex @code{canFocus} instance variable @idxclscite{X11LabelPane}
@item canFocus
A @code{Boolean} that determines whether the widget is highlighed when
the pointer passes over it, or the application sets the focus; for
example, by pressing the @key{Tab} key.

If this variable is true, which is the default, then the class should
also declare event handlers for focus in and focus out events.
Otherwise, the program prints a warning each time the @mnm{shiftFocus}
method, described below, calls a @code{NULL} @code{Method} object.

@cindex handleDestroy instance variable @idxclscite{X11PaneDispatcher}
@item handleDestroy
A @code{Method} that provides the default handler to delete
a subpane window and its data.

@cindex handleEnterNotify instance variable @idxclscite{X11PaneDispatcher}
@cindex handleLeaveNotify instance variable @idxclscite{X11PaneDispatcher}
@item handleEnterNotify
@item handleLeaveNotify
Handlers for events that are generated when a pointer crosses from one
window to another.

@cindex handleFocusIn instance variable @idxclscite{X11PaneDispatcher}
@cindex handleFocusOut instance variable @idxclscite{X11PaneDispatcher}
@item handleFocusIn
@item handleFocusOut
Handles highlighting or un-highlighting a widget when receiving a
FOCUSIN or FOCUSOUT event from the application; for example, when the
user presses the @key{Tab} key.

@cindex handleKbdInput instance variable @idxclscite{X11PaneDispatcher}
@item handleKbdInput
A @code{Method} that provides the default handler for
subpanes to handle keyboard input.

@cindex handleMove instance variable @idxclscite{X11PaneDispatcher}
@item handleMove
A @code{Method} that provides the default handler for
moving subpane windows.

@cindex handlePointerInput instance variable @idxclscite{X11PaneDispatcher}
@item handlePointerInput
A @code{Method} that provides the default handler for pointer input
(mainly ButtonPress) events.

@cindex handlePointerMotion instance variable @idxclscite{X11PaneDispatcher}
@item handlePointerMotion
A @code{Method} that provides the default handler for pointer motion
events.

@cindex handleResize instance variable @idxclscite{X11PaneDispatcher}
@item handleResize
A @code{Method} that provides the default handler for resizing subpane
windows within the main window.

@cindex handleSelectionClear instance variable @idxclscite{X11PaneDispatcher}
@item handleSelectionClear
A @code{Method} that provides the default handler for SelectionClear
events.

@cindex handleSelectionRequest instance variable @idxclscite{X11PaneDispatcher}
@item handleSelectionRequest
A @code{Method} that provides the default handler for SelectionRequest
events.  Currently, this callback is here for completeness; X selection
events are handled internally, and only in the library functions used
by @code{X11TextEditorPane} objects.

@cindex handleWMFocusChage instance variable @idxclscite{X11PaneDispatcher}
@item handleWMFocusChange
The method that handles the events received from the desktop's window
manager when it changes the window focus in response to a pointer
motion or click; or when the window manager raises a window.

@cindex hasFocus
@item hasFocus
An @code{Integer} that is true if the current subpane has the input
focus.  For programs with only a single widget class, this variable
is not used.

@cindex @code{highlight} instance variable @idxclscite{X11PaneDispatcher}
@item highlight
A @code{Boolean} that indicates whether the widget is displayed
highlighted.

@cindex @code{modalWin} instance variable @idxclscite{X11PaneDispatcher}
@item modalWin
When a dialog window is popped up over the main window, this holds
the window ID of the popup.  The @mnm{handleSubPaneEvent} method uses
this to determine how the application's main window should respond
to X events; generally it keeps the dialog window above the main
window until the dialog window is withdrawn.  When their is no
window popped up over the main window, the value of @code{modalWin}
is zero (@samp{0}).

@cindex @code{tabFocus} instance variable @idxclscite{X11PaneDispatcher}
@item tabFocus
A @code{Boolean} that determines, if true (which is the default), whether
the @mnm{handleSubPaneEvent} method intercepts the @key{Tab} key in
order to shift the input focus when it is pressed.  If @code{tabFocus} is
true, the subpane's class must implement methods to handle the @code{focusin}
and @code{focusout} events that shifting focus with the keyboard implements,
or the program will display warning messages when it can't find the methods.

@end table

@subsubheading Instance Methods
@table @code

@cindex @mnm{attachTo} instance method @idxclscite{X11PaneDispatcher}
@item @mnm{attachTo} (@code{Object} @var{parentPane})
@item @mnm{attachTo} (@code{Object} @var{parentPane}, @code{String} @var{geometry})
Attach the receiver to its parent pane, typically a @code{X11Pane} or
@code{X11PaneDispatcher}.  Also creates a X window, although
@code{X11PaneDispatcher} windows themselves are not normally visible.

When the subwindow is attached to the parent window, the Ctalk library
creates the pane object's window and graphics context, and clears the
window to the background color of the pane object's @code{backgroundColor}
instance variable; for example, with an expression like this:

@example

myCanvasPane backgroundColor = "blue";

@end example

Otherwise, the method clears the subpane's window to black.

The @var{geometry} argument, if present, defines the size and placement
of the subpane's window within the parent window.  A geometry specification
has the form:

@example

width[%]xheight[%]+x[%]+y[%]

@end example

The dimensions are in pixels, unless a percent sign (@samp{%}) follows
a dimension.  In that case, the dimension is a fractional percentage
of the parent pane's width or height. The @code{String} may contain a
combination of absolute and relative dimensions.

@cindex @mnm{handleSubPaneEvent} instance method @idxclscite{X11PaneDispatcher} 
@item @mnm{handleSubPaneEvent} (@code{InputEvent} @var{event})
Handle an input event from the window system. Typically the
parent pane's @code{inputStream} provides the event.
@xref{X11TerminalStream}.

This method also checks keypresses for the @key{Tab} key, and
calls the @code{shiftFocus} method in order to shift focus between
a window's subpanes when the user presses @key{Tab}.

@cindex @mnm{new} instance method @idxclscite{X11PaneDispatcher}
@item @mnm{new} (@var{dispatcherName})
Create a new @code{X11PaneDispatcher} object.  Initializes the
instance variables to the default subpane event handlers and
the container mode to @samp{full}.  If the argument list contains
more than one label, created new @code{X11PaneDispatcher} objects
with the names of each label.

@cindex @mnm{setMethodHandler} instance method @idxclscite{X11PaneDispatcher}
@item @mnm{setMethodHandler} (@code{String} @var{handlerType}, @code{Method} @var{handlerMethod})
Set the pane's handler for @var{handlerType} to
@var{handlerMethod}.  Currently supported handler types are: @samp{resize}.

@cindex @mnm{shiftFocus} instance method @idxclscite{X11PaneDispatcher}
@item shiftFocus (@code{void})
When the user presses @key{Tab}, @code{handleSubPaneEvent} calls this method,
which highlights a window's subpanes in succession, if the subpanes can
take the input focus.

Refer to the @code{canFocus} instance variable, and the handlers for focus
in and focus out events.  These event handlers are called by the program,
and are not the same as the @code{handleWMFocusChange} handler, which
is called when the window focus changes on the desktop.

@cindex @mnm{clearFocus} instance method @idxclscite{X11PaneDispatcher}
@item @mnm{clearFocus} (@code{void}
Called before shifting the focus highlight to a new pane to insure
that only one pane indicates that it should receive focus, including
the synthetic focus that is assigned when shifting focus using the
@key{Tab} key.


@cindex @mnm{subPaneDestroy} instance method @idxclscite{X11PaneDispatcher}
@item @mnm{subPaneDestroy} (@code{Object} @var{subPaneRef}, @code{InputEvent} @var{destroyEvent})
The default handler for @code{WINDELETE} events.  Like the
other method handlers, @var{subPaneRef} is typically a
@code{Symbol} object.  The @code{X11TerminalStream} section
describes these events.  @xref{X11TerminalStream}.

@cindex @mnm{subPaneGeometry} instance method @idxclscite{X11PaneDispatcher} 
@item subPaneGeometry
A @code{String} that stores a subpane's geometry specification, if
any.  For an explanation of geometry string's format, refer to the
@mnm{attachTo} method, below.

@cindex @mnm{subPaneKbdInput} instance method @idxclscite{X11PaneDispatcher}
@item @mnm{subPaneKbdInput} (@code{Object} @var{subPaneRef}, @code{InputEvent} @var{kbdInputEvent})
The default handler for @code{KEYPRESS} and
@code{KEYRELEASE} events.  Like the other method handlers,
@var{subPaneRef} is typically a @code{Symbol} object.  The
@code{X11TerminalStream} section describes these events.
@xref{X11TerminalStream}.

@cindex @mnm{subPaneMove} instance method @idxclscite{X11PaneDispatcher}
@item @mnm{subPaneMove} (@code{Object} @var{subPaneRef}, @code{InputEvent} @var{moveNotifyEvent})
The default event handler for @code{MOVENOTIFY} events
from the system's GUI.  Like the other method handlers,
@var{subPaneRef} is typically a @code{Symbol} object.  The
@code{X11TerminalStream} section describes these events.
@xref{X11TerminalStream}.

With some window managers, a @mnm{subPaneMove} method might
also need to handle @code{RESIZENOTIFY} events.

@cindex @mnm{subPanePointerMotion} instance method @idxclscite{X11PaneDispatcher}
@item @mnm{subPanePointerMotion} (@code{Object} @var{subPaneRef}, @code{InputEvent} @var{event})
@cindex @mnm{subPanePointerInput} instance method @idxclscite{X11PaneDispatcher}
@item @mnm{subPanePointerInput} (@code{Object} @var{subPaneRef}, @code{InputEvent} @var{event})
The default handlers for @code{MOTIONNOTIFY}, and @code{BUTTONPRESS}
and @code{BUTTONRELEASE} events.  Like the other method handlers,
@var{subPaneRef} is typically a @code{Symbol} object.  The
@code{X11TerminalStream} section describes these events.
@xref{X11TerminalStream}.

@cindex @mnm{subPaneResize} instance method @idxclscite{X11PaneDispatcher}
@item @mnm{subPaneResize} (@code{Object} @var{subPaneRef}, @code{InputEvent} @var{resizeNotifyEvent})
The default resize handler for subpane windows.  Typically
@var{subPaneRef} is a @code{Symbol} object that contains a
reference to the subpane object.  The @var{resizeEvent}
argument is typically a @code{RESIZENOTIFY} event from the
system's GUI.  @xref{X11TerminalStream}.

@end table

@node X11CanvasPane, X11ButtonPane, X11PaneDispatcher, Classes
@iftex
@section @code{X11CanvasPane} Class
@end iftex
@ifnottex
@subheading @code{X11CanvasPane} Class
@end ifnottex
@cindex @code{X11CanvasPane} class

The @code{X11CanvasPane} class provides the instance
variables and methods for basic X window graphics operations
like drawing points, lines, and rectangles.  The width and
color of shapes is controlled by the @code{pen} instance
variable.

Here is brief drawing program that uses a
@code{X11CanvasPane} object.  Clicking on the pane's window
draws a dot at that point.  If the program is given the argument
@samp{-v}, the program displays the X events it receives from
the display.
@c ctalk/test/expect/examples-x11/canvas.c
@example

int main (int argv, char **argc) @{
  X11Pane new xPane;
  X11PaneDispatcher new xTopLevelPane;
  X11CanvasPane new xCanvasPane;
  InputEvent new e;
  Integer new nEvents;
  Integer new verbose;
  Exception new ex;
  String new text;
  Application new paneApp;

  paneApp enableExceptionTrace;
  paneApp installExitHandlerBasic;

  xPane initialize 0, 0, 200, 100;
  xPane inputStream eventMask =
    WINDELETE|BUTTONPRESS|BUTTONRELEASE|MOVENOTIFY|EXPOSE;
  xTopLevelPane attachTo xPane;
  xCanvasPane attachTo xTopLevelPane;
  xPane map;
  xPane raiseWindow;

  xPane openEventStream;

  xCanvasPane clear;
  xCanvasPane background "blue";
  xCanvasPane pen width = 5;
  xCanvasPane pen colorName = "white";

  xCanvasPane refresh;

  verbose = FALSE;
  if (argc == 2) @{
    if (!strcmp (argv[1], "-v")) @{
      verbose = TRUE;
    @}
  @}

  WriteFileStream classInit;

  while (TRUE) @{
    xPane inputStream queueInput;
    if (xPane inputStream eventPending) @{
      e become xPane inputStream inputQueue unshift;
      xPane subPaneNotify e;  /* Call the classes' event handlers. */
      if (ex pending)
 	ex handle;

      switch (e eventClass value) 
	@{
	  /*
	   *  Handle both types of events in case the window
	   *  manager doesn't distinguish between them.
	   */
	case MOVENOTIFY:
	  if (verbose) @{
	    stdoutStream printOn "MOVENOTIFY\t%d\t%d\t%d\t%d\n",
	      e xEventData1, 
	      e xEventData2, 
	      e xEventData3, 
	      e xEventData4;
	    stdoutStream printOn "Window\t\t%d\t%d\t%d\t%d\n",
	      xPane origin x, 
	      xPane origin y, 
	      xPane size x,
	      xPane size y;
	  @}
	  break;
	case RESIZENOTIFY:
	  if (verbose) @{
	    stdoutStream printOn "RESIZENOTIFY\t%d\t%d\t%d\t%d\n",
	      e xEventData1, 
	      e xEventData2, 
	      e xEventData3, 
	      e xEventData4;
	    stdoutStream printOn "Window\t\t%d\t%d\t%d\t%d\n",
	      xPane origin x, 
	      xPane origin y, 
	      xPane size x,
	      xPane size y;
	  @}
	  break;
	case EXPOSE:
	  if (verbose) @{
	    stdoutStream printOn "Expose\t\t%d\t%d\t%d\t%d\t%d\n",
	      e xEventData1, 
	      e xEventData2, 
	      e xEventData3, 
	      e xEventData4,
	      e xEventData5;
	  @}
	  break;
	case BUTTONPRESS:
	  xCanvasPane drawPoint e xEventData1, e xEventData2;
	  if (verbose) @{
	    stdoutStream printOn "ButtonPress\t\t%d\t%d\t%d\t%d\t%d\n",
	      e xEventData1, 
	      e xEventData2, 
	      e xEventData3, 
	      e xEventData4,
	      e xEventData5;
	  @}
	  xCanvasPane refresh;
	  break;
	case BUTTONRELEASE:
	  if (verbose) @{
	    stdoutStream printOn "ButtonRelease\t\t%d\t%d\t%d\t%d\t%d\n",
	      e xEventData1, 
	      e xEventData2, 
	      e xEventData3, 
	      e xEventData4,
	      e xEventData5;
	  @}
	  break;
	case WINDELETE:
 	  xPane deleteAndClose;
	  exit (0);
	  break;
	default:
	  break;
	@}
    @}
  @}
@}


@end example

@subheading Instance Variables
@table @code
@cindex @code{dragStart} instance variable @idxclscite{X11CanvasPane}
@item dragStart
A @code{Point} object that records the beginning of a canvas
motion operation within a window or view port.  

@cindex @code{moveCursor} instance variable @idxclscite{X11CanvasPane}
@item @code{moveCursor}
The @code{X11Cursor} displayed when moving the
@code{X11CanvasPane} object within a window or view port.

@cindex @code{pen} instance variable @idxclscite{X11CanvasPane}
@item @code{pen}
A @code{Pen} object that contains the width in pixels and
color of lines and points drawn on the pane's window.

@cindex @code{regions} instance variable @idxclscite{X11CanvasPane}
@item @code{regions}
An @code{AssociativeArray} that contains the rectangular regions defined
by the @mnm{defineRegion} method, below.  

@cindex @code{viewHeight} instance variable @idxclscite{X11CanvasPane}
@item @code{viewHeight}
An @code{Integer} that contains the height of the pane's
window and buffers in pixels.

@cindex @code{viewWidth} instance variable @idxclscite{X11CanvasPane}
@item @code{viewWidth}
An @code{Integer} that contains the height of the pane's
window and buffers in pixels.

@cindex @code{viewXOrg} instance variable @idxclscite{X11CanvasPane}
@item @code{viewXOrg}
The X coordinate of the upper right-hand corner of a canvas'
visible rectangle within a window or view port.

@cindex @code{viewYOrg} instance variable @idxclscite{X11CanvasPane}
@item @code{viewYOrg}
The Y coordinate of the upper right-hand corner of a canvas'
visible rectangle within a window or view port.

@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{attachTo} instance method @idxclscite{X11CanvasPane}
@item @mnm{attachTo} (@code{Object} @var{parent_pane})
@item @mnm{attachTo} (@code{Object} @var{parent_pane}, @code{String} @var{geometry})
@item @mnm{attachTo} (@code{Object} @var{parent_pane}, @code{Integer} @var{xOrg}, @code{Integer} @var{yOrg})
@item @mnm{attachTo} (@code{Object} @var{parent_pane}, @code{Integer} @var{xOrg}, @code{Integer} @var{yOrg}, @code{Integer} @var{xSize}, @code{Integer} @var{ySize})
Attach a @code{X11CanvasPane} object to its parent pane, which is
typically a @code{X11PaneDispatcher} object.  With one argument, this
method initializes the size of the pane's window and buffers to
the parent pane's dimensions, and positions the pane at the upper left-hand
origin of the main window.

If two arguments are present, the second is a @code{String} with the
geometry specifcation for the subpane.  Subpane geometry strings have
the form:

@example

width[%]xheight[%]+x[%]+y[%]

@end example

The dimensions are in pixels, unless a percent sign (@samp{%}) follows
a dimension.  In that case, the dimension is a fractional percentage
of the parent pane's width or height.  The @code{String} may contain a
combination of absolute and relative dimensions.

With three arguments, the method positions the pane at
@var{xOrg},@var{yOrg} within the parent pane, which usually is
relative to the upper left hand origin of the window.

With five arguments, the method positions the pane at
@var{xOrg},@var{yOrg} within the parent pane, with the width and
height @var{xSize},@var{ySize}.

@cindex @mnm{background} instance method @idxclscite{X11CanvasPane}
@item @mnm{background} (@code{String} @var{color})
Set the background of the pane to @var{color}.  You need to
update the pane using, for example, @mnm{clearRectangle}, for
the new background to be visible.
See the note for
@code{X11Bitmap} class's @mnm{background} method.
@xref{X11Bitmap}.

@cindex @mnm{clear} instance method @idxclscite{X11CanvasPane}
@item @mnm{clear} (@code{void})
Clear the pane to the background color.

@cindex @mnm{clearRectangle} instance method @idxclscite{X11CanvasPane}
@item @mnm{clearRectangle} (@code{Intger} @var{xOrg}, @code{Integer} @var{yOrg}, @code{Integer} @var{xSize}, @code{Integer} @var{ySize})
Clear the pane's image to the window background in a rectangle bounded
by the method's arguments, and update the top-level pane's window.

@cindex @mnm{copy} instance method @idxclscite{X11CanvasPane}
@item @mnm{copy} (@code{X11Bitmap} @var{src_bitmap}, @code{Integer} @var{src_x_ort}, @code{Integer} @var{src_y_org}, @code{Integer} @var{src_width}, @code{Integer} @var{src_height}, @code{Integer} @var{dest_x_org}, @code{Integer} @var{dest_y_org})
Copies the contents of @var{src_bitmap} to the receiver's drawing surface.
The source dimensions are determined by @var{src_x_org}, @var{src_y_org},
@var{src_width}, and @var{src_height}.  The method draws the source 
bitmap's contents with the source's upper left-hand corner at @var{dest_x_org},
@var{dest_y_org}.

The @code{X11Bitmap's} parent drawable must be the receiver's drawable
surface, and the color depths of the source and destination must match.

The process is similar to the @mnm{refresh} method, below, so programs
do not need to call both @mnm{copy} and @mnm{refresh} for the same operation.

This slightly abbreviated example program is included in the Ctalk
package at test/expect/examples-x11/canvas-copy.c as well as the XPM
graphic, but almost any XPM should work as well.

@example
#include "coffee-cup.xpm"

/* 
   Set these to the width and height of your pixmap,
   and edit the pixmapFromData expression below to
   the xpm's declaration name. 
*/
#define XPM_WIDTH 127
#define XPM_HEIGHT 141

X11CanvasPane instanceMethod drawXPMs (X11Bitmap xpmBitmap) @{
  Integer new i;

  for (i = 0; i < 5; i++) @{
    self copy xpmBitmap, 0, 0, XPM_WIDTH, XPM_HEIGHT, (i* 40), (i * 40);
  @}

  self refresh;
@}

int main () @{
  X11Pane new xPane;
  InputEvent new e;
  X11PaneDispatcher new xTopLevelPane;
  X11CanvasPane new xCanvasPane;
  Application new paneApp;
  X11Bitmap new srcBitmap;

  paneApp enableExceptionTrace;
  paneApp installExitHandlerBasic;

  xPane initialize 10, 10, 300, 300;
  xTopLevelPane attachTo xPane;
  xCanvasPane attachTo xTopLevelPane;

  srcBitmap create xCanvasPane xWindowID, XPM_WIDTH, XPM_HEIGHT, 
    xCanvasPane depth;

  xPane map;
  xPane raiseWindow;
  xPane openEventStream;

  xCanvasPane background "white";

  srcBitmap pixmapFromData (0, 0, coffee_cup);

  xCanvasPane drawXPMs srcBitmap;

  while (TRUE) @{
    xPane inputStream queueInput;
    if (xPane inputStream eventPending) @{
      e become xPane inputStream inputQueue unshift;
      /* We don't have to use, "xPane subPaneNotify e" here, because
         the program doesn't need to handle any X events for the
         graphics classes. */
      switch (e eventClass value)
        @{
        case WINDELETE:
          xPane deleteAndClose;
          exit (0);
          break;
        case EXPOSE:
        case RESIZENOTIFY:
	  xCanvasPane drawXPMs srcBitmap;
          break;
        default:
          break;
        @}
    @}
    usleep (100000);
  @}
@}

@end example

@emph{Note:} The @mnm{copy} method retrieves the @code{paneBuffer}
instance variable.  If you use an expresion like the following,
then the program calls the @code{X11Bitmap : copy} method instead.
@xref{X11Bitmap}.

@example

  myRcvrPane paneBuffer copy ...

@end example


@cindex @mnm{defineRegion} instance method @idxclscite{X11CanvasPane}
@item @mnm{defineRegion} (@code{String} @var{regionName}, @code{Integer} @var{xOrg}, @code{Integer} @var{yOrg}, @code{Integer} @var{xSize}, @code{Integer} @var{ySize})
Define a rectangular region with name @var{regionName} with the upper
left-hand corner at @var{xOrg}, @var{yOrg} relative to the upper left-hand
corner of the canvas. The region has the width @var{xSize} and height 
@var{ySize}.  When handling input events, the window system clips the
region to the canvas' viewable area.

@cindex @mnm{drawCircle} instance method @idxclscite{X11CanvasPane}
@item @mnm{drawCircle} (@code{Circle} @var{aCircle}, @code{Integer} @var{filled}, @code{String} @var{bgColor})
@item @mnm{drawCircle} (@code{Circle} @var{aCircle}, @code{Pen} @var{aPen}, @code{Integer} @var{filled}, @code{String} @var{bgColor})
Draw the circle defined by @var{aCircle} in the receiver's paneBuffer.
If @var{filled} is true, draws a filled circle.  If the @var{aPen}
argument is given, draws the circle with the color and the line width
defined by the @code{Pen}, and fills the interior of the circle with
@var{bgColor}.

For an example program, refer to the @code{Circle} section of this
manual. @xref{Circle}.

@cindex @mnm{drawPoint} instance method @idxclscite{X11CanvasPane}
@item @mnm{drawPoint} (@code{Intger} @var{x}, @code{Integer} @var{y})
Draw a dot on the pane's window at the x and y coordinates
given by the arguments.

@cindex @mnm{drawLine} instance method @idxclscite{X11CanvasPane}
@item @mnm{drawLine} (@code{Line} @var{aLine})
@item @mnm{drawLine} (@code{Line} @var{aLine}, @code{Pen} @var{aPen})
@item @mnm{drawLine} (@code{Intger} @var{startX}, @code{Integer} @var{startY}, @code{Integer} @var{endX}, @code{Integer} @var{endY})
@item @mnm{drawLine} (@code{Intger} @var{startX}, @code{Integer} @var{startY}, @code{Integer} @var{endX}, @code{Integer} @var{endY}, @code{pen} @var{aPen})
With one argument, a @code{Line} object, draws the line using the receiver's
@code{Pen} instance variable. With two arguments, draws the @code{Line} object
with the color and line width given by @var{aPen}.

If given the line's endpoints as arguments, the method draws a line on
the pane's window from the point given by the @var{startX} and
@var{startY} arguments to the point given by the @var{endX} and
@var{endY} arguments, with the color and the line width given
by the receiver's @code{Pen} object.

@cindex @mnm{drawFilledRectangle} instance method @idxclscite{X11CanvasPane}
@item @mnm{drawLine} (@code{Intger} @var{xOrg}, @code{Integer} @var{yOrg}, @code{Integer} @var{xSize}, @code{Integer} @var{ySize})
Draw a filled rectangle on the pane's window with the upper-left
hand corner at the point given by the @var{xOrg} and
@var{yOrg} arguments, with the width @var{xSize} and the
height @var{ySize}.  If a @code{Pen} argument isn't given, uses the
line width and color defined by the receiver's @code{pen} instance
variable; otherwise uses the line width and color defined by the
@code{Pen} argument.

@cindex @mnm{drawRoundedRectangle} instance method @idxclscite{X11CanvasPane}
@item @mnm{drawRoundedRectangle} (@code{Intger} @var{xOrg}, @code{Integer} @var{yOrg}, @code{Integer} @var{xSize}, @code{Integer} @var{ySize}, @code{Integer} @var{radius})
Similar to @mnm{drawFilledRectangle}, but this method takes an extra
argument, the radius of the corner arcs that round the rendered rectangle's
corners.

@cindex @mnm{drawRectangle} instance method @idxclscite{X11CanvasPane}
@item @mnm{drawRectangle} (@code{Intger} @var{xOrg}, @code{Integer} @var{yOrg}, @code{Integer} @var{xSize}, @code{Integer} @var{ySize})
Draw the borders of a rectangle on the pane's window with
the upper-left hand corner at the point given by the
@var{xOrg} and @var{yOrg} arguments, with the width
@var{xSize} and the height @var{ySize}.

@cindex @mnm{drawRoundedRectangle} instance method @idxclscite{X11CanvasPane}
@item @mnm{drawRoundedRectangle} (@code{Intger} @var{xOrg}, @code{Integer} @var{yOrg}, @code{Integer} @var{xSize}, @code{Integer} @var{ySize}, @code{Integer} @var{radius})
This method is similar to @mnm{drawRectangle}, except that it takes an
extra argument, @var{radius}, which specifies the radius of the arcs
that form the rectangle's corners.

@cindex @mnm{directCopy} instance method @idxclscite{X11CanvasPane}
@item @mnm{directCopy} (@code{X11Bitmap} @var{src_bitmap}, @code{Integer} @var{src_x_ort}, @code{Integer} @var{src_y_org}, @code{Integer} @var{src_width}, @code{Integer} @var{src_height}, @code{Integer} @var{dest_x_org}, @code{Integer} @var{dest_y_org})
Similar to the @mnm{copy} method, above, except @mnm{directCopy}
copies the @code{X11Bitmap} object given as its argument directly
to the window.  This might be quicker, and doesn't require that
the program call @mnm{refresh} (below) to update the window
contents, but this method may also cause flickering when the
window is updated. 

@cindex @mnm{foreground} instance method @idxclscite{X11CanvasPane}
@item @mnm{foreground} (@code{String} @var{color})
Set the background of the pane to @var{color}.
See the note for
@code{X11Bitmap} class's @mnm{background} method.
@xref{X11Bitmap}.

@cindex @mnm{new} instance method @idxclscite{X11CanvasPane}
@item @mnm{new} (@code{String} @var{pane_name})
Create a new @code{X11CanvasPane} instance and initialize
its event handlers.

If the argument list contains more than one label, create
a new @code{X11CanvasPane} object with the names given by
the arguments; for example,

@example

X11CanvasPane new pane1, pane2, pane3;

@end example

@anchor{X11CanvasPane_pixmapFromData}
@cindex @mnm{pixmapFromData} instance method @idxclscite{X11CanvasPane}
@item @mnm{pixmapFromData} (@code{int} @var{x_org}, @code{int} @var{y_org}, @code{char *}@var{xpm_data}@var{[]}) 
Draw the X pixmap defined by @var{xpm_data} with the upper left 
corner at @var{x_org},@var{y_org} on the receiver's pane.

The @var{xpm_data} argument is the name of the array declared at the 
start of a @flnm{xpm} file's data array.

@cindex @mnm{refresh} instance method @idxclscite{X11CanvasPane}
@item @mnm{refresh} (@code{void})
Redraw the pane on the main window.

@cindex @mnm{refreshReframe} instance method @idxclscite{X11CanvasPane}
@item @mnm{refreshReframe} (@code{void})
Redraw the pane on the main window.  If the user has moved the pane
by clicking and dragging on it, then reposition the pane within the window.

@cindex @mnm{putStrXY} instance method @idxclscite{X11CanvasPane}
@item @mnm{putStrXY} (@code{Integer} @var{xOrg}, @code{Integer} @var{yOrg} @code{String} @var{text})
@item @mnm{putStrXY} (@code{Integer} @var{xOrg}, @code{Integer} @var{yOrg} @code{String} @var{text}, @code{String} @var{font_desc})
@item @mnm{putStrXY} (@code{Integer} @var{xOrg}, @code{Integer} @var{yOrg} @code{String} @var{text}, @code{String} @var{font_desc}, @code{String} @var{color_name}))
Write @var{text} on the receiver pane's drawing surface (usually a X11Bitmap)
at position @var{xOrg},@var{yOrg}.  @xref{X11Bitmap}.

If the fourth argument is @var{font_desc}, the method draws the text
using that font.  If a @var{color_name} argument is also given, draws
the text using that color.

@cindex @mnm{subPaneDestroy} instance method @idxclscite{X11CanvasPane}
@item @mnm{subPaneDestroy} (@code{Object} @var{subPaneRef}, @code{InputEvent} @var{event})
Deletes the pane's window and its data when the user closes the 
pane's window.

@cindex @mnm{subPaneExpose} instance method @idxclscite{X11CanvasPane}
@item @mnm{subPaneExpose} (@code{Object} @var{subPaneRef}, @code{InputEvent} @var{event})
Redraws the pane's window whenever it is mapped or displayed after
being covered by another window.

@cindex @mnm{subPanePointerInput} instance method @idxclscite{X11CanvasPane}
@item @mnm{subPanePointerInput} (@code{Object} @var{subPaneRef}, @code{InputEvent} @var{event})
Default handler for mouse ButtonPress and ButtonRelease events.  This
method is a no-op here, but it can be re-implemented if necessary by
subclasses.  The application receives pointer events, like all other
events, via the top-level window's @code{inputStream} (a
@code{X11TerminalStream} object).

@cindex @mnm{subPaneResize} instance method @idxclscite{X11CanvasPane}
@item @mnm{subPaneResize} (@code{Object} @var{subPaneRef}, @code{InputEvent} @var{event})
The handler for Resize events from the X display.  Resizes the pane's 
X window and adjusts the pane's dimensions.
@end table

@node X11ButtonPane, X11LabelPane, X11CanvasPane, Classes
@iftex
@section @code{X11ButtonPane} Class
@end iftex
@ifnottex
@subheading @code{X11ButtonPane} Class
@end ifnottex
@cindex @code{X11ButtonPane} class

The @code{X11ButtonPane} class defines instance variables and methods
that draw buttons on X windows.  The buttons' appearance is defined
by the values in the instance variables, and they may be used to define
the format of customized buttons and labels.

The definitions of the @code{X11ButtonPane's} instance variables'
define the parameters for basic buttons with beveled and non-beveled
edges, and the buttons' text is contained in a @code{X11LabelPane}
object, which defines the appreance of a button's text.

Here is a brief example program.

@c demos/x11/buttons.ca
@example

/* buttons.ca - X11ButtonPane Demonstration */

#include <ctalk/ctalkdefs.h>

/* Uncomment this #define to use X bitmap fonts. */
/* #define XFONTS */

/* Also, uncomment this to draw a multiline label. */
/* #define MULTILINE */

/* Define CORNER_RADIUS > 0 for rounded corners (non-beveled, too). 
   The value is the radius of the corner arcs. */
#define CORNER_RADIUS 0

/* See the X11FreeTypeFont section of the the Ctalk reference. */
#define FTFONT_BOLD   200
#define FTFONT_MEDIUM 100

int main (void) @{
  X11Pane new mainWindow;
  X11PaneDispatcher new dispatcher;
  X11ButtonPane new lbutton;
  X11ButtonPane new rbutton;
  X11LabelPane new label;
  InputEvent new e;

  mainWindow backgroundColor = "blue";
  lbutton backgroundColor = "blue";
  rbutton backgroundColor = "blue";
  label backgroundColor = "blue";
  label textColor = "white";
  label canFocus = false;
  label borderWidth = 0;

  mainWindow initialize 255, 200;
  mainWindow inputStream eventMask = 
    EXPOSE|ENTERWINDOWNOTIFY|LEAVEWINDOWNOTIFY|BUTTONPRESS|BUTTONRELEASE|KEYPRESS|KEYRELEASE;
  dispatcher attachTo mainWindow;
  lbutton attachTo dispatcher, "90x50+25+100";
  rbutton attachTo dispatcher, "90x50+135+100";
  label attachTo dispatcher, "147x80+44+15";

  mainWindow map;
  mainWindow raiseWindow;

  mainWindow openEventStream;

  mainWindow setWMTitle "X11ButtonPane Demo";

#ifndef XFONTS
  /*
   * This is the recommended way to set up fonts for each widget.
   */
  label ftFontVar initFontLib;
  label ftFont "DejaVu Sans", 0, FTFONT_BOLD, 0, 12.0;
  label ftFontVar saveSelectedFont;
  lbutton ftFont "DejaVu Sans", 0, FTFONT_MEDIUM, 0, 10.0;
  lbutton ftFontVar saveSelectedFont;
  rbutton ftFont "DejaVu Sans", 0, FTFONT_MEDIUM, 0, 10.0;
  rbutton ftFontVar saveSelectedFont;
#else
  lbutton label font "fixed";
#endif  

  label multiLine "X11ButtonPane\nDemo";

#ifndef MULTILINE
  lbutton label text "Left";
  rbutton label text "Right";
#else
  lbutton label multiLine "Click\nHere";
  rbutton label multiLine "Click\nHere, Too";
#endif

#if CORNER_RADIUS > 0
  lbutton bevelEdges = false;
  lbutton radius = CORNER_RADIUS;
  lbutton label radius = CORNER_RADIUS;
  rbutton bevelEdges = false;
  rbutton radius = CORNER_RADIUS;
  rbutton label radius = CORNER_RADIUS;
#endif  

  lbutton label highlightBackgroundColor = "gray90";
  rbutton label highlightBackgroundColor = "gray90";

  lbutton label highlightTextColor = "gray";
  rbutton label highlightTextColor = "gray";

  lbutton draw;
  lbutton refresh;
  rbutton draw;
  rbutton refresh;
  label draw;
  label refresh;

  while (TRUE) @{
    mainWindow inputStream queueInput;
    if (mainWindow inputStream eventPending) @{
      e become mainWindow inputStream inputQueue unshift;

      mainWindow subPaneNotify e;

      switch (e eventClass value)
	@{
	case EXPOSE:
	  lbutton subPaneExpose (lbutton, e);
	  rbutton subPaneExpose (rbutton, e);
	  label subPaneExpose (label, e);
	  break;
	default:
	  if (lbutton haveClick) @{
	    printf ("left button!\n");
	    lbutton clearClick;
	  @} else if (rbutton haveClick) @{
	    printf ("right button!\n");
	    rbutton clearClick;
	  @}
	  break;
	@}
    @} else @{
      usleep (1000);
    @}
  @}

@}

@end example

@subsubheading Retrieving Button States

The @code{X11ButtonPane} class provides several methods to
retrieve the state of a button object.  

@table @code

@item haveClick
Returns true or false depending on whether the button has
been clicked recently.  This means that programs do not
need to constantly monitor a button's state.  If @mnm{haveClick}
returns true, then the click state can be cleared with the
@mnm{clearClick} method (below).

@item isClicked
This method returns true or false depending on whether the
pointer's button 1 is currently pressed within the button's
area.

@item clearClick
Resets a previous clicked state as returned by the @mnm{haveClick}
method, above.

@item text
Returns a @code{String} with the button's text.  If the text is
displayed on several lines, the method concatenates the lines with
a space character @samp{' '} between them.

@end table


@subsubheading Instance Variables

@table @code

@cindex @code{bevelEdges} instance variable @idxclscite{X11ButtonPane}
@item bevelEdges
A @code{Boolean} that causes the widget to display beveled edges
if true.

@cindex @code{bevelWidth} instance variable @idxclscite{X11ButtonPane}
@item bevelWidth
An @code{Integer} that defines the width of the button's bevelled
edges in pixels.

@cindex @code{borderColor} instance variable @idxclscite{X11ButtonPane}
@item borderColor
A @code{String} that contains the name of the button's border color when
drawing a non-beveled button.

@cindex @code{borderMargin} instance variable @idxclscite{X11ButtonPane}
@item borderMargin
An @code{Integer} that defines the distance between the border and the
pane's edge in pixels, when drawing a non-beveled button.

@cindex @code{borderWidth} instance variable @idxclscite{X11ButtonPane}
@cindex @code{borderHighlightWidth} instance variable @idxclscite{X11ButtonPane}
@item borderWidth
@item borderHighlighWidth
@code{Integer} values that determine the width a non-beveled button when it is clicked on and in its non-highlighted state.

@cindex @code{clicked} instance variable @idxclscite{X11ButtonPane}
@item clicked
A @code{Boolean} that is true when the pointer's Button 1 is
pressed while over the widget, and false otherwise.

@cindex @code{highlightHPen} instance variable @idxclscite{X11ButtonPane}
@cindex @code{highlightVPen} instance variable @idxclscite{X11ButtonPane}
@cindex @code{shadowPen} instance variable @idxclscite{X11ButtonPane}
@item highlightHPen
@item highlightVPen
@item shadowPen
@code{Pen} objects that defines the color of the edges' bevels
when drawing a beveled widget.

@cindex @code{label} instance variable @idxclscite{X11ButtonPane}
@item label
A @code{X11LabelPane} object that contains a button's text
and provides the methods to draw on the button's surface.
@xref{X11LabelPane}.

@cindex @code{radius} instance variable @idxclscite{X11ButtonPane}
@item radius
If greater than zero (@samp{0}), this @code{Integer} defines the
radius in pixels of the curves displayed when the button is drawn
with rounded corners.

@end table

@subsubheading Instance Methods

@table @code

@cindex @code{attachTo} instance method @idxclscite{X11ButtonPane}
@item attachTo (@code{Object} @var{parentPane}, @code{String} @var{geometry})
Attaches the receiver to the parentPane named by @var{parentPane},
with the placement and size given by @code{geometry}.  The parent pane
should generally be a @code{X11PaneDispatcher} which directs X events
to the correct subpane.

The positioning of subwindows within the parent window is controlled
by the arguments to the @mnm{attachTo} methods; in particular, these
methods accept a geometry specification, as an argument, which has
the following format.

@example

width[%]xheight[%]+x[%]+y[%]

@end example

If a dimension does not contain a percent (@samp{%}) sign, the dimensions
are in pixels.  With a percent sign, the dimensions are a fractional
percentage of the parent pane's width or height, or a horizontal or
vertical distance that places the subwindow's upper left-hand corner
that distance from the parent window's upper left-hand corner.

@cindex @code{clearClick} instance method @idxclscite{X11ButtonPane}
@item clearClick (@code{void})
Resets a button's clicked state as returned by @mnm{haveClick} to
false.

@cindex @code{draw} instance method @idxclscite{X11ButtonPane}
@item draw (@code{void})
Draws the button and its label on the pane's buffer so the
widget can be displayed with the refresh method.

If the program has saved a font specification to the widget's
@code{ftFontVar} instance variable, then this method also selects
the font before drawing the widget.  If you want a button to display
a different font than the surronding window, this is the way to
declare and save a font specification.

@example

/* The button inherits the ftFont method from X11Pane class. */

button ftFont "DejaVu Sans", FTFONT_ROMAN, FTFONT_MEDIUM, DEFAULT_DPI, 10.0;
button ftFontVar saveSelectedFont;

@end example

The @code{X11FreeTypeFont} section describes the parameters that
the @code{X11FreeTypeFont} class uses when selecting fonts. @xref{X11FreeTypeFont}.

@cindex @code{haveClick} instance method @idxclscite{X11ButtonPane}
@item haveClicked (@code{void})
Returns a @code{Boolean} true or false depending on whether the
button has been clicked previously.  In that case, the program
should call the @mnm{clearClick} method to detect further
button clicks.

@cindex @code{isClicked} instance method @idxclscite{X11ButtonPane}
@item isClicked (@code{void})
Returns a @code{Boolean} value of true or false depending on
whether the pointer's button 1 is currently pressed within the
button. 

@cindex @code{new} instance method @idxclscite{X11ButtonPane}
@item new (@code{String} @var{newObjectName})
The @code{X11ButtonPane} constructor.  Creates a @code{X11ButtonPane}
object with the classes' instance variables, and initialized the
object's event handlers and @code{Pen} objects for drawing a beveled
button.

@cindex @code{subPaneExpose} instance method @idxclscite{X11ButtonPane}
@item subPaneExpose (@code{Object} @var{subPane}, @code{InputEvent} @var{event})
@cindex @code{subPaneButtonPress} instance method @idxclscite{X11ButtonPane}
@item subPaneButtonPress (@code{Object} @var{subPane}, @code{InputEvent} @var{event})
@cindex @code{subPaneEnter} instance method @idxclscite{X11ButtonPane}
@item subPaneEnter (@code{Object} @var{subPane}, @code{InputEvent} @var{event})
@cindex @code{subPaneLeave} instance method @idxclscite{X11ButtonPane}
@item subPaneLeave (@code{Object} @var{subPane}, @code{InputEvent} @var{event})
The class's handlers for events generated by the X server.

@cindex @code{subPaneFocusIn} instance method @idxclscite{X11ButtonPane}
@cindex @code{subPaneFocusOut} instance method @idxclscite{X11ButtonPane}
@item subPaneFocusIn (@code{void})
@item subPaneFocusOut (@code{void})
Handlers for focus changes generated by the application.  These do not
respond to X events and don't require any arguments. These methods are
designed to be called by methods like @code{X11PaneDispatcher :
shiftFocus} (e.g., in response to a @key{Tab} keypress).

@cindex @code{text} instance method @idxclscite{X11ButtonPane}
@item text (@code{void})
Returns a @code{String} with the button's text.  If the text is
displayed on multiple lines, this method concatenates the lines
with a space character (@samp{ }) between them.

@end table


@node X11LabelPane, X11MessageBoxPane, X11ButtonPane, Classes
@iftex
@section @code{X11LabelPane} Class
@end iftex
@ifnottex
@subheading @code{X11LabelPane} Class
@end ifnottex
@cindex @code{X11LabelPane} class

@code{X11LabelPane} objects display text in graphical windows.  The
class provides instance variables and methods that control the label's
font, border, justification, whether the label is highlighted when the
pointer is over it, and formatting of single and multiple line labels.

Formatting label text for multiple line labels, as well as controlling
the text's justification, is described in the subsections below.

Here is a simple example program that displays a X11LabelPane widget.

@c test/expect/examples-x11/x11labelpane.ca
@example

#include <ctalk/ctalkdefs.h>

#define FTFONTS    /* Comment this line out to use X fonts. */
#define MULTILINE  /* Comment out to display a single line label. */
#define ROUNDED    /* Comment out to draw borders with straight edges. */

int main (int argv, char **argc) @{
  X11Pane new xPane;
  X11PaneDispatcher new xTopLevelPane;
  X11CanvasPane new xCanvasPane;
  X11LabelPane new xLabelPane;
  InputEvent new e;
  Integer new verbose;
  Exception new ex;

#ifdef FTFONTS 
  xPane ftFontVar initFontLib;
#endif       

  xPane initialize 0, 0, 300, 300;
  xPane inputStream eventMask =
    WINDELETE|EXPOSE|ENTERWINDOWNOTIFY|LEAVEWINDOWNOTIFY;
  xTopLevelPane attachTo xPane;
  xLabelPane attachTo xTopLevelPane, "100x100+25+50";
  xPane map;
  xPane raiseWindow;

  xPane openEventStream;

#ifdef FTFONTS
  xLabelPane ftFont "DejaVu Sans", 0, 0, 72, 11.0;
#else
  xLabelPane font "-*-helvetica-medium-r-*-*-*-80-*-*-*-*-*-*";
#endif       
  xLabelPane textColor = "navyblue";

#ifdef MULTILINE
  xLabelPane multiLine "Labels\ncan occupy\nmultiple\nlines.";
#else
  xLabelPane text "A Label";
#endif

#ifdef ROUNDED
  xLabelPane radius = 10;
#endif  

  xLabelPane draw;
  
  while (TRUE) @{
    xPane inputStream queueInput;
    if (xPane inputStream eventPending) @{
      e become xPane inputStream inputQueue unshift;
      xPane subPaneNotify e;  /* Call the classes' event handlers. */
      if (ex pending)
	ex handle;
      
      switch (e eventClass value)
     	@{
     	case WINDELETE:
      	  xPane deleteAndClose;
     	  exit (0);
     	  break;
     	default:
     	  break;
     	@}
    @}
  @}
@}


@end example

@subsubheading Multiple Line Labels

If the label's text contains embedded newline @samp{\n} characters,
and the text is defined using the @mnm{multiLine} method, below, then
the text is display on multiple lines, with the breaks appearing where
the newline characters appear in the text.  The text is displayed
centered vertically, and justified as described in the next section.

For single line labels, use the @mnm{text} method with a @code{String}
argument to fit on one line.

@subsubheading Justification

The @code{X11LabelPane} widget contains a simple layout engine that can
center label text, or justify it against the right or left margins.

The text's justification is determined by the setting of the
@code{justification} instance variable, which can have one of three
values, which are defined by the following macros:

@example

LABEL_LEFT
LABEL_RIGHT
LABEL_CENTER

@end example

These macros are defined in the @flnm{ctalk/ctalkdefs.h} include file.
To use them, add the line

@example

#include <ctalk/ctalkdefs.h>

@end example

to the beginning of the source module.

The widget calculates the right and left margins as the following:

@example

(aLabel margin) + (aLabel highlightBorderWidth) + (aLabel padding)

@end example

The highlighted border width is included regardless of whether the
border actually is drawn or the label is hightlighted, so text
alignment remains constant if a program draws and then obscures the
border, or when the pointer passes over the label.


@subsubheading Instance Variables

@table @code
@cindex @code{border} instance variable @idxclscite{X11LabelPane}
@item border
A @code{Boolean} that controls whether the label displays a border.
The default is @samp{true}.

@cindex @code{borderColor} instance variable @idxclscite{X11LabelPane}
@item borderColor
A @code{String} that contains the name of the border's color if the
label displays a border.  The default is @samp{black}.

@cindex @code{borderWidth} instance variable @idxclscite{X11LabelPane}
@item borderWidth
An @code{Integer} that defines the width of the border in pixels when
the widget is not highlighted.  The default is @samp{2}.

@cindex @code{grayed} instance variable @idxclscite{X11LabelPane}
@item grayed
A @code{Boolean} that determines whether to draw the widget in a
grayed, or inactive, state.  The state has no other effect for a
@code{X11LabelPane} object.  It can indicate the state of other
controls in the window.  The default is @code{false}.

@cindex @code{grayedColor} instance variable @idxclscite{X11LabelPane}
@item grayedColor
A @code{String} that contains the name of the color to draw the widget
when it is grayed. The default is is @samp{gray}.

@cindex @code{haveMultiLine} instance variable @idxclscite{X11LabelPane}
@item haveMultiLine
A @code{Boolean} that indicates whether the widget's text is defined
using the @mnm{multiLine} method, and indicates that the widget should
format the label's text to span multiple lines.

@cindex @code{highlightBorderColor} instance variable @idxclscite{X11LabelPane}
@item highlightBackgroundColor
A @code{String} that contains the color to draw a highlighted label's
background.

@cindex @code{highlightBorderColor} instance variable @idxclscite{X11LabelPane}
@item highlightBorderColor
A @code{String} that contain's the name of a highlighed border's
color.  The default is @samp{black}.

@cindex @code{highlightBorderWidth} instance variable @idxclscite{X11LabelPane}
@item highlightBorderWidth
An @code{Integer} that determines the width in pixels of the label's
border when the widget is highlighed.  The default is two pixels.

@cindex @code{highlighTextBold} instance variable @idxclscite{X11LabelPane}
@item highlightTextBold
A @code{Boolean} that indicates whether the widget should draw a
highlighted widget's text using a bold typeface.  The default is
@code{false}.

This variable has no effect when using X11 bitmap fonts.
@cindex @code{highlightTextColor} instance variable @idxclscite{X11LabelPane}

@item highlightTextColor
A @code{String} that contains the name of the text color when the widget
is drawn highlighted.  The default is @samp{black}.

@cindex @code{justify} instance variable @idxclscite{X11LabelPane}
@item justify
An @code{Integer} that determines whether to draw the label's text
centered horizontally, or justified on the right or left margins.

This variable recognizes three values, which are #defines in the
@flnm{ctalk/ctalkdefs.h} include file.  The definitions are:

@example

LABEL_LEFT
LABEL_CENTER
LABEL_RIGHT

@end example

To use these macros, add the statement

@example

#include <ctalk/ctalkdefs.h>

@end example

near the top of the source module.

@cindex @code{leading} instance variable @idxclscite{X11LabelPane}
@item leading
An @code{Integer} that defines the space between lines of a multi-line
label.  This variable only affects text drawn using scalable fonts of
the Freetype library.  X11 bitmap fonts contain the leading in the
character glyphs.

@cindex @code{margin} instance variable @idxclscite{X11LabelPane}
@item margin
An @code{Integer} that defines the distance in pixels between the
border and the edges of the @code{X11LabelPane} object.

@cindex @code{padding} instance variable @idxclscite{X11LabelPane}
@item padding
An @code{Integer} that defines the minimum distance in pixels between the
inner edge of the border and the pane object's text.

@cindex @code{radius} instance variable @idxclscite{X11LabelPane}
@item radius
An @code{Integer} that describes the radius to round the corners
of the border with.  If the value is @samp{0} (the default), then
draw borders with straight edges.

@cindex @code{textColor} instance variable @idxclscite{X11LabelPane}
@item textColor
A @code{String} that defines the name of the text color when the
widget is not highlighted.  The default is @samp{black}.

@cindex @code{textLine} instance variable @idxclscite{X11LabelPane}
@item textLine
A @code{String} that contains the label's text if the text is to
appear on a single line.  The default is an empty string.

@cindex @code{textLines} instance variable @idxclscite{X11LabelPane}
@item textLines
An @code{Array} that contains a multi-line widget's text, as set using
the @mnm{multiLine} method.

@end table

@subsubsection Instance Methods

@table @code

@cindex @code{draw} instance method @idxclscite{X11LabelPane}
@cindex @code{drawButtonLayout} instance method @idxclscite{X11LabelPane}
@item draw (@code{void})
@item drawButtonLayout (@code{void})
Draws the text of the label, and updates the visible label on the
display.  The instance variables in this class and the text font's
class allow programs to adjust how the text is laid out.

The @mnm{drawButtonLayout} method is similar, but it uses a different
algorithm that is more suited to laying out text on button labels.

If the widget has saved a font specification to its @code{ftFontVar}
instance variable, then this method also selects the font before
drawing the label.  If you want a label to have a different font
than the rest of the window, this is how to declare and save
a font specification.

@example

/* The label inherits the ftFont method from X11Pane class. */

label ftFont "DejaVu Sans", FTFONT_ROMAN, FTFONT_MEDIUM, DEFAULT_DPI, 10.0;
label ftFontVar saveSelectedFont;

@end example

The @code{X11FreeTypeFont} section describes the parameters that
the @code{X11FreeTypeFont} class uses when selecting fonts. @xref{X11FreeTypeFont}.

@cindex @code{new} instance method @idxclscite{X11LabelPane}
@item new
Creates a new @code{X11LabelPane} object, initializes the object's
instance variables and event handlers, and sets the pane's default
foreground and background colors.

@cindex @code{subPaneExpose} instance method @idxclscite{X11LabelPane}
@item subPaneExpose (@code{Object} @var{subPane}, @code{InputEvent} @var{event})
The widget's Expose event handler.  When the widget receives an Expose
event, this method redraws the widget.

@cindex @code{subPaneEnter} instance method @idxclscite{X11LabelPane}
@item subPaneEnter (@code{Object} @var{subPane}, @code{InputEvent} @var{event})
@cindex @code{subPaneLeave} instance method @idxclscite{X11LabelPane}
@item subPaneLeave (@code{Object} @var{subPane}, @code{InputEvent} @var{event})
The widget's EnterNotify and LeaveNotify event handlers.  These
methods set the @code{subPane's} @code{highlight} instance variable to
true or false (if the widget is configured to accept input focus),
then calls the @mnm{draw} method to redraw the label.

@cindex @code{font} instance method @idxclscite{X11LabelPane}
@item font (@code{String} @var{fontdesc})
Sets the X11 font to use for the label's text.  When drawing using
Freetype scalable fonts, the widget uses the @mnm{ftFont} method from
@code{X11CanvasPane}.

@cindex @code{text} instance method @idxclscite{X11LabelPane}
@item text (@code{String} @var{labelText})
Sets the text of a single-line label.

@cindex @code{text} instance method @idxclscite{X11LabelPane}
@item text (@code{String} @var{labelText})
Sets the receiver's @code{textLine} instance variable for single-line
labels.

@cindex @code{multiText} instance method @idxclscite{X11LabelPane}
@item multiText (@code{String} @var{labelText})
Divides the text given as the argument into lines where newline
characters @samp{\n} appear in the text, and sets the elements of the
receiver's @code{textLine} instance variable to one line for each
array element.  Also sets the @code{haveMultiLine} instance variable
to @code{true}.

@end table

@node X11MessageBoxPane, X11ScrollBarPane, X11LabelPane, Classes
@iftex
@section @code{X11MessageBoxPane} Class
@end iftex
@ifnottex
@subheading @code{X11MessageBoxPane} Class
@end ifnottex
@cindex @code{X11MessageBoxPane} class

A @code{X11MessageBoxPane} object displays a popup window that
contains a text message and a button that closes the window.

The button's text is displayed by a @code{X11LabelPane} object,
and the button is a @code{X11ButtonObject}.  Generally,
@code{X11MessageBoxPane} objects override any input to the
program that opened them, so they contain their own event
loop, in the @code{show} method.

Here is an example of a program that creates its own
@code{X11MessageBoxPane} object, and then opens it when
the user clicks on the main window's button.

@c demos/x11/messagebox.ca
@example

#include <ctalk/ctalkdefs.h>

/* See the X11FreeTypeFont section of the the Ctalk reference. */
#define FTFONT_BOLD   200
#define FTFONT_MEDIUM 100

int main (void) @{
  X11Pane new mainWindow;
  X11PaneDispatcher new dispatcher;
  X11ButtonPane new button;
  X11LabelPane new label;
  X11MessageBoxPane new messageBox;
  InputEvent new e;

  mainWindow backgroundColor = "blue";
  button backgroundColor = "blue";
  label backgroundColor = "blue";
  label textColor = "white";
  label canFocus = false;
  label borderWidth = 0;

  mainWindow initialize 255, 200;
  mainWindow inputStream eventMask = 
    EXPOSE|ENTERWINDOWNOTIFY|LEAVEWINDOWNOTIFY|BUTTONPRESS|BUTTONRELEASE|KEYPRESS|KEYRELEASE;

    messageBox foreground "red";
   messageBox background "red";
   /* messageBox backgroundColor = "red"; */
    
  dispatcher attachTo mainWindow;
  button attachTo dispatcher, "110x50+73+100";
  label attachTo dispatcher, "177x80+34+15";
  messageBox attachTo dispatcher, "300x200+30+30";

  mainWindow map;
  mainWindow raiseWindow;

  mainWindow openEventStream;

  mainWindow setWMTitle "X11MessageBoxPane Demo";

  label ftFontVar initFontLib;
  label ftFont "DejaVu Sans", 0, FTFONT_BOLD, 0, 12.0;
  label ftFontVar saveSelectedFont;
  button ftFont "DejaVu Sans", 0, FTFONT_MEDIUM, 0, 10.0;
  button ftFontVar saveSelectedFont;

  label multiLine "X11MessageBoxPane\nDemo";

  button label multiLine "Open\nMessageBox";

  button label highlightBackgroundColor = "gray90";

  button draw;
  button refresh;
  label draw;
  label refresh;

  /* The program uses the "replaceAt" method because the key/value
     entry for "backgroundColor" the X11MessageBoxPane : new method
     has alread created an entry for backgroundColor. */
     messageBox resources replaceAt "backgroundColor", "blue";

  while (TRUE) @{
    mainWindow inputStream queueInput;
    if (mainWindow inputStream eventPending) @{
      e become mainWindow inputStream inputQueue unshift;

      mainWindow subPaneNotify e;

      switch (e eventClass value)
	@{
	case EXPOSE:
	  button subPaneExpose (button, e);
	  label subPaneExpose (label, e);
	  break;
	case BUTTONPRESS:
	  if (button haveClick) @{
	    button clearClick;
	    button draw;
	    button refresh;
	    messageBox show;
	  @}
	  break;
	@}
    @} else @{
      usleep (1000);
    @}
  @}

@}

@end example

@subsubheading Instance Variables

@table @code

@cindex @code{button} instance variable @idxclscite{X11MessageBoxPane}
@item button
A @code{X11ButtonPane} object that closes the window when clicked.
The button's default text is, @samp{Ok}.  Programs can change
the text with a statement like the following, which changes the
button's text to, @samp{Close}.

@example

myMessageBox resources atPut "buttonText", "Close";

@end example

@cindex @code{initialized} instance variable @idxclscite{X11MessageBoxPane}
@item initialized
A @code{Boolean} that is @code{true} if the pane has already been initialized.
When a message box is closed, it is not deleted - it is simply unmapped
from the window.  This variable is set to true sot that the message box is
initialized only once.

@cindex @code{label} instance variable @idxclscite{X11MessageBoxPane}
@item label
A @code{X11LabelPane} that displays the message box's text.  As
configured, the label is the same color as the main message box window,
and uses no borders.  The label's text is controlled by the resource,
@samp{messageText}.  To set the message text, use a statement like the
following.

@example

myMessageBox resources atPut "messageText", "Today Is\nJanuary 3rd";

@end example

The class draws the label using multiline formatting, so if you want
the text to appear on multiple lines, include the sequence @samp{\n}
in the text (that's a backslash and the character, @samp{n}, not a
literal newline).

@cindex @code{mainWindowPtr} instance variable @idxclscite{X11MessageBoxPane}
@item mainWindowPtr
A @code{Symbol} that contains a pointer to the main window.

@end table

@subsubheading Instance Methods

@table @code

@cindex @code{attachTo} instance method @idxclscite{X11MessageBoxPane}
@item attachTo (@code{Object} @var{parentPane}, @code{String} @var{geometry})
Sets the message box's dimensions and creates the object's buffers and
main window.  Unlike other @code{X11Pane} subclasses, this method does
not immediately attach the message box's object to its parent pane, so
the message box isn't displayed until the program invokes the @code{show}
method.

@cindex @code{draw} instance method @idxclscite{X11MessageBoxPane}
@item draw (@code{void})
Draws the label and button subpanes in the message box's buffers
and the buffers of the button and label subpanes.  After calling
this method, the @code{refresh} method makes the changes visible.


@cindex @code{fill} instance method @idxclscite{X11MessageBoxPane}
@item fill (@code{String} @var{colorName})
A convenience method that fills the pane window with the color
given as the argument.

@cindex @code{initWidgets} instance method @idxclscite{X11MessageBoxPane}
@item initWidgets (@code{void})
Initializes the message box's button and label subpanes when the pane's
window is first opened.  When constructed this method sets the
@code{initialized} instance variable to @samp{true}, so when the
message box appears again, this method is a no-op.

@cindex @code{new} instance method @idxclscite{X11MessageBoxPane}
@item new (@code{String} @var{newPaneName})
The X11MessageBoxPane constructor.

@cindex @code{refresh} instance method @idxclscite{X11MessageBoxPane}
@item refresh (@code{void})
After the method @var{draw} renders the main window and the label and
the button subwindow's contents on the pane objects' buffers, this
method updates the visible window with the contents of the buffers.

@cindex @code{show} instance method @idxclscite{X11MessageBoxPane}
@item show (@code{void})
This method displays the message box, waits for events from the
display system, and closes the message box when its button is
clicked, then returns to the calling program.

@cindex @code{subPaneButton} instance method @idxclscite{X11MessageBoxPane}
@item subPaneButton (@code{Object} @var{subPane}, @code{InputEvent} @var{event})
This is the event handler for button press and button release events from
the display hardware.  When a button is clicked on, the message box
draws the button in its clicked state.  When the button is released,
the pane draws the button unclicked, then unmaps the message box window
from the display, and returns to the main program.

@cindex @code{subPaneExpose} instance method @idxclscite{X11MessageBoxPane}
@item subPaneExpose (@code{Object} @var{subPane}, @code{InputEvent} @var{event})
Handles drawing the message box when the program receives an Expose
event from the display.  This method calls the message box's @code{draw}
and @code{refresh} methods.

@cindex @code{withdraw} instance method @idxclscite{X11MessageBoxPane}
@item withdraw (@code{void})
Unmaps the message box's window from the display after the pane object
receives a button release event while processing the @code{show} method.
When the @code{show} method receives the button release event, this
method is called to remove the pane's window from the display, and the
@code{show} method returns to the main program.

@end table


@node X11ScrollBarPane, X11TextPane, X11MessageBoxPane, Classes
@iftex
@section @code{X11ScrollBarPane} Class
@end iftex
@ifnottex
@subheading @code{X11ScrollBarPane} Class
@end ifnottex
@cindex @code{X11ScrollBarPane} class

A @code{X11ScrollBarPane} object draws a basic scroll bar and allows
the user to move the scroll thumb by clicking and dragging.  

Applications can set and read the scroll thumb's size and position via
the object's instance variables.  In particular, the
@code{thumbHeight} instance variable sets the vertical size of the
scroll thumb, and the @mnm{thumbDimensions} method sets the coordinates
and height of the thumb when sliding it to a new position.

@cindex @mnm{dimension} instance method @idxclscite{Rectangle}
The scroll bar's @code{frame} and @code{thumb} instance variables are
both @code{Rectangle} objects.  Applications can use the
@code{Rectangle} class's methods, like @mnm{dimension,} to set the
scroll position, and can read the position using the @code{Rectangle}
object's instance variables. @xref{Rectangle}.

Here is an example program that demonstrates the basic steps needed
to draw a scroll bar.

@c demos/x11/scrollbar.ca
@example

int main (int argv, char **argc) @{
  Integer new xWindowSize;
  Integer new yWindowSize;
  X11Pane new xPane;
  X11PaneDispatcher new xTopLevelPane;
  X11ScrollBarPane new xScrollBarPane;
  X11CanvasPane new xCanvasPane;
  InputEvent new e;
  Exception new ex;
  Application new scrollDemo;
  String new pctstr;
  Integer new strWidth;

  scrollDemo enableExceptionTrace;
  scrollDemo installExitHandlerBasic;
  scrollDemo installAbortHandlerBasic;

  xWindowSize = 400;
  yWindowSize = 400;

  xPane ftFontVar initFontLib;
  xPane ftFont "DejaVu Sans", 0, 0, 0, 48.0;

  xPane initialize xWindowSize, yWindowSize;
  xPane inputStream eventMask = WINDELETE|EXPOSE|BUTTONPRESS|BUTTONRELEASE|MOTIONNOTIFY;
  xTopLevelPane attachTo xPane;
  xScrollBarPane attachTo xTopLevelPane, "20x100%+0+0";
  xCanvasPane attachTo xTopLevelPane, "380x100%+20+0";

  xPane map;
  xPane raiseWindow;

  xPane openEventStream;

  xScrollBarPane background "lightblue";
  xScrollBarPane refresh;
  
  xCanvasPane background "navy";
  xCanvasPane foreground "navy";
  xPane ftFontVar namedX11Color "white";
  xCanvasPane clear;
  pctstr printOn "%0.2f%%", xScrollBarPane percent * 100.0;
  strWidth = xPane ftFontVar textWidth pctstr;
  xCanvasPane putStrXY (380 / 2) - (strWidth / 2), (400 / 2), pctstr;
  xCanvasPane refresh;

  while (TRUE) @{

    xPane inputStream queueInput;
    if (xPane inputStream eventPending) @{
      e become xPane inputStream inputQueue unshift;

      if (ex pending)
  	ex handle;

      xPane subPaneNotify e;

      switch (e eventClass value)
 	@{
	case EXPOSE:
	  xCanvasPane paneBuffer clear;
	  pctstr printOn "%0.2f%%", xScrollBarPane percent * 100;
	  strWidth = xPane ftFontVar textWidth pctstr;
	  xCanvasPane putStrXY (380 / 2) - (strWidth / 2), (400 / 2), pctstr;
	  xCanvasPane refresh;
	  break;
 	case WINDELETE:
  	  xPane deleteAndClose;
 	  exit (0);
 	  break;
  	default:
	  xCanvasPane paneBuffer clear;
	  pctstr printOn "%0.2f%%", xScrollBarPane percent * 100;
	  strWidth = xPane ftFontVar textWidth pctstr;
	  xCanvasPane putStrXY (380 / 2) - (strWidth / 2), (400 / 2), pctstr;
	  xCanvasPane refresh;
  	  break;
 	@}
    @}
  @}
@}

@end example

@subsubheading Instance Variables

@table @code

@cindex @code{arrowCursor} instance variable @idxclscite{X11ScrollBarPane}
@item arrowCursor
A @code{X11Cursor} object that contains the resource ID of the widget's
arrow cursor. @xref{X11Cursor}.

@cindex @code{bevel} instance variable @idxclscite{X11ScrollBarPane}
@item bevel
A @code{Boolean} that determines whether the scroll thumb is drawn
as a beveled widget.

@cindex @code{dragging} instance variable @idxclscite{X11ScrollBarPane}
@item dragging
A @code{Boolean} object that is True while the right mouse button is
clicked while over the scroll thumb. @xref{Boolean}.

@cindex @code{frame} instance variable @idxclscite{X11ScrollBarPane}
@item frame
A @code{Rectangle} object that contains coordinates of the scroll bar frame.
@xref{Rectangle}.

@cindex @code{frameWidthVar} instance variable @idxclscite{X11ScrollBarPane}
@item frameWidthVar
An @code{Integer} that contains the width of the scrollbar's visible frame
in pixels.

@cindex @code{framePen} instance variable @idxclscite{X11ScrollBarPane}
@item framePen
A @code{Pen} object that sets the line color and width of the scroll bar frame.
@xref{Pen}.

@cindex @code{grabCursor} instance variable @idxclscite{X11ScrollBarPane}
@item grabCursor
A @code{X11Cursor} object that contains the resource ID of the widget's
grab cursor. @xref{X11Cursor}.

@cindex @code{lastY} instance variable @idxclscite{X11ScrollBarPane}
@item lastY
An @code{Integer} object that contains the previous PointerMotion
event's y coordinate while dragging. @xref{Integer}.

@cindex @code{margin} instance variable @idxclscite{X11ScrollBarPane}
@item margin
An @code{Integer} that defines the distance in pixels between the
pane's edge and the outer edge of the scrollbar frame.

@cindex @code{mouseOver} instance variable @idxclscite{X11ScrollBarPane}
@item mouseOver
A @code{Boolean} that is true if the pointer is over the scrollbar frame,
false otherwise.

@cindex @code{padding} instance variable @idxclscite{X11ScrollBarPane}
@item padding
An @code{Integer} that defines the distance in pixels between the inner
edge of the scrollbar frame and the thumb.

@cindex @code{thumb} instance variable @idxclscite{X11ScrollBarPane}
@item thumb
A @code{Rectangle} object that contains coordinates of the scroll thumb.
@xref{Rectangle}.

@cindex @code{thumbBackgroundColor} instance variable @idxclscite{X11ScrollBarPane}
@item thumbBackgrondColor
A @code{String} that contains the name of the X11 color used to draw
the thumb.

@cindex @code{thumbErasePen} instance variable @idxclscite{X11ScrollBarPane}
@item thumbErasePen
A @code{Pen} object that sets the color and line width of the scroll thumb
background when animating the thumb.
@xref{Pen}.

@cindex @code{thumbHeight} instance variable @idxclscite{X11ScrollBarPane}
@item thumbHeight
An @code{Integer} that sets the height of the scroll thumb.
@xref{Integer}.

@cindex @code{thumbPen} instance variable @idxclscite{X11ScrollBarPane}
@item thumbPen
A @code{Pen} object that sets the color and line width of the scroll thumb.
@xref{Pen}.

@cindex @code{thumbPix} instance variable @idxclscite{X11ScrollBarPane}
@item thumbPix
A @code{X11Bitmap} that contains the thumb's beveled image, if the
pane is drawn with @code{bevel} set to @samp{true}.
@end table

@subsubheading Instance Methods

@table @code

@cindex @code{attachTo} instance method @idxclscite{X11ScrollBarPane}
@item @mnm{attachTo} (@code{Object} @var{parentPane})
Attaches the @code{X11ScrollBarPane} object to its parent pane,
which is usually a @code{X11PaneDispatcher} object.  Also sizes the
pane and its buffers to fit within the visible window, and sets the
dimensions of the scrollbar's visible frame and thumb.

@cindex @code{background} instance method @idxclscite{X11ScrollBarPane}
@item background (@code{String} @var{colorName})
Sets the pane's background color to @var{colorName}, and also sets
the color to use when performing scrollbar animations.

@cindex @code{drawThumb} instance method @idxclscite{X11ScrollBarPane}
@cindex @code{eraseThumb} instance method @idxclscite{X11ScrollBarPane}
@item @mnm{drawThumb} (@code{void})
@item @mnm{eraseThumb} (@code{void})
These methods animate the thumb so that it tracks the pointer's
position within the scrollbar.

@cindex @code{frameWidth} instance method @idxclscite{X11ScrollBarPane}
@item @mnm{frameWidth} (@code{Integer} @var{lineWidth})
Calculates the scrollbar frame's dimensions within the pane's margins
for the line width in pixels given as the argument.

@cindex @code{new} instance method @idxclscite{X11ScrollBarPane}
@item @mnm{new} (@code{String} @var{paneName})
Creates a new @code{X11ScrollBarPane} object, initializes the pane's
event handlers, and sets the default colors of the pane's elements.

@cindex @code{percent} instance method @idxclscite{X11ScrollBarPane}
@item percent (@code{void})
Returns a @code{Float} with the position of the thumb's top edge
in the usable trough of the scrollbar, as a percentage between 0.0
and 1.0.

The usable area of the trough is defined as the distance that the
top edge of the scrollbar thumb can travel within the scrollbar's
margins; i.e,

@example

usableTrough = aScrollBar size y -
                  ((aScrollBar margin * 2) +
                   (aScrollBar frameWidthVar * 2) +
                   (aScrollBar padding * 2) +
                   (aScrollBar thumbHeight));

@end example

@cindex @code{pointIsInThumb} instance method @idxclscite{X11ScrollBarPane}
@item pointIsInThumb (@code{Integer} @var{x}, @code{Integer}, @var{y})
This method returns a @code{Boolean} value of true if the point
@var{x,y} is within the scroll bar thumb.

@cindex @code{subPaneDestroy} instance method @idxclscite{X11ScrollBarPane}
@cindex @code{subPaneExpose} instance method @idxclscite{X11ScrollBarPane}
@cindex @code{subPanePointerInput} instance method @idxclscite{X11ScrollBarPane}
@cindex @code{subPanePointerMotion} instance method @idxclscite{X11ScrollBarPane}
@cindex @code{subPaneResize} instance method @idxclscite{X11ScrollBarPane}
@cindex @code{subPaneEnterNotify} instance method @idxclscite{X11ScrollBarPane}
@cindex @code{subPaneLeaveNotify} instance method @idxclscite{X11ScrollBarPane}
@item @mnm{subPaneDestroy} (@code{Object} @var{subPane}, @code{InputEvent} @var{event}
@item @mnm{subPaneExpose} (@code{Object} @var{subPane}, @code{InputEvent} @var{event}
@item @mnm{subPanePointerInput} (@code{Object} @var{subPane}, @code{InputEvent} @var{event}
@item @mnm{subPanePointerMotion} (@code{Object} @var{subPane}, @code{InputEvent} @var{event}
@item @mnm{subPaneEnterNotify} (@code{Object} @var{subPane}, @code{InputEvent} @var{event}
@item @mnm{subPaneLeaveNotify} (@code{Object} @var{subPane}, @code{InputEvent} @var{event}
The @code{X11ScrollBarPane} object's event handlers for DESTROY,
EXPOSE, BUTTONPRESS/BUTTONRELEASE, MOTIONNOTIFY, ENTERWINDOWNOTIFY,
and LEAVEWINDOWNOTIFY X Window System events.

@cindex @code{thumbDimensions} instance method @idxclscite{X11ScrollBarPane}
@item @mnm{thumbDimensions} (@code{Integer} @var{y}, @code{Integer} @var{height})
Calculates the position and size thumb's rectangle within the pane using the vertical @var{y} position and the thumb's @var{height}.

@cindex @code{thumbPercent} instance method @idxclscite{X11ScrollBarPane}
@item @mnm{thumbPercent} (@code{Float} @var{pct})
Calculates the thumb's height as a percent of the trough's vertical distance.
The argument, @var{pct}, is a @code{Float} between 0.0 and 1.0.

Note that, in order to make these calculations and update the thumb height in
the pane's viewing area, the scrollbar must already be attached to its parent
pane, and the program needs to be receiving X events.  So this method should
only be used after a call to, for example, X11Pane : openEventStream.

@end table

@node X11TextPane, X11TextEditorPane, X11ScrollBarPane, Classes
@iftex
@section @code{X11TextPane} Class
@end iftex
@ifnottex
@subheading @code{X11TextPane} Class
@end ifnottex
@cindex @code{X11TextPane} class

@code{X11TextPane} objects display text within a X window.  The class
defines methods to display text when opening or resizing a window, and
scrolling through the text.

The Ctalk distribution's, @flnm{demos,} subdirectory contains
several example applications of @code{X11TextPane} objects.

@subsubheading Viewing Text

With a @code{X11TextPane} window open, the class provides the
following keyboard commands.

@example

Key(s)                 Action
------                 ------
j, Control-N, <Up>     Scroll the text down by one line.
k, Control-P, <Down>   Scroll the text up by one line.
Control-V              Scroll the text down one screenful.
Control-T              Scroll the text up one screenful.
Control-Q              Go to the start of the text.
Control-Z              Go to the end of the text.
Escape, Control-C      Close the window and exit the program.

@end example

@subsubheading Adding and Formatting Text

To display text, the class provides the methods @mnm{addText},
@mnm{putStr}, and @mnm{printOn}.

The @mnm{addText} method wraps long lines to fit within the window's
viewing area, and recognizes newline characters as hard line breaks
and inserts soft line breaks where necessary.  The methods @mnm{putStr}
and @mnm{printOn} can display shorter items of text at specific X,Y
positions.

For word wrapped text, each member of the @mnm{textList} instance
variable (described below) is a @code{TextBox} object, which is an
iternal class that is used exclusively by @cite{__ctalkWrapText}
library function and the @mnm{displayText} method.

@cindex @mnm{initFontLib} instance method @idxclscite{X11FreeTypeFont}
The class supports both X bitmapped fonts and the X11FreeTypeFont
outline font libraries.  Applications enable outline font support by
calling the @code{X11FreeTypeFont} method @mnm{initFontLib} at the
start of the program.

In addition, the class supports different typefaces and simple
line formatting with a small set of HTML-like formatting tags.

@example
Tag(s)                Action
------                ------
<b>, </b>             Start/end boldface type.
<i>, </i>             Start/end italic (or oblique) type.
<center>, </center>   Start/end a centered line of text.

@end example

@subheading Instance Variables

@table @code
@cindex @code{leading} instancevariable @idxclscite{X11TextPane}
@item leading
An @code{Integer} that contains the extra space between lines, in
pixels.  Its value depends on the font that the program uses.  The
dimensions of Xlib bitmap fonts seems to provide enough space without
adding any extra space. Outline fonts, however, seem to need this.
The default is 2 (pixels), which the program can set whenever it
selects a font.  Currently, this variable has no effect with
Xlib fonts, though.

@cindex @code{lineHeight} instance variable @idxclscite{X11TextPane}
@item lineHeight
An @code{Integer} that contains the height of a line in pixels.  Its
value is set when the program selects a font.  The default is 12
pixels, which is the value used whenever a program doesn't specify
any fonts.
The total lineHeight is the height of the tallest character ascent +
the longest character descent, and optionally, any leading, either
added by the font designer or the X11TextPane object.  Refer to the
@mnm{font} method, below.

@cindex @code{scrollHeight} instance variable @idxclscite{X11TextPane}
@item scrollHeight
An @code{Integer} that contains the number of lines that the text
moves when scrolling by one screenful.  Its value is

@example

textPaneObject scrollHeight = textPaneObject viewHeight -
                                textPaneObject scrollMargin

@end example

@cindex @code{scrollMargin} instance variable @idxclscite{X11TextPane}
@item scrollMargin
An @code{Integer} that contains the number of lines to overlap when
scrolling by pagefuls.  Its default value is 3.

@cindex @code{text} instance variable @idxclscite{X11TextPane}
@item text
A @code{String} that contains the unformmated text to be displayed
in the window.  Formatting raw text for display is done by the
@mnm{addText} method, below.

@cindex @code{textList} instance variable @idxclscite{X11TextPane}
@item textList
This @code{List} object contains the output of the word wrapping
routines.  Each item of the @code{List} is a @code{TextBox} object,
an internal class that stores information about each word of the
text.

@cindex @code{textLines} instance variable @idxclscite{X11TextPane}
@item textLines
An @code{Integer} that contains the number of lines of text after
it is formatted.

@cindex @code{viewStartLine} instance variable @idxclscite{X11TextPane}
@item viewStartLine
An @code{Integer} that contains the number of the first text line
that is visible in the window.

@cindex @code{requestClose} instance variable @idxclscite{X11TextPane}
@item requestClose
A @code{Boolean} that indicates whether the @code{X11TextPane} object
has requested to be closed, normally in response to an Escape or
Control-C keypress.

@cindex @code{viewXOffset} instance variable @idxclscite{X11TextPane}
@item viewXOffset
An @code{Integer} that contains the left margin of the text
when displayed in the window.

@cindex @code{viewHeight} instance variable @idxclscite{X11TextPane}
@cindex @code{viewWidth} instance variable @idxclscite{X11TextPane}
@item viewHeight
@item viewWidth
@code{Integer} objects that contain the width and height of viewable
area, in characters.  These are normally determined by the font that
the program selects, and after the program calculates the line height
(refer to the @mnm{font} method, below). The @code{X11TextPane} class
adjusts for variable width fonts and faces whenever necessary (and
possible, in some cases).

If the program has selected a font, the @code{X11TextPane} class
calculates the width and height of the viewing area like this.

@example

self viewHeight = self size y / self lineHeight;
self viewWidth = self size x / self fontVar maxWidth;

@end example

If the program doesn't select any fonts, the class uses 14 pixels
as the height of each character and 12 pixels as the character width.

@end table


@subsubheading Instance Methods
@table @code
@cindex @mnm{addText} instance method @idxclscite{X11TextPane}
@item addText (@code{Object} @var{text})
Adds the argument's text to the receiver pane's @code{text} instance
variable, then word-wraps the entire text into the @code{textList} instance
variable.

@cindex @mnm{attachTo} instance method @idxclscite{X11TextPane}
@item attachTo (@code{Object} @var{parentPane})
Attaches the @code{X11TextPane} object to its parent pane.
The parent pane should always be a @code{X11PaneDispatcher}
object.  

@cindex @mnm{cursorPos} instance method @idxclscite{X11TextPane}
@item cursorPos (@code{Integer} @var{x}, @code{Integer} @var{y})
Set the pane's cursor to the coordinates given as arguments.

@cindex @mnm{background} instance method @idxclscite{X11TextPane}
@item background (@code{String} @var{colorname})
Set the background color of the text pane.  See the note for
@code{X11Bitmap} class's @mnm{background} method.
@xref{X11Bitmap}.

@cindex @mnm{clear} instance method @idxclscite{X11TextPane}
@item clear (@code{void})
Clear the pane to the background color.

@cindex @mnm{displayText} instance method @idxclscite{X11TextPane}
@item displayText (@code{void})
Update the pane's text.  The pane's window is updated at the 
next @mnm{refresh} message (see below).

@cindex @mnm{faceRegular} instance method @idxclscite{X11TextPane}
@cindex @mnm{faceBold} instance method @idxclscite{X11TextPane}
@cindex @mnm{faceItalic} instance method @idxclscite{X11TextPane}
@cindex @mnm{faceBoldItalic} instance method @idxclscite{X11TextPane}
@item @mnm{faceRegular} (@code{void})
@item @mnm{faceBold} (@code{void})
@item @mnm{faceItalic} (@code{void})
@item @mnm{faceBoldItalic} (@code{void})
Selects the typeface of the currently selected font.  The font
should be selected by a previous call to the @mnm{font} method
(below).  The @mnm{font} call gathers information about the
type variations if the typeface is available.

@cindex @mnm{font} instance method @idxclscite{X11TextPane}
@item @mnm{font} (@code{String} @var{font_descriptor})
Loads the bitmap font named by @var{font_descriptor} and the bold,
italic, and bold italic typefaces if they are available, and makes the
font named by the argument the currently selected the receiver Pane's
currently selected font.

If a program uses outline fonts, it has more freedom to decide when to
select the fonts, because the font libraries operate independently of
the program's connection to the GUI. @xref{X11FreeTypeFont}.

Programs that use Xlib bitmap fonts, however, need to wait until the
connection to the GUI is opened, with a call to @mnm{openEventStream}
(class @code{X11Pane}). @xref{X11Pane}.

Here's a code snippet from @code{X11TextPane} class.

@example

  X11FreeTypeFont new ftFont;
  Integer new ftMaxCharWidth;
  
  self fontDescStr = fontDesc;
  self fontVar getFontInfo fontDesc;
  (X11Bitmap *)self paneBuffer font fontDesc;

  if (ftFont libIsInitialized) @{
    self lineHeight = ftFont textHeight "ghyl";
    self lineHeight += self leading;
    ftMaxCharWidth = ftFont textWidth "M";
    self viewWidth = self size x / ftMaxCharWidth;
  @} else @{
    /* Note that we don't add the leading to the lineHeight here */
    self lineHeight = self fontVar height;
    self viewWidth = self size x / self fontVar maxWidth;
  @}
  self viewHeight = self size y / self lineHeight;

@end example

@cindex @mnm{foreground} instance method @idxclscite{X11TextPane}
@item foreground (@code{String} @var{colorname})
Set the forground color of the text pane.
See the note for
@code{X11Bitmap} class's @mnm{foreground} method.
@xref{X11Bitmap}.

@cindex @mnm{gotoXY} instance method @idxclscite{X11TextPane}
@item gotoXY (@code{Integer} @var{x}, @code{Integer} @var{y})
Set the pane's cursor to the coordinates given as arguments.
The coordinates are the number of horizontal and vertical
pixels from the pane's top-left corner.

This method is a synonym for @mnm{cursorPos}, above.

@cindex @mnm{new} instance method @idxclscite{X11TextPane}
@item new (@code{String} @var{paneName})
Creates a @code{X11TextPane} object and initializes the
pane's event handlers and other instance data.

If the argument list contains more than one name, create
@code{X11TextPane} objects with the names given by the arguments.

@cindex @mnm{printOn} instance method @idxclscite{X11TextPane}
@item printOn (@code{char *}@var{fmt}, ...)
Print the argument, which is a @cite{printf(3)} style format string
with arguments for the format conversion specifiers, in the pane's
buffer at the position given by the pane's software cursor.  To update
the visible window with the pane buffer's contents, call the
@mnm{refresh} method (below), after calling this function.

@cindex @mnm{putChar} instance method @idxclscite{X11TextPane}
@item putChar (@code{Character} @var{c})
Write a character in the pane's window at the pane's cursor
position. 

@cindex @mnm{putStr} instance method @idxclscite{X11TextPane}
@item putStr (@code{String} @var{s})
Write a string in the pane's window at the pane's cursor
position. 

@cindex @mnm{refresh} instance method @idxclscite{X11TextPane}
@item refresh (@code{void})
Update the text displayed in the pane's window.

@cindex @mnm{subPaneDestroy} instance method @idxclscite{X11TextPane}
@item subPaneDestroy (@code{Object} @var{subPaneReference}, @code{InputEvent} @var{event})
The class's destructor method.  This method deletes only the
data associated with the pane object's window, not the pane
object itself, which is treated like any other object.  

@cindex @mnm{subPaneExpose} instance method @idxclscite{X11TextPane}
@item subPaneExpose (@code{Object} @var{subPaneReference}, @code{InputEvent} @var{event})
The class's @code{EXPOSE} event handler.  Refreshes the main window from 
the pane's text buffer.

@cindex @mnm{subPaneKbdInput} instance method @idxclscite{X11TextPane}
@item subPaneKbdInput (@code{Object} @var{subPaneReference}, @code{InputEvent} @var{event})
The handler for @code{KEYPRESS} and @code{KEYRELEASE} events from the
window system.

@cindex @mnm{subPaneResize} instance method @idxclscite{X11TextPane}
@item subPaneResize (@code{Object} @var{subPaneReference}, @code{InputEvent} @var{event})
The handler for @code{RESIZENOTIFY} events from the window system.
@end table

@node X11TextEditorPane, Symbol, X11TextPane, Classes
@iftex
@section @code{X11TextEditorPane} Class
@end iftex
@ifnottex
@subheading @code{X11TextEditorPane} Class
@end ifnottex
@cindex @code{X11TextEditorPane} class

Objects of @code{X11TextEditorPane} class create a X window which
displays text, and editing commands to perform basic text editing
operations.

There is an example program that demonstrates a @code{X11TextEditorPane}
object's use in a text editor program at the end of this section.

@subsubheading Editing Commands

The set of editing commands that a @code{X11TextEditorPane} object
uses is given here, along with their key bindings.  You can bind them
to different keys by modifying the @mnm{handleKbdInput} method.

@example
Right, Ctrl-F       Next character
Left, Ctrl-B        Previous character
Up, Ctrl-P          Previous line
Down, Ctrl-N        Next line
PgDn, Ctrl-V        Next page
PgUp, Ctrl-T        Previous page
Home, Ctrl-A        Start of line
End, Ctrl-E         End of line
Ctrl-Q              Start of text
Ctrl-Z              End of text
Ctrl-D              Delete character under cursor
Backspace           Delete previous character.  If selecting text, delete
                    the selection.
Del                 Delete the character under the cursor, or the
                    previous character if at the end of the text.
                    If there is selected text, delete the selection.
Esc                 Close the window and exit the program.

Mouse-1             Move the insertion point cursor to the click.
                    Click and drag the pointer to select text.
Mouse-2             Paste text of the X selection at the insertion point.

@end example

@subsubheading Cutting and Pasting Text

@cindex Selecting text
@cindex Cutting text
@cindex Pasting text
@code{X11TextEditorPane} objects can copy text selections to the X
primary selection, and paste selected text from other X programs into
the program's text.

To select text to be pasted into another application, press the left
pointer button and drag the pointer across the text that you want to
select.  The text should be highlighted with the color defined in the
@code{selectionBackgroundColor} instance variable.

Then, switch to the window that you want to paste the text into, and
press the center pointer button at the point where you want to insert
the text (or press the left and right buttons simultaneously on
machines with two buttons).

Conversely, to paste text into the @code{X11TextEditorPane} object's
contents, select the text in the other application's window, then
switch to the @code{X11TextEditorPane} object's window, and press the
center pointer button at the point where you want the text inserted.

If the program has text selected and another program tries to place
its contents in the X primary selection, the class will allow the
selection ownership to change to the other program. Any text that was
selected in the @code{X11TextEditor} pane's window will no longer be
selected.

In general, X programs aren't required to send their to the display's
X selection buffers.  Many programs only use selected contents
internally, and may require another command to send the content to the
X display's primary selection buffer.  @code{X11TextEditorPane}
objects maintain the contents of its selection buffer continuously
when selecting, but they only send the contents to the X display's
primary selection when another program requests it.


@subsubheading Fonts

@cindex @code{fontVar} instance variable @idxclscite{X11Pane}
@cindex @code{ftFontVar} instance variable @idxclscite{X11Pane}
@cindex Fonts, selecting
@cindex @code{ctedit.ca} demonstration program
The demonstration program, @flnm{demos/x11/ctedit.ca}, provides
options to change the default font and point size.  The X11 utility
programs @cite{xfontsel(1)} and @cite{fc-list(1)} can display the X
bitmap fonts and the Xft library's scalable fonts that are available
on the machine, respectively.

@cindex @code{fontVar} instancevariable @idxclscite{X11TextEditorPane}
Programs configure X fonts within the window's graphics context, using
the instance variable @code{fontVar}, which is inherited from
@code{X11Pane} class.

@cindex @code{ftFontVar} instancevariable @idxclscite{X11TextEditorPane}
FreeTypeFonts need to be configured separately from the X window, but
the parent @code{X11Pane} object also defines the @code{ftFontVar}
instance variable, so the program can configure outline fonts before
entering its event loop.

If a program is to be configurable for different machines, it should
check which of the font libraries are present on the system, and which
of the @code{fontVar} or @code{ftFontVar} instance variables the
program has configured in the program's initialization.

The @code{X11TextEditorPane} class uses monospaced fonts exclusively.
If a program requests a proportionally spaced font, the pane's
libraries won't maintain alignment between the displayed text and
editing operations.

The sections, @code{X11FreeTypeFont} and @code{X11Font} contain more
information about how to select fonts. @xref{X11FreeTypeFont}, @xref{X11Font}.

@subsubheading Instance Variables
@table @code
@cindex @code{bufLength} instance variable @idxclscite{X11TextEditorPane}
@item bufLength
An @code{Integer} that records the size of the object's text buffer.
The class adjusts the buffer's size automatically if necessary.

@cindex @code{button} instance variable @idxclscite{X11TextEditorPane}
@item button
An @code{Integer} that records the state of the mouse buttons, i.e., whether
they are pressed or not.  The values that the the variable might contain
are composed of these definitions.

@example

#define BUTTON1MASK  (1 << 0)
#define BUTTON2MASK  (1 << 1)
#define BUTTON3MASK  (1 << 2)  

@end example

@cindex @code{foregroundColor} instance variable @idxclscite{X11TextEditorPane}
@item foregroundColor
A @code{String} that contains the window's foreground color.  The
variable is included here to facilitate drawing the cursor in reverse
video.  The @code{backgroundColor} instance variable is declared in
@code{X11Pane} class. @xref{X11Pane}.

@cindex @code{lineWidth} instance variable @idxclscite{X11TextEditorPane}
An @code{Integer} that defines the right margin in character columns.
Setting this to zero @samp{0} sets the line width limit to the line
length, so the line width in character columns is calculated as:

@example

lineWidth = (window_width_px - left_margin_px - right_margin_px) /
               character_width_px;

@end example

@cindex @code{rightMargin} instance variable @idxclscite{X11TextEditorPane}
@item rightMargin
The distance in pixels from the right edge of the window, leftward to
the right-hand limit of each line's length.

@cindex @code{point} instance variable @idxclscite{X11TextEditorPane}
@item point
An @code{Integer} that contains the current position in the text where
editing occurs.

@cindex @code{selectionBackgroundColor} instance variable @idxclscite{X11TextEditorPane}
@item selectionBackgroundColor
A @code{String} that contains the background color of selected text.
The foreground color is the same as normal text.

@cindex @code{sStart} instance variable @idxclscite{X11TextEditorPane}
@cindex @code{sEnd} instance variable @idxclscite{X11TextEditorPane}
@cindex @code{selecting} instance variable @idxclscite{X11TextEditorPane}
@item sStart
@item sEnd
@item selecting
The @code{Integer} variables @code{sStart} and @code{sEnd} record the
beginning and end of selected text as character indexes into the text.
The @code{Boolean} variable @code{selecting} is true while the pointer
is being dragged across text while Button 1 is pressed.

@cindex @code{shiftState} instance variable @idxclscite{X11TextEditorPane}
@item shiftState
An @code{Integer} that records whether the Shift of Control keys
are currently pressed.

@cindex @code{textLength} instance variable @idxclscite{X11TextEditorPane}
@item textLength
An @code{Integer} that records the length of the object's text.

@end table

@subsubheading Instance Methods
@table @code
@cindex @mnm{attachTo} instance method @idxclscite{X11TextEditorPane}
@item @mnm{attachTo} (@code{Object} @var{parent_pane})
Attach a @code{X11TextEditorPane} object to its parent pane, which is
typically a @code{X11PaneDispatcher} object.  This method initializes
the size of the pane's window and buffers to the parent pane's
dimensions, and positions the pane at the upper left-hand origin of
the main window.

@cindex @mnm{background} instance method @idxclscite{X11TextEditorPane}
@cindex @mnm{foreground} instance method @idxclscite{X11TextEditorPane}
@item background (@code{String} @var{colorName})
@item foreground (@code{String} @var{colorName})
Sets the foreground and backgrounds color of the pane's window and
buffers.

@cindex @mnm{clearSelection} instance method @idxclscite{X11TextEditorPane}
@item clearSelection (@code{void})
Sets the @code{sStart} and @code{sEnd} instance variables to @samp{0},
cancelling text selection.

@cindex @mnm{defaultFormat} instance method @idxclscite{X11TextEditorPane}
@item defaultFormat (@code{void})
Sets the document-wide margins and text text colors.  If the pane is
using an @code{X11FreeTypeFont} object to render text, the font needs
to be configured before calling this method.  @xref{X11FreeTypeFont}.

@cindex @mnm{displayText} instance method @idxclscite{X11TextEditorPane}
@item displayText (@code{void})
Displays the text and editing cursor.  Programs should call this
method as soon as possible after the program starts the X event loop
(which it does by calling the @code{X11TerminalStream :
openEventStream} method), and after every editing operation.

@cindex @mnm{gotoChar} instance method @idxclscite{X11TextEditorPane}
@item gotoChar (@code{Integer} @var{n})
Sets the @code{point} instance variable to the @var{n}'th character in
the text.  If @var{n} is greater than the length of the text, sets
@code{point} to the end of the text.

@cindex @mnm{new} instance method @idxclscite{X11TextEditorPane}
@item new (@code{String} @var{paneName})
Initializes the @code{X11TextEditorPane} object's event handlers, and
calls constructors in the @code{X11TextEditorPane's} superclasses to
perform addition initialization.  The method @mnm{attachTo}, declared
in @code{X11TextPane} class, performs the actual dimensioning of the
pane and its buffers. @xref{X11TextPane}.

@cindex @mnm{subPaneKbdInput} instance method @idxclscite{X11TextEditorPane}
@item subPaneKbdInput (@code{X11TextEditorPane} @var{subPane}, @code{InputEvent} @var{event})
Handles Keypress and KeyRelease events from the X server.  It's
possible to reconfigure the editing commands by modifying this method.

The method works in conjuction with the Ctalk library's editing
functions to translate alphanumeric and punctuation characters with
the correct shift and control state, and to transmit special keys like
arrow keys and Home/End keys untranslated.

@cindex @mnm{subPaneButtonPress} instance method @idxclscite{X11TextEditorPane}
@item subPaneButtonPress (@code{X11TextEditorPane} @var{subPane}, @code{InputEvent} @var{event})
The handler for button press and button release events.  This method
sets the value of the @code{button} instance variable, in addition
to performing other tasks.

@cindex @mnm{subPaneMotionNotify} instance method @idxclscite{X11TextEditorPane}
@item subPaneMotionNotify (@code{X11TextEditorPane} @var{subPane}, @code{InputEvent} @var{event})
The handler method for pointer motion events.

@cindex @mnm{subPaneResize} instance method @idxclscite{X11TextEditorPane}
@item subPaneResize (@code{X11TextEditorPane} @var{subPane}, @code{InputEvent} @var{event})
Handles resizing the @code{X11TextEditor} pane's dimensions in response
to a window resize event.  This method is a no-op in the current release.

@cindex @mnm{subPaneSelectionClear} instance method @idxclscite{X11TextEditorPane}
@item subPaneSelectionClear (@code{X11TextEditorPane} @var{subPane}, @code{InputEvent} @var{event})
Updates the program's state after receiving a a SelectionClear event.
Normally this occurs when another program requests the X primary
selection.  The method updates this program's state so that it is
no longer selecting, and redraws the text.

@end table


@cindex Text editor example program
@cindex Example program, text editor
@subsubheading Example Text Editing Program
@c demos/x11/ctedit.ca
@example
/*
  ctedit.ca - Basic text editor using X11TextEditorPane class.

  Usage:

    ctedit [<options>] <filename>

  Typing, "ctedit -h" displays a list of options.

  Pressing Esc or selecting "Close" from the window menu
  exits the program and saves the edited text.
  
  If <filename> exists, ctedit renames the previous version
  of the file to <filename>.bak.  If <filename> doesn't
  exist, ctedit creates a new file.

  The editing commands are set in the X11TextEditorPane :
  handleKbdInput method.  They are:

     Right, Ctrl-F       Next character
     Left, Ctrl-B        Previous character
     Up, Ctrl-P          Previous line
     Down, Ctrl-N        Next line
     PgDn, Ctrl-V        Next page
     PgUp, Ctrl-T        Previous page
     Home, Ctrl-A        Start of line
     End, Ctrl-E         End of line
     Ctrl-Q              Start of text
     Ctrl-Z              End of text
     Ctrl-D              Delete character under cursor
     Backspace           Delete previous character
     Del                 At the end of the text, delete the
                         previous character.  Otherwise delete
                         the character under the cursor.
     Esc                 Close the window, save the edited text,
                         and exit the program.
 */

#define WIN_WIDTH 500
#define WIN_HEIGHT 340
#define WIN_X 25
#define WIN_Y 30
#define FIXED_FONT "fixed"
#define DEFAULT_BG "white"
#define DEFAULT_FG "black"
#define DEFAULT_FT_FONT "DejaVu Sans Mono"
#define DEFAULT_FT_PTSIZE 12.0

Application new ctEdit;
String new geomString;
String new infileName;
String new xFontName;
String new ftFontName;
Float new ftFontSize;
String new bgColor;
String new fgColor;

Boolean new createFile;

Boolean new useFtFonts;
X11FreeTypeFont new ftFont;
Boolean new useXFont;

void exit_help () @{
  printf ("usage: ctedit [-h] | [-g <geom>] [-fg <color>] "
	  "[-bg <color>] [-fn <font> ] <filename>\n");
  printf ("-bg <color>    Set the window background to <color>.\n");
  printf ("-fg <color>    Display the text using <color>.\n");
  printf ("-fn <font>     Use the X <font> to display the text. See xfontsel(1).\n");
  printf ("-ft <font>     Use the FreeType <font> to display the text. See\n");
  printf ("               X11FreeTypeFont class.\n");
  printf ("-g  <geom>     Set the window geometry to <geom>. See XParseGeometry (3).\n");
  printf ("-h             Print this message and exit.\n");
  printf ("-xfonts        Use X bitmap fonts, even if outline fonts are available.\n");
  exit (1);
@}

/* UNIX-compatible line ending. */
#define LF 10

X11TextEditorPane instanceMethod writeOutput (String infileName) @{
  "Create a backup of the previous version of the file, if any,
   and check that the text ends with a UNIX-standard newline
   (ASCII 10) character."
  WriteFileStream new writeFile;
  Character new c;

  c = self text at (self text length - 1);
  if (c != LF) @{
    self text += "\n";
  @}
  
  if (!createFile)
    writeFile renameFile infileName, infileName + ".bak";
  writeFile openOn infileName;
  writeFile writeStream (self text);
  writeFile closeStream;

@}

Application instanceMethod commandLineOptions (void) @{
  Integer new i, nParams;
  String new param;


  nParams = self cmdLineArgs size;
  for (i = 1; i < nParams; i++) @{

    param = self cmdLineArgs at i;

    if (param  == "-g") @{
      ++i;
      geomString = self cmdLineArgs at i;
      continue;
    @}
    if (param == "-fn") @{
      ++i;
      xFontName = self cmdLineArgs at i;
      continue;
    @}
    if (param == "-bg") @{
      ++i;
      bgColor = self cmdLineArgs at i;
      continue;
    @}
    if (param == "-fg") @{
      ++i;
      fgColor = self cmdLineArgs at i;
      continue;
    @}
    if (param == "-ft") @{
      ++i;
      ftFontName = self cmdLineArgs at i;
      continue;
    @}
    if (param == "-xfonts") @{
      useXFont = True;
      continue;
    @}
    if (param == "-pt") @{
      ++i;
      ftFontSize = (self cmdLineArgs at i) asFloat;
      continue;
    @}
    if (param == "-h" || param == "--help" || param == "--h" ||
	param at 0 == '-') @{
      exit_help ();
    @}
    
    infileName = param;

  @}

@}

Application instanceMethod winDimensions (void) @{
  if (geomString length > 0) @{
    self parseX11Geometry geomString;
    if (self winWidth == 0) @{
      self winWidth = WIN_WIDTH;
    @}
    if (self winHeight == 0) @{
      self winHeight = WIN_HEIGHT;
    @}
    if (self winXOrg == 0) @{
      self winXOrg = WIN_X;
    @}
    if (self winYOrg == 0) @{
      self winYOrg = WIN_Y;
    @}
  @} else @{
    self winWidth = WIN_WIDTH;
    self winHeight = WIN_HEIGHT;
    self winXOrg = WIN_X;
    self winYOrg = WIN_Y;
  @}
@}

Application instanceMethod findFtFonts (void) @{

  if (useFtFonts && !useXFont) @{
    ftFont initFontLib;
    ftFont selectFont ftFontName, 0, 80, 72, ftFontSize;
    ftFont namedX11Color fgColor;
  @}
  
@}

int main (int argc, char **argv) @{
  X11Pane new xPane;
  X11PaneDispatcher new xTopLevelPane;
  X11TextEditorPane new xEditorPane;
  InputEvent new e;
  Exception new ex;
  X11Cursor new watchCursor;
  ReadFileStream new readFile;
  String new winTitle;

  geomString = "";
  xFontName = FIXED_FONT;
  bgColor = DEFAULT_BG;
  fgColor = DEFAULT_FG;
  infileName = "";
  useFtFonts = True;
  useXFont = False;
  ftFontSize = DEFAULT_FT_PTSIZE;
  ftFontName = DEFAULT_FT_FONT;

  ctEdit parseArgs argc, argv;
  ctEdit commandLineOptions;
  ctEdit winDimensions;

  if (ftFont version < 10) @{
    useFtFonts = false;
  @} else @{
    ctEdit findFtFonts;
  @}
  

  if (infileName length == 0) @{
    exit_help ();
  @}

  if (!readFile exists infileName) @{
    createFile = true;
    winTitle = infileName + "   (New file)";
  @} else @{
    readFile openOn infileName;
    xEditorPane text = readFile readAll;
    readFile closeStream;
    winTitle = infileName;
    createFile = false;
  @}

  xPane initialize ctEdit winXOrg, ctEdit winYOrg,
    ctEdit winWidth, ctEdit winHeight, ctEdit geomFlags, winTitle;

  xTopLevelPane attachTo xPane;
  xEditorPane attachTo xTopLevelPane;
  xPane map;
  xPane raiseWindow;
  watchCursor watch;

  xPane openEventStream;

  /* This sets the maximum line width to the width of the window. */
  xEditorPane lineWidth = 0;

  if (!useFtFonts || useXFont) @{
    xEditorPane foreground fgColor;
    xEditorPane font xFontName;
    xEditorPane defaultFormat;
  @} else @{
    xEditorPane defaultFormatFT ftFont;
  @}

  xEditorPane background bgColor;
  xEditorPane clear;

  xPane defaultCursor;

  while (TRUE) @{
    xPane inputStream queueInput;
    if (xPane inputStream eventPending) @{
      e become xPane inputStream inputQueue unshift;
      xPane subPaneNotify e;
      if (ex pending)
 	ex handle;
      switch (e eventClass value) 
	@{
	  /*
	   *  Handle both types of events in case the window
	   *  manager doesn't distinguish between them.
	   */
	case MOVENOTIFY:
	  break;
	case RESIZENOTIFY:
	  break;
	case EXPOSE:
	  xEditorPane displayText;
	  break;
	case WINDELETE:
	  xEditorPane writeOutput infileName;
 	  xPane deleteAndClose;
	  exit (0);
	  break;
	default:
	  break;
	@}
    @} else @{
      if (xEditorPane requestClose) @{
	xEditorPane writeOutput infileName;
	xPane deleteAndClose;
	exit (0);
      @}
    @}
  @}
@}
@end example



@node Symbol, Key, X11TextEditorPane, Classes
@iftex
@section @code{Symbol} Class
@end iftex
@ifnottex
@subheading @code{Symbol} Class
@end ifnottex
@cindex @code{Symbol} class

@code{Symbol} class objects represent memory locations.  They can
refer to objects, C variables, buffers, I/O ports, and other data
located in memory.

As an alternative, if you receive an @code{Unimplemented C type}
warning, you can store various types of C data in @code{Symbol}
objects. @xref{Objects in Function Arguments}.

A unary @samp{*} operator behaves similarly to the C operator. That is,
it refers to the value of the @code{Symbol} object, not the object itself.
The following example might make this clearer.

@c test/expect/examples/prefixsym.c
@example

int main () @{

  Symbol new sym1;
  Symbol new sym2;
  Symbol new sym3;
  Integer new i;
  
  i = 2;

  sym3 = sym1;   /* Save the original value of sym1. */

  sym1 = i;
  printf ("%d\n", sym1);

  *sym2 = i;
  printf ("%d\n", *sym2);

  sym1 = sym3;  /* Restore sym1 to the original object. */

  i = 4;
  
  *sym1 = i;

  printf ("%d\n", *sym1);
@}

@end example

@subheading Instance Variables

@table @code

@cindex @code{value} instance variable @idxclscite{Symbol}
@item value
The value of a @code{Symbol} is a hexadecimal memory address.

@end table

@subsubheading Instance Methods

@table @code

@cindex @mnm{*} instance method @idxclscite{Symbol}
@item @mnm{*} (@code{void})
The @code{*}. A shortcut for the @mnm{getValue} method, below.

@cindex @mnm{=} instance method @idxclscite{Symbol}
@item @mnm{=} (@code{void *}@var{v})
Assign a reference to the argument as the value of the
receiver.  If @var{v} is also a @code{Symbol} object, simply
copy the reference.  This method is a synonym for
@mnm{symbolReference}, below.  If you want to use multiple
levels of object references and dereferences, see the
@mnm{addressOf} method in @code{Object} class @xref{Object},
and the @mnm{deref} method, below.

@cindex @mnm{asAddrString} instance method @idxclscite{Symbol}
@item @mnm{asAddrString} (@code{void})
Returns a @code{String} object with the formatted hexadecimal
address of the object pointed to by the receiver.

@cindex @mnm{asString} instance method @idxclscite{Symbol}
@item @mnm{asString} (@code{void})
Returns the receiver's value as a @code{String} object with the value
of the @code{char} string that the @code{Symbol} receiver object
points to.  The result object has the same name as the receiver and
the class of @code{String}.

@cindex @mnm{basicObject} instance method @idxclscite{Symbol}
@item @mnm{basicObject} (@code{char *}@var{name}, @code{char *}@var{classname}, @code{char *}@var{superclassname}, @code{char *}@var{value_expr})
Create a basic object and make the receiver's value point to it.  The
new object has the scope @samp{LOCAL_VAR|VAR_REF_OBJECT} and a
reference count of 1.

Referencing the object with a @code{Symbol} makes it easy to create
objects and then assign them to C variables in the calling method
or function. For example,

@example

  Symbol new s;
  OBJECT *int_object;

  s basicObject "new_int", "Integer", "Magnitude", "10";

  int_object = s getValue;

  printf ("%d\n", int_object value);

@end example

@cindex @mnm{deref} instance method @idxclscite{Symbol}
@item @mnm{deref} (@code{void})
Return the object referred to by the receiver. This method
is functionally equivalent to the C @samp{*} operator.

@cindex @mnm{getValue} instance method @idxclscite{Symbol}
@item @mnm{getValue} (@code{void})
Return the object that the receiver's value (previously set by @mnm{=}
or @mnm{symbolReference}) refers to.  If the address doesn't refer to
an object, returns the receiver and generates an exception, which the
program can handle in whatever manner is necessary.  In some cases,
the internals of Ctalk's object-to-C routines can also generate an
warning message.

Note that when assigning a non-object data address to a C variable
like a @code{void *}, Ctalk allows both of these expressions:

@example

 void *myVoidPtr;

 myVoidPtr = mySymbol;

 myVoidPtr = *mySymbol;   /* Generates an exception. */

@end example

@cindex @mnm{name} instance method @idxclscite{Symbol}
@item @mnm{name} (@code{void})
Return a new @code{String} object containing the receiver's name.

@cindex @mnm{removeValue} instance method @idxclscite{Symbol}
@item @mnm{removeValue} (@code{void})
Remove the reference to the target object from the receiver. Delete
the target object if there are no further references to it.

@cindex @mnm{symbolReference} instance method @idxclscite{Symbol}
@item @mnm{symbolReference} (@code{void *}@var{v})
Return a new @code{String} object containing the receiver's name.

@end table

@node Key, Vector, Symbol, Classes
@iftex
@section @code{Key} Class
@end iftex
@ifnottex
@subheading @code{Key} Class
@end ifnottex
@cindex @code{Key} class

Objects of class @code{Key} are key-value pairs.  Other classes and
programs can use @code{Key} objects' names when looking up 
objects.  The value of a key object is a reference to the value object.

Many of the @code{Collection} subclasses are composed entirely of
@code{Key} objects, which act as the ``glue'' that maintains references
to the the actual contents of the collection.  @xref{Collection}.

Programs can also manipulate @code{Key} objects independently.  Most
of the math operators that work with collections actually work with
@code{Key} objects.  So it's important to add the attribute
OBJECT_IS_MEMBER_OF_PARENT_COLLECTION to a @code{Key} object when
building collections.  This tells Ctalk that the @code{Key} object can
be used independently, as well as part of its parent collection.
@xref{Attributes}.

Here's a program that manipulates the @code{Key} objects of a
collection (here, an @code{AssociativeArray})
directly. @xref{AssociativeArray}.

@c test/expect/icol3.c
@example

int main (int argc, char **argv) @{

  AssociativeArray new a;
  Key new k;

  a atPut "key1", "value1";
  a atPut "key2", "value2";
  a atPut "key3", "value3";
  a atPut "key4", "value4";

  k = *a;

  while (++k)
    printf ("%s --> %s\n", k name, *k);

@}

@end example

@subheading Instance Variables

@table @code

@cindex @code{value} instance variable @idxclscite{Key}
@item value
The value is the formatted representation of a hexadecimal pointer
to a memory address.

@end table

@subsubheading Instance Methods

@table @code

@cindex @mnm{+} instance method @idxclscite{Key}
@item @mnm{+} (@code{Integer} @var{n})
Increments the receiver by @var{n}.  For a @code{Key} object, this
sets the receiver to the @var{nth} successive element in a collection.
The increments are numbered with @samp{1} pointing to the first member
of the collection, and so on.  If there are no more elements, the
receiver's value is NULL.  For an example, refer to @mnm{-}, below.

@cindex @mnm{++} instance method @idxclscite{Key}
@item @mnm{++}
Increments the receiver to point to the next @code{Key} in a
collection.  If the receiver is already the last item item in the
collection, the value of the receiver after it is incremented is NULL.
This method works as both a prefix and postfix method, and increments
the receiver either before or after it is referenced, respectively.

Here is an example of how to iterate over an @code{AssociativeArray} using
@mnm{++}.

@example

  AssociativeArray new a;
  Key new k;

  a atPut "key1", "value1";
  a atPut "key2", "value2";
  a atPut "key3", "value3";
  a atPut "key4", "value4";

  k = *a;

  while (++k)
    printf ("%s --> %s\n", k name, *k);

@end example

@cindex @mnm{-} instance method @idxclscite{Key}
@item @mnm{-} (@code{Integer} @var{n})
Decrements the receiver by @var{n}.  For a @code{Key} object,
this sets the receiver to the @var{nth} previous element of
the collection that the receiver is a member of.  Here is
a brief example

@example

int main () @{

  AssociativeArray new a;
  Key new k;

  a atPut "1", "value1";
  a atPut "2", "value2";
  a atPut "3", "value3";
  a atPut "4", "value4";

  k = *a;
  printf ("%s --> %s\n", k name, *k);
  k = k + 3;
  printf ("%s --> %s\n", k name, *k);
  k = k - 1;
  printf ("%s --> %s\n", k name, *k);
@}

@end example

Running this program produces the following output.

@example

1 --> value1
4 --> value4
3 --> value3

@end example

@cindex @mnm{--} instance method @idxclscite{Key}
@item @mnm{--}
Decrements the receiver to point to the previous @code{Key} in a
collection. If the receiver is the first item in the collection, the
value of the receiver after it is decremented is NULL.  Like @mnm{++},
this method works as both a prefix and postfix method, and decrements
the receiver either before or after it is referenced, respectively.

@cindex @mnm{=} instance method @idxclscite{Key}
@item @mnm{=}
If the receiver refers to an object reference (that is, preceded by a
@samp{*} operator), sets the value of the receiver to the address of
the argument.  Otherwise, sets the receiver to refer to the argument.

@cindex @mnm{getKeyObject} instance method @idxclscite{Key}
@item @mnm{getKeyObject} (@code{void})
Return the receiver.

@cindex @mnm{setName} instance method @idxclscite{Key}
@item @mnm{setName} (@code{char *}@var{key_name})
Set the receiver's name to the argument, a @code{String} object.

@emph{Note:} In some cases, the object's name is the only way that
Ctalk can refer to it.  In that case, the program needs to maintain an
alias to the object, like an @code{OBJECT *,} so that it can refer to
the object later.  In the following example, the program can refer to
@code{keyObject} by using @code{key_alias_ptr,} regardless of the
object's name.
@example
Key new keyObject;
OBJECT *key_alias_ptr;
...
key_alias_ptr = KeyObject setName keyNameString;
@end example

@cindex @mnm{detach} instance method @idxclscite{Key}
@item @mnm{ulink} (@code{void})
Detach the receiver object from its parent collection.  The
method also removes the OBJECT_IS_MEMBER_OF_PARENT_COLLECTION
attribute from the receiver.

@end table

@node Vector, , Key, Classes
@iftex
@section @code{Vector} Class
@end iftex
@ifnottex
@subheading @code{Vector} Class
@end ifnottex
@cindex @code{Vector} class

Objects of @code{Vector} class refer to blocks of memory of arbitrary length.
The memory area that the @code{Vector} object points to may contain
any data, including NULL bytes.

@cindex readVec instance method @idxclscite{ReadFileStream}
Whenever a program or method assigns a @code{Vector} object a new area
of memory, the program or method also sets the @code{Vector} object's
@code{length} instance variable; for example, the method @mnm{readVec}
(class @code{ReadFileStream}) records the memory area's size in the
@code{length} instance variable after it has read a chunk of data from
a disk file.  @xref{ReadFileStream}.

Here's an example program that writes a copy of a JPEG image file.

@example

int main () @{
  ReadFileStream new readF;
  WriteFileStream new writeF;
  FileStream new f;
  Vector new vec;
  LongInteger new size;

  readF openOn "original.jpeg";
  readF statStream;
  size = readF streamSize;
  
  vec = readF readVec size;

  writeF openOn "copy.jpeg";
  writeF writeVec vec;

  writeF closeStream ;
  readF closeStream;
@}

@end example

@subsubheading Instance Variables

@table @code

@cindex @code{length} instance variable @idxclscite{Vector}
@item length
An @code{Integer} that contains the size in bytes of the memory area
that the @code{Vector} object points to.


@end table

@subsubheading Instance Methods

@table @code

@cindex @mnm{+} instance method @idxclscite{Vector}
@item + (@code{Vector} @var{v})
Return a @code{Vector} object that is the concatenation
of the receiver and the argument.

@cindex @mnm{+=} instance method @idxclscite{Vector}
@item += (@code{Vector} @var{v})
Concatenate the receiver with the vector given as the argument.

@cindex @mnm{asString} instance method @idxclscite{Vector}
@item asString (void)
Returns the value of the receiver as a @code{String} object terminated
with a NUL byte to the value of the receiver's @code{length} instance
variable.  Does not check for NULs or non-printing characters in the
value, so the returned @code{String} may still be truncated to less
than the receiver's length.

@cindex @mnm{basicNew} instance method @idxclscite{Vector}
@item basicNew (@code{char *}@var{name}, @code{char *}@var{value}, @code{int} @var{value_length}
@item basicNew (@code{char *}@var{name}, @code{char *}@var{classname}, @code{char *}@var{superclassname}, @code{char *}@var{value}, @code{int} @var{value_length})
Create a new @code{Vector} object with the name, contents, length,
and, optionally, class name and superclass name given as the
arguments.  

For the five-argument form of @code{basicNew}, the class should be
@code{Vector} and the superclassname should be @code{Symbol}, unless
the program has subclassed @code{Vector}.  

In the three-argument form, the receiver must be a member of
@code{Vector} class or its subclasses, in which case the method takes
the class and superclass from the receiver, as in this example.

@example

myBuf = Vector basicNew "memorybuf", memory_buf_ptr, memory_buf_length;

@end example

The @var{value} argument may be any memory address that points to data
of arbitrary size, and may contain any data, including NULL bytes.

The @var{value_length} argument supplies the length of the memory
segment in bytes, which the returned @code{Vector} object stores in
its @code{length} instance variable.

Most of the internal work of setting the values and attributes of the
returned object, and registering the memory area, is performed by
@cite{__ctalkSetObjectValueAddr}, which each of these methods call.
@xref{ctalkSetObjectValueAddr}.

It's also necessary that these methods take care of other initialization
tasks which are necessary for all classes of objects.  They're described
in general in the description of @mnm{basicNew} (@code{Object} class).
@xref{ObjectbasicNew}.

@cindex @mnm{contains} instance method @idxclscite{Vector}
@item contains (@code{String} @var{pattern})
@item contains (@code{String} @var{pattern}, @code{Integer} @code{start_offset})
With one argument, returns an @code{Integer} with the byte offset of
the first occurence of @var{pattern} in the receiver, starting from
the beginning of the receiver's value, or -1 if the pattern is not
found.

If a second argument is given, it contains the @code{Integer} offset
into the buffer where the method begins its search.  That allows
programs to find multiple matches of the same pattern in the
receiver's value.

@end table

@c CLASS-DOC-END-COOKIE ***

@node Methods, C, Classes, Top
@iftex
@chapter Methods
@end iftex
@ifnottex
@heading Methods
@end ifnottex
@cindex Methods

The following sections outline some of the programming
features that Ctalk methods implement.  The @cite{Ctalk
Tutorial} provides step-by-step instructions on how to write
some common method types.

Declaring a method is similar to declaring a C function, but
the declaration syntax adds some additional features.

@itemize
@item
The declaration specifies the class that the method belongs to.
@item
The statement allows the method to be identified by an alias, so the
method can overload operators.  Classes can implement overloaded methods
in other ways, too.  @xref{Overloading}.
@end itemize

To declare an instance method, use the @code{instanceMethod} keyword,
as in the following example.

@example
String instanceMethod = set_value (char *s) @{

 ... method statements

@}
@end example

This example declares an instance method, @mnm{=}, which is recognized
by objects that belong to the class @code{String} and its subclasses.
The @code{=} in the declaration overloads C's @code{=} operator, so
that, instead of assigning a value to a C variable, the method sets the value
of its receiver. 

In this example, the receiver is an instance of class @code{String.}

@example
newObject = "Hello, World!";
@end example

If the variable reference immediately preceding @code{=} refers to a C
variable, then @mnm{=} behaves as the C operator, @code{=.}

Ctalk can use most C operators as methods, with the exception of
parentheses and prefix operators.  Receivers always precede the method
message.  

For example, the @code{Integer} methods @mnm{invert} and
@mnm{bitComp} perform the same operations as the C prefix operators
@code{!}  and @code{~.}
@example
int i;              /* C variable. */
Integer new myInt;  /* Ctalk object. */

i = 0;
myInt = 0;

/* These two statements are equivalent. */
printf ("%d", !i); 
printf ("%d", myInt invert).

/* And so are these two statements. */
printf ("%d", ~i);
printf ("%d", myInt bitComp);
@end example




@iftex
@section Declaring Methods
@end iftex
@ifnottex
@subheading Declaring Methods
@end ifnottex
@cindex Methods
@cindex Method declarations

The declaration syntax for instance methods is:

@quotation
@var{classname} @code{instanceMethod} [@var{alias}] @var{funcname} (@var{args}) @{
@var{method body}
@}
@end quotation

and for class methods:

@quotation
@var{classname} @mnm{classMethod} [@var{alias}] @var{funcname} (@var{args}) @{
@var{method body}
@}
@end quotation

If @var{alias} is omitted, Ctalk refers to the method by
@var{funcname.}

In the example at the beginning of this section, if @mnm{=} were
omitted, a program could refer to the method by the message,
@code{set_value.}

With the exception of the primitive methods @mnm{class}, @mnm{new},
@mnm{classMethod}, and @mnm{instanceMethod}, Ctalk declares methods
in its class library, or in the program input. @xref{Classes}.

@iftex
@section Method Parameters
@end iftex
@ifnottex
@subheading Method Parameters
@end ifnottex
@cindex Method parameters

You can use Ctalk class objects to declare method parameters, but you
can also declare parameters using C data types, in order to prevent
class libraries from being loaded recursively.  This is necessary in
many of the basic classes.

Regardless of how you declare method parameters, when the method's
message is sent to an object, Ctalk translates C language arguments
into class objects.

For example, these two declarations are equivalent.  
@example
Integer instanceMethod + add (int i) @{
...
@}

Integer instanceMethod + add (Integer i) @{
...
@}
@end example

Ctalk does not use objects in C function arguments, so if you need to
use objects as parameters, you must write a method instead of a C
function.

@ifnottex
@menu
* Method API::            The method application programming interface.
* Self and super::        How to refer to receivers and superclass methods.
* Class initialization::  How to set class variables at run time.
* Translating::           C to objects and back again.
* C Macros::              Macros that provide convenient shortcuts.
* Prefixes::              Methods can also overload C unary operators.
* Required classes::      Preloading classes that you will need.
* Scoping::               An object can have many scopes.
* Templates::             Method wrappers for C-language tasks.
* Return values::         How to return objects of various classes.
* Variable arguments::    Calling C library functions with variable arguments.
* Overloading::           How Ctalk works with multiple method definitions.
* Variable method arguments:: 
                          Ctalk allows flexible argument lists.
* Method functions::      Methods that are called as C functions.
* Errors::                Exception and error handling.
* Cautions::              Precautions for using objects with C variables.
* Method keywords::       Ctalk keywords that apply to methods.
* Documentation::         Describing methods, classes, and variables 
                          in publicly visible comments.
* Ctalk library::         Library function reference.
@end menu
@end ifnottex


@node Method API, Self and super, , Methods
@iftex
@section Method Application Programming Interface
@end iftex
@ifnottex
@subheading Method Application Programming Interface
@end ifnottex
@cindex Method API

This section describes the C functions and macros that methods use to
interface with the Ctalk run time libraries and with each other.

At this point, the method API is still developing, and relies heavily
on C library functions.  

This example shows method @mnm{+} of class @code{Integer}, which
adds two Integer objects, creates an object for the result, and
returns the result.

@example
Integer instanceMethod + add (int i) @{

  OBJECT *op1, *op2;

  op1 = self value;
  op2 = i value;

  methodReturnInteger(atoi(op1->__o_value) + atoi(op2->__o_value))
@}
@end example

The keyword @code{self} refers to the receiver of the method.
@xref{Self and super}.

@cindex @mnm{value} method @idxclscite{Object}
The variables @code{op1} and @code{op2} are the @code{value} instance
variables of the receiver and the argument.  Ctalk has a method,
@mnm{value} (class @code{Object}), which returns the @code{value}
instance variable, but you can also refer to instance variables by
sending an instance variable's name as a message to an object.

Internally, the receiver, arguments, and return value of a method are
all @samp{OBJECT *}.  When you use C functions with objects, you use
the members of an OBJECT type, a @code{struct.}  (@xref{OBJECT
typedef}.)  If you declare an object as a C @code{OBJECT *,} then the
method uses it like any other C @code{struct *.}


All methods return an @samp{OBJECT *} as the result.  The macro
@code{methodReturnInteger} defines the object that the method
returns.  @xref{Return values}.

The @mnm{add} method is in @flnm{classes/Integer}.  The file
@flnm{include/object.h} contains the declaration of the @samp{OBJECT}
type.

@node Self and super, Class initialization, Method API, Methods
@iftex
@section @code{self} and @code{super}
@end iftex
@ifnottex
@subheading @code{self} and @code{super}
@end ifnottex
@cindex @code{self} keyword
@cindex @code{super} keyword

The keywords @code{self} and @code{super} refer to the method's
receiver object and a method in a superclass of the receiver's class,
respectively.

@cindex @mnm{+} method @idxclscite{Integer}
Refer to the method @mnm{+} (class @code{Integer}) from the previous
section.  If you call @mnm{+} with the statement below, @code{self} in
the @mnm{+} method would refer to @code{i.}

@example
j = i + 2;
@end example

The @code{super} keyword refers to a method in one of the superclasses
of the receiver.  It is commonly used in constructors. 

For example, if a class implements its own @mnm{new} method that
performs additional initialization for instances of a class, it can
also call @mnm{new} implemented by a superclass.  

@cindex @mnm{new} method @idxclscite{ReadFileStream}
@cindex @mnm{new} method @idxclscite{Object}
This constructor from the @code{ReadFileStream} method, @mnm{new}, also calls
@mnm{new} from class @code{Object.}

@example
ReadFileStream instanceMethod new (char *name) @{

  ReadFileStream super new name;

  __ctalkInstanceVarsFromClassObject (name);

  ReadFileStream classInit;
  
  return name;
@}
@end example

The first statement, @code{ReadFileStream super new name,} calls @mnm{new} from class
@code{Object} before performing its own initialization.

@node Class initialization, Prefixes, Self and super, Methods
@iftex
@section Class Initialization
@end iftex
@ifnottex
@subheading Class Initialization
@end ifnottex
@cindex Class initialization

Some classes that have class variables require initialization when
the program is run.  For example, class @code{ReadFileStream} needs
to have its class variable @code{stdinStream} set to the
application's @code{stdin} file stream before the program can read
from standard input.  

Classes that require initialization need to define a method,
@code{classInit}, which is called by a constructor when the first
object is created.  An example is the @code{ReadFileStream} method
@mnm{new} from the previous section.

Here is the @mnm{classInit} method for class @code{ReadFileStream}.

@example
ReadFileStream classMethod classInit (void) @{

  OBJECT *classObject,
    *stdinStreamVar,
    *classInitVar;
  char buf[MAXLABEL];

  if (self classInitDone)
    return NULL;

  classObject = __ctalkGetClass ("ReadFileStream");
  stdinStreamVar = __ctalkGetClassVariable ("stdinStream", TRUE);
  
  sprintf (buf, "%p", _IO_stdin);
  __ctalkSetObjectValueVar (stdinStreamVar, buf);

  __ctalkInstanceVarsFromClassObject (stdinStreamVar);
  stdinStream statStream;

  classInitVar = 
    __ctalkCreateObjectInit ("classInitDone", classObject -> __o_name,
				classObject -> __o_superclassname,
				classObject -> scope, "1");
  __ctalkAddInstanceVariable (classObject, "classInitDone", classInitVar);

  return NULL;
@}
@end example

A @code{classInit} method needs to be called only once.  The method
checks the @code{classInitDone} instance variable to determine the
method has already performed the initialization that the class needs.

@node Prefixes, Translating, Class initialization, Methods
@iftex
@section Overloading C Unary Operators
@end iftex
@ifnottex
@subheading Overloading C Unary Operators
@end ifnottex
@cindex @mnm{++} operator
@cindex @mnm{--} operator
@cindex @mnm{~} operator
@cindex @mnm{!} operator
@cindex @mnm{*} operator
@cindex @mnm{&} operator
@cindex @mnm{sizeof} operator

Methods can also overload C unary operators like @samp{*}, @samp{&},
@samp{!}, @samp{~}, and @samp{sizeof}.  For most unary operators, if
the class defines a method to overload the operator, then Ctalk uses
the method; otherwise, it treats the operator as a normal C operator.

Methods that overload unary operators contain the
@code{__prefix__} attribute in their declaration.  This
simplifies method writing considerably, because that allows
a class to define two different method @samp{*} methods, for
example, one a unary dereference operator, the other a
multiplication operator.

In the method's declaration, use the @code{__prefix__}
attribute in place of paramter declarations, as in this example.
@example
String instanceMethod * deref_prefix (__prefix__) @{
... Method statements here ...
@}
@end example

@cindex @mnm{sizeof} instance method @idxclscite{Object}
When Ctalk encounters a @samp{sizeof} operator, it checks whether the
argument is a Ctalk object, or a C variable or type cast expression.
If the argument is a C variable or type cast expression, then Ctalk
uses the C @code{sizeof} operator.  Otherwise, it uses the
@mnm{sizeof} method (@code{Object} class).  This method's
implementation is simple: it treats a Ctalk object as an @code{OBJECT
*}, and returns the size in bytes of a pointer on the system.  On
32-bit systems, the @mnm{sizeof} method always returns 4.  However,
you can overload the @samp{sizeof} operator in your own classes if
necessary.

You need to take care when using unary operators in complex
statements, due to the precedence of Ctalk's method messages.  In the
following highly experimental example, you would need to use
parentheses to specify the order of evaluation, because the expression
needs the result of @code{(*s) asString} to be a @code{String} also.
@example
String new s;
String new sFirstChar;
Character new c;
Integer new i;
s = "Hello, ";
sFirstChar = (*s) asString; 
@end example
@cindex @mnm{deref} instance method @idxclscite{Symbol}
@cindex @mnm{invert} instance method @idxclscite{Character}
@cindex @mnm{invert} instance method @idxclscite{Integer}
@cindex @mnm{invert} instance method @idxclscite{LongInteger}
Ctalk also provides postfix equivalents for many of these operators,
like @mnm{deref} (class @code{Symbol}) and @mnm{invert}
(@code{Character,} @code{Integer,} and @code{LongInteger} classes).

Ctalk can overload these operators even if the class defines a method
that uses the operator with an argument.  For example, the pointer
(@samp{*}) and unary minus (@samp{-}) operators can have different
methods than the methods that perform multiplication and
subtraction. 

The subject of method overloading is discussed further in its own section.
@xref{Overloading}.

@node Translating, C Macros, Prefixes, Methods
@iftex
@section Translating C Variables into Object Values
@end iftex
@ifnottex
@subheading Translating C Variables into Object Values
@end ifnottex
@cindex Method API
@cindex __ctalkDecimalIntegerToASCII

The @code{OBJECT} C data type that Ctalk uses internally stores 
objects' values as C @code{char *}'s. 
@xref{OBJECT typedef}.

To store numeric values, you must format them as character strings,
using, for example, @code{sprintf}.  In many cases, however, Ctalk
performs this translation automatically.

@code{Integer} objects can also translate values with @cite{atoi(3)}
or @cite{__ctalkDecimalIntegerToASCII}.  Other scalar data types have
corresponding functions that translate numbers to character strings.

If for some reason you need to translate an object to its C type or
back again, the Ctalk library provides the following functions.

@table @code
@cindex __ctalkToCArrayElement function
@item __ctalkToCArrayElement (OBJECT *@var{o})
Translate the value of an @code{Integer,} @code{Character,}
@code{String,} or @code{LongInteger} array element to a @code{void *}
that points to its corresponding C data type.

@cindex __ctalkToCCharPtr function
@item __ctalkToCCharPtr (OBJECT *@var{o}, int @var{keep})
Translate the value of a @code{String} object into a C @code{char *.}
If @var{keep} is @code{FALSE}, delete @var{o}.

@cindex __ctalkToCIntArrayElement function
@item __ctalkToCIntArrayElement (OBJECT *@var{o})
Translate the value of an @code{Integer} array element to an
@code{int.}

@cindex __ctalkToCInteger function
@item __ctalkToCInteger (@code{OBJECT *}@var{o}, @code{int} @var{keep_object})
Translate the value of an @code{Integer} to an @code{int.}  If
@var{keep_object} is @code{FALSE,} then delete the object.

@cindex __ctalkToCLongInteger function
@item __ctalkToCInteger (@code{OBJECT *}@var{o}, @code{int} @var{keep_object})
Translate the value of an @code{Integer} to a @code{long int.}  If
@var{keep_object} is @code{FALSE,} then delete the object.

@cindex __ctalk_to_c_char_ptr function
@item __ctalk_to_c_char_ptr (OBJECT *@var{o})
Translate the value of a @code{String} object into a C @code{char *.}
Note: This function is being phased out.  Use @cite{__ctalkToCCharPtr ()},
above, instead.

@cindex __ctalk_to_c_double function
@item __ctalk_to_c_double (OBJECT *@var{o})
Translate the value of a @code{Float} object into a C @code{double.}

@cindex __ctalk_to_c_int function
@item __ctalk_to_c_int (OBJECT *@var{o})
Translate the value of an @code{Integer} object into a C @code{int.}

@cindex __ctalk_to_c_longlong function
@item __ctalk_to_c_longlong (OBJECT *@var{obj}, int @var{keep})
Translate the value of a @code{LongInteger} object into a C @code{long
long int.}  If @var{keep} is non-zero, does not delete @var{obj}, or,
in compound expressions that need to interface with C variables, (like
complex if-statement conditionals), whether to delete the library's
internal C variable registrations.

@cindex __ctalkCallerPrintOnSelf (@code{char *}@var{fmt_arg})
Formats the arguments of the second-most calling method and
prints them on the receiver.  This function is meant to be used
within a method that is called by another method.  One method that
uses this function is @code{String : vPrintOn}.  Refer to
@code{String : vPrintOn} for an example of this function's use.
@xref{vPrintOn--class String}

@cindex __ctalkCBoolToObj function
@item __ctalkCBoolToObj (bool @var{b})
Create a @code{Boolean} object with the boolean (either true or false)
value of the argument.

@cindex __ctalkCCharPtrToObj function
@item __ctalkCCharPtrToObj (char *@var{s})
Create a @code{String} object with the value @var{s}.

@cindex __ctalkClassLibraryPath function
@cindex Class library search path
@cindex Search path, classes
@cindex @samp{CLASSLIBDIRS} environment variable
@item __ctalkClassLibraryPath (void)
Return a @code{char *} containing the directories that Ctalk
searches for class libraries.  When compiling programs Ctalk
searches first for directories given as arguments to the
@samp{-I} option, then directories given by the
@code{CLASSLIBDIRS} environment variable, then the standard
class library directory which is defined when Ctalk is
built.  In addition, for each directory, if a subdirectory named 
@flnm{ctalk} exists, then Ctalk searches that subdirectory also.

The standard library directory defaults to
@flnm{/usr/local/include/ctalk}, although if you define a
different @samp{--prefix} when building and installing
Ctalk, the class libraries will be located in
@var{prefix}@code{/include/ctalk}.

If it is necessary to look up class libraries at run time,
Ctalk first searches the directories listed by the
@code{CLASSLIBDIRS} environment variable, then the default
class library directory mentioned above.

@cindex __ctalkClassSearchPath function
@item __ctalkClassSearchPath (void)
A synonym for @cite{__ctalkClassLibraryPath()}, above.

@cindex __ctalkCDoubleToObj function
@item __ctalkCDoubleToObj (double @var{f})
Create a @code{Float} object with the value @var{f}.

@cindex __ctalkCIntToObj function
@item __ctalkCIntToObj (int @var{i})
Create an @code{Integer} object with the value @var{i}.

@cindex __ctalkCLongLongToObj function
@item __ctalkCLongLongToObj (long long int @var{l})
Create a @code{LongInteger} object with the value @var{l}.

@cindex __ctalkCSymbolToObj function
@item __ctalkCSymbolToObj (@code{unsigned int} @var{label})
Create a @code{Symbol} object with the value that is the address of
@var{label}.  This is used for expressions where a function name
appears by itself, for example.  In that case, the result is a
@code{Symbol} object with the address of the function.

@end table

The functions that create objects give the objects the scope of the
function call, either global or local.

@emph{Note:} In future versions of Ctalk, the names of these functions
are likely to change.

@node C Macros, Required classes, Translating, Methods
@iftex
@section C Macros
@end iftex
@ifnottex
@subheading C Macros
@end ifnottex
@cindex @flnm{ctalkdefs.h} include file
@cindex Macro definitions

Ctalk also provides many macros that help standardize the Ctalk-to-C
conventions.  They're defined in the @flnm{ctalkdefs.h} include file.
To use them, include @flnm{ctalkdefs.h} in a source file or class library.

@example

#include <ctalk/ctalkdefs.h>

@end example

Some of the macro definitions in @flnm{ctalkdefs.h} are described here.

@table @code

@anchor{ARG macro}
@cindex @code{ARG} macro
@item ARG
With a numeric argument, retrieves the n'th method or template
argument from the stack; i.e., @code{ARG(0)} refers to the first
argument on the stack, @code{ARG(1)} retrieves the second argument,
and so on.

@cindex @code{CLASSNAME} macro
@anchor{CLASSNAMEMacro}
@item CLASSNAME
Returns an object's classname.

@emph{Note:} You should use this macro in new code.  While typing
@code{__o_classname} directly with an @code{OBJECT *} should work for
a while, it's going to be phased out.

Using __o_classname with an object and the @mnm{->} method is still
okay, though.  For example:

@example

  OBJECT *myObjRef;
  String new myString;

  /* The use of __o_classname as struct member is going away... */
  myObjRef -> __o_classname;
  /* Instead, write this. */
  myObjRef -> CLASSNAME;

  /* These are still okay, because -> is a method, not the C operator. */
  myString -> __o_classname;
  self -> __o_classname;

  /* The same is true for the SUPERCLASSNAME definition. */

  SUPERCLASSNAME(myObjRef);

  self -> SUPERCLASSNAME;
  myString ->  SUPERCLASSNAME;
@end example

@cindex @code{FILEEOF} macro
@item FILEEOF
Writes an fEOF to the @code{char *} buffer given as its argument.

@cindex @code{FMT_0XHEX} macro
@item FMT_0XHEX
When used with a function like @cite{sprintf ()}, formats a pointer into its
string representation.  For example:

@example

char buf[64];
OBJECT *my_object_ptr;

....   /* Do stuff. */

sprintf (buf, FMT_0XHEX(my_object_ptr));

@end example

However, this macro is not very portable and using functions that use
stdargs (e.g., printf, scanf, etc.) can be cumbersome.  Library
functions like @cite{__ctalkGenericPtrFromStr ()}
@xref{ctalkGenericPtrFromStr}, and @cite{__ctalkFilePtrFromStr ()}
@xref{ctalkFilePtrFromStr}, might be faster and more reliable.


@cindex @code{IS_OBJECT} macro
@item IS_OBJECT
Returns True or False if its argument, a C pointer, refers to a valid
object.

@cindex @code{IS_VALUE_INSTANCE_VAR} macro
@item IS_VALUE_INSTANCE_VAR
Returns True or False if its argument, a C pointer, refers to the
value instance variable of an object.

@cindex @code{MEMADDR} macro
@item MEMADDR
Casts its operand to a @code{void **}, which is what Ctalk's
internal function @cite{__xfree ()} uses when freeing memory.
Normally you should use __ctalkFree () to free memory, but
the MEMADDR macro is here in case you want to call __xfree ()
directly.  Refer to the entry for __ctalkFree () for details.
@xref{ctalkFree}.

@cindex @code{STR_0XHEX_TO_PTR} macro
@item STR_0XHEX_TO_PTR
Does the converse of @code{FMT_0XHEX;} it converts the string
representation of a pointer into an actual pointer, when used with a
function like @cite{sscanf ()}.  For example:

@example

OBJECT *my_object;
OBJECT *my_object_ptr;

sscanf (my_object -> __o_value, STR_0XHEX_TO_PTR(my_object_ptr));

@end example

Again, using stdargs functions can be cumbersome and not very
portable.  In many cases, @cite{__ctalkObjValPtr ()} accomplishes
the same thing. @xref{ctalkObjValPtr}.

@cindex @code{SUPERCLASSNAME} macro
@item SUPERCLASSNAME
Returns an object's superclass name.  This macro should be used only
with OBJECT *'s, as it is rather extensive and written in C.  Returns
an empty string if the object doesn't have a
superclass. @xref{CLASSNAMEMacro}, above.

@cindex @code{__LIST_HEAD} macro
@item __LIST_HEAD(List *l)
When given an argument that is a collection like a @code{List} object,
returns the first member of the collection.

@cindex @code{STR_IS_NULL} macro
@item STR_IS_NULL(char *s)
Evaluates to True if the @code{char *} argument evaluates to zero;
i.e., its value is @samp{(null)}, @samp{0}, @samp{0x0} or the
first character is an ASCII @code{NUL} (@samp{\0}) byte.

@end table


@node Required classes, Scoping, C Macros, Methods
@iftex
@section Required Classes
@end iftex
@ifnottex
@subheading Required Classes
@end ifnottex
@cindex @code{require} keyword

The keyword @code{require} tells @command{ctalk} to preload the class
given as its argument before any other classes or methods.

The following lines appear in the @flnm{ctalklib} library.

@example
require Object;
require Symbol;
require String;
@end example

These statements tell @command{ctalk} to first load the @code{Object}
class and its methods, and then load the class @code{Symbol} and its
methods, and then class @code{String.}  Ctalk loads the class and its
methods at that point in the program, before further processing of the
source file.

The @code{require} keyword always occurs in a global scope; that is,
outside of any method or function.

@node Scoping, Templates, Required classes, Methods
@iftex
@section Scope of Objects
@end iftex
@ifnottex
@subheading Scope of Objects
@end ifnottex
@cindex Scope of objects

In Ctalk, an object can have a number of different scopes,
and Ctalk implements many more scopes for objects than for C
variables.  

All of the scopes are available when creating and modifying
objects.  In practice, however, you should only need to use
a few of them.  Ctalk uses many of the scopes internally.

These are the scopes that Ctalk implements.

@table @code
@item GLOBAL_VAR
An object that is declared globally; that is, outside of any
function or method.
@item LOCAL_VAR
An object declared within a function or method.
@item ARG_VAR
An object derived from a C function argument that is used
within a Ctalk expression.  This scope is normally used
only internally.
@item RECEIVER_VAR
An object created internally for receiver objects that do
not already have objects.  Ctalk assigns RECEIVER_VAR
objects C constants and constant expressions when they are
used as receivers.
@item PROTOTYPE_VAR
Used by the front end when evaluating objects that are
declared as method parameters.
@item CREATED_PARAM
Used mainly for temporary objects that are derived from
C constants that are arguments to methods and functions.
@item CVAR_VAR_ALIAS_COPY
Used for temporary and non-temporary objects that are
created from C variables.
@item CREATED_CVAR_SCOPE
This is a combination of CVAR_VAR_ALIAS_COPY|LOCAL_VAR scopes.
Used for C variable objects that are only needed for the duration
of an expression.  Also used for other values that aren't needed 
after an expression has been evaluated, like boolean method
return values.
@item SUBEXPR_CREATED_RESULT
Used internally for temporary objects that are the results
of subexpressions.
@item VAR_REF_OBJECT
Used for objects that are referred to by other objects;
for example an object referred to by a @code{Symbol} object
may have this scope set.
@item METHOD_USER_OBJECT
This scope is used mostly internally for objects that are
returned by methods and saved as method resources.
@item TYPECAST_OBJECT
Used internally for temporary objects that are derived from
C type cast expressions.
@end table
@cindex __ctalkSetObjectScope function
@cindex __ctalkCreateObjectInit function
@cindex __ctalkCreateObject function
You set a new object's scope with the
@cite{__ctalkCreateObject} or @cite{__ctalkCreateObjectInit}
functions.  To change an existing object's scope, use the
@cite{__ctalkSetObjectScope} library function to set an
object's scope.  

Even though you can set an @code{OBJECT *}'s @code{scope}
directly, using these functions insures that the object and
all of its instance variables maintain the same scope.

When creating an object with a function like
@cite{__ctalkCreateObjectInit}, you can declare a scope directly.
@example
result = __ctalkCreateObjectInit ("result",  
                                  "Symbol", "Object",
                                  LOCAL_VAR, "0x0");
@end example
When altering the scope of an existing object, however, you
should add or subtract only that scope from the object's
existing scope.

For example, to add a @code{VAR_REF_OBJECT} scope to an object:
@example
__ctalkSetObjectScope (object, object -> scope | VAR_REF_OBJECT);
@end example
To remove the scope, use an expression like this.
@example
__ctalkSetObjectScope (object, object -> scope & ~VAR_REF_OBJECT);
@end example

For values of integral classes like @code{Integer}, @code{LongInteger}
or @code{Symbol}, @code{__ctalkCreateObjectInit} tries to convert the
@var{value} parameter to its numeric value.  It the function can't
figure out a way to convert the argument to its numeric value, it
issues a warning message.

@example

ctalk: can't convert d to an int.

@end example

In these cases (and in many others) it is easier to simply use an
empty string as the final parameter and then fill in the value
after the object is created, as in this example (assuming that the
object is an @code{Integer})..

@example

result = __ctalkCreateObjectInit 
  (INTEGER_CLASSNAME, INTEGER_SUPERCLASSNAME, LOCAL_VAR, "");
*(int *)result -> __o_value = int_value;
*(int *)result -> instancevars -> __o_value = int_value;

@end example

@cindex INTVAL macro
@cindex LLVAL macro
@cindex SYMVAL macro
In this case, the INTVAL, LLVAL, and SYMVAL macros can help make the
expression more readable, depending on whether the new object is an
@code{Integer}, @code{LongInteger}, or @code{Symbol}.

@example

INTVAL(result -> __o_value) = int_value;
INTVAL(result -> instancevars -> __o_value) = int_value;

@end example

@node Templates, Return values, Scoping, Methods
@iftex
@section Templates
@end iftex
@ifnottex
@subheading Templates
@end ifnottex
@cindex Templates

@emph{Templates} are simplified methods that are defined as macros and
written in C.  They provide a method-compatible wrapper to C
functions.

Template methods can appear in place of C functions in complex
expressions, and they must be used if a C function writes to its
arguments (e.g., like @cite{scanf(3)} or @cite{sscanf(3)}).  For
example, if we have a template defined for the function
@code{myPrintMsg}, then Ctalk subsitutes the method expression
wherever @code{myPrintMsg} appears in an expression like this one.

@example

  if ((myInt = myPrintMsg (someMsg)) != 0) @{
     @emph{... do something...}
  @}

@end example

After compilation, the expression looks like this.

@example

  if ((myInt = CFunction cMyPrintMsg (someMsg)) != 0) @{
     ...

@end example

You can also use @code{myPrintMsg} on the left-hand side of an assignment,
like this.

@example

  myInt = myPrintMsg (someMsg);

  @emph{-or-}

  self = myPrintMsg (someMsg);

@end example

Additionally, you can use templates on their own, by prefacing the
method's name (the template function's alias) with its class object.

@example

  CFuntion myPrintMsg (someMsg);

@end example

@cindex @code{CFunction} class
As the last example implies, templates are class methods in the
pseudo-class @code{CFunction}.  Ctalk loads and caches templates where
necessary when compiling the input file, so you won't see any methods
of the @code{CFunction} class unless the program calls for one or more
of them.

If the template wraps a C function of the same name, then, of course,
you can also use the C function on its own.  However, templates don't
necessarily need to correspond to a C function; they can provide any
set of C expressions with a method compatible interface.

Ctalk defines a number of built-in templates for the standard C
library.  You can determine if Ctalk substitutes a template for a C
function by giving the @code{--printtemplates} option to
@command{ctalk} when it compiles a source file.  This displays the
templates that the compiler loads and caches (but doesn't necessarily
send to the output).

You can define templates for application-specific C functions and
routines also.  Ctalk retrieves and caches them similarly to its
built-in templates, but they are cataloged and stored separately in
each user's @flnm{~/.ctalk/templates} directory.

As mentioned above, templates don't need to wrap a function of the
same name as the template.  That is, @code{myPrintMsg}, above, does not
have to be an actual function (although you need to prototype it that
way).  Templates for C library functions always correspond to an
actual library function.  Program specific templates can serve as a
wrapper for any function or set of routines.

When compiling templates, the Ctalk compiler checks the user template
registry first.  If a user defines a template with the same name as
one of Ctalk's C library templates, then the compiler uses the user's
template instead of Ctalk's built-in template.  That means you can
define a template that replaces a C library template.

When creating a template for a function, you need to follow these
steps.

@itemize
@item
Add a prototype of the function to the input file. For example:

@example

  OBJECT *myPrintMsg (char *text);

@end example

Ctalk uses the prototype's argument list to check the number and
type of arguments.  The prototype's argument list must be the same
as the template's argument list.

@item
Check that any terms in the expression before and after the template
are compatible.  Ctalk can in most cases distinguish between objects
and C variables in expressions.  Ctalk will try to warn you if it sees
a mixed object/variable expression it can't handle.  If an expression
causes an error, try breaking it into smaller pieces, with objects and
methods in one set of terms, and C variables and operators in another.
Also, try making the template function the first term in the
expression (or the first term after an assignment operator).  This
expression, for example, is relatively easy to handle because
everything that follows the template is normal C code.

@example

myFloat = rand () + 0.33 + (float)my_dbl;

@end example


@cindex @code{template} command
@item
Write a template for the function, and add it to the local directory's
template cache with the @command{template} command. The following
sections describe the format that templates use.
@end itemize

@subheading Writing Templates

Templates are basically multiple line macros that provide a method
selector and method body in a #define preprocessor statement.  When
Ctalk finds a function name that has a template defined for it, it
subsitutes the template name for the function name in the expression,
adds the template's body to the output, and adds the template to the
CFunction classes' initialization.

Templates can accept arguments similarly to methods, and, like
methods, they return a C @code{OBJECT *}, or NULL.

Here is the template for the @cite{myPrintMsg()} C function.  The
template provides a wrapper for the @cite{printf(3)} function, and,
like @cite{printf(3)}, returns an integer value (as an @code{Integer}
object).  The template contains a few features that are part of the
template protocol.

@example

#define myPrintMsg \n\
cMyPrintMsg (char *text) @{\n\
  char buf[255]; \n\
  int result; \n\
  OBJECT *objresult; \n\
  if (__ctalkIsObject(ARG(0))) @{\n\
    result = printf ("myPrintMsg: %s\n", \n\
                      __ctalkToCCharPtr(ARG(0), 1)); \n\
    __ctalkDecimalIntegerToASCII (result, buf); \n\
    return __ctalkCreateObjectInit ("result", "Integer", \n\
                                    "Magnitude", LOCAL_VAR, buf); \n\
  @} else @{ \n\
    __ctalkDecimalIntegerToASCII (-1, buf); \n\
    objresult =  __ctalkCreateObjectInit ("result", "Integer", \n\
                                    "Magnitude", LOCAL_VAR, buf); \n\
    __ctalkRegisterUserObject (objresult); \n\
    return objresult; \n\
  @}\n\
@}

@end example

@itemize
@item
The template embeds newlines with the string @samp{\n\}.  When the
template is preprocessed, this expression joins the lines of the
template but keeps the line endings intact.
@item
The method selector, @samp{cMyPrintMsg} is built from the function name
(@samp{myPrintMsg}) by uppercasing the first letter and prepending a
@samp{c} to it.
@item
The template must declare its arguments, like the @samp{char *text}
declaration above, even though the actual arguments are objects, as
described in the next item.
@cindex @code{ARG} macro
@item
The expression @code{__ctalkIsObject(ARG(0))} checks that the
argument to the template is a valid object.  You can acccess
the template's arguments with the @code{ARG} macro.  The first
argument is @code{ARG(0)}, the second argment is @code{ARG(1)},
and so on.
@item
The function, @cite{__ctalkToCCharPtr()} translates the argument
object into a @code{char *} string that @cite{printf(3)} expects as
its argument.  
@idxlibfn{__ctalkCreateObjectInit}
@item
Normally templates create a return object manually, using the API function
@cite{__ctalkCreateObjectInit ()} or a similar function.  Note that
@cite{__ctalkCreateObjectInit ()} uses a @code{char *} to store the
value of the object, which is why many templates declare a buffer for
the C function's result and use __ctalkDecimalIntegerToASCII ().  If
the result is more complex, then the template might need to format it
with a function like @cite{sprintf (3)}.  Templates can also return
NULL, but if a program uses such a templated function in an assignment
statement, it causes a program to generate a NULL argument object
warning when the program is run.
@item
Whenever a method returns an object it creates, it should register the
object, for example by calling @cite{__ctalkRegisterUserObject} as in
the template above.  That way Ctalk can either maintain the object or
clean it up when it needs to be deleted.  This function call is
optional, but omitting it may cause memory leaks when the program is
run.
@item
A template can use macros, like @code{LOCAL_VAR}.  The most convenient
way to define macros is to @samp{#include <ctalk/ctalkdefs.h>}
somewhere in the input.  Many classes already do this, and the
template can use the same set of macro definitions as the class
libraries.

@end itemize

@subheading Cataloging Templates

When looking up templates, Ctalk looks in the template registry file,
which is normally @flnm{~/.ctalk/templates/fnnames} for the name
given in the input.  If the function is aliased to another name by
a macro substitution, @flnm{fnnames} contains the name of the alias
also.  

For example, on some systems, the function @cite{getc(3)} is a macro
that expands to @samp{_IO_getc}.  The @flnm{fnnames} file would then
contain @samp{_IO_getc} as the templated function's name.

When the compiler finds the function's name or alias in @flnm{fnnames},
it looks in the directory for the template file, which is named for
the first letter of the function's name.  That is, when looking for
@code{myPrintMsg's} template, Ctalk looks for a file named
@flnm{~/.ctalk/templates/m}.

The C library templates that come with Ctalk use the same scheme,
except that the template files are stored in a subdirectory of
the class library called @flnm{libc}.  The registry is part
or the run-time library, so C library templates do not need a
separate registry file.

The manual page, @cite{fnnames(5ctalk)} contains more information
about the @flnm{fnnames} file.  The @cite{templates(5ctalk)} manual
page describes the format of individual templates.

@node Return values, Variable arguments, Templates, Methods
@iftex
@section Return Values
@end iftex
@ifnottex
@subheading Return Values
@end ifnottex
@cindex @code{returnObjectClass}

Internally, methods return either an @code{OBJECT *} or
@code{NULL}.  If you write a method that returns a C
variable, Ctalk normally translates it into an equivalent
object.  

Methods that return arrays declared in C generally assign
the C array to an equivalent @code{Array} object.  The
@code{Array} object's size is the same as the array
declaration, regardless of how it the array's members are
initialized.  

The @code{Array} allocation only occurs for
arrays declared with a subscript; that is, a variable
declared as @code{int *} is not always stored in an
@code{Array} object, while a variable declared as
@code{int[@var{size}]} is.

Ctalk treats C arrays declared as @code{char[@var{size}]} a
little differently.  If the method's definition says the
return class of the method is @code{Array}, then Ctalk
returns an @code{Array} of @code{Character} objects;
otherwise, it returns a @code{String} object.

Because Ctalk does not have equivalent classes for
multi-dimensioned arrays; that is, arrays with more than one
subscript, it does not translate the arrays automatically.
In these cases, the method might return a multi-dimensioned
array by assigning it to a @code{Symbol} object.

Occasionally, you might need to return the result of an
expression that Ctalk can't translate automatically.  In
that case, you can use the @code{eval} keyword to evaluate
the expression when the program is run, as in this example.
@example
MyClass instanceMethod myMethod (void) @{
  ...
  return eval <expression>
@}
@end example

If a method must create an object of its own to return, the object
should have the scope CREATED_PARAM, which tells the Ctalk libraries
that the the program only needs the object if it's the result of a
complete expression; if not, the program cleans up the object
automatically when it is no longer needed.  @xref{__ctalkRegisterUserObject}.

@example

return __ctalkCreateObjectInit ("myStringAnswer", "String",
                                "Character", CREATED_PARAM,
                                "The contents of the String object.");

@end example

@cindex __ctalkRegisterUserObject function
If the program needs to store a return object for longer than the
scope that the object is called in, the method can save the object in its
object pool with the library function __ctalkRegisterUserObject, which
is described below. @xref{__ctalkRegisterUserObject}.

@example

String instanceMethod myMethod (void) @{

  OBJECT *return_object; 

  @emph{... Do stuff. ...}

  return_object =  __ctalkCreateObjectInit ("myStringAnswer", "String",
                                "Character", CREATED_PARAM,
                                "The contents of the String object.");
  __ctalkRegisterUserObject (return_object);
  return return_object;

@}

@end example

@cindex __ctalkRegisterExtraObject function
Another case may be when a method needs to retrieve an
object reference.  In these cases, the method may need to
increase the object's reference count.  However, such a
method can also call @code{__ctalkRegisterExtraObject} to
save the object so its memory isn't lost later.  The
@code{__ctalkRegisterExtraObject} function does not, itself,
set the object's reference count, and it saves an object
(not copies of objects) only once.  

@iftex
@subsection Method Return Macros
@end iftex
@ifnottex
@subsubheading Method Return Macros
@end ifnottex
@anchor{Returning method values}

Alternatively, if a method needs to return an object of a
particular class, you can use the following
@code{methodReturn*} statements.  These are macros that
implement the statements to store and return objects
which represent different types or classes, like @code{ints}
as Integer objects, @code{doubles} as Float objects,
and so on.

These macros have been superseded in more recent versions of Ctalk,
which has the ability to insert the correct return code for any class
of object, and many C variables, functions, and expressions.  If the
compiler doesn't recognize some particular expression, however, these
macros may still be useful.

Remember that these return value functions are implemented
as macros and contain their own code block, so you can use
them in places where normal functions would cause a syntax
error.

@table @code

@cindex @code{methodReturnBoolean} macro
@item methodReturnBoolean (@code{int} @var{i})
Return a @code{Boolean} object that Ctalk can evaluate to @code{TRUE}
or @code{FALSE} depending on the value of its argument.
Mostly deprecated; an expression like, @code{"return TRUE"}
is equivalent.

@cindex @code{methodReturnFalse} macro
@item methodReturnFalse
Return a @code{Boolean} object that evaluates to @code{FALSE.}
Deprecated; using the expression, @samp{return FALSE;} has
the same effect.

@cindex @code{methodReturnInteger} macro
@item methodReturnInteger(@code{int} @var{i}) 
Return an @code{Integer} object with the value @var{i}.
Mostly deprecated; an expression like, @code{"return <int>"}
is equivalent.

@cindex @code{methodReturnLongInteger} macro
@item methodReturnLongInteger(@code{int} @var{l}) 
Return a @code{LongInteger} object with the value @var{l}.
Mostly deprecated; an expression like, @code{"return <longlongint>|<longint>"}
is equivalent.

@cindex @code{methodReturnNULL} macro
@item methodReturnNULL 
Returns the C value @code{NULL.} Deprecated; simply use the
expression, @samp{return NULL;} instead.

@cindex @code{methodReturnObject} macro
@item methodReturnObject(@var{object})
Return @var{object}. Deprecated; the expression,
@samp{return @var{object}} has the same effect.

@cindex @code{methodReturnObjectName} macro
@item methodReturnObjectName(@var{objectname})
Return the object referred to by @var{objectname}.  Also
deprecated; like @code{methodReturObject}, above, the
expression, @samp{return @var{object}} has the same effect.

@cindex @code{methodReturnSelf} macro
@cindex @code{self} keyword
@item methodReturnSelf
Returns the method's receiver, @code{self}.  Slightly
deprecated; simply using the statement, ``@code{return
self},'' has the same effect.

@cindex @code{methodReturnString} macro
@item methodReturnString(@code{char *}@var{s}) 
Return a @code{String} object with the value @var{s}.
Mostly deprecated; an expression like, @code{"return <char
*>|<string constant>"} is equivalent.

@cindex @code{methodReturnTrue} macro
@item methodReturnTrue
Return a @code{Boolean} object that evaluates to @code{TRUE.}
Deprecated; use the expression, @samp{return TRUE;} instead.

@end table

The macros that return objects use the
@cite{__ctalkRegisterUserObject} function to keep track of
method's return values, and, if necessary, other objects
that the method creates.  @xref{__ctalkRegisterUserObject}.

@node Variable arguments, Overloading, Return values, Methods
@iftex
@section Variable Arguments
@end iftex
@ifnottex
@subheading Variable Arguments
@end ifnottex
@cindex Variable arguments
@cindex @idxfncite{scanf(3)}
@cindex @idxfncite{sscanf(3)}
@cindex @idxfncite{fscanf(3)}

C functions like @cite{scanf(3),} @cite{sscanf(3),} and
@cite{fscanf(3)} have templates that allow you to call them
with a variable number of arguments.  

If you need to call other C functions that use variable arguments, 
you must call @code{__ctalkLibcFnWithMethodVarArgs} with the
name of the function, the method that contains the function's 
template, and the function's return class.  

The @mnm{readFormat} method (implemented in @code{String} and
@code{ReadFileStream} classes) can scan a string or input file into
the objects that the program gives as arguments.  The methods also
take care of scalar-to-object translation, memory allocation, and
several other tasks.

However, programs can also accomplish the same thing manually.

For example, here is the code of the template method for
@cite{fscanf(3),} @code{cFscanf} (@code{CFunction} class), without the
preprocessing directives.

@example
cFscanf (FILE *s, char *fmt,...) @{
  EXPR_PARSER *parser;
  OBJECT *result_object;
  parser = __ctalkGetExprParserAt (__ctalkGetExprParserPtr ());
  result_object =
    __ctalkLibcFnWithMethodVarArgs ((int (*)())fscanf, parser -> e_method, "Integer");
  return result_object;
@}
@end example

At run time, the @code{e_method} member of an expression parser
contains the method and its arguments.

The third argument of @code{__ctalkLibcFnWithMethodVarArgs} determines
the class of @code{result_object.}  For C library functions that use
variable arguments, the return class is @code{Integer.}

The typecast @code{(int (*)())} in the first argument in front of
@code{fscanf} is not strictly needed because we know that the number
and types of arguments to @cite{fscanf(3)} (or @cite{scanf(3)} or any
other variable-argument function) might vary from the
@code{__ctalkLibcFnWithMethodVarArgs} prototype, but it tells the
compiler not to print a warning message in that case.

@cindex @mnm{writeFormat} method @idxclscite{WriteFileStream}
@cindex @mnm{writeFormat} method @idxclscite{String}
@cindex @mnm{printOn} method @idxclscite{String}
@cindex @mnm{readFmt} method @idxclscite{String}
@cindex @mnm{readFmt} method @idxclscite{ReadFileStream}
If you simply need to print formatted output, the @mnm{writeFormat} or
@mnm{printOn} methods (implemented in @code{String},
@code{WriteFileStream} and many other classes classes) perform
format-argument translations automatically.  Several classes also
implement a @mnm{readFmt} method, which reads formatted input from a
@code{String} or @code{ReadFileStream}.  @xref{writeFormat--class
WriteFileStream}, and @ref{writeFormat--class String}.

@node Overloading, Variable method arguments, Variable arguments, Methods
@cindex Overloading methods
@cindex Method overloading
@iftex
@section Overloading Methods
@end iftex
@ifnottex
@subheading Overloading Methods
@end ifnottex

You can always implement a method in different classes.  For example, 
you can define a @samp{+} method in @code{Integer,} @code{LongInteger,}
@code{Character,} and @code{Float} classes, and Ctalk calls the 
method defined for that class of the receiver object.

Some operators also have methods implemented in a superclass, like
@code{Magnitude} in this case, which can provide any extra error
checking and processing that may be necessary, for example, if you try
to use a unary minus (@samp{-}) operator with a receiver like a
@code{Pen} or @code{Rectangle} object.

When you overload methods @emph{within} a class, however, Ctalk does
some extra checking. The compiler needs to examine the expression to
find out how many arguments the statement has, whether the operator is
a prefix operator, or whether the method's argument is a block of code
or a variable argument list, or whether the method uses a C calling
convention.

Ctalk can overload math operators when they are also used as prefix
operators.  Two examples of these are the unary minus (@samp{-}) and
pointer (@samp{*}) methods, which have different methods than the
operators that perform subtraction and multiplication. Writing methods
that are prefix operators is described above. @xref{Prefixes}.

@iftex
@subsection Overloading Parameters
@end iftex
@ifnottex
@subsubheading Overloading Parameters
@end ifnottex
@cindex Overloading parameters
@cindex Parameters, overloading

Exactly when you should write methods that overload things like
parameters and variable arguments is somewhat within the philosophy of
programming languages.  For example, a common use of method
overloading based on the number of parameters is the,
``getter/setter,'' type of method, which retrieves and sets an
object's private data.

In Ctalk, these are much less necessary than in other languages,
because Ctalk can address an object's private data with a message that
has the same name as an instance or class variable.  Since these
messages bind more tightly to receiver objects than messages that
refer to methods, these types of methods might not work the way you
think they would.  So be sure that if you write a method of this type,
that the program is actually using a method message, and not an
instance data message.

Here is an example of overloading parameters.  Because the
@code{String} class already has a @mnm{concat} method (it overloads
the @samp{+} operator), we overload the method, @mnm{myConcat,} to
concatenate one or two strings to the receiver.

As long as the program is relatively simple, it's easy to keep track
of which methods already exist in a class.  In a bigger application,
though, you might want to define a subclass of @code{String} class for
this program.

@c test/expect/examples/overload1.c
@example

String instanceMethod myConcat (String s1) @{

  self = self + s1;

@}

String instanceMethod myConcat (String s1, String s2) @{

  self = self + s1 + s2;

@}

int main () @{
  String new s1;
  String new s2;
  String new s3;

  s1 = "Hello, ";
  s2 = "world! ";
  s3 = "Again.";

  s1 myConcat s2;
  printf ("%s\n", s1);
  
  s1 myConcat s2, s3;
  printf ("%s\n", s1);

@}

@end example

We should mention that the @mnm{myConcat} method changes its receiver.
So the arguments to the second @mnm{myConcat} message simply get added
to the receiver again.  The output should look something like this.

@example
Hello, world!
Hello, world! world! Again.
@end example

@node Variable method arguments, Method functions, Overloading, Methods
@iftex
@section Variable Method Arguments
@end iftex
@ifnottex
@subheading Variable Method Arguments
@end ifnottex

Ctalk supports variable arguments lists for methods that follow the
@code{stdarg.h} format for argument lists, where the argument assigned
to the last named parameter determines the number and type of the
following arguments. (The manual page @cite{stdarg (3)} has more
details.)

@example

  String instanceMethod writeFormat (char *fmt, ...)

@end example

In addition, Ctalk supports argument lists with @emph{no} named
parameters.  To implement this, Ctalk interprets an ellipsis as a
variable argument list, as usual.  It is then up to the method to
interpret the arguments as they appear on Ctalk's argument stack.

For this task, the @cite{__ctalkNArgs} library function returns
the number of arguments that the run-time libraries place on
the stack.  The method can then interpret these arguments
as necessary.

@cindex @mnm{=} instance method @idxclscite{List}
Here is the slightly abbreviated code for the @code{List} : @mnm{=}
method, which should help illustrate this. @xref{List}.

@example

List instanceMethod = initEQ (...) @{
  int n, i;
  OBJECT *arg;

  self delete;         /* Start with an empty List. */
  n = __ctalkNArgs ();

  for (i = (n - 1); i >= 0; --i) @{
    arg = __ctalk_arg_internal (i);
    self push arg;
  @}
@}

@end example

@node Method functions, Errors, Variable method arguments, Methods
@iftex
@section Method Functions
@end iftex
@ifnottex
@subheading Method Functions
@end ifnottex

@cindex @code{SigHandler} class
Occasionally an application needs to call a method as a function.  One
example of this is a @code{SignalHandler} method that the program
installs as the handler for signals from the operating system.

Methods that use a C calling convention need to do several things
differently than normal methods.
@itemize
@item 
The method needs to use a C variable as its argument.
@item
Because the method can be called with no receivers, Ctalk does not 
perform any of the normal initialization of local and parameter
objects.
@item
The method body needs to be written almost entirely in C.
@end itemize

@cindex @code{__c_arg__} attribute
In order to make Ctalk interpret a method parameter as a C variable, the
method must declare the parameter with the @code{__c_arg__} attribute.

@emph{Note:} C functions that are called by the operating system
generally need only one argument, and the @code{__c_arg__} attribute
only works for methods with a single parameter.

@cindex @code{noMethodInit} keyword
Additionally, to prevent Ctalk from adding local object initialization
code to the method, the method must contain the @code{noMethodInit}
keyword. 

Here is an example of a method that is used as a signal handler, and
installed by the statements in @code{main.}
@example
SignalHandler instanceMethod myHandler (__c_arg__ int signo) @{
  noMethodInit;
  printf ("sigInt handler! Signal %d.\n", signo);
  return NULL;
@}

int main () @{

  SignalHandler new s;

  s setSigInt;
  s installHandler myHandler;
@}
@end example

@cindex @mnm{setSigInt} method @idxclscite{SignalHandler}
The @mnm{setSigInt} method (class @code{SignalHandler}) tells the
@code{SignalHandler} object @code{s} that it is going to handle
@code{SIGINT} signals.  @xref{SignalHandler}, for the other signals
that the class can handle.

The @code{__ctalkNewSignalEventInternal} function can generate and
queue @code{SignalEvent} objects, so the signal handler does not need
to create objects in order to send signal events to the application.
@xref{__ctalkNewSignalEventInternal}.

@subsubheading Including C Header Files

Often you will need to use C functions and data types in 
method functions.  However, you need to take care that 
if you include a C header file,  it might not be included
later on if a class library requires that file.  

Normally Ctalk includes whatever C definitions it needs in
the class libraries.  However, that can cause the preprocessor
to omit those definitions from another source file, should
the definitions be needed later.  

For example, in the method @mnm{handleSignal}, from the 
@flnm{timeclient.c} program,  the method needs the definition
of the @cite{time(2)} function.  If you were to @code{#include} 
@flnm{time.h} in the input, as in this example, then @flnm{time.h}'s 
definitions would not be included in the @code{CTime} class later on. 
@example
#include <time.h>    /* Could cause errors later. */

SignalHandler instanceMethod handleSignal (__c_arg__ int signo) @{
  time_t t;
  char buf[MAXLABEL];
  noMethodInit;
  t = time (NULL);
  __ctalkDecimalIntegerToASCII (t, buf);
  __ctalkNewSignalEventInternal (signo, getpid (), buf);
  return NULL;
@}
@end example

The best way to avoid omitting dependencies is to include only
the definitions that the method needs.  In this case, you can 
include the prototype of @cite{time(2)} in the source file.
@example
extern time_t time (time_t *__timer) __THROW;  /* From time.h. */

SignalHandler instanceMethod handleSignal (__c_arg__ int signo) @{
  time_t t;
  char buf[MAXLABEL];
  noMethodInit;
  t = time (NULL);
  __ctalkDecimalIntegerToASCII (t, buf);
  __ctalkNewSignalEventInternal (signo, getpid (), buf);
  return NULL;
@}
@end example

The @code{time_t} type is defined with @flnm{ctalklib}, and is 
available to all programs.

How to resolve multiple library definitions depends on the 
system's header files, and may vary between different operating
systems or compiler versions.

@node Errors, Cautions, Method functions, Methods
@iftex
@section Exception and Error Handling
@end iftex
@ifnottex
@subheading Exception and Error Handling
@end ifnottex
@cindex Exceptions
@cindex Errors
@cindex Warnings

There are two ways to handle error conditions in Ctalk.  You can
simply print an error or warning message in your code.  An error
message formats the text and data that you provide, the same as in a
@code{printf} statement, and then exits the program.  Here is an
example.
@example
_error ("Program exited with code %d.\n", result_code);
@end example

A @code{_warning} message is similar, but it prints the message and
continues processing.  @xref{errorfuncs}.

The other way to handle errors is with exceptions.  This is the method
you need to use if an error occurs within a method, and the program
needs either to print a warning message, or exit.

@cindex @mnm{pending} method @idxclscite{Exception}
@cindex @mnm{handle} method @idxclscite{Exception}
There are two methods of class @code{Exception} that handle exceptions
in application programs: @mnm{pending} and @code{handle.}  There are
also other API functions, but they are mostly used internally to
translate exceptions into events that application programs can use.

These two methods are generally used together.  The method
@mnm{pending,} if it returns @code{TRUE,} signals that there is an
exception pending.  Then the function @code{handle} handles the event
by executing an exception handler.

Generally, events simply issue error messages.  It is up to you to
determine how the program should handle the exception: by exiting,
trying the procedure again, ignoring the condition, or some other
procedure.  Here is an example.

@example
Exception new e;
...
inputStream openOn fileArg;
if (e pending) @{
   e handle;
  exit (1);
@}
if (inputStream isDir) @{
  printf ("Input is a directory.\n");
  exit (1);
@}
@end example
This is simply the way that Ctalk notifies the application if the
method @code{openOn} (class @code{ReadFileStream}) encountered an
error while opening the file named by its argument, @code{fileArg.}

@cindex @mnm{isDir} method @idxclscite{FileStream}
You should note that the program also checks whether the input is
actually a directory, because opening a directory as if it were a file
does not necessary cause an error condition.  The @mnm{isDir} (class
@code{FileStream}) method is one portable way to check if the input path
is actually a directory.

@cindex @mnm{raiseException} method @idxclscite{SystemErrnoException}
The method @mnm{openOn,} like other methods, raises an exception if
necessary.  It does this with @mnm{raiseException} (class
@code{SystemErrnoException}).

@cindex @code{errno} macro
Ctalk handles most @code{stdio} error codes in this manner.  A program
that uses the @code{ReadFileStream} and @code{WriteFileStream} classes
should rarely need to use the C library's @code{errno} macro, but it
is still available if applications need to check for other errors from
the C libraries.

The Ctalk library also provides exceptions for missing arguments,
undefined methods, and other error conditions. The file,
@flnm{include/except.h,} contains the definitions of Ctalk's
compile and run time exceptions.


@node Cautions, Method keywords, Errors, Methods
@iftex
@section Cautions when Using Arguments with C Library Calls
@end iftex
@ifnottex
@subheading Cautions when Using Arguments with C Library Calls
@end ifnottex

The interface for C functions is in development.  You can use a C
function in a simple expression with any argument, as in the following
example.

@example
op1 = __ctalkGetInstanceVariableByName ("self", "value", TRUE);
@end example

However, if you want to use a C function in a complex expression, then
you must take care that the arguments to the function are C values
that correspond to a Ctalk class, unless the function has a template
written for it in the class library that performs the translations of
specific classes and data types.  @xref{Templates}.

If you use a function in a method, and the compiler generates an,
``implicit declaration,'' warning, you can include the library
function's prototype in either the source file or in
@flnm{classes/ctalklib}.

@iftex
@section Cautions when using @code{Array} class elements in C expressions.
@end iftex
@ifnottex
@subheading Cautions when using @code{Array} class elements in C expressions.
@end ifnottex
@cindex @code{Array} class

If you want to use an @code{Array} element in a C expression, you need
to take care that the value of the element translates to a @code{void
*,} which is the C type that Ctalk returns the values of these
elements as.

That means elements of class @code{LongInteger} might be truncated, and 
@code{Float} class array elements cannot be translated in this manner.  

If array elements of these classes occur in C expressions, Ctalk
prints a warning at run time.

In these cases, it is necessary to convert the values to a compatible
pointer type, for example an object of class @code{String.}

@node Method keywords, Documentation, Cautions, Methods
@iftex
@section Method Keywords
@end iftex
@ifnottex
@subheading Method Keywords
@end ifnottex
@cindex Method keywords.

@table @code

@cindex @code{__c_arg__} attribute
@item __c_arg__
Treat the next method argument as a C argument.  @xref{Method functions}.

@cindex @code{classMethod} keyword
@item classMethod
The @code{classMethod} keyword declares a method, as described
above.

@cindex @code{classVariable} keyword
@anchor{ClassVariableKeyword}
@item classVariable 
Adds a class variable definition to a class.  This 
method needs to be used globally, when a class is declared.  
The syntax is:

@quotation
@var{parent_class} classVariable @var{name} [@var{native_class}|@var{typecast_expr}] [@var{initial_value}] [@var{docstring}] ;
@end quotation
For example:

@example
FileStream class ReadFileStream;
ReadFileStream classVariable stdin Symbol 0x0;
@end example

The value of @var{initial_value} can be either a constant or an
expression that evaluates to a constant.  

Ctalk can also translate a typecast into a native class  for the
variable.  Also refer to the entry for @mnm{instanceVariable}, below.
@xref{InstanceVariableKeyword}.

Similarly, the @var{docString} element is also optional.
@xref{VariableDocStrings}.

@cindex @code{eval} keyword
@item eval
Do not try to evaluate the following statement until run time.
Methods can use this keyword if they need to wait until run time to
determine an receiver's class and are not able to alias the object or
otherwise inform the front end of the receiver's class before the
program is run.

@cindex @code{instanceMethod} keyword
@item instanceMethod
The @code{instanceMethod} keyword declares a method, as described
above.

@cindex @code{instanceVariable} keyword
@anchor{InstanceVariableKeyword}
@item instanceVariable 
Adds an instance variable definition to a class.  This 
method needs be used when the class is declared.  The syntax is:

@quotation
@var{parent_class} instanceVariable @var{name} [@var{native_class}|@var{typecast_expr}] [@var{initial_value}] [@var{docString}] ;
@end quotation

For example:

@example
FileStream class ReadFileStream;
ReadFileStream instanceVariable pos LongInteger 0L;
@end example

The value of @var{initial_value} can be either a constant or an
expression that evaluates to a constant.

You can also use a typecast in place of the variable's @var{native_class.}
Ctalk can translate most builtin C types or typedefs to a class, but
for less common data types, Ctalk will translate a pointer to the type
as a Symbol object.

Similarly, the @var{docString} element is also optional.
@xref{VariableDocStrings}.

Note that the @mnm{instanceVariable} method does not @emph{create} any 
variables.  Ctalk only creates instance variables for each object when 
it receives a constructor message (e.g., @mnm{new}) by a program.

@cindex @code{noMethodInit} keyword
@item noMethodInit
Do not include method initialization code for the method.
@xref{Method functions}.

@cindex @code{require} keyword
@item require
Require a class to be loaded before any other classes or methods.

@cindex @code{returnObjectClass} keyword
@item returnObjectClass
Set the return class of a method to the argument if it is different
than the receiver class. @xref{Return values}.

@cindex @code{self} keyword
@item self 
Return the method's receiver object.  In version
@value{VERSION}, you can also use @code{self} in arguments as a 
synonym for the receiver of the statement, as in this example.
@example
String new path;
path = "/home/user/joe";

printf ("%s", path subString 1, self length - 1);
@end example

The use of @code{self} in method arguments is experimental in version
@value{VERSION}, and it should be used with caution.

@cindex @code{super} keyword
@item super
The keyword @code{super} has two different meanings.  It can 
modify a method, as in the following example.

@example 
MyReceiverClass super new instanceObject;
@end example

@code{super} can also represent the receiver's superclass
object, so it can appear as a receiver, as in this example.

@example
return super new checksum;
@end example

@end table

@node Documentation, Ctalk library, Method keywords, Methods
@iftex
@section Documenting Methods, Classes, and Variables
@end iftex
@ifnottex
@subheading Documenting Methods, Classes, and Variables
@end ifnottex
@cindex Documentation, methods and classes
@cindex Method documentation
@cindex Class documentation
@cindex Instance variable documentation
@cindex Class variable documentation
@cindex Documentation, methods, classes and variables

Ctalk allows you to add publicly visible comments to methods, classes,
and instance and class variables.  These comments are different than
comments within the code that may have meaning only for specific
routines

If you want to add documentation for a class, Ctalk allows
documentation string is class declarations (see
below). @xref{ClassDocStrings}.

You can also document instance and class variables.  @xref{VariableDocStrings}.

@anchor{MethodDocStrings}
When documenting methods, Ctalk recognizes both C-style comments and
C++ comments.

In addition, Ctalk recognizes a character string at the beginning of a
method or function as a public documentation string, and it adds a few rules
for comments and documentation strings that make it easier to describe
methods when browsing the class library.

Basically, if the method contains a comment or documentation string at
the start of a method or function body, then that style of comment is
used as the method's public documentation when it is referenced by
other programs.

@example

MyClass instanceMethod myMethod (Object myArg) @{
  /* Using a C-style comment at the start of a method body,
     or a series of C-style comments, makes those comments 
     available as the method's public documentation. */
  /* The public documentation can span several comments if the
     comments appear before any lines of source code. */

     @emph{Method body...}
 

  /* That allows you to add (perhaps temporary) comments elsewhere
     in the method that do not appear as part of the method's
     public documentation. */

     @emph{More lines of code...}

@}

MyClass instanceMethod myMethod (Object myArg) @{
  // A series of C++ comments before the first line of
  // code also can appear as the method's public 
  // documentation.

     @emph{Method body...}

  /* A different style of comment anywhere else within
     the method does not appear in the method's public
     documentation. */
@}

MyClass instanceMethod myMethod (Object myArg) @{
  "A character string at the start of the method also gets
   interpreted as a public documentation string."

   @emph{Method body...}
@}

@end example

@cindex @mnm{methodSource} instance method @idxclscite{Application}
@cindex @mnm{methods} instance method @idxclscite{Object}
@cindex @mnm{tokenize} instance method @idxclscite{String}
The Ctalk libraries contain several methods that can be useful when
printing documentation.  Particularly, the method @mnm{methods} (in
@code{Object} class) and @mnm{methodSource} (in @code{Application} class)
can retrieve the names of the methods in a class and their source code,
and the method @mnm{tokenize} (in @code{String} class) can split
the source code into tokens, which you can then process.

Here's a simple application that retrieves a method's source code
and splits it into tokens.

@c test/expect/examples/mthdsrc.c
@example

int main () @{

  Application new app;
  String new methodStr;
  List new tokens;
  
  /* The first argument to methodSource is the class name, and
     the second argument is the method name. */
  methodStr = app methodSource "Application", "methodSource";

  methodStr tokenize tokens;

  tokens map @{
    printf ("%s ", self);  /* This example simply prints the method's
                              tokens, but you can perform any processing
                              or formatting that you want here. */
  @}
  printf ("\n");
@}

@end example

@cindex @mnm{methodPrototypes} instance method @idxclscite{Application}
If you want only the prototype of the method; that is, the declaration
and the argument list, feed the output of @mnm{methodSource} to
@mnm{methodPrototypes}, which is also in class @code{Application.}  The
@mnm{methodPrototypes} method takes a string with the source code of a
method or methods as input, which means you can also extract all of the
prototypes of a class library.

@c test/expect/examples/mthdprotos.c
@example

int main () @{

  Application new app;
  String new src;
  String new prototypes;

  src = app methodSource "Object", "basicNew";

  prototypes = app methodPrototypes src;

  printf ("%s\n", prototypes);

@}

@end example


There are a few caveats:

@cindex @mnm{readAll} instance method @idxclscite{ReadFileStream}
The @mnm{methods} method is designed to be quick, so it only finds
methods whose declaration appears on one line.  If you prefer method
declarations spread over several lines, you can read the entire class
file using @mnm{readAll} (class @code{ReadFileStream}).  @xref{ReadFileStream}.
Then you can tokenize the entire class file at once, which disregards any
line formatting, although tokenizing an entire file takes considerably
longer.

Also, The @mnm{methodPrototypes} method does not do any special
formatting; it simply collects the prototypes into one @code{String}
object.

@iftex
@subsection Class Documentation
@end iftex
@ifnottex
@subsubheading Class Documentation
@end ifnottex
@anchor{ClassDocStrings}

Ctalk also allows you add documentation to class declarations.  The
declaration syntax allows you to add an option character string
between the class name and the closing semicolon.  The syntax of a
class documentation is the following.

@example

@var{superclassname} class @var{classname} @var{<docstring>};

@end example

For example, here is the class declaration of @code{WriteFileStream}
which contains a documentation string.

@example

FileStream class WriteFileStream   "Defines the methods and instance 
variables that write data to files. Also defines the class variables 
stdoutStream and stderrStream, which are the object representation 
of the standard output and standard error streams.";

@end example

@cindex @command{classdoc} utility program
The @command{classdoc} program can print the documentation string
of a class if it provides one.  The @cite{classdoc(1)} manual page
provides more information.

@iftex
@subsection Instance and Class Variable Documentation
@end iftex
@ifnottex
@subsubheading Instance and Class Variable Documentation
@end ifnottex
@anchor{VariableDocStrings}
@cindex Instance variable documentation
@cindex Class variable documentation

You can add an optional documentation string to an instance or class
variable's declaration by enclosing the text within quotes immediately
before the final semicolon.

@example

WriteFileStream classVariable stdoutStream
"Defines an object that contains the value of the system's standard output";

@end example

The main thing to watch out for is, syntactically, a documentation string
could be mistaken for a variable's initial value if one isn't included in
the definition.  For example, this definition uses a character string as
its initial value.

@example

ObjectInspector instanceVariable promptString String "> ";

@end example

So in this case, if you wanted to add a documentation string, you
would also need to include an initial value, otherwise the
documentation string would be mistaken for the variable's value.

@example

                                                      /* Incorrect! */
ObjectInspector instanceVariable promptString String      
"The string that is displayed as the object inspector's   
prompt";

@end example

Instead, you need to add both an an initial value, and the documentation
string.

@example

                                                           /* Correct. */
ObjectInspector instanceVariable promptString String "> "
"The string that is displayed as the object inspector's
prompt";

@end example

@node Ctalk library, , Documentation, Methods
@iftex
@section Ctalk Library Reference
@end iftex
@ifnottex
@subheading Ctalk Library Reference
@end ifnottex
@cindex Library functions

This section describes some of the Ctalk library functions that you
can use in methods and, in many cases, in Ctalk programs generally.

The file @flnm{classes/ctalklib} contains the prototypes of the
library functions.

@table @code
@c LIB-DOC-START-COOKIE ***
@cindex __argvName function
@item __argvName (@code{char *}@var{s})
Set the name of the program at run time.  Normally this is the
same as @code{argv[0]}.

@cindex __argvFileName function
@item __argvFileName (@code{void})
Returns the name of the executable program.

@cindex __arg_trace function
@item __arg_trace (@code{int} @var{stack_index})
Prints the object at argument stack index @var{stack_index}.

@cindex __ctalkAddClassVariable function
@item __ctalkAddClassVariable (@code{OBJECT *}@var{class_object}, @code{char *}@var{name}, @code{OBJECT *}@var{variable_object})
Add a class variable @var{variable_object}to @var{class_object}.

@cindex __ctalkAddInstanceVariable function
@item __ctalkAddInstanceVariable (@code{OBJECT *}@var{object}, @code{char *}@var{name}, @code{OBJECT *}@var{variable_object})
Add an instance variable to an object.  Note that the function
adds a copy of @var{variable_object} to @var{object}.

@cindex __ctalkAliasObject function
@item __ctalkAliasObject (@code{OBJECT *}@var{rcvr}, @code{OBJECT *} @var{target})
Set the @var{rcvr} object's label to the @var{target} object, so the
@var{target} object can be referred to by the @var{rcvr} object's
identifier.  This function does not require @var{rcvr} to be the
actual receiver of the method, so the results can be unpredictable if
it is used in a context other than where @code{self} is the first
argument.  To insure that @var{rcvr} is the actual receiver of the
calling method, use @cite{__ctalkAliasReceiver (),} below.

@cindex __ctalkAliasReceiver function
@item __ctalkAliasReceiver (@code{OBJECT *}@var{rcvr}, @code{OBJECT *} @var{target})
Like @cite{__ctalkAliasObject (),} above, but the function checks that
@var{rcvr} is the actual receiver of the calling method and returns
@code{ERROR} (@samp{-1}) if it isn't.  Here is an example.

@example

String instanceMethod = setEqual (OBJECT *__stringArg) @{
  // String assignment method. Assigns the argument  to the
  // receiver label.  Also does some String-specific
  // semantic stuff for different sorts of String objects.
  // Returns the new String object.

  __ctalkStringifyName (self, __stringArg);
  if (__ctalkAliasReceiver (self, __stringArg) != 0) @{
    __ctalkAddInstanceVariable (self, "value", __stringArg);
    return self;
  @} else @{
    return __stringArg;
  @}
@}

@end example

@cindex __ctalkANSIClearPaneLine function
@item __ctalkANSIClearPaneLine (@code{OBJECT *}@var{paneObject}, @code{int} @var{lineNumber})
Clear (to spaces) the pane line at @var{lineNumber}.

@cindex __ctalkANSITerminalPaneMapWindow function
@item __ctalkANSITerminalPaneMapWindow (@code{Object *}@var{childPane})
Map @var{childPane} onto the receiver pane.  The child pane's upper
left-hand corner origin is relative to the receiver pane's origin.
The receiver pane should be large enough to completely enclose the
child pane.  The child pane is displayed at the next @mnm{refresh}
message. 

@cindex __ctalkANSITerminalPaneUnmapWindow function
@item  __ctalkANSITerminalPaneUnmapWindow (@code{Object *}@var{childPane})
Removes the pane given as the argument from the receiver pane.

@cindex __ctalkANSITerminalPanePutchar function
@item __ctalkANSITerminalPanePutChar (@code{int} @var{x}, @code{int} @var{y}, @code{char} @var{c})
Store character @var{c} at coordinates @var{x},@var{y} in the pane's
content region.  The character will be displayed after the next
@mnm{refresh} message.

@cindex __ctalkANSITerminalPaneRefresh function
@item __ctalkANSITerminalPaneRefresh (@code{void})
Display the contents of @code{ANSITerminalPane} objects on the display,
including text and window decorations if any.

@cindex __ctalkANSITerminalPaneUnMapWindow function
@item __ctalkANSITerminalPaneUnMapWindow (@code{Object} @var{childPane})
Unmap @var{childPane} from the receiver pane's visible area.  The
child pane is not deleted; it is simply not displayed at the next
@mnm{refresh} message.

@cindex Shaders, OpenGL
@cindex GLEW library
@idxlibfn{__ctalkARB}
@item __ctalkARB (@code{void})
Returns a boolean value of true if the GLEW libraries support
the GLEW_ARB_vertex_shader and GLEW_ARB_fragment_shader
extensions.  Programs must call the @cite{__ctalkInitGLEW}
function before using this function.

@idxlibfn{__ctalkArgBlkReturnVal}
@item __ctalkArgBlkReturnVal (@code{void})
Called by the calling function of an argument block to retrieve
the block's return value, if any.  

@idxlibfn{__ctalkArgBlkSetCallerReturn}
@item __ctalkArgBlkSetCallerReturn (@code{void})
Called by a map method to indicate to a calling method or function
that an argument block has requested a return from the function or
method that called it.  Map-type methods for general use should
include a call to this function, which provides argument block support
for @code{return} statements. Refer to
@cite{__ctalkRegisterArgBlkReturn}, below, and the @code{String : map}
method for an example of these functions' use.

@idxlibfn{__ctalkArrayElementToCCharPtr}
@item __ctalkArrayElementToCCharPtr (@code{OBJECT *}@var{array_element})
@idxlibfn{__ctalkArrayElementToCChar}
@item __ctalkArrayElementToCChar (@code{OBJECT *}@var{array_element})
@idxlibfn{__ctalkArrayElementToCDouble}
@item __ctalkArrayElementToCDouble (@code{OBJECT *}@var{array_element})
@idxlibfn{__ctalkArrayElementToCInt}
@item __ctalkArrayElementToCInt (@code{OBJECT *}@var{array_element})
@idxlibfn{__ctalkArrayElementToCLongLongInt}
@item __ctalkArrayElementToCLongLongInt (@code{OBJECT *}@var{array_element})
@idxlibfn{__ctalkArrayElementToCPtr}
@item __ctalkArrayElementToCPtr (@code{OBJECT *}@var{array_element})
Translates the object @var{array_element}'s value to a C @code{char
*}, @code{char}, @code{double}, @code{int}, @code{long long int}, or
@code{void *}.

@idxlibfn{__ctalkBackgroundMethodObjectMessage}
@cindex @mnm{backgroundMethodObjectMessage} instance method @idxclscite{Object}
@item __ctalkBackgroundMethodObjectMessage (@code{OBJECT *}@var{rcvr}, @code{OBJECT *}@var{method_instance})
Perform a method call by sending @var{rcvr} the message defined by
@var{method_instance}, which is a previously defined @code{Method}
object.  @xref{Method}.

The function starts @var{method_instance} as a separate process,
which runs concurrently with the process that launched it.
The background process exits when @var{method_instance} returns.

The @var{method instance} argument is a normal method.  However,
@cite{__ctalkBackgroundMethodObjectMessage} does not save the return
object before @var{method_instance} exits, and @var{method_instance},
does not take any arguments.

The function returns the PID of the child process, or @samp{-1} on
error.

This function is used by the method
@mnm{backgroundMethodObjectMessage} (class @code{Object}).  Refer to
the description of the method for more information.
@xref{Object}.

For examples of method instance calls, @xref{methodObjectMessage}.

@idxlibfn{__ctalkBackgroundMethodObjectMessage2Args}
@item __ctalkBackgroundMethodObjectMessage2Args (@code{OBJECT *}@var{rcvr}, @code{OBJECT *}@var{method_instance}, @code{OBJECT *}@var{arg1}, @code{OBJECT *}@var{arg2})

This function combines a background method instance call with two arguments.
Its function is similar to @cite{__ctalkMethodObjectMessage}, below.

For examples of method instance calls, @xref{methodObjectMessage}.

@cindex __ctalkCallMethodFn function
@item __ctalkCallMethodFn (@code{METHOD *}@var{method})
Used internally to perform a method call.

@cindex __ctalkCallingFnObjectBecome
@item __ctalkCallingFnObjectBecome (@code{OBJECT *}@var{old}, @code{OBJECT *}@var{new})
Used by @code{Object} : @mnm{become} to translate the receiver when
@mnm{become} is called within a function.

@cindex __ctalkCallingInstanceVarBecome
@item __ctalkCallingInstanceVarBecome (@code{OBJECT *}@var{old}, @code{OBJECT *}@var{new})
Used by @code{Object} : @mnm{become} to translate the receiver when
the receiver is an instance variable.

@cindex __ctalkCallingMethodObjectBecome
@item __ctalkCallingMethodObjectBecome (@code{OBJECT *}@var{old}, @code{OBJECT *}@var{new})
Used by @code{Object} : @mnm{become} to translate the receiver when
@mnm{become's} receiver is an object declared in another method.

@cindex __ctalkCallingReceiverBecome
@item __ctalkCallingReceiverBecome (@code{OBJECT *}@var{old}, @code{OBJECT *}@var{new})
Used by @code{Object} : @mnm{become} to translate the receiver when
@mnm{become's} receiver also the receiver of the method that calls
@mnm{become}.

@cindex __ctalkCBoolToObj function
@item __ctalkCBoolToObj (bool @var{b})
Create a @code{Boolean} object with the boolean (either true or false)
value of the argument.

@cindex __ctalkCCharPtrToObj function
@item __ctalkCCharPtrToObj (@code{char *}@var{s})
Create a String object from a C @code{char *}.

@cindex __ctalkConsoleReadLine function
@item __ctalkConsoleReadLine (@code{OBJECT *}string_object, @code{char *}prompt_string)
Prints the prompt @var{prompt_string} to standard output of a
terminal, then reads a line of text from the standard input, until it
encounters a newline, and saves it as the value of
@var{string_object}.

If Ctalk is built with support for the GNU readline libraries, the
function provides the readline libraries' command line editing and
history facilities.  Otherwise, the function reads input up to a
newline using only the basic text input and editing facilities
provided by the stdio functions.

@cindex __ctalkCreateArg function
@item __ctalkCreateArg (@code{OBJECT *}@var{receiver}, @code{char *}@var{methodname}, @code{char *}@var{arg_expr})
Create an argument for the following @code{__ctalk_method} or
@code{__ctalk_primitive_method} function call.  Unlike
@code{__ctalk_arg}, this function always creates a new object.  Its
primary use is to create local method objects that are fully instantiated
into a class by a following @mnm{new} method.

@cindex __ctalkCreateArgA function
@item __ctalkCreateArgA (@code{OBJECT *}@var{receiver}, @code{char *}@var{methodname}, @code{char *}@var{arg_expr})
Like @cite{__ctalkCreateArg}, creates local method objects that are
instantiated into a class by a following @mnm{new} method.  The
@cite{__ctalkCreateArgA ()} function is more specialized so it can be
used when performing method cache fixups.

@cindex __ctalkCDoubleToObj function
@item __ctalkCDoubleToObj (@code{double}@var{d})
Create a Float object from a C @code{float} or @code{double}.

@cindex __ctalkCharRadixToChar function
@item __ctalkCharRadixToChar (@code{char *}@var{s})
Return the character as a C @code{char} that is represented by the
formatted argument.

If @var{s} contains a number of more than one digit, then it is
converted from an integer to the ASCII code of a character.

@cindex __ctalkCharRadixToCharASCII function
@item __ctalkCharRadixToCharASCII (@code{char *}@var{s})
Return a C string with a lexically correct character - a character
enclosed in single quotes - from the formatted argument.  If @var{s}
is already a character, then no conversion is done.

If @var{s} contains a decimal number of more than one digit, then it
is converted from a decimal integer to a character.

@cindex __ctalkCFUNCReturnClass function
@item __ctalkCFUNCReturnClass (@code{CFUNC *}@var{fn}, @code{char *}@var{buf})
Return in @var{buf} the name of the class that corresponds to
@var{fn}'s return type.

@cindex __ctalkCIntToObj function
@item __ctalkCIntToObj (@code{int} @var{i})
Create an @code{Integer} object from a C @code{int.}

@cindex __ctalkCLongLongToObj function
@item __ctalkCLongLongToObj (@code{long long int} @var{l})
Create a @code{LongInteger} object from a C @code{long long int.}

@cindex __ctalkClassMethodInitReturnClass function
@item __ctalkClassMethodInitReturnClass (@code{char *}@var{rcvr_class}, @code{char *}@var{method_name}, @code{char *}@var{return_class});
Set the return class of @var{method} in @var{rcvr_class} to @var{return_class}.

@cindex __ctalkClassMethodParam function
@item __ctalkClassMethodParam (@code{char *}@var{rcvrclassname}, @code{char *}@var{methodname}, @code{OBJECT *}@var{(*selector_fn)()}, @code{char *}@var{paramclass}, @code{char *}@var{paramname}, @code{int} @var{param_is_pointer})
Define a method parameter when initializing a class method. Normally
the compiler generates this call for inclusion in @code{__ctalk_init
()} for the method initialization at run time.

@cindex __ctalkClassObject function
@item __ctalkClassObject (@code{OBJECT *}@var{object})
Returns the class object of the argument.

@idxlibfn{__ctalkClassVariableObject}
@item __ctalkClassVariableObject (@code{OBJECT *}@code{var})
Return the object that @code{var} is a class variable of, or NULL.

@anchor{ctalkFree}
@cindex __ctalkFree function
@cindex __xfree function
@item __ctalkFree (@code{void *}@var{p})
This is an API wrapper for Ctalk's memory free routines.  Much of the
old code in the class libraries still uses __xfree () (which now gets
macroized to __ctalkFree () anyway), but you should use __ctalkFree ()
in new class libraries.

In cases where you prefer to call __xfree () directly, then you need
to use the MEMADDR macro to cast the argument to a @code{void **}, i.e.,

@example

  char *my_buf;

  ... do stuff ...

  __xfree (MEMADDR(my_buf));

@end example

which is what __ctalkFree () does automagically.

@cindex __ctalkLocalTime function
@item __ctalkLocalTime (@code{long int} @var{utctime}, @code{int *}@var{seconds_return}, @code{int *}@var{minutes_return}, @code{int *}@var{hours_return}, @code{int *}@var{dom_return}, @code{int *}@var{mon_return}, @code{int *}@var{years_return}, @code{int *}@var{dow_return}, @code{int *}@var{doy_return}, @code{int *}@var{have_dst_return})
Returns the system's local time in the arguments that return the
current second, minute, hour, day of the month, month, year, day of the week, day of the year, and (T/F) whether the time uses daylight savings time.

The first argument is the system's UTC time, as returned by the
@cite{time ()} library function.

@idxlibfn{__ctalkCloseGLXPane}
@item __ctalkCloseGLXPane (@code{OBJECT *}@var{pane_object})
Releases the pane's GLX context and the context's XVisualInfo
struct, and deletes the @var{pane_object's} X11 window.

@idxlibfn{__ctalkCloseX11Pane}
@item __ctalkCloseX11Pane (@code{OBJECT *}@var{pane_object})
Deletes and closes subpanes of a main X11 window.

@cindex __ctalkCopyPaneStreams function
@item __ctalkCopyPaneStreams (@code{OBJECT *}@var{src}, @code{OBJECT *}@var{dest})
Copy the @var{src} @code{inputHandle} and @code{outputHandle} values
to @var{dest}.

@cindex __ctalkCopyVariable function
@item __ctalkCopyCVariable (@code{CVAR *}@var{c})
Return a @code{CVAR *} to a copy of the argument.

@cindex __ctalkCopyObject function
@item __ctalkCopyObject (@code{OBJREF_T} @var{src}, @code{OBJREF_T} @var{dest})
Return an @code{OBJECT *} to a copy of the argument.

@cindex @code{OBJREF} macro
@cindex @mnm{at} method @idxclscite{Array}
@cindex @mnm{atPut} method @idxclscite{AssociativeArray}
@emph{Note:} When copying normal objects, you can translate them to
@code{OBJREF_T} types with the @code{OBJREF} macro.  When copying
method arguments, it is necessary to alias the argument to an object.
See @mnm{at} (class @code{Array}) and @mnm{atPut} (class
@code{AssociativeArray}) for examples.

@cindex __ctalkCreateArgEntry function
@item __ctalkCreateArgEntry (@code{void})
Used internally to create an ARG type, which maintains a method's
argument entries.

@cindex __ctalkCreateArgEntryInit function
@item __ctalkCreateArgEntryInit (@code{OBJECT *}@var{obj})
Creates an internal method argument entry and initializes the entry to
the argument object.

@cindex __ctalkDeleteArgEntry function
@item __ctalkDeleteArgEntry (@code{ARG *}@var{arg})
Delete a method ARG entry.

@cindex __ctalkCreateObject function 
@item __ctalkCreateObject (@code{char *}@var{name}, @code{char *}@var{class}, @code{char *}@var{superclass}, @code{int} @var{scope})
Create an object without instance variables with name @var{name} 
of class @var{class} and superclass @var{superclass} with scope @var{scope}.

@cindex __ctalkCreateObjectInit function 
@item __ctalkCreateObjectInit (@code{char *}@var{name}, @code{char *}@var{class}, @code{char *}@var{superclass}, @code{int} @var{scope}, @code{char *}@var{value})
Create an object with name @var{name} of class @var{class} and
superclass @var{superclass} with scope @var{scope} and value
@var{value}.

For more information about how to use @cite{__ctalkCreateObjectInit}, refer
to the examples in @xref{Scoping}, and other examples in this manual.

@cindex __ctalkCreateWinBuffer function
@item __ctalkCreateWinBuffer (@code{int} @var{x_size}, @code{int} @var{y_size}, @code{int} @var{cell_size})
Create a buffer for a @code{Pane} object's window.

@cindex __ctalkCreateGLXMainWindow function
@item __ctalkCreateGLXMainWindow (@code{OBJECT *} @var{pane_object})
Normally called by the @mnm{initialize} method in class
@code{GLXCanvasPane}, creates a X11 window with a GLX visual.
The
visual's default attributes are: @samp{GLX_RGBA}, @samp{GLX_DEPTH_SIZE},
24 bits per pixel, and @samp{GLX_DOUBLEBUFFER}.  These attributes are
adjustable via the instance variables in @code{GLXCanvasPane} class.

The @var{self_object} argument must be an instance of @code{GLXCanvasPane}
class.  This function fills in the object's @code{visualInfoPtr} instance
variable with a pointer to the @code{XVisualInfo} structure specified
by @var{self_object}.
@xref{GLXCanvasPane}.

@cindex __ctalkCreateX11MainWindow function
@cindex __ctalkCreateX11MainWindow (@code{OBJECT *}@var{x11pane_object})
Called by the @mnm{initialize} methods (class @code{X11Pane}) to
create a X window.  Returns the window system's ID for the window, an
@code{int}.


If a program doesn't specify a window size, then default size is
250x250 pixels.  If the program doesn't specify a location for the
window, then this function sets the window's @emph{X,Y} origin to 0,
although the actual window placement depends on the machine's window
manager.  @xref{ctalkX11SetSizeHints}.

Application programs can provide a window geometry specification which
is used to set the window's size and placement
@xref{parseX11Geometry}.

If a program doesn't specify a foreground and background color,
the window's background is set to white and the foreground is set to
black.

Refer also to the @cite{__ctalkCreateX11MainWindowTitle} and
@cite{__ctalkCreanteX11SubWindow} functions. @xref{X11Pane}.

@cindex __ctalkCreateX11MainWindowTitle function
@cindex __ctalkCreateX11MainWindowTitle (@code{OBJECT *}@var{x11pane_object},
@code{char *}@var{title})
Similar to @cite{__ctalkCreateX11MainWindow}, except that if @var{title}
is non-null, the function uses it to set the new window's title.  Returns
the X resource ID of the new window, an @code{int}.  @xref{X11Pane}.

@cindex __ctalkCreateX11SubWindow function
@cindex __ctalkCreateX11SubWindow (@code{OBJECT *}@var{subpane_object}, @code{OBJECT *}@var{parentpane_object})
Creates an X subwindow that has the parent window defined by
@var{parentpane_object's} @code{xWindowID} instance variable.  The
dimensions of the subwindow within the parent window are determined by
the @var{subpane_object's} @code{origin} and @code{size} instance
variables.  Creates a new graphics context for the window and saves
its address in the @var{subpane_object's} @code{xGC} instance
variable.

If the @var{subpane_object}'s @code{backgroundColor} instance variable
is set; for example, with a statement like this:

@example

myCanvasPane backgroundColor = "blue";

@end example

Then the function initiazes and clears the window to the value of
the @code{backgroundColor} instance variable.  Otherwise, the function
sets the window's color to black and clears the window.

Also sets the display depth in the @code{depth} instance
variable, and the ID of the subwindow in the @code{xWindowID} instance
variable.

@cindex __ctalkCriticalExceptionInternal function
@cindex @mnm{raiseCriticalException} method @idxclscite{SysErrnoException}
@item __ctalkCriticalExceptionInternal (@code{MESSAGE *}@var{orig}, @code{EXCEPTION} @var{ex}, @code{char *}@var{text})
Raise a critical exception at run time.  The argument @var{orig}
should be @code{NULL.}  This function should be called from a method.
This function saves a snapshot of the @emph{calling method's}
run-time context.

For an example, see @mnm{raiseCriticalException} (class
@code{SysErrnoException}) in the Ctalk class library, which calls
@code{__ctalkCriticalSysErrExceptionInternal,} below.

@cindex __ctalkCriticalSysErrExceptionInternal function
@cindex @code{errno} macro
@item __ctalkCriticalSysErrExceptionInternal (@code{MESSAGE *}@var{orig}, @code{int} @var{errno}, @code{char *}@var{text})
A convenience function that calls
@code{__ctalkCriticalExceptionInternal} with the Ctalk exception that
corresponds to @var{errno}, the C library's error macro.

@cindex __ctalkCVARReturnClass function
@item __ctalkCVARReturnClass (@code{CVAR *}@var{var}, @code{char *}@var{buf})
Return in @var{buf} the name of the class that corresponds to
@var{var}'s data type.

@idxfncite{__ctalkDecimalIntegerToChar}
@item __ctalkDecimalIntegerToChar (@code{int} @var{n}, @code{char *}@var{buf})
Formats the ASCII 8-bit character representation of @var{n} as the
first character in @var{buf}, and returns @samp{(char)n} as its return
value. If @var{n} is greater than 255 (0xff hex), returns the
formatted character @samp{(char)(n & 255)}.

@cindex __ctalkDecimalIntegerToASCII function
@item __ctalkDecimalIntegerToASCII (@code{int} @var{i}, @code{char *}@var{s});
Format an ASCII representation of @var{i}, a decimal integer, in @var{s}.

@cindex __ctalkLongLongToDecimalASCII function
@cindex __ctalkLongLongToHexASCII function
@cindex __ctalkLongToDecimalASCII function
@cindex __ctalkLongToHexASCII function
@item __ctalkLongLongToDecimalASCII (@code{long long int} @var{l}, @code{char *}@var{buf});
@item __ctalkLongLongToHexASCII (@code{long long int} @var{l}, @code{char *}@var{buf}, @code{bool} @var{uppercase});
@item __ctalkLongToDecimalASCII (@code{long int} @var{l}, @code{char *}@var{buf});
@item __ctalkLongToHexASCII (@code{long int} @var{l}, @code{char *}@var{buf}, @code{bool} @var{uppercase});
Format a decimal or hexadecimal ASCII representation of @var{l}, a
long long int, in @var{buf}, and return @var{buf}.

When using @cite{__ctalkLongLongToHexASCII,} or
@cite{__ctalkLongToHexASCII,} if @var{uppercase} is @code{true},
format the number using uppercase letters; e.g., @samp{0XFFFF};
otherwise format the number using lowercase letters: @samp{0xffff}.

@cindex __ctalkDefaultSignalHandler function
@item __ctalkDefaultSignalHandler (@code{int} @var{signo})
Set the handler of signal @var{signo} to the system's
default handler.

@cindex __ctalkDefineClassMethod function
@item __ctalkDefineClassMethod (@code{char *}@var{class}, @code{char *}@var{name}, @code{OBJECT *(*)(fn)}, @code{int} @var{required_args});

Define a class method in class @var{class} with name @var{name}, which
calls the function @var{fn}, and requires @var{required_args} arguments.

@cindex __ctalkDefineClassVariable function
@item __ctalkDefineClassVariable (@code{char *}@var{class}, @code{char *}@var{name}, @code{char *}@var{varclass}, @code{char *}@var{init_expr});

Define a class variable in class @var{class} with @var{name}.  
The variable is an object of class @var{varclass} with the initial
value @var{init_expr}.

@cindex __ctalkDefineInstanceMethod function
@item __ctalkDefineInstanceMethod (@code{char *}@var{class}, @code{char *}@var{name}, @code{OBJECT *(*)(fn)}, @code{int} @var{required_args});

Define an instance method in class @var{class} with name @var{name}, which
calls the function @var{fn}, and requires @var{required_args} arguments.

@cindex __ctalkDefineInstanceVariable function
@item __ctalkDefineInstanceVariable (@code{char *}@var{class}, @code{char *}@var{name}, @code{char *}@var{varclass}, @code{char *}@var{init_expr});

Define an instance variable in class @var{class} with @var{name}.  
The variable is an object of class @var{varclass} with the initial
value @var{init_expr}.

@cindex __ctalkDefinedClassMethodObject function
@item __ctalkDefinedClassMethodObject (@code{OBJECT *}@var{rcvr}, @code{char *}@var{classname}, @code{char *}@var{method_name})
Initialize a @code{Method} object from the class method
@var{method_name} from class @var{classname}.  Note that this function
only works for methods that are already defined.  @xref{Method}.

@cindex __ctalkDefinedInstanceMethodObject function
@item __ctalkDefinedInstanceMethodObject (@code{OBJECT *}@var{rcvr}, @code{char *}@var{classname}, @code{char *}@var{method_name})
Initialize a @code{Method} object from the instance method
@var{method_name} from class @var{classname}.  Note that this function
only works for methods that are already defined.  @xref{Method}.

@cindex __ctalkDefineTemplateMethod function
@item __ctalkDefineTemplateMethod (@code{char *}@var{classname}, @code{char *}@var{name}, @code{OBJECT *}@var{(*cfunc)}(), @code{int} @var{required_args}, @code{int} @var{n_args})
Defines a template method.  First calls __ctalkDefineClassMethod (), then
performs additional initialization needed for templates.

@cindex __ctalkDeleteLastExceptionInternal function
@item __ctalkDeleteLastExceptionInternal (@code{void})
Deletes the most recent exception from Ctalk's internal exception list.

@anchor{__ctalkDeleteObject}
@cindex __ctalkDeleteObject function.
@cindex __objRefCntDec function.
@cindex __objRefCntZero function.
@item __ctalkDeleteObject (@code{OBJECT *}@var{object})
Delete an object, and any objects it refers to, if they are not
referenced elsewhere.  It's a good idea to call @code{__objRefCntZero}
first.  The object then won't be showing any extra references.

Zeroing the reference count first causes the function to delete the
object @emph{completely}.  It bypasses Ctalk's internal mechanisms
that decide when objects are no longer needed.  Don't use these
functions unless you know where the object and any objects it refers
to are declared.

It should seldom be necessary to remove an object from a particular
scope manually anyway.  But in that case, call @code{__objRefCntDec}
instead, and then let Ctalk try to clean up the object when it goes
out of scope.

For example, to delete a scratch object using C, 

@example

Object new tmpObject;
OBJECT *tmpObject_alias;

tmpObject_alias = tmpObject;

__objRefCntZero (OBJREF(tmpObject_alias));
__ctalkDeleteObject(tmpObject_alias);

@end example

Translating the object to C should work in all cases, regardless of
the surrounding code.  Of course, you can also use the @mnm{delete}
method (class @code{Object}) with many simple C expressions.

@example

Object tmpObject;
OBJECT *tmpObject_alias;

tmpObject delete;

@emph{..or..}

tmpObject_alias delete;

@emph{..or even this expression..}

tmpObject_alias -> instancevars delete;

@end example

@cindex __ctalkDeleteObjectInternal (@code{OBJECT *}@var{obj})
Deletes @var{obj} if there are no references to it, or if this is the
last reference to the object.  In this case, the function works
similarly to @cite{__ctalkDeleteObject}.  Otherwise, the function
decreases the object's reference count by 1.

@cindex __ctalkDeleteObjectList function
@item __ctalkDeleteObjectList (@code{OBJECT *}@var{object})
Delete an object and any objects that link to it.

@cindex __ctalkDeleteWinBuffer function
@item __ctalkDeleteWinBuffer (@code{OBJECT *}@var{paneBuffer_instance_var})
Deletes a @code{paneBuffer} backing store allocated when a
subclass of @code{Pane} creates an object.

@cindex __ctalkDocDir function
@item __ctalkDocDir (@code{void})
Returns a @code{char *} that contains the path where the
Ctalk-specific documentation is installed on the system (i.e.,
documentation other than man pages and Texinfo manuals).

@cindex __ctalkDoubleToASCII function
@cindex __ctalkFloatToASCII function
@cindex __ctalkLongDoubleToASCII function
@item __ctalkDoubleToASCII (@code{double} @var{d}, @code{char *}@var{s});
@item __ctalkFloatToASCII (@code{float} @var{f}, @code{char *}@var{s});
@item __ctalkLongDoubleToASCII (@code{long double} @var{f}, @code{char *}@var{s});
Format an ASCII representation of the first argument in @var{s}.  Returns
@var{s}.

@idxfncite{__ctalkEnterArgBlockScope}
@item __ctalkEnterArgBlockScope (@code{void})
Ctalk inserts this call at the beginning of argument blocks.  Checks
that the block call is the result of an inline method call and sets
the run-time stack's RTINFO structure to indicate a block call with
the correct stack frame for the block's scope.

@anchor{ctalkExec}
@idxfncite{__ctalkExec}
@item __ctalkExec(@code{char *}@var{cmdline}, @code{OBJECT *}@var{strObject})
Executes the command line given as the argument and waits for the
subprocess to finish.  If the @var{strObject} argument is non-NULL,
the function saves the subprocesses' standard output as the object's
@code{value}.  Normally, @var{strObject} should be a @code{String}
object.

If the @var{strObject} argument is NULL, @cite{__ctalkExec} reads and
prints the subprogram's standard output to the terminal's standard
output.

@cite{__ctalkExec} supports the redirection operators @samp{>} or
@samp{>>}, which send the subprocess's standard output to the file
given as the redirection operator's target. If @var{cmdLine} is a
shell script, it is executed by a sub-shell using the @cite{system(3)}
library function.

@idxfncite{__ctalkExitArgBlockScope}
@item __ctalkExitArgBlockScope (@code{void})
Ctalk inserts this function, which is currenly a no-op, as the last
function call in an argument block.

@cindex __ctalkErrorExit function
@item __ctalkErrorExit (@code{void})
Cleans up the program's immediate object environment before a call
to the C @cite{exit(3)} function.

@cindex __ctalkEvalExpr function
@item __ctalkEvalExpr (@code{char *}@var{expr})
Evaluate @var{expr} and return an @code{OBJECT *} to the result.

@cindex __ctalkEvalExprU function
@item __ctalkEvalExprU (@code{char *}@var{expr})
Like @cite{__ctalkEvalExpr}, above, but @cite{__ctalkEvalExprU}
returns a C NULL instead of a null result object when an expression
evaluates to 0.

@cindex __ctalkExceptionInternal function
@item __ctalkExceptionInternal (@code{MESSAGE *}@var{msg}, @code{EXCEPTION} @var{e}, @code{char *}@var{text}) 
Generate an exception of type @var{e}.  Exceptions are listed in
@flnm{except.h}, and in the description of @code{Exception}
class. @xref{Exception}. If @var{msg} is non-NULL, which is usually
the case when the compiler generates and exception, the function
records the line and column number of the exception.  If @var{text} is
non-NULL, the exception handler adds the text to the exception record,
so it can be displayed when the program handles the exception.

Programs should handle run-time exceptions as soon as possible after
returning from a method.  The function
@code{__ctalkHandleRunTimeExceptionInternal} is the normal exception
handler, and @code{__ctalkTrapExceptionInternal} determines whether 
an exception has occurred.

@cindex __ctalkFindClassVariable function
@item __ctalkFindClassVariable (@code{char *}@var{varname}, @code{int} @var{warn})
Search the class library for @emph{first occurrence} of the class variable
@var{varname}.  

If @var{warn} is @code{TRUE,} issues a warning if the variable is not found.

@idxfncite{__ctalkFindMethodByName}
@item __ctalkFindMethodByName (@code{OBJECT **}@var{object}, @code{const char *}@var{name}, @code{int} @var{warn})
Returns the first instance or class method @var{name} if it exists in
@var{object}'s class or superclasses, or NULL if a method with that
name isn't found.  If @var{warn} is true, prints a warning message if
the method isn't found.

@cindex __ctalkFindPrefixMethodByName function
@item __ctalkFindPrefixMethodByName (@code{OBJECT **}@var{rcvr}, @code{const char *}@var{name}, @code{int} @var{warn})
Looks up a classes' instance method that matches @var{name} which has
the @code{prefix} attribute set.  If @var{warn} is true, prints a
warning if the method is not found.

@cindex __ctalkExceptionNotifyInternal function
@item __ctalkExceptionNotifyInternal (@code{I_EXCEPTION *}@var{i})
The handler function of most exceptions.  Prints a message including
any text provided as an argument to @code{__ctalkExceptionInternal}.

@cindex __ctalkFilePtrFromStr function
@cindex @code{errno}
@anchor{ctalkFilePtrFromStr}
@item __ctalkFilePtrFromStr (@code{char *s}@var{formatted_ptr})
Like @cite{__ctalkGenericPtrFromStr (),} below, converts a string
containing a formatted hexadecimal number to a pointer, and also
checks that the pointer is a valid file.   

The function returns a @code{void *} in order to keep Ctalk's header
inclusion simple, or NULL if the argument does not contain a valid
hexadecimal number, or if the pointer does not point to a valid file.

This function can also set @code{errno} in case of an error.

Because the function returns a @code{void *} an app or method must
perform the cast from  @code{void *} to @code{File *} when it calls
this function.

@cindex __ctalkFindClassMethodByFn function
@item __ctalkFindClassMethodByFn (@code{OBJECT **}@var{rcvr_p}, @code{OBJECT *(*}@var{fn}@code{)()}, @code{int} @var{warn})
Finds a class method by calling @code{__ctalkGetClassMethodByFn} for
the method's receiver and then the receivers of previous method calls.
On success, returns the method, and @var{rcvr_p} contains the address
of the method's receiver.

If @var{warn} is @code{TRUE,} issues a warning if the method is not found.

@cindex __ctalkFindClassMethodByName function
@item __ctalkFindClassMethodByName (@code{OBJECT **}@var{rcvr_p}, @code{char *}@var{name}, @code{int} @var{warn})
Finds a class method by by calling @code{__ctalkGetClassMethodByName}
for the method's receiver and then the receivers of previous method
calls.  On success, returns the method, and @var{rcvr_p} contains the
address of the method's receiver.

If @var{warn} is @code{TRUE,} issues a warning if the method is not found.

@cindex __ctalkFindInstanceMethodByFn function
@item __ctalkFindInstanceMethodByFn (@code{OBJECT **}@var{rcvr_p}, @code{char *}@var{name}, @code{int} @var{warn})
Finds an instance method by calling @code{__ctalkGetInstanceMethodByFn} for
the method's receiver and then the receivers of previous method calls.
On success, returns the method, and @var{rcvr_p} contains the address
of the method's receiver.

If @var{warn} is @code{TRUE,} issues a warning if the method is not found.

@cindex __ctalkFindInstanceMethodByName function
@item __ctalkFindInstanceMethodByName (@code{OBJECT **}@var{rcvr_p}, @code{char *}@var{name}, @code{int} @var{warn})
Finds an instance method by by calling @code{__ctalkGetInstanceMethodByName}
for the method's receiver and then the receivers of previous method
calls.  On success, returns the method, and @var{rcvr_p} contains the
address of the method's receiver.

If @var{warn} is @code{TRUE,} issues a warning if the method is not found.

@idxlibfn{__ctalkSaveCVARArrayResource}
@item __ctalkSaveCVARArrayResource (@code{char *}@var{name}, @code{int} @var{initializer_size}, @code{void *}@code{var})
Saves an @code{Array} object with the contents of @code{var} in a method's
object pool.

@idxlibfn{__ctalkSaveCVARResource}
@item __ctalkSaveCVARResource (@code{char *}@var{name})
Saves the contents of C variable @var{name} in a method's object pool.

@idxlibfn{__ctalkSaveOBJECTMemberResource}
@item __ctalkSaveOBJECTMemberResource (@code{OBJECT *}@var{object})
Saves an @code{OBJECT *} member to a method's resource pool.

@idxlibfn{__ctalkSleep}
@item __ctalkSleep (@code{int} @var{usecs})
Put a program to sleep for @var{usecs} microseconds.  The operating
system restores the program to a running state no sooner than that
amount of time has elapsed.

@idxlibfn{__ctalkSort}
@idxlibfn{__ctalkSortByName}
@item __ctalkSort (@code{OBJECT *}@var{collection}, @code{bool} @var{sortdescending})
@item __ctalkSortByName (@code{OBJECT *}@var{collection}, @code{bool} @var{sortdescending})
Sorts a collection's members into ascending or descending order.
@cite{__ctalkSort} performs the sort using the collection members'
values, while @cite{__ctalkSortByName} uses the members' names.

The algorithm used is very simple minded, although due to the
mechanics of finding earlier/later collection members, it is as fast
as divide-and-conquer algorithms for small or medium sized
collections.  For large collections it is probably more practical to
sort the collection as an @code{OBJECT **} array and create a new list
based on the collection members' sorted order.

However, it is almost always faster to add members to collections in
the order you want them sorted rather than trying to re-arrange the
collection later.  For this, refer to the methods in the
@code{SortedList} class @xref{SortedList}.

@idxlibfn{__ctalkStrToPtr}
@item __ctalkStrToPtr (@code{char *}@var{ptr})
Converts a formatted hexadecimal number to a @code{void *}.  The
function @cite{__ctalkGenericPtrFromStr}, below, performs some extra
validation.

@cindex __ctalkGenericPtrFromStr function
@cindex __ctalkStrToPtr function
@anchor{ctalkGenericPtrFromStr}
@item __ctalkGenericPtrFromStr (@code{char *}@var{s})
A wrapper function for @cite{__ctalkStrToPtr ()} that
performs some extra validation of the string argument.  These functions
convert a string containing a formatted hexadecimal number (e.g., 
@code{"0xnnnnnn"} or ``@code{"0XNNNNNN"} into a @code{void *.}  Both
of the functions return a @code{void *}, or NULL if the string does not
contain a valid hexadecimal number.

@cindex __ctalkGetCallingFnObject function
@item __ctalkGetCallingFnObject (@code{char *}@var{name}, @code{char *}@var{classname})
When used within @mnm{Object : become}, returns the object with the name @var{name} in the class @var{classname} from @mnm{become's} calling function.  Also adjusts its caller indexes if @mnm{become} is called within an argument block.

@cindex __ctalkGetCallingMethodObject function
@item __ctalkGetCallingMethodObject (@code{char *}@var{name}, @code{char *}@var{classname})
When used within @mnm{Object : become}, returns the object with the name @var{name} in the class @var{classname} from @mnm{become's} calling method.  Also adjusts its caller indexes if @mnm{become} is called within an argument block.

@idxlibfn{__ctalkGetCArg}
@item __ctalkGetCArg (@code{OBJECT *}@var{obj})
Retrieves the CVAR of the C variable named by @var{obj}.

@idxlibfn{__ctalkGetInstanceMethodByFn}
@item __ctalkGetInstanceMethodByFn (@code{OBJECT *}class_object, @code{OBJECT *}@var{(*fn)}(void), @code{int} @var{warn})
Returns the method that defines function @var{fn} from @var{class_object}, or
NULL if the method doesn't exist.  If @var{warn} is true, prints a warning
message if the method isn't found.

@idxlibfn{__ctalkGetInstanceMethodByName}
@item __ctalkGetInstanceMethodByName (@code{OBJECT *}class_object, @code{const char *}@var{name}, @code{int} @var{warn})
Returns the method named @var{name} from @var{class_object}, or NULL
if the class doesn't define a method with that name.  If @var{warn} is
true, prints a warning message if the method isn't found.

@idxlibfn{__ctalkGetReceiverPtr}
@item __ctalkGetReceiverPtr (@code{void})
Returns an @code{int} with the current value of the receiver stack
pointer.

@cindex __ctalkGetRS function
@item __ctalkGetRS (void)
Returns a @code{char} with the current record separator.  The record
separator determines, among other uses, how regular expression
characters act at line endings. @xref{RecordSeparator}.

@idxlibfn{__ctalkGetRunTimeException}
@item __ctalkGetRunTimeException (@code{void})
Remove the first exception from the exception queue and return the
exception's message as a char *.

@anchor{__ctalkGetTemplateCallerCVAR}
@cindex __ctalkGetTemplateCallerCVAR function
@item __ctalkGetTemplateCallerCVAR (@code{char *} @var{name})
If called from within a function template, looks up the @code{CVAR}
@var{name} in the calling function or method.  This function returns a
temporary object with the name and class, superclass, and value that
correspond to the @code{CVAR}'s data type.  The return object persists
until the next time this function is called.

@cindex __ctalkGetClass function
@item __ctalkGetClass (@code{char *} @var{classname})
Get the class object for @var{classname.}

@cindex __ctalkGetClassMethodByFn function
@item __ctalkGetClassMethodByFn (@code{OBJECT *}@var{rcvr}, @code{OBJECT *(*}@var{fn}@code{)(void)}, @code{int} @var{warn})
Return a class method of @var{rcvr's} class with the run-time function
@var{fn.} 

If @var{warn} is @code{TRUE,} issue a warning if the method is not found.

@cindex __ctalkGetClassMethodByName function
@item __ctalkGetClassMethodByName (@code{OBJECT *}@var{rcvr}, @code{char *}@var{name}, @code{int} @var{warn})
Return a class method of @var{rcvr's} class with the name @var{name.} 

If @var{warn} is @code{TRUE,} issue a warning if the method is not found.

@anchor{__ctalkGetExprParserAt}
@cindex __ctalkGetExprParserAt function
@item __ctalkGetExprParserAt (@code{int} @var{idx})
Return the expression parser, which is a struct @samp{EXPR_PARSER}
typedef, at stack index @var{idx.}

@cindex __ctalkGetExprParserPtr function
@item __ctalkGetExprParserPtr (@code{void})
Return the expression parser pointer, and @code{int.}

@idxlibfn{__ctalkGetClassVariable}
@item __ctalkGetClassVariable (@code{OBJECT *}@var{receiver}, @code{char *}@var{varname}, @code{int})
@var{warn})
Return the class variable named @var{varname} from the
receiver's class object, or @code{NULL} if the variable does
not exist.  If @var{warn} is @code{TRUE,} issue a warning
message if the variable is not found.

@idxlibfn{__ctalkGetExceptionTrace}
@item __ctalkGetExceptionTrace (@code{void})
Return @code{TRUE} if a program has enabled exception walkbacks,
@code{FALSE} otherwise.

@idxlibfn{__ctalkGetInstanceVariable}
@item __ctalkGetInstanceVariable (@code{OBJECT *}@var{receiver}, @code{char *}@var{varname}, @code{int})
@var{warn}) Return the instance variable named @var{varname}
from the receiver, or @code{NULL} if the variable does not
exist.  If @var{warn} is @code{TRUE,} issue a warning
message if the variable is not found.

@idxlibfn{__ctalkGetInstanceVariableByName}
@item __ctalkGetInstanceVariableByName (@code{char *}@var{receiver_name}, @code{char *}@var{varname}, @code{int})
@var{warn}) Return the instance variable named @var{varname} from the
object named by @var{receiver_name}, or @code{NULL} if the variable
does not exist.  If @var{warn} is @code{TRUE,} issue a warning message
if the variable is not found.

@idxlibfn{__ctalkGetPrefixMethodByName}
@item __ctalkGetPrefixMethodByName (@code{OBJECT *}class_object, @code{const char *}@var{name}, @code{int} @var{warn})
Returns the method named @var{name} from @var{class_object} that has
the @code{prefix} attribute set, or NULL if the class doesn't define a
prefix method with that name.  If @var{warn} is true, prints a warning
message if the method isn't found.

@idxlibfn{__ctalkGetTypeDef}
@item __ctalkGetTypeDef (@code{char *} @var{name})
Return the @code{CVAR} of the typedef @var{name}.

@idxlibfn{__ctalkGetX11KeySym}
@item __ctalkGetX11KeySym (@code{int} @var{keycode}, @code{int} @var{shift_state}, @code{int} @var{keypress})
Returns an @code{int} with the keyboard mapping of a keypress in X
applications.  This allows programs to distinguish between modifier
keypresses (e.g., shift, control, and alt), and alphanumeric
keypresses.

The first and second parameters are taken from an XKeyPressEvent or
XKeyReleaseEvent structure.  The third parameter, @var{keypress},
should be true for Keypress events and false for keyrelease events.

For alphanumeric keys, this function does not automatically modify the
ASCII code of a key that is pressed when the shift key (or any other
modifier key) is pressed.  That is, pressing @samp{A} and @samp{a}
both return the ASCII value 97.  It is up to the program to record
whether the shift key is pressed at the same time, and to provide the
shifted character itself if necessary.

@cindex @mnm{run} instance method @idxclscite{GLXCanvasPane}
Refer to the @mnm{run} method in @code{GLXCanvasPane} class for an
example.

This function uses @cite{XGetKeyboardMapping(3)} internally.

@cindex Shaders, OpenGL
@cindex GLEW library
@idxlibfn{__ctalkGLEW20}
@item __ctalkGLEW20 (@code{void})
Returns a boolean value of true if the GLEW library supports version
2.0 extensions, mainly for OpenGL programs that use shaders.  Programs must
call the @cite{__ctalkInitGLEW} function before using this function.


@idxlibfn{__ctalkGlobalObjectBecome}
@item __ctalkGlobalObjectBecome (@code{OBJECT *}@var{old}, @code{OBJECT *}@var{new})
Called when the receiver of @mnm{Object : become} is a global object.

@idxlibfn{__ctalkGlobFiles}
@item __ctalkGlobFiles (@code{char *}@var{pattern}, @code{OBJECT *}list)
If the system's C libraries support file globbing with the @cite{glob}
library function, @cite{__ctalkGlobFiles} returns the file and
directory pathnames that match @var{pattern} in the @code{List} object
given as the @var{list} argument.  

For information about how the C library matches file patterns, refer
to the @cite{glob(3)} and related manual pages.

@cindex GLUT library API functions
@item __ctalkGLUTVersion (void)
@item __ctalkGLUTCreateMainWindow (@code{char *}@var{title})
@item __ctalkGLUTInitWindowGeometry (@code{int} @var{x}, @code{int} @var{y}, @code{int} @var{width}, @code{int} @var{height})
@item __ctalkGLUTInit (@code{int} @var{argc}, @code{char **}@var{argv})
@item __ctalkGLUTRun (@code{void})
@item __ctalkGLUTInstallDisplayFn (@code{void (*}@var{fn}@code{)()})
@item __ctalkGLUTInstallReshapeFn (@code{void (*}@var{fn}@code{)(int, int)})
@item __ctalkGLUTInstallIdleFn (@code{void (*}@var{fn}@code{)()})
@item __ctalkGLUTInstallOverlayDisplayFunc (@code{void (*}@var{fn}@code{)()})
@item __ctalkGLUTInstallKeyboardFunc (@code{void (*}@var{fn}@code{)(unsigned char, int, int)})
@item __ctalkGLUTInstallMouseFunc (@code{void (*}@var{fn}@code{)(int, int, int, int)})
@item __ctalkGLUTInstallMotionFunc (@code{void (*}@var{fn}@code{)(int, int)})
@item __ctalkGLUTInstallPassiveMotionFunc (@code{void (*}@var{fn}@code{)(int, int)})
@item __ctalkGLUTInstallVisibilityFunc (@code{void (*}@var{fn}@code{)(int)})
@item __ctalkGLUTInstallEntryFunc (@code{void (*}@var{fn}@code{)(int)})
@item __ctalkGLUTInstallSpecialFunc (@code{void (*}@var{fn}@code{)(int, int, int)})
@item __ctalkGLUTInstallSpaceballMotionFunc (@code{void (*}@var{fn}@code{)(int, int, int)})
@item __ctalkGLUTInstallSpaceballRotateFunc (@code{void (*}@var{fn}@code{)(int, int, int)})
@item __ctalkGLUTInstallSpaceballButtonFunc (@code{void (*}@var{fn}@code{)(int, int)})
@item __ctalkGLUTInstallButtonBoxFunc (@code{void (*}@var{fn}@code{)(int, int)})
@item __ctalkGLUTInstallDialsFunc (@code{void (*}@var{fn}@code{)(int, int)})
@item __ctalkGLUTInstallTabletMotionFunc (@code{void (*}@var{fn}@code{)(int, int, int, int)})
@item __ctalkGLUTInstallMenuStatusFunc (@code{void (*}@var{fn}@code{)(int, int, int)})
@item __ctalkGLUTInstallMenuStateFunc (@code{void (*}@var{fn}@code{)(int)})
@item __ctalkGLUTInstallMenuStateFunc (@code{void (*}@var{fn}@code{)(int)})
@item __ctalkGLUTSphere (double, int, int, int);
@item __ctalkGLUTCube (double, int);
@item __ctalkGLUTCone (double, double, int, int, int);
@item __ctalkGLUTTorus (double, double, int, int, int);
@item __ctalkGLUTDodecahedron (int);
@item __ctalkGLUTOctahedron (int);
@item __ctalkGLUTTetrahedron (int);
@item __ctalkGLUTIcosahedron (int);
@item __ctalkGLUTTeapot (double, int);
@item __ctalkGLUTFullScreen (void);
@item __ctalkGLUTPosition (int, int);
@item __ctalkGLUTReshape (int, int);
@item __ctalkGLUTWindowID (@code{char *}@var{window_name})
The functions that make up Ctalk's glue layer for the GLUT API.  For
their use, refer to the methods in GLUTApplication class.

@idxlibfn{__ctalkGLXAlphaFT}
@item __ctalkGLXAlpha (@code{float} @var{alpha})
Sets the alpha (opacity) channel for outline text rendering.
Values should be between 0.0 (transparent) and 1.0 (opaque).
The Ctalk library's default value is 1.0 (opaque).

@idxlibfn{__ctalkGLXDrawText}
@item __ctalkGLXDrawText (@code{char *}@var{text})
This is another convenience function that draws text on a
@code{GLXCanvasPane} using a X font that the program registered with
the pane's GLX context via a previous call to
@cite{__ctalkGLXUseXFont}.

The @code{GLXCanvasPane} class defines several methods that facilitate
drawing with X fonts when using GLX. @xref{GLXCanvasPane}.

@idxlibfn{__ctalkGXLDrawTextFT}
@item __ctalkGLXDrawTextFT (@code{char *}@var{text}, @code{float} @var{x}, @code{float} @var{y})
Draws @var{text} at the matrix coordinates given by the
@var{x},@var{y} arguments.  Programs should call at least
@cite{__ctalkGLXUseFTFont} before calling this function.

@idxlibfn{__ctalkGLXExtensionsString}
@item __ctalkGLXExtensionsString (@code{void})
Returns a @code{char *} containing the extensions supported glX.

@idxlibfn{__ctalkGLXExtensionSupported}
@item __ctalkGLXExtensionSupported (@code{char *}@var{extName})
Returns a boolean value of True if the system's glX extension
supports @var{extName}, False otherwise.

@idxlibfn{__ctalkGLXFrameRate}
@item __ctalkGLXFrameRate (@code{void})
Returns a @code{float} with the frames per second of the calling
program.  The function averages the rate over each interval of
approximately five seconds.

@idxlibfn{__ctalkGLXFreeFTFont}
@item __ctalkGLXFreeFTFont (@code{void})
Frees the font and library data from a previous call to
@cite{__ctalkGLXUseFTFont.}  

@idxlibfn{__ctalkGLXFreeXFont}
@item __ctalkGLXFreeXFont (@code{void})
Frees X font data that was allocated by a previous call to
@cite{__ctalkGLXUseXFont}.  The @code{GLXCanvasPane} class defines
several methods that facilitate drawing with X fonts when using GLX.
@xref{GLXCanvasPane}.

@idxlibfn{__ctalkGLXFullScreen}
@item __ctalkGLXFullScreen (@code{OBJECT *}@var{selfObject}, @code{char *}@var{winTitle})
Toggles the window's full screen mode on and off.
      

@idxlibfn{__ctalkGLXNamedColorFT}
@item __ctalkGLXNamedColorFT (@code{char *}@var{colorname})
Sets the foreground color for drawing text with Freetype fonts
to the named X11 color given as the argument.

@idxlibfn{__ctalkGLXPixelHeightFT}
@item __ctalkGLXPixelHeightFT (@code{int} @var{pxheight})
Sets the height of the current Freetype face in use to the
pixel height given as the argument.

@idxlibfn{__ctalkGLXRefreshRate}
@item __ctalkGLXRefreshRate (@code{void})
Returns a @code{float} with the display's refresh rate if the OpenGL
installation supports the @code{GLX_OML_sync_control} extension.  If
OpenGL doesn't support @code{GLX_OML_sync_control}, the function prints
a warning message on the terminal and returns -1.

@idxlibfn{__ctalkGLXSwapBuffers}
@item __ctalkGLXSwapBuffers (@code{OBJECT *}@var{glxpane_object})
This is an API-level wrapper for the GLXSwapBuffers library function.

@idxlibfn{__ctalkGLXSwapControl}
@item __ctalkGLXSwapControl (@code{int} @var{interval})
Sets the swap buffer synchronization to 1/interval.  If interval is 0,
disables buffer swap synchronization. If the machine's OpenGL does not
support the @code{GLX_MESA_swap_control} extension, the function is a
no-op.  Returns 0 on success, -1 if the extension is not supported.

@idxlibfn{__ctalkGLXTextWidth}
@item __ctalkGLXTextWidth (@code{char *}@var{text})
Returns an @code{int} with the width in pixels of @var{text} rendered
in the current font.  The program must first have selected a X
font using @cite{__ctalkGLXUseFon}.  If no font is selected, the
function returns @samp{-1}.

@idxlibfn{__ctalkGLXUseFTFont}
@item __ctalkGLXUseFTFont (@code{String} @var{fontfilename})
Initializes the Freetype library and loads the font from
the file given as the argument.  Use @cite{__ctalkGLXFreeFTFont}
to release the font data before calling this function again
when changing fonts.

@idxlibfn{__ctalkGLXUseXFont}
@item __ctalkGLXUseXFont (@code{OBJECT *}@var{glxCanvasPaneObject}, @code{char *}@var{fontname})
This is a convenience function that registers the X font,
@var{fontname} for use with @var{glxCanvasPaneObject}, first by
retrieving the X font data for @var{fontname}, then registering the
font using @cite{glXUseXFont(3)}.

After the program has finished drawing with the font, the program
should call @cite{__ctalkGLXFreeXFont}.

The @code{GLXCanvasPane} class defines several methods that facilitate
drawing with X fonts when using GLX. @xref{GLXCanvasPane}.

@idxlibfn{__ctalkGLXFullScreen}
@item __ctalkGLXFullScreen (@code{void})
Returns a boolean value of true if the window is using
Freetype fonts, false otherwise.

@idxlibfn{__ctalkGLXWindowPos2i}
@item __ctalkGLXWindowPos2i (@code{int} @var{x}, @code{int} @var{y})
This is a wrapper for the @cite{glWindowPos2i} function, which several
methods in @code{GLXCanvasPane} class use.

Because @cite{glWindowPos2i} is an extension in many GL implementations,
Ctalk checks for the function's presence when compiling the libraries.

If the GL implementation does not provide @cite{glWindowPos2i}, then
any Ctalk program that tries to use this function (or one of the
methods that call it), prints an error message and exits.

@idxlibfn{__ctalkGLXWinXOrg}
@idxlibfn{__ctalkGLXWinYOrg}
@idxlibfn{__ctalkGLXWinXSize}
@idxlibfn{__ctalkGLXWinYSize}
@item __ctalkGLXWinXOrg (@code{void})
@item __ctalkGLXWinYOrg (@code{void})
@item __ctalkGLXWinXSize (@code{void})
@item __ctalkGLXWinYSize (@code{void})
These functions return an int with the window's current origin
and size.

@idxlibfn{__ctalkGUIPaneDrawCircleBasic}
@item __ctalkGUIPaneDrawCircleBasic (@code{void *}@var{display}, @code{int} @var{window_id}, @code{int} @var{gc}, @code{int} @var{center_x}, @code{int} @var{center_y}, @code{int} @var{radius}, @code{int} @var{fill}, @code{int} @var{pen_width}, @code{int} @var{alpha} @code{char *}@var{fg_color_name}, @code{char *}@var{bg_color_name})
Draws a circle centered at @var{center_x},@var{center_y} with radius
@var{radius}. The dimensions are given in pixels.  If @var{filled} is
true, then the function draws a filled circle; otherwise, the circle's
edge has the width @var{pen_width}.

This function is a synonym for @cite{__ctalkX11PaneDrawCircleBasic}.

@idxlibfn{__ctalkGUIPaneClearRectangle}
@item __ctalkGUIPaneClearRectangle (@code{OBJECT *}@var{pane_object}, @code{int} @var{x}, @code{int} @var{y}, @code{int} @var{width}, @code{int} @var{height})
Clear a rectangular region in a GUI Pane object. Also clear
the region in any buffers associated with the object.

@idxlibfn{__ctalkGUIPaneClearWindow}
@item __ctalkGUIPaneClearWindow (@code{OBJECT *}@var{pane_object})
Clear a pane object's window.

@idxlibfn{__ctalkGUIPaneDrawLine}
@item __ctalkGUIPaneDrawLine (@code{OBJECT *}@var{pane_object}, @code{OBJECT *}@var{line_object}, @code{OBJECT *}@var{pen_object})
Draw a line specified by @var{line_object} (an instance of
@code{Line} class) using @var{pen_object} (an instance of @code{Pen}
class).

@idxlibfn{__ctalkGUIPaneDrawLineBasic}
@idxlibfn{__ctalkX11PaneDrawLineBasic}
@item __ctalkGUIPaneDrawLineBasic (@code{void *}@var{display}, @code{int} @var{drawable_id}, @code{int} @var{gc_ptr}, @code{int} @var{x_start}, @code{int} @var{y_start}, @code{int} @var{x_end}, @code{int} @var{y_end}, @code{int} @var{pen_width}, @code{int} @var{alpha}, @code{char *}@var{pen_color})
@item __ctalkX11PaneDrawLineBasic (@code{void *}@var{display}, @code{int} @var{drawable_id}, @code{int} @var{gc_ptr}, @code{int} @var{x_start}, @code{int} @var{y_start}, @code{int} @var{x_end}, @code{int} @var{y_end}, @code{int} @var{pen_width}, @code{int} @var{alpha}, @code{char *}@var{pen_color})
Draw a line between the points (x_start,y_start) and (x_end, y_end)
with the color, and transparency using the drawable ID, graphics
context, and pen color, width, and transparency given as arguments.

This function is a synonym for @cite{__ctalkX11PaneDrawPointBasic.}

@idxlibfn{__ctalkGUIPaneDrawPoint}
@item __ctalkGUIPaneDrawPoint (@code{OBJECT *}@var{pane_object}, @code{OBJECT *}@var{point_object}, @code{OBJECT *}@var{pen_object})
Draw a point on @var{pane_object} specified by
@var{point_object} using @var{pen_object}.

@idxlibfn{__ctalkGUIPaneDrawRectangle}
@item __ctalkGUIPaneDrawRectangle (@code{OBJECT *}@var{pane_object}, @code{OBJECT *}@var{rectangle_object}, @code{OBJECT *}@var{pen_object}, @code{int} @var{fill})
Draw a rectangle on @var{pane_object} specified by
@var{rectangle_object} using @var{pen_object}.  If
@var{fill} is non-zero, draw a filled rectangle.

@idxlibfn{__ctalkGUIPaneDrawRoundedRectangle}
@item __ctalkGUIPaneDrawRoundedRectangle (@code{OBJECT *}@var{pane_object}, @code{OBJECT *}@var{rectangle_object}, @code{OBJECT *}@var{pen_object}, @code{int} @var{fill}, @code{int} @var{radius})
This is similar to @cite{__ctalkGUIPaneDrawRectangle}, except that it takes an extra argument, @var{radius}, which specifies the radius of the arcs that are used to draw the corners.

@idxlibfn{__ctalkGUIPanePutStr}
@item __ctalkGUIPanePutStr (@code{OBJECT *}@var{pane_object}, @code{int} @var{x}, @code{int} @var{y}, @code{char *}@var{string})
Display @code{String} object @var{string} at coordinates
@var{x},@var{y} on @var{pane_object}.  You can select the
font with the @mnm{font} method in class @code{X11Pane}.
This function relies on instance variables defined in
@code{X11Pane} class.  The @code{__ctalkX11PanePutStrBasic}
function, below, provides a more flexible interface to the X
libraries.

@idxlibfn{__ctalkGUIPaneRefresh}
@item __ctalkGUIPaneRefresh (@code{OBJECT *}@var{pane_object}, @code{int} @var{srcX}, @code{int} @var{srcY}, @code{int} @var{srcWidth}, @code{int} @var{srcHeight}, @code{int} @var{destX}, @code{int} @var{destY})
Refresh the Pane object by updating the visible window with
@var{pane_object}'s buffers and, if necessary, notifying the
GUI library that the window has been updated.

@idxlibfn{__ctalkGUISetBackground}
@item __ctalkGUISetBackground (@code{OBJECT *}@var{pane_object}, @code{char *}@var{color})
Set the background of a pane's window to @var{color}.  This
function is intended only for objects that have
an actual window; e.g., @code{X11Pane} objects.  For all
other visual types, like pixmaps, use
__ctalkX11SetBackgroundBasic.

@idxlibfn{__ctalkX11SubWindowGeometry}
@cindex Window geometry
@cindex Geometry, windows
@item __ctalkX11SubWindowGeometry (@code{OBJECT *} @var{parentpane}, @code{char *} @var{geomstr}, @code{int *}@var{x_out}, @code{int *}@var{y_out}, @code{int *}@code{width_out}, @code{int *}@var{height_out})
Parses a string that contains the geometry specification of a
subwindow, and returns the width and height of the subwindow and its
X,Y position within the parent pane's window.

A geometry specification has the form:

@example

width[%]xheight[%][+x_org[%]+y_org[%]]

@end example

The @emph{x, y, width, and height} parameters are interpreted as the
actual origin and size of the subwindow, unless a parameter is
followed by a percent sign (@samp{%}).  In that case, the dimension is
interpreted as a fraction of the parent window's corresponding
vertical or horizontal dimension.

For some @code{Pane} classes, like dialog windows, if @emph{x_org} and
@emph{y_org} are missing, then the class positions the dialog window
centered over the parent window.

@idxlibfn{__ctalkX11TextFromData}
@item __ctalkX11TextFromData (@code{void *}@var{display}, @code{int} @var{drawable_id}, @code{int} @var{GD_ptr}, @code{char *}@var{text})
Displays @var{text} on @var{drawable_id}.

@idxlibfn{__ctalkX11TextWidth}
@item __ctalkX11TextWidth (@code{char *}@var{fontDesc}, @code{char *}@var{text})
Returns an @code{int} with the width in screen pixels of the
@var{text} argument when rendered in the font named by @var{fontDesc}.
There is more information about how to use fonts in the sections
that discuss the X graphics classes. @xref{X11Font}.

@idxlibfn{__ctalkHandleRunTimeException}
@item __ctalkHandleRunTimeException (@code{void})
Execute the exception handler for a pending exception.  The
@mnm{handle} method (class @code{Exception}) calls this function.
@xref{Exception}.

@idxlibfn{__ctalkHandleRunTimeExceptionInternal}
@item __ctalkHandleRunTimeExceptionInternal (@code{void})
Execute the exception handler for a pending exception.  If the
exception is generated by an expression, execute the exception handler 
only if further expressions or subexpressions need to be evaluated.

@idxlibfn{__ctalkHaveFTFaceBasic}
@item __ctalkHaveFTFaceBasic (@code{void})
Returns TRUE if an application has created a new FreeType2 font face,
FALSE otherwise.  This is a lower level library function that
apps should not need to use directly, and may go away in the future.

@idxlibfn{__ctalkHexIntegerToASCII}
@item __ctalkHexIntegerToASCII (@code{unsigned int} @var{ptr}, @code{char *}@var{s})
Format a hexadecimal representation of @var{ptr} in @var{s}.  The return
value is the formatted string in @var{s}.

On 64-bit machines, the prototype is: 

@example

char *__ctalkHexIntegerToASCII (unsigned long long int ptr, char *buf)

@end example

@cindex Icon, dialog
@cindex Dialog icon
@idxlibfn{__ctalkIconXPM}
@item __ctalkIconXPM (@code{int} @var{iconID})
Returns a @code{char **} with the XPM data for the dialog icon given
by @var{iconID}.  The library defines the following icon IDs.

@example

ICON_NONE
ICON_STOP
ICON_CAUTION
ICON_INFO

@end example

@idxlibfn{__ctalkIgnoreSignal}
@item __ctalkIgnoreSignal (@code{int} @var{signo})
Set the handler for @var{signo} to ignore the signal.

@idxlibfn{__ctalkIncKeyRef}
@idxlibfn{__ctalkIncStringRef}
@item __ctalkIncKeyRef (@code{OBJECT *}@var{object}, @code{int} @var{inc}, @code{int} @var{op})
@item __ctalkIncStringRef (@code{OBJECT *}@var{object}, @code{int} @var{idx}, @code{int} @var{op})
Increment the reference to the value of @var{object}, a @code{String}
or @code{Key} object, or one of its subclasses, by @var{idx}.  If
@var{idx} is negative, decrements the reference to the value of the
receiver.  If the reference is before or after the start or end of the
receiver's value, further uses of the object return NULL.

The argument @var{op} can be one of the following constants, which are
defined in @flnm{ctalkdefs.h}.

@table @code
@item TAG_REF_PREFIX
Increments (or decrements) the value of the receiver immediately. 
Normally this is used for prefix @code{++} and @code{--} operators,
and also @code{+=} and @code{-=} operators.

@item TAG_REF_POSTFIX
Increments (or decrements) the value of the receiver after its
value is accessed.  Used normally for postfix @code{++} and @code{--}
operators.

@item TAG_REF_TEMP
Adds a temporary reference that is cleared after the receiver is
next read.  Normally you would use this for expressions that assign
the reference to another object, as in this example.

@example

String new str1;
String new str2;

str1 = "Hello, world!";

str2 = str1 + 3;

@end example

The object @code{str2} is assigned the calculated reference.  The
value of @code{str1} is unaffected.

@end table

@cindex Shaders, OpenGL
@cindex GLEW library
@idxlibfn{__ctalkInitGLEW}
@item __ctalkInitGLEW (@code{void})
Initialize the GLEW library.  Programs must call this function
before performing any operations that use OpenGL extensions.

@idxlibfn{__ctalkInlineMethod}
@item __ctalkInlineMethod (@code{OBJECT *}@var{rcvr}, @code{METHOD *}@var{method}, @code{int} @var{n_args}, ...)
Call a method or block of code that is an argument to another method.
The class of @var{rcvr} and the class of @var{method} do not need to
be the same.  Currently, only the @mnm{map} method uses inline method
calls.  For an example of the @code{__ctalkInlineMethod ()}'s use, see
@mnm{map} (implemented by the @code{List}, @code{Array}, and
@code{AssociativeArray} classes).  This function can (and should) be
used to implement inline method messages or code blocks when streaming
over collections.

The @var{n_args} argument specifies the number of arguments to be passed
to the target method.  Currently @code{__ctalkInlineMethod ()} supports
0 - 6 arguments.

@idxlibfn{__ctalkIntRadixToDecimalASCII}
@item __ctalkIntRadixToDecimalASCII (@code{char *}@var{intbuf})
Return a C string with the integer formatted in @var{intbuf} formatted
as a decimal (base 10) integer.

@idxlibfn{__ctalkInstallHandler}
@item __ctalkInstallHandler (@code{int} @var{signo}, @code{OBJECT *(*}@var{method_c_function}@code{)()})
Set the handler of signal @var{signo} to
@var{method_c_function}.  The prototype of
@var{method_c_function} is similar to the intermediate C prototype of
Ctalk's methods.  Signal handlers installed with this
function reset the handler to the default after each use,
except for handlers on DJGPP platforms.

@idxlibfn{__ctalkInstallPrefix}
@item __ctalkInstallPrefix (@code{void})
Returns a @code{char *} with the top-level directory where Ctalk is
installed.  Ctalk's installation uses this directory as the top-level
directory of its installation layout; for example, in relative terms,
this is where Ctalk's various components get installed:

@example

Executables:            @emph{prefixdir}@code{/bin}
Libraries:              @emph{prefixdir}@code{/lib}
Class Libraries:        @emph{prefixdir}@code{/include/ctalk}
Texinfo Manuals:        @emph{prefixdir}@code{share/info}
Manual Pages:           @emph{prefixdir}@code{/share/man}
Searchable Docs:        @emph{prefixdir}@code{/share/ctalk}

@end example

@idxlibfn{__ctalkInstanceMethodInitReturnClass}
@item __ctalkIntanceMethodInitReturnClass (@code{char *}@var{rcvrclassname}, @code{char *}@var{methodname}, @code{char *}@var{returnclassname})
Set the return class of method @var{methodname} of class
@var{rcvrclassname} to @var{returnclassname}.

@idxlibfn{__ctalkInstanceVarsFromClassObject}
@item __ctalkInstanceVarsFromClassObject (@code{OBJECT *}@var{obj})
Add the instance variables defined by @var{obj's} class object.

@idxlibfn{__ctalkInstanceVarIsCallersReceiver}
@item __ctalkInstanceVarIsCallersReceiver (@code{void})
Used by @mnm{Object: become}. Returns True if the receiver object is
an instance variable, False otherwise.

@idxlibfn{__ctalkInitFTLib}
@item __ctalkInitFTLib (@code{void})
Initialize the system's FreeType2 library.  Returns 0 if
successful, ERROR (@samp{-1}) if unsuccessful or if the
library isn't available.  This is a lower level function
that should not normally be needed by apps directly, and may
go away in the future.

@idxlibfn{__ctalkInstanceMethodParam}
@item __ctalkInstanceMethodParam (@code{char *}@var{rcvrclassname}, @code{char *}@var{methodname}, @code{OBJECT *}@var{(*selector_fn)()}, @code{char *}@var{paramclass}, @code{char *}@var{paramname}, @code{int} @var{param_is_pointer})
Define a method parameter when initializing a method. Normally the compiler
generates this call for inclusion in @code{__ctalk_init ()} for the method
initialization at run time.

@idxlibfn{__ctalkIntFromCharConstant}
@item __ctalkIntFromCharConstant (@code{char *}@var{str})
Returns the @code{int} value of the character constant @var{str}.  Recognizes
all of the escape sequences that Ctalk uses, whether the constant is enclosed
in single quotes or not.  Also recognizes backslash escape sequences and
the following control character constants.

@example

Escape Sequence    Int Value
\0                 0
\a                 1
\b                 2
\e                 27
\f                 6
\n                 10
\r                 13
\t                 9
\v                 11

@end example

The @samp{\e} escape sequence is an extension to the C language
standard.

@idxlibfn{__ctalkIsClassVariableOf}
@item __ctalkIsClassVariableOf (@code{char *}@var{class}, @code{char *}@var{varname})
Returns @code{TRUE} if @var{varname} is a class variable of
@var{class}, @code{FALSE} otherwise.

@idxlibfn{__ctalkIsCallersReceiver}
@item __ctalkIsCallersReceiver (@code{void})
Used by @mnm{Object : become} to determine if an object is the
calling method's receiver.

@idxlibfn{__ctalkIsDir}
@item __ctalkIsDir (@code{char *}@var{path})
Returns @code{TRUE} if @var{path} is a directory, @code{FALSE}
otherwise.

@idxlibfn{__ctalkIsInstanceMethod}
@item __ctalkIsInstanceMethod (@code{OBJECT *}@var{self_object}, @code{char *}@var{method_name})
@idxlibfn{__ctalkIsClassMethod}
@item __ctalkIsClassMethod (@code{OBJECT *}@var{self_object}, @code{char *}@var{method_name})
The functions return True if the method given by @var{method_name} is
an instance or class method, respectively, in @var{self_object's}
class.

@idxlibfn{__ctalkIsInstanceVariableOf}
@item __ctalkIsInstanceVariableOf (@code{char *}@var{class}, @code{char *}@var{varname})
Returns @code{TRUE} if @var{varname} is an instance variable of
@var{class}, @code{FALSE} otherwise.

@idxlibfn{__ctalkIsObject}
@item __ctalkIsObject (@code{OBJECT *}@var{o})
Return @code{TRUE} if if @var{o} is a valid object, @code{FALSE} otherwise.

@idxlibfn{__ctalkIsSubClassOf}
@item __ctalkIsSubClassOf (@code{char *}@var{classname}, @code{char *}@var{superclassname})
Return @code{TRUE} if @var{classname} is a subclass of
@var{superclassname}, @code{FALSE} otherwise.

@idxlibfn{__ctalkLastMatchLength}
@item __ctalkLastMatchLength (@code{void})
Return the length of the match from the last call to @cite{__ctalkMatchText},
below.

@idxlibfn{__ctalkLibcFnWithMethodVarArgs}
@item __ctalkLibcFnWithMethodVarArgs (@code{int (*}@var{libcfn}@code{)()}, @code{METHOD *}@var{method}, @code{char *}@var{libcfn_return_class})
Call the C library function @var{libcfn} using with its template
method @var{method}.  For C library functions that use @code{stdarg.h}
variable arguments, @var{libcfn_return_class} should be
@code{Integer.}

When evaluating an expression, the currently executing method is
contained in the current
@code{EXPR_PARSER}. @xref{__ctalkGetExprParserAt}.  

@emph{Note:} This version of Ctalk only supports
variable-argument functions on 32-bit Intel platforms.  If you try to
use a variable-argument function on another hardware platform, Ctalk
issues a warning and returns @code{NULL.}

@idxlibfn{__ctalkLogMessage}
@item __ctalkLogMessage (@code{char *, ...})
Formats the message given as the argument and writes the
message to the system's syslog facility.

@idxlibfn{__ctalkMatchAt}
@idxlibfn{__ctalkMatchIndexAt}
@item __ctalkMatchAt (@code{Integer} @var{n})
@item __ctalkMatchIndexAt (@code{Integer} @var{n})
Returns, respectively, the text, or the character index matched by the
@var{n'th} parenthesized subexpression during a previous call to
@cite{__ctalkMatchText} (i.e., a backreference).  The argument, @var{N},
is @samp{0} for the first parenthesized subexpression, @samp{1}
for the next subexpression, and so on. If the @emph{n'}th pattern didn't
match any text, returns NULL. @xref{Pattern Matching}.

@idxlibfn{__ctalkMatchText}
@item __ctalkMatchText (@code{char *}@var{pattern}, @code{char *}@var{text}, @code{long long int *}@var{offsets})
Find the occurences of @var{pattern} in @var{text}.  Returns the index
of each match in the @var{offsets} array, with the list terminated by
-1.  Returns the number of matches, or -1 if there are no matches.

@idxlibfn{__ctalkMatchPrintToks}
@item __ctalkMatchPrintToks (@code{bool} @var{printToks})
If @var{printToks} is @code{true}, then Ctalk prints the regular
expression tokens and the matching text for every regular
expression match, which can be useful for debugging regular
expressions.

@idxlibfn{__ctalkMapGLXWindow}
@item __ctalkMapGLXWindow (@code{OBJECT *}@var{glxcanvaspane_object})
Maps a @code{GLXCanvasPane's} window to the display and creates
a @code{GLXContext} for the window, and makes the GLXContext current.

Saves the GLXContext pointer in the receiver's @code{glxContextPtr}
instance variable. @xref{GLXCanvasPane}.

@idxlibfn{__ctalkMapX11Window}
@item __ctalkMapX11Window (@code{OBJECT *}@var{x11pane_object})
The X library interface of the @mnm{map} (class @code{X11Pane})
method @xref{X11Pane}. This function is a wrapper for the @cite{XMapWindow} and
@cite{XMapSubwindows} Xlib functions.

@idxlibfn{__ctalkMethodObjectMessage}
@item __ctalkMethodObjectMessage (@code{OBJECT *}@var{rcvr}, @code{OBJECT *}@var{method_instance})
Perform a method call by sending @var{rcvr} the message defined by
@var{method_instance}, which is a previously defined @code{Method}
object.  @xref{Method}.

The function returns @samp{0} on success, @samp{-1} on error.

For examples of @code{Method} object calls, @xref{methodObjectMessage}.

@idxlibfn{__ctalkMethodObjectMessage2Args}
@item __ctalkMethodObjectMessage (@code{OBJECT *}@var{rcvr}, @code{OBJECT *}@var{method_instance}, @code{OBJECT *}@var{arg1}, @code{OBJECT *}@var{arg2})
Perform a method call by sending @var{rcvr} the message defined by
@var{method_instance}, which is a previously defined @code{Method}
object.

The parameters @var{arg1} and @var{arg2} are the arguments
to the method instance.  @code{Method} objects with two arguments
are commonly used in graphical event dispatchers, particularly
in @code{X11PaneDispatcher} class.  This helps simplify the
event dispatcher methods.

The function returns @samp{0} on success, @samp{-1} on error.

For examples of @code{Method} object calls, @xref{methodObjectMessage}.

@idxlibfn{__ctalkMethodReturnClass}
@item __ctalkMethodReturnClass (@code{char *}@var{classname})
Set the return class of an instance or class method during method
initialization.

@idxlibfn{__ctalkNArgs}
@item __ctalkNArgs (@code{void})
Returns an @code{int} with the number of arguments passed to the
current method.

@idxlibfn{__ctalkNMatches}
@item __ctalkNMatches (@code{void})
Returns an @code{int} with the number of matches from the
last call to __ctalkMatchText.

@idxlibfn{__ctalkNewFTFace}
@item __ctalkNewFTFace (@code{void})
Initialize a new FreeType2 face object.  This is a lower level library
function that apps should not need to use directly, and may go away in
the future.

@anchor{__ctalkNewSignalEventInternal}
@idxlibfn{__ctalkNewSignalEventInternal}
@item __ctalkNewSignalEventInternal (@code{int} @var{signo}, @code{int} @var{pid}, @code{char *}@var{data})
Generate and queue a @code{SignalEvent} object for signal @var{signo}
with process ID @var{pid}.  The @var{data} argument is a @code{String}
object that the program can use to pass information back to the
application. 

@idxlibfn{__ctalkNonLocalArgBlkReturn}
@item __ctalkNonLocalArgBlkReturn (@code{void})
Returns a @code{bool} value of true or false to an argument
block's parent method to indicate whether the argument block
executed a @code{return} statement.

@idxlibfn{__ctalkObjValPtr}
@anchor{ctalkObjValPtr}
@item __ctalkObjValPtr (@code{OBJECT *}@var{o}, @code{void *}@var{ptr})
Set the value of the object @var{o} to @var{ptr}.

@idxlibfn{__ctalkPandResource}
@item __ctalkPaneResource (@code{OBJECT *}@var{paneObject}, @code{char *}@var{resourceName}, @code{bool} @var{warn})
Returns an @code{OBJECT *} with the value corresponding to
@var{resourceName} from @var{paneObject's} @code{resource} instance
variable.  If @var{warn} is true, displays a warning if the resource
isn't found.

@idxlibfn{__ctalkPeekExceptionTrace}
@item __ctalkPeekExceptionTrace (@code{void})
Returns a @code{char *} with the text of the most recent exception and
its stack trace.

@idxlibfn{__ctalkPeekRunTimeException}
@item __ctalkPeekRunTimeException (@code{void})
Returns a @code{char *} with the text of the most recent
exception.

@idxlibfn{__ctalkPendingException}
@item __ctalkPendingException (@code{void})
A convenience method for @code{__ctalkTrapException.}  Returns
@code{TRUE} if an exception is pending, @code{FALSE} otherwise.

@cindex __ctalkPrintExceptionTrace function
@item __ctalkPrintExceptionTrace (@code{void})
Print a walkback of the current exception's copy of the program call
stack.  

@anchor{__ctalkPrintObject}
@idxlibfn{__ctalkPrintObject}
@item __ctalkPrintObject (@code{OBJECT *}@var{object})
Print the object given by the argument, and its instance variables, to
standard output.

@idxlibfn{__ctalkPrintObjectByName}
@item __ctalkPrintObjectByName (@code{OBJECT *}@var{object_name})
Print the object named by @var{object_name} to the standard output.

@idxlibfn{__ctalkProcessWait}
@item __ctalkProcessWait (@code{int} @var{child_processid}, @code{int *}@var{child_return_value_out}, @code{int *}@var{child_term_sig_out}, @code{int *}@var{errno_out})
Checks the status of the child process specified by @var{child_processid}.

If the return value of @cite{__ctalkProcessWait} is 0, then there is
no change in the child processes' status to report.  A return value
equal to @var{child_processid} indicates that the child process has
exited.  If the return value is -1, then there was an error either in
the process that called @cite{__ctalkProcessWait}, the child process,
or both.

When @cite{__ctalkProcessWait's} return value is equal to
@var{child_processid}, the function returns the child
processes' return value in @var{child_return_value_out}.  If the
child process was terminated by an uncaught signal, the signal
number is returned in @var{child_term_sig_out}.

If the function's return value is -1, then function returns
the system's error code in @var{errno_out}.

@idxlibfn{__ctalkRaiseX11Window}
@item __ctalkRaiseX11Window (@code{OBJECT *}@var{x11pane_object})
The X library interface of the @mnm{raise} (class @code{X11Pane})
method. 

@idxlibfn{__ctalkReceiverReceiverBecome}
@item __ctalkReceiverReceiverBecome (@code{OBJECT *}@var{object})
Used by @mnm{become} (class @code{Object}) to change the
calling method's receiver to the object given as the argument.

@idxlibfn{__ctalkReferenceObject}
@item __ctalkReferenceObject (@code{OBJECT *}@var{obj}, @code{OBJECT *}@var{reffed_obj})
Sets @var{obj's} value to @var{reffed_obj's} hexadecimal address.
Also incrememts @var{reffed_obj's} reference count by 1 and adds
VAR_REF_OBJECT to its scope.

@idxlibfn{__ctalkRegisterArgBlkReturn}
@item __ctalkRegisterArgBlkReturn (@code{int} @var{return_code}, @code{OBJECT *}@var{return_object})
This function gets called when Ctalk encounters a return statement in
an argument block.  The first argument is the return code of the
argument block itself (typically an @code{Integer} object with a value
of -2, which signals the @mnm{map} method that the argument block has
requested a return from the parent function or method), and the second
argument is the object that is to be returned by the caller.  

The following example should hopefully explain how these functions
work together.  The comments indicate where the compiler inserted
these functions.

@c test/expect/examples/mapstring3.c
@example

int main () @{
  String new str;

  str = "Hello, world!";

  str map @{
    if (self == 'o') @{
      break;
    @}
    printf ("%c", self);
  @}
  printf ("\n");

  str map @{
    switch (self)
      @{
      case 'a':
      case 'e':
      case 'i':
      case 'o':
      case 'u':
	if (self == 'o') @{
	  printf ("\n");
	  return 11;          /* __ctalkRegisterArgBlkReturn inserted   */
	@}                    /* here.  The String map method, which is */
	break;                /* the argument block's direct caller,    */
      @}                      /* contains a __ctalkArgBlkSetCallerReturn*/
    (Character *)self -= 32;  /* function call.                         */
    printf ("%c", self);
  @}
  printf ("\n");
@}


/* After the argument block call, the compiler inserts a 
   construct like the following:   

    if (__ctalkNonLocalArgBlkReturn ()) @{
        return __ctalkToCInteger (__ctalkArgBlkReturnVal (), 1);
    @}

  This retrieves the argument block's return value if any,
  and returns from the calling function.
*/
@end example

The @code{String : map} method contains an example of how an argument
block can signal a return from the function or method that called it.
Refer also to the @cite{__ctalkArgBlkSetCallerReturn} and
@cite{__ctalkArgBlkClearCallerReturn} functions above.

@cindex @code{boolTrue} class variable @idxclscite{Boolean}
@cindex @code{boolFalse} class variable @idxclscite{Boolean}
@anchor{ctalkRegisterBoolReturn}
@idxlibfn{__ctalkRegisterBoolReturn}
@item __ctalkRegisterBoolReturn (@code{int} @var{t-or-f-arg})
Returns a boolean object with a true or false value depending
on the value of @var{t-or-f-arg}.  If the Boolean class variables
@code{boolTrue} or @code{boolFalse} are defined, returns one of
those objects.  Otherwise, creates a @code{Boolean} object with
the value true or false.

@idxlibfn{__ctalkRegisterCharPtrReturn}
@item __ctalkRegisterCharPtrReturn (@code{char *}@var{var})
Saves a C @code{char *} method return value to the method's
resource pool.

@idxlibfn{__ctalkRegisterCharReturn}
@item __ctalkRegisterCharPtrReturn (@code{char} @var{var})
Saves a C @code{char} method return value to the method's
resource pool.

@idxlibfn{__ctalkRegisterCTypedef}
@item (@code{char *}@var{type}, @code{char *}@var{qualifier}, @code{char *}@var{qualifier2}, @code{char *}@var{qualifier3}, @code{char *}@var{qualifier4}, @code{char *}@var{storage_class}, @code{char *}@var{name}, @code{int} @var{n_derefs}, @code{int} @var{attrs}, @code{int} @var{is_unsigned}, @code{int} @var{scope})
Register a C typedef with an application.  This function is typically
used by @cite{__ctalk_init} to register typedefs defined in C include
files and elsewhere.

@idxlibfn{__ctalkRegisterExtraObject}
@item __ctalkRegisterExtraObject (@code{OBJECT *}@var{created_object})
Save an object retrieved by a function so it may be referred to later.
This function registers each object only once and does not adjust the
object's reference count or scope.  The
@code{__ctalkRegisterExtraObject} function silently ignores request to
register global and class objects.  Refer to the entry for
@code{__ctalkRegisterUserObject,} below.

@idxlibfn{__ctalkRegisterFloatReturn}
@item __ctalkRegisterFloatReturn (@code{double} @code{d})
Registers a C @code{double} return value as a @code{Float} method
resource object.  Note that the C libraries do not automatically
convert C @code{floats} to @code{doubles}, so if you register a C
@code{float} as a method resource, you need to cast it to a
@code{double} first.

@idxlibfn{__ctalkRegisterIntReturn}
@item __ctalkRegisterIntReturn (@code{int} @var{returnval})
Registers a C @code{int} method return value as an @code{Integer}
method resource object.

@idxlibfn{__ctalkRegisterLongLongIntReturn}
@item __ctalkRegisterIntReturn (@code{long long int} @var{returnval})
Registers a C @code{long long int} method return value as a
@code{LongInteger} method resource.

@idxlibfn{__ctalkRegisterUserFunctionName}
@item __ctalkRegisterUserFunctionName (@code{char *}@var{name})
Registers the names of C functions in the program, mainly for
diagnostic messages. This function is added automatically to
@code{__ctalk_init} whenever a C function in the source code
is parsed and is called at the start of a program.

@anchor{__ctalkRegisterUserObject}
@idxlibfn{__ctalkRegisterUserObject}
@item __ctalkRegisterUserObject (@code{OBJECT *}@var{created_object})
Save objects created by a method so they may be referred to
later.  New objects registered by this function have a
reference count of 1, and have the additional scope
@code{METHOD_USER_OBJECT}.  This function is also used by
many of the @code{methodReturn*} macros, and if necessary
you can included it in a method if you need to register an
object in some non-standard manner. @xref{Returning method
values}.

Note that global objects and class objects do not need to be
registered.  In fact, registering such objects as method
resources can confuse the object's entries in their
respective dictionaries, because method resources have a
separate dictionary of their own.  If a method tries to
register a class object or global object,
@code{__ctalkRegisterUserObject} silently ignores the
request.


@cindex @mnm{copy} instance method @idxclscite{Object}
@cindex Variable identifiers (tags)
@cindex Identifiers for variables (tags)
@idxlibfn{__ctalkReplaceVarEntry}
@idxlibfn{__ctalkAliasReceiver}
@item __ctalkReplaceVarEntry (@code{VARENTRY *}@var{varentry}, @code{OBJECT *}@var{new_object})
This function has been superceded.  If you want to attach an Object to
another tag, it's only necessary to use an assignment statement.  See
@cite{__ctalkAliasReceiver ()} for an example

@idxlibfn{__ctalkRtGetMethod}
@item __ctalkRtGetMethod (@code{void})
Returns the currently executing method as a @code{METHOD *} from the
call stack, or NULL if called from within a C function.

@idxlibfn{__ctalkRtReceiver}
@item __ctalkRtReceiver (@code{OBJECT *}@var{receiver_object})
Sets the call stack's receiver to @var{receiver_object}.  The function
however, does not alter the currently executing method's receiver on
the receiver stack.

@idxlibfn{__ctalkRtReceiverObject}
@item __ctalkRtReceiverObject (@code{void})
Returns the currently executing method's receiver object from
the call stack.

@idxlibfn{__ctalkRtSaveSourceFileName}
@item __ctalkRtSaveSourceFileName (@code{char *}@var{fn})
Called during the initialization of a function or method to
store the name of its source file.

@idxlibfn{__ctalkRtGetMethodFn}
@item __ctalkRtGetMethodFn (@code{void})
Returns the C function pointer (an @code{OBJECT *(*)()} of the currently
executing method, or NULL if called from within a C function.

@idxlibfn{__ctalkRtMethodClass}
@item __ctalkRtMethodClass (@code{OBJECT *}@var{class_object})
Sets the class object of the currently executing method to @var{class_object}.

@idxlibfn{__ctalkRtMethodClassObject}
@item (@code{OBJECT *}@var{class_object})
Returns the class object of the currently executing method.

@idxlibfn{__ctalkSearchBuffer}
@item __ctalkSearchBuffer (@code{char *}@var{pattern}, @code{char *}@var{buffer}, @code{long long *}@var{offsets})
Finds all occurrences of @var{pattern} in @var{buffer}, and
returns the positions of the matches in @var{offsets}, terminated by -1.

@idxlibfn{__ctalkSelectXFontFace}
@idxlibfn{__ctalkX11UseFontBasic}
@item __ctalkSelectXFontFace (@code{void *}@var{display}, @code{int} @var{drawable_id}, @code{int} @var{gc_ptr}, @code{int} @var{face})
Selects the typeface of the currently selected font, if available,
which should have been loaded with a call like
@cite{__ctalkX11UseFontBasic}, or the equivalent calls for
FreeType fonts.

The argument, @var{face}, may be one of the following.

@example

X_FACE_REGULAR
X_FACE_BOLD
X_FACE_ITALIC
X_FACE_BOLD_ITALIC

@end example

Because these functions use shared memory to manage each X typeface's
metrics, it is generally necessary to call this function after calling
@cite{__ctalkOpenX11InputClient} in order to display multiple faces
with the correct character spacing.

@idxlibfn{__ctalkSelfPrintOn}
@item __ctalkSelfPrintOn (void)
Print the calling method's arguments to the receiver.  This 
function is called directly by @mnm{printOn} (class @code{String})
and similar methods. @xref{String}.

@idxlibfn{__ctalkSetExceptionTrace}
@item __ctalkSetExceptionTrace (@code{int} @var{val})
Enable or disable exception method traces in @mnm{handle} (class
@code{Exception}) and other methods. @xref{Exception}.

@idxlibfn{__ctalkSetObjectName}
@item __ctalkSetObjectName (@code{OBJECT *}@var{object}, @code{char *}@var{name})
Sets the name of @var{object} to @var{name}.

@idxlibfn{__ctalkSetObjectScope}
@cindex Scope of objects
@item __ctalkSetObjectScope (@code{OBJECT *}@var{object}, @code{int} @var{scope})
Set the scope of @var{object} to @var{scope}.  Note that many of
Ctalk's scopes are only used internally.  The scopes that are useful
in methods are defined in @flnm{ctalkdefs.h}.  Those definitions
are listed here along with their values. @xref{Scoping}.

@example

GLOBAL_VAR          (1 << 0)
LOCAL_VAR           (1 << 1)
CREATED_PARAM       (1 << 6)
CVAR_VAR_ALIAS_COPY (1 << 7)
VAR_REF_OBJECT      (1 << 9)
METHOD_USER_OBJECT  (1 << 10)

@end example


@idxlibfn{__ctalkSetObjectValue}
@item __ctalkSetObjectValue (@code{OBJECT *}@var{object}, @code{char *}@var{value})
This is a wrapper for @cite{__ctalkSetObjectValueVar ()}, below, which
was used in earlier versions of the class libraries.  You should use
@cite{__ctalkSetObjectValueVar ()} instead.

@anchor{ctalkSetObjectValueAddr}
@idxlibfn{__ctalkSetObjectValueAddr}
@item __ctalkSetObjectValueAddr (@code{OBJECT *}@var{object}, @code{void *}@var{mem_addr}, @code{int} @var{data_length})
Set @var{object's} value to a pointer to the memory area
@var{mem_addr}.  The object must be a member of Vector class or one of
its subclasses.  The function also sets the object @code{length} instance
variable, and adds OBJECT_VALUE_IS_MEMORY_VECTOR to its attributes, and
registers the vector * address.

@idxlibfn{__ctalkSetObjectValueBuf}
@item __ctalkSetObjectValueBuf (@code{OBJECT *}@var{object}, @code{char *}@var{buf})
Set the @code{value} instance variable to the buffer @var{buf}.
Unlike @cite{__ctalkSetObjectValue ()} and
@cite{__ctalkSetObjectValueVar (),} this function replaces the value
of @var{object} with @var{buf}, even if @var{buf} is empty, so you can
add a random-length buffer to @var{object}.

@idxlibfn{__ctalkSetObjectValueVar}
@item __ctalkSetObjectValueVar (@code{OBJECT *}@var{object}, @code{char *}@var{value})
Set the value of @var{object} to @var{value}.  If @var{value} is
@code{NULL}, sets @var{object}'s value to Ctalk's @samp{(null)} 
string.

@idxlibfn{__ctalkSetObjPtr}
@item __ctalkSetObjPtr (@code{OBJECT *}@var{object}, @code{void *}@var{p})
Save the pointer @var{p} in @var{object}.

@idxlibfn{__ctalkSetRS}
@item __ctalkSetRS (@code{char} @var{record_separator_char})
Set's the current program's record separator character, which
determines, among other things, how regular expression metacharacters
work with line endings. @xref{RecordSeparator}.

@idxlibfn{__ctalkSignalHandlerBasic}
@item __ctalkSignalHandlerBasic (@code{int} @var{signo})
Provides a basic signal handler that is more robust than the methods
in @code{SignalHandler} class, but less flexible.  Causes the
application to terminate and print a walkback trace if enabled.

Applications can use @code{__ctalkInstallHandler ()} to install the
signal handler.  In this case it works similarly to a method with a C
calling protocol.  Here is the @code{installExitHandlerBasic} method
from @code{Application} class.

@example

Application instanceMethod installExitHandlerBasic (void) @{
  __ctalkInstallHandler
    (__ctalkSystemSignalNumber ("SIGINT"),
     (OBJECT *(*)())__ctalkSignalHandlerBasic);
						    
  return NULL;
@}

@end example

@idxlibfn{__ctalkSpawn}
@idxlibfn{__ctalkExec}
@item __ctalkSpawn (@code{char *}@var{command}, @code{int} @var{restrict_io})
The @cite{__ctalkSpawn} function launches the program named
by @var{command} as a daemon process, and then returns to
the parent program and continues execution of the parent.

The function returns the process id of the child process.

The daemon process runs as a true daemon - that is, without a
controlling terminal, and without the standard input, output, or error
channels.  All communication between the daemon and the parent program
should take place with UNIX interprocess communication facilities.

If @var{restrict_io} is non-zero, the program changes the daemon
processes' working directory to @samp{/} and sets its umask to
@samp{0}.

Traditionally, a parent program exits immediately after spawning a
daemon process.  But @cite{__ctalkSpawn} maintains the session process
- the process that handles the session and I/O initialization before
it launches the daemon. The session process stays active until the
parent process exits and orphans it.  Then the session process exits
also, leaving the daemon to run completely in the background until it
is killed.  That means, while the parent program is running, there can
be @emph{three} entries in the system's process table, when viewed
with a program like @command{ps} or @command{top}.  However, it also
mimimizes the possibility of causing zombie processes should any part
of the program quit unexpectedly.

You should note that @cite{__ctalkSpawn} does not use a shell or any
shell facilities to exec the daemon process, which means the function
doesn't support I/O redirection or globbing.  If you want the parent
process to handle the child processes' I/O, refer to the
@cite{__ctalkExec} function. @xref{ctalkExec}.

@idxlibfn{__ctalkStringifyName}
@item __ctalkStringifyName (@code{OBJECT *}@var{src}, @code{OBJECT *}@var{dest})
When called by a function like @code{String} : @mnm{=}, performs some
munging of different types of @code{String} objects in order to keep the
API consistent for different types of @code{String} objects.

@idxlibfn{__ctalkSplitText}
@item __ctalkSplitText (@code{char *}@var{text}, @code{OBJECT *}@var{list_out})
Splits a text buffer into word tokens, and returns the tokens
as members of @var{list_out}.  This function preserves newlines
and spaces, and places HTML-style format tags in their own tokens.
This is used by classes like @code{X11TextPane} to split its text
buffer before displaying the wrapped text. @xref{X11TextPane}.

@idxlibfn{__ctalkStrToPtr}
@item __ctalkStrToPtr (@code{char *}@var{s})
If @var{s} is a C string formatted as a hexadecimal number 
with the format @code{0x}@var{nnnnnnn}, return a C @code{void *} 
pointer with that address.

@idxlibfn{__ctalkSysErrExceptionInternal}
@item __ctalkSysErrExceptionInternal (@code{MESSAGE *}@var{orig}, @code{int} @var{errno}, @code{char *}@var{text})
Generates an exception base on @var{errno} with the text @var{text}.
Ctalk translates @var{errno} in an exception that represents the C library's
@code{errno} error definitions.  The @var{orig} argument provides the line
and column number where the exception occurred.  If NULL, the exception
doesn't record the line and column information.

@idxlibfn{__ctalkSystemSignalName}
@item __ctalkSystemSignalName (@code{int} @var{signo})
Returns a string containing a mnemonic name like
@code{SIGINT} or @code{SIGHUP} that corresponds to
@var{signo}.  Includes the mnemonics of the common signals
defined by POSIX standards.

@idxlibfn{__ctalkSymbolReferenceByName}
@item __ctalkSymbolReferenceByName (@code{OBJECT *}@var{object})
Used in @code{Symbol : =} and similar methods returns a boolean value
of @code{true} if the object (the argument to the method normally) was
retrieved by its name, or false if the argument is the result of
pointer math or indirection.  This allows the method to determine
whether it needs to perform additional indirection or pointer math on
the argument before assigning it the the receiver.

@idxlibfn{__ctalkSystemSignalNumber}
@item __ctalkSystemSignalNumber (@code{char *}@var{signame})
For a signal named @var{signame}, return the number
system-dependent number of the signal.  The function defines
names POSIX 1990 signals on most systems.  Refer to the
system's @cite{signal(2)} (or similar) manual page for
information.

@idxlibfn{__ctalkTemplateCallerCVARCleanup}
@item __ctalkTemplateCallerCVARCleanup (@code{void})
Cleans up after a @cite{__ctalkGetTemplateCallerCVAR}
call. @xref{__ctalkGetTemplateCallerCVAR}.  Ctalk calls this function
internally; you should not need to use it in your own programs.

@idxlibfn{ARG()} (macro)
Note that this function does not know about parameter substitution.  If
you want to print an object that is an argument to a method, use the
@code{ARG(@var{n})} macro, and reference the @code{name} member.
@xref{ARG macro}.
@example
__ctalkPrintObject(ARG(0)->__o_name);
@end example

@idxlibfn{__ctalkTerminalHeight}
@item __ctalkTerminalHeight (@code{void})
@idxlibfn{__ctalkTerminalWidth}
@item __ctalkTerminalWidth (@code{void})
Returns the height and width of the terminal in character rows and
columns.  If the terminal does not support reporting its size, these
functions return 0.

@idxlibfn{__ctalkToCArrayElement}
@item __ctalkToCArrayElement (OBJECT *@var{o})
Translate the value of an @code{Integer,} @code{Character,}
@code{String,} or @code{LongInteger} array element to a @code{void *}
that points to its corresponding C data type.

@idxlibfn{__ctalkToCCharPtr}
@item __ctalkToCCharPtr (@code{OBJECT *}@var{obj}, @code{int} @var{keep})
Returns the value of @var{obj} as a C @code{char *}.  If @var{keep} is
zero, deletes @var{obj} if possible.

@idxlibfn{__ctalkToCDouble}
@item __ctalkToCDouble (@code{OBJECT *}@var{obj})
Returns the value of @var{obj} as a C @code{double}.

@idxlibfn{__ctalkToCIntArrayElement}
@item __ctalkToCIntArrayElement (@code{OBJECT *}@var{obj})
Returns the value of @var{obj} as a C @code{int}.  This function
has mostly been superceded by @cite{__ctalkToCInteger} (below).

@idxlibfn{__ctalkToCInteger}
@item __ctalkToCInteger (@code{OBJECT *}@var{obj})
Returns the value of @var{obj} as a C @code{int}.  The value can be a
binary, octal, decimal, or hexadecimal number.  Prints a warning
message if the value is not a valid number or is out of range.

@idxlibfn{__ctalkTrapException}
@item __ctalkTrapException (@code{void})
If there is a run-time exception pending, returns the first exception
in Ctalk's internal format.  Otherwise, returns NULL.

@idxlibfn{__ctalkTrapExceptionInternal}
@item __ctalkTrapExceptionInternal (@code{void})
Similar to @cite{__ctalkTrapException}, except that
it works with the passes in the compiler as well as
the run time library.

@idxlibfn{__ctalkObjectPrintOn}
@item __ctalkObjectPrintOn (@code{OBJECT *}@var{object})
Print the calling method's arguments to the argument's @code{value}
instance variable.  This function is called directly by @mnm{printOn}
(class @code{ANSITerminalStream}) and similar
methods. @xref{ANSITerminalStream}.

@idxlibfn{__ctalkOpenX11InputClient}
@item __ctalkOpenX11InputClient (@code{OBJECT *}@var{X11TerminalStream_object})
Start a GUI program's input client in the background.  The input client
receives input events, like mouse motion and keypresses, and window events,
like resize notifications from the X display server, and sends the information
to the application program so that it can queue @code{InputEvent} objects which
the app can then process.

The argument is a @code{X11TerminalStream} object, which is normally created
with a @code{X11Pane} object, and which programs can refer to by the
@code{X11Pane} object's @code{inputStream} instance variable.  

This is the lower-level function that the @mnm{openEventStream}
(class @code{X11Pane}) method uses to begin communicating with the X
display server.  For an example, refer to the @code{X11TerminalStream}
section. @xref{X11TerminalStream}.

@idxlibfn{__ctalkUNIXSocketOpenReader}
@item __ctalkUNIXSocketOpenReader (@code{char *}@var{socketpath})
Opens a UNIX domain socket, binds the socket to the path given
by @var{socketpath}, and places the socket in listening mode.

Returns the file descriptor of the new socket on success, or -1 if an error
occured, in which case the C library sets the variable @code{errno}.

@idxlibfn{__ctalkUNIXSocketOpenWriter}
@item __ctalkUNIXSocketOpenWriter (@code{char *}@var{socketpath})
Opens a UNIX domain socket and connects to the socket given by
@var{socketpath}.

Returns the file descriptor of the new socket on success, or -1
if an error occurs, in which case the C library sets the variable
@code{errno}.

@idxlibfn{__ctalkUNIXSocketRead}
@item __ctalkUNIXSocketRead (@code{int} @var{sockfd}, @code{void *} @var{buf_out})
Reads data from the socket given by @var{sockfd}.  On success, returns
the data read in @var{buf_out} and the return value is the number of
bytes read.  On error returns -1 and the C library sets the variable
@var{errno}.

@idxlibfn{__ctalkUNIXSocketShutdown}
@item __ctalkUNIXSocketShutdown (@code{int} @var{sockfd}, @code{int} @var{how})
This function is a wrapper for the C library's @code{shutdown}
function.  Shuts down the socket identified by the @var{sockfd}
argument.  The second argument, @var{how}, can be either
@code{SHUT_RD, SHUT_WR, or SHUT_RW.}  These constants are defined in
@code{UNIXNetworkStream} class and described in the @cite{shutdown(1)}
manual page.

The function returns 0 on success, or -1 if an error occurred.

@idxlibfn{__ctalkUNIXSocketWrite}
@item __ctalkUNIXSocketWrite (@code{int} @var{sockfd}, @code{void *} @var{data}, @code{int} @var{length})
Writes @var{length} bytes of @var{data} to the socket given by @var{sockfd}.

On success returns the number of bytes written, or returns -1 on error,
in which case the C library sets the variable @code{errno}.

@idxlibfn{__ctalkUTCTime}
@item __ctalkUTCTime (@code{void})
Returns an @code{int} with the system's UTC time.  This function is
currently a wrapper for the @cite{time(2)} function.  Because
@cite{time(2)}'s argument is an @code{int *}, it can often be more
reliable to use @cite{__ctalkUTCTime} and let the library worry about
the argument's storage.  There is also a template for @cite{time(2)}
if you want to use the function directly in complex expressions.

@idxlibfn{__ctalkWarning}
@item __ctalkWarning (@code{char *}@var{fmt}, @code{...})
Prints a formatted message to the terminal.  Unlike
@cite{_warning} and other functions, does not add line numbers
or input file information to the output.

@idxlibfn{__ctalkWrapText}
@item __ctalkWrapText (@code{unsigned int} @var{drawable}, @code{unsigned int} @var{gc_ptr}, @code{OBJECT *}@var{text_list}, @code{int} @var{pane_width}, @code{int} @var{lmargin})
Formats the text in @var{text_list} to be displayed between
@var{lmargin} and @var{pane_width} (the right edge of the drawing
surface given as the first argument..  The @var{text_list} list should
have been generated by @cite{__ctalkSplitText}.  The
@cite{__ctalkWrapText} function uses the current typeface to determine
character widths.  If no font or typeface is selected, uses the
default font, ``fixed'' to format the text.

@idxlibfn{__ctalkX11CloseClient}
@item __ctalkX11CloseClient (@code{OBJECT *}@var{pane_object})
Closes the main program's connection to the X11 client and exits the
client process.

@idxlibfn{__ctalkX11CloseParentPane}
@item __ctalkX11CloseParentPane (@code{OBJECT *}@var{pane_object})
Closes and deletes an application's main X11 window, and its buffers
and other data.  Does not delete subpanes - see __ctalkCloseX11Pane ()
(above) to delete subpanes.  Applications should delete subpanes before
closing and deleting the main window.  For an example of the functions'
use, refer to the method @mnm{X11Pane : deleteAndClose}. @xref{X11Pane}.

@c /***/
@c @idxlibfn{__ctalkX11ClearBufferRectangle}
@c @item __ctalkClearBufferRectangle (@code{OBJECT *}@var{pane_object}, @code{int} @var{x}, @code{int} @var{y}, @code{int} @var{width} @var{height}) 
@c Clear a rectangle in @var{pane_object}'s pane buffer starting at
@c @var{X},@var{Y}, with width @var{width} and height @var{height}.  Note that
@c this function is being phased out in favor of
@c @cite{__ctalkX11ClearRectangleBasic}, which does not rely on
@c hard-coded instance variable names.


@idxlibfn{__ctalkX11ClearRectangleBasic}
@item __ctalkX11ClearRectangleBasic (@code{void *}@var{display}, @code{int} @var{visual_id}, @code{int} @var{gc_ptr}, @code{int} @var{x}, @code{int} @var{y}, @code{int} @var{width}, @code{int} @var{height})
Clear a rectangle of a visual type like a pixmap to the
background color.

@idxlibfn{__ctalkX11Colormap}
@item __ctalkX11Colormap (@code{void})
Returns the X resource ID of the display's default 
colormap.  It's contained in a library function because
the X headers define some of the DefaultColormap's 
dependent macros after DefaultColormap, which is not 
compatible with the ctpp preprocessor.

@idxlibfn{__ctalkX11CopyPixmapBasic}
@item __ctalkX11CopyPixmapBasic (@code{void *}@var{display}, @code{int} @var{dest_drawable_id}, @code{int} @var{dest_gc_ptr}, @code{int} @var{src_drawable_id}, @code{int} @var{src_x_org}, @code{int} @var{src_y_org}, @code{int} @var{src_width}, @code{int} @var{src_height}, @code{int} @var{dest_x_org}, @code{int} @var{dest_y_org})
Copies the drawable @var{src_drawable_id} to @var{dest_drawable_id},
with the dimensions of the source graphic given by @var{src_x_org},
@var{src_y_org}, @var{src_width}, and @var{src_height}.  The image is
drawn with its upper left-hand corner positioned at @var{dest_x_org},
@var{dest_y_org} on the destination drawable.

@cindex @mnm{copy} instance method @idxclscite{X11CanvasPane}
This function is called by @code{X11CanvasPane} : @mnm{copy}.  For
an example, refer the @code{X11CanvasPane} classes' description.
@xref{X11CanvasPane}.

@idxlibfn{__ctalkX11CreateGC}
@item __ctalkX11CreateGC (@code{void *}@var{display}, @code{int} @var{drawable})
Create a X Graphics Context and return its address as a @code{void *}.
The GC is created with the following values:

@example

foreground     white
background     black
fill_style     FillSolid
function       GXcopy
font           fixed

@end example


@idxlibfn{__ctalkX11CreatePixmap}
@item __ctalkX11CreatePixmap (@code{void *}@var{display}, @code{int} @var{x_drawable}, @code{int} @var{width}, @code{int} @var{height}, @code{int} @var{depth})
reate a X pixmap and return its X resource ID as an unsigned int.

@idxlibfn{__ctalkX11CreatePaneBuffer}
@cindex @code{paneBuffer} instance variable
@cindex @code{paneBackingStore} instance variable
@item __ctalkX11CreatePaneBuffer (@code{OBJECT *}@var{pane_object}, @code{int} @var{width}, @code{int} @var{height}, @code{int} @var{depth})
Create the buffers for a pane object's X window.  Applications
normally call this function when the pane object is created or when a
subpane is attached to a parent pane.  This function sets the @var{pane_object's}
@code{paneBuffer} and @code{paneBackingStore} instance variables.

@idxlibfn{__ctalkX11DeletePixmap}
@item __ctalkX11DeletePixmap (@code{int} @var{drawable_id})
Delete the server-side pixmap whose ID is given as the argument.

@idxlibfn{__ctalkX11Display}
@item __ctalkX11Display (@code{void})
Return a pointer to the X display, opening the display
if necessary.

@idxlibfn{__ctalkX11DisplayHeight}
@item __ctalkX11DisplayHeight (@code{void})
Returns an @code{int} with the display's height in pixels.

@idxlibfn{__ctalkX11DisplayWidth}
@item __ctalkX11DisplayWidth (@code{void})
Returns an @code{int} with the display's width in pixels.

@idxlibfn{__ctalkX11FontCursor}
@item __ctalkX11FontCursor (@code{OBJECT *}@var{cursor_object}, @code{int} @var{cursor_id})
Set @var{cursor_object}'s value to a X11 @var{cursor_id}.  Cursor ID's
are defined by the X server in the include file
@flnm{X11/cursorfont.h}.  @xref{X11Cursor}.


@idxlibfn{__ctalkX11FreeGC}
@item __ctalkX11FreeGC (@code{int} @var{gc_addr})
Free the X11 graphics context pointed to by @var{gc_addr}.  The address
of the GC is given as an @code{int} which does not require any special
handling by methods; the library function casts @var{gc_addr} to a 
@code{GC *}.

@idxlibfn{__ctalkX11FreePaneBuffer}
@item __ctalkX11FreePaneBuffer (@code{OBJECT *}@var{pane_object})
Release the server-side buffers used by @var{pane_object}.  Note that
this function is being phased out; programs should use
@cite{__ctalkX11DeletePixmap}, which does not rely on hard-coded
instance variable names.

@idxlibfn{__ctalkX11FreeSizeHints}
@item __ctalkX11FreeSizeHints (@code{void})
Frees the data allocated by @cite{__ctalkX11SetSizeHints ()}, below.

@idxlibfn{__ctalkX11GetSizeHints}
@item __ctalkX11GetSizeHints (@code{int} @var{win_id}, @code{int *}@var{x_org_return}, @code{int *}@var{y_org_return}, @code{int *}@var{width_return}, @code{int *}@var{height_return}, @code{int *}@var{win_gravity_return}, @code{int *}@var{flags_return})
Get the actual size and placement of the window, as reported by the X
server, after the window is created, normally with @cite{__ctalkCreateX11MainWindow ()}.

@idxlibfn{__ctalkX11InputClient}
@item __ctalkX11InputClient (@code{OBJECT *}@var{streamobject} @code{int} @var{fd})
The @code{X11TerminalStream} input client.  This function is not used
directly by any method but is a process of the
@cite{__ctalkOpenX11InputClient} function, above.

@idxlibfn{__ctalkX11MakeEvent}
@item __ctalkX11MakeEvent (@code{OBJECT *}@var{eventobject_value_var}, @code{OBJECT *}inputqueue)
Encapsulates much of the function of the @mnm{X11TerminalStream :
queueInput} method: receives the data for an X event from the X11 input client and saves it in an @code{InputEvent} object, then queues the @code{InputEvent} object in the @code{X11TerminalStream}'s @code{inputQueue}.

@idxlibfn{__ctalkX11MoveWindow}
@item __ctalkX11MoveWindow (@code{OBJECT *}@var{pane_object}, @code{int} @var{x}, @code{int} @var{y})
Move @var{pane_object}'s window so that its origin is at @var{X},@var{Y}.

@idxlibfn{__ctalkX11OpenInputClient}
@item __ctalkX11OpenInputClient (@code{OBJECT *}@var{streamobject})
The library interface of the @code{X11TerminalStream} class's input
client. This function is called by @mnm{openInputClient} (class
@code{X11TerminalStream}).  The @var{streamobject} argument is a
@code{X11TerminalStream} object, generally the stream created by
@mnm{new} (class @code{X11Pane}).  @xref{X11TerminalStream}.

@idxlibfn{__ctalkX11ParseGeometry}
@item __ctalkX11ParseGeometry (@code{char *}@var{geomString}, @code{int*} @var{x}, @code{int*} @var{y}, @code{int*} @var{y}, @code{int*} @var{width}, @code{int*} @var{height})
Parses a X11 geometry string and returns the values specified in the @var{x}, @var{y}, @var{width}, or @var{height} variables.  If the geometry string does not specify one of these values, sets the corresponding variable to zero.

For information about the format of a X11 geometry specification, refer to the
@cite{XParseGeometry(3)} manual page.

@idxlibfn{__ctalkX11PaneDrawCircleBasic}
@item __ctalkX11PaneDrawCircleBasic (@code{void *}@var{display}, @code{int} @var{window_id}, @code{int} @var{gc}, @code{int} @var{center_x}, @code{int} @var{center_y}, @code{int} @var{radius}, @code{int} @var{fill}, @code{int} @var{pen_width}, @code{int} @var{alpha}, @code{char *}@var{fg_color_name}, @code{char *} @var{bg_color_name})
Draws a circle centered at @var{center_x},@var{center_y} with radius @var{radius}. The dimensions are given in pixels.  If @var{filled} is true, then the function
draws a filled circle; otherwise, the circle's edge has the width @var{pen_width}.

This function is a synonym for @cite{__ctalkGUIPaneDrawCircleBasic}.

@idxlibfn{__ctalkX11PanePutStr}
@item __ctalkX11PanePutStr (@code{OBJECT *}@var{pane_object}, @code{int} @var{x}, @code{int} @var{y}, @code{char *}@var{str})
Displays @var{str} at window coordinates @var{x},@var{y} on
@var{pane_object}'s drawable in the pane's current font.  If
@code{pane_object} is buffered, writes the string to the pane's
buffers, and the string is displayed at the next @mnm{refresh} method
call.  

Note that this method is slowly being superceded because it relies on
instance variable names that are defined in several class libraries.
If the application uses different drawables than @var{pane_object}'s
window surface or its buffers, use @cite{__ctalkX11PanePutStrBasic}
instead.

@anchor{ctalkX11SetSizeHints}
@idxlibfn{__ctalkX11SetSizeHints}
@item __ctalkX11SetSizeHints (@code{int} @var{x}, @code{int} @var{y}, @code{int}p @var{width}, @code{int} @var{height}, @code{int} @var{geom_flags})
Set the window size hints based on the window dimensions set by the
application.  The @var{geom_flags} argument has the format provided by
the @cite{__ctalkX11ParseGeometry ()} function, above.  Normally this 
function is called by a @code{X11Pane*} class when initializing a window.

If an application calls this function, it must also call
@cite{__ctalkX11FreeSizeHints ()}, above.

@idxlibfn{__ctalkX11ResizePaneBuffer}
@item __ctalkX11ResizePaneBuffer (@code{OBJECT *}@var{pane_object}, @code{int} @var{width}, @code{int} @var{height})
Resize @var{pane_object}'s buffers to width @var{width} and height
@var{height}.  New programs should use @cite{__ctalkX11ResizePixmap},
which does not rely on hard-coded instance variable names.

@idxlibfn{__ctalkX11ResizePixmap}
@item __ctalkX11ResizePixmap (@code{void *}@var{display}, @code{int}, @var{parent_drawable_id}, @code{int} @var{self_xid}, @code{int} @var{gc}, @code{int} @var{old_width}, @code{int} @var{old_height}, @code{int} @var{new_width}, @code{int} @var{new_height}, @code{int} @var{depth}, @code{int *}@var{new_pixmap_return})
Create a new Pixmap with the dimensions @var{new_width} and
@var{new_height} that contains the contents of the original
pixmap.  Returns the X ID of the new pixmap in @var{new_pixmap_return}.

@idxlibfn{__ctalkX11ResizeWindow}
@item __ctalkX11ResizeWindow (@code{OBJECT *}@var{pane_object}, @code{int} @var{width}, @code{int} @var{height}, @code{int} @var{depth})
Resize a pane object's X window.  Returns @samp{1} on success,
@samp{0} if the window's new size is <= its current size, and
@samp{-1} if there is an error.

@idxlibfn{__ctalkX11PaneClearRectangle}
@item __ctalkX11PaneClearRectangle (@code{OBJECT *}@var{pane_object}, @code{int}  @var{x}, @code{int} @var{y}, @code{int} @var{width}, @code{int} @var{height})
Clears a rectangle in @var{pane_object}'s window.  Note that this
function is deprecated - it relies on the Pane object having specific
instance variables.  New programs should use
@cite{__ctalkX11PaneClearRectangleBasic} instead.

@idxlibfn{__ctalkX11PaneDrawLine}
@item __ctalkX11PaneDrawLine (@code{OBJECT *}@var{pane_object}, @code{OBJECT *}@var{line_object}, @code{OBJECT *}@var{pen_object})
Draw a line on the drawable identified by @var{pane_object}
@xref{X11Pane}, with the endpoints given by @var{line_object}
@xref{Line}, with the line width and color defined in @var{pen_object}
@xref{Pen}.  This function is a synonym for
@cite{__ctalkGUIPaneDrawLine} on systems with a X Window System display.

@idxlibfn{__ctalkX11PaneDrawLineBasic}
@item __ctalkX11PaneDrawLineBasic (@code{int} @var{drawable_id}, @code{int} @var{gc_ptr}, @code{int} @var{x_start}, @code{int} @var{y_start}, @code{int} @var{x_end}, @code{int} @var{y_end}, @code{int} @var{pen_width}, @code{int} @var{alpha}, @code{char *}@var{pen_color})
Draw a line between the points (x_start,y_start) and (x_end, y_end)
with the color, and transparency using the drawable ID, graphics
context, and pen color, width, and transparency given as arguments.

@idxlibfn{__ctalkX11PaneDrawPoint}
@item __ctalkX11PaneDrawPoint (@code{OBJECT *}@var{pane_object}, @code{OBJECT *}@code{point_object}, @code{OBJECT *}@var{pen_object})
Draw a point on the drawable id given in @var{pane_object}
@xref{X11Pane}, with the location given by @var{point_object}
@xref{Point}, with the radius and color given by @var{pen_object}
@xref{Pen}.  This function is a synonym for @cite{__ctalkGUIPaneDrawPoint}
on systems that use the X Window system.

@idxlibfn{__ctalkX11PaneDrawPointBasic}
@item __ctalkX11PaneDrawPointBasic (@code{void *}@var{display}, @code{int} @var{drawable_id}, @code{int} @var{gc_ptr}, @code{int} @var{x}, @code{int} @var{y}, @code{int} @var{pen_width}, @code{int} @var{alpha}, @code{char *}@var{pen_color})
Draw a point of the size, position, color, and transparency using the
drawable ID, graphics context, and Pen color, transparency, and width
given as arguments.

@idxlibfn{__ctalkX11PaneClearWindow}
@item __ctalkX11PaneClearWindow (@code{OBJECT *}@var{pane_object})
Clears @var{pane_object}'s window.  Note that this function is
deprecated - it relies on the Pane object having specific instance
variables.  New programs should use 

@idxlibfn{__ctalkX11PaneDrawRectangle}
@item __ctalkX11PaneDrawRectangle (@code{OBJECT *}@var{pane_object}, @code{OBJECT *}@var{rectangle_object}, @code{OBJECT *}@var{pen_object}, @code{Integer} @var{fill})
Draw a rectangle on the drawable identified by @var{pane_object}
@xref{X11Pane}, with the dimensions given by @var{rectangle_object}
@xref{Rectangle}, and with the line width and color given by
@var{pen_object} @xref{Pen}.  If @var{fill} is true, draw a filled
rectangle.

@idxlibfn{__ctalkX11PanePutStrBasic}
@item __ctalkX11PanePutStrBasic (@code{void *}@var{display}, @code{int} @var{visual_id},@code{int} @var{gc_ptr}, @code{int} @var{x}, @code{int} @var{y}, @code{char *}@var{text})
Write the string @var{text} on the drawable named by @var{visual_id} at
@var{X},@var{Y} using the graphics context pointed to by @var{gc_ptr}.  If the
drawable is a @code{X11CanvasPane} buffer, the text will not be visible
until the next call to the pane's @mnm{refresh} method.

@idxlibfn{__ctalkX11PaneRefresh}
@item __ctalkX11PaneRefresh (@code{OBJECT *}@var{pane_object}, @code{int} @var{src_x_org}, @code{int} @var{src_y_org}, @code{int} @var{src_width}, @code{int} @var{src_height}, @code{int} @var{dest_x_org}, @code{int} @var{dest_y_org})
If @var{pane_object} is a buffered pane, copy the contents of the pane
buffer(s) within the rectangle given by @var{src_x_org}, @var{src_y_org},
@var{src_width}, @var{src_height} to the visible window at @var{dest_x},
@var{dest_y}.

@idxlibfn{__ctalkX11QueryFont}
@item __ctalkX11QueryFont (@code{OBJECT *}@var{font_object}, @code{char *}@var{xlfd}) 
Fills in @var{font_object}'s @samp{ascent}, @samp{descent},
@samp{maxWidth}, @samp{height}, and @samp{fontDesc} instance variables
with the font metrics returned by the X server for the font given by
@var{xlfd}.

@idxlibfn{__ctalkX11SetBackground}
@item __ctalkX11SetBackground (@code{OBJECT *}@var{pane_object}, @code{char *}@var{color_name})
Set @var{pane_object}'s background color to @var{color_name}.  This
function is being phased out because it uses named instance variables
of @var{pane_object}.  Programs should use
@cite{__ctalkX11SetBackgroundBasic ()}, below, instead.

@idxlibfn{__ctalkX11SetBackgroundBasic}
@item __ctalkX11SetBackgroundBasic (@code{void *}@var{display}, @code{int} @code{visual_xid}, @code{int} @var{gc_ptr}, @code{char *}@var{color})
Sets the background color of any class with a X11 visual and 
graphics context.

@idxlibfn{__ctalkX11SetForegroundBasic}
@item __ctalkX11SetForegroundBasic (@code{void *}@var{display}, @code{int} @code{visual_xid}, @code{int} @var{gc_ptr}, @code{char *}@var{color})
Sets the foreground color of any class with a X11 drawable and 
graphics context.

@idxlibfn{__ctalkX11SetResource}
@item __ctalkX11SetResource (@code{void *}@var{display}, @code{int} @var{drawable_id}, @code{char *}@var{resource_name}, @code{char *}@var{resource_value}) 
Sets the X11 resource @var{resource_name} to @var{resource_value} for
the drawable identified by @var{drawable_id}.

@idxlibfn{__ctalkX11SetWMNameProp}
@item __ctalkX11SetWMNameProp (@code{OBJECT *}@var{pane_object}, @code{char *}@var{name})
Sets the WMName property @var{pane_object}'s window to @var{name}.
This is the window property that window managers use to set the window
frame's title.

@idxlibfn{__ctalkX11UseCursor}
@item __ctalkX11UseCursor (@code{OBJECT *}@var{pane_object}, @code{OBJECT *}@var{cursor_object})
Sets the X11 cursor of @var{pane_object} to
@var{cursor_object}. @xref{X11Cursor}.

@idxlibfn{__ctalkX11UseXRender}
@item __ctalkX11UseXRender (@code{bool} @var{b})
If @var{b} is true, draw using the X Render entension if it
is available.  If @var{b} is false, use Xlib for drawing
even if X Render is available.

@idxlibfn{__ctalkX11UseFontBasic}
@item __ctalkX11UseFontBasic (@code{void *}@var{display}, @code{int} @var{drawable_id}, @code{int} @var{gc_ptr}, @code{char *}@var{font_desc})
Sets the font of the graphics context @var{gc_ptr} and
drawable @var{drawable_id} for further string printing
operations.  See use in @code{X11Bitmap} class, where the
GC pointer, which is an opaque object, is encoded as an
@code{int}, in order to avoid confusion with @code{OBJECT *'s}.

@idxlibfn{__ctalkX11UsingXRender}
@item __ctalkX11UsingXRender (@code{void})
Returns a boolean value of True if the program is using the X Render
extension for drawing, False otherwise.  To use the X Render
extension, the extension and its supporting libraries must be
available when the Ctalk libraries are built, and the program has not
changed the default setting, normally via @cite{__ctalkX11UseRender},
above.

@idxlibfn{__ctalkX11XPMFromData}
@item __ctalkX11XPMFromData (@code{void *}@var{display}, @code{int} @var{drawable_id}, @code{int} @var{gc_ptr}, @code{int} @var{x_org}, @code{int} @var{y_org}, @code{char **}@var{xpm_data})
Draw a X pixmap at the x,y position on the drawable named by
@var{drawable_id}.  The @var{xpm_data} argument is the declaration of
the data given in a XPM file, and has the C data type @code{char **}.

@idxlibfn{__ctalkX11XPMInfo}
@item __ctalkX11XPMInfo (@code{void *}@var{display}, @code{char **}@var{xpm_data}, @code{int *}@var{width_ret}, @code{int *}@var{height_ret}, @code{int *}@var{n_colors_ret}, @code{int *}@var{chars_per_color_ret})
Returns the width, height, number of colors, and characters per color of the
XPM data referred to by @var{xpm_data}

@idxlibfn{__ctalkXPMToGLTexture}
@idxlibfn{__ctalkXPMToGLXTexture}
@item __ctalkXPMToGLTexture (@code{char **}@var{xpm_data}, @code{unsigned short int} @var{alpha}, @code{int *}@var{width_out}, @code{int *}@var{height_out}, @code{void **}@var{texel_data_out})
@item __ctalkXPMToGLXTexture (@code{char **}@var{xpm_data}, @code{unsigned short int} @var{alpha}, @code{int *}@var{width_out}, @code{int *}@var{height_out}, @code{void **}@var{texel_data_out})
Read the XPM data pointed to by @var{xpm_data}, and return the OpenGL
texture data pointed to by @var{texel_data_out}.  

The @var{alpha} parameter defines the texture data transparency
and should be in the range 0 - 0xffff.  The alpha channel's effect
may not be apparent in the image that is displayed, because OpenGL
has its own set of functions to perform texture blending.

For Mesa OpenGL implementations, like those found on Linux systems,
textures have the format GL_RGBA and the data type
GL_UNSIGNED_INT_8_8_8_8.  To define a basic 2-dimensional texture to
the OpenGL API, use an OpenGL function like this.

@example

glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, my_width, my_height, 0,
              GL_RGBA, GL_UNSIGNED_INT_8_8_8_8, my_texel_data);

@end example

Apple OpenGL implmentations use a different internal format, so a
program would define a texture from the @cite{__ctalkXPMToGLXTexture}
function's output like this.

@example

glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, my_width, my_height, 0,
              GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, my_texel_data);

@end example

Note that the function does not make any changes for 1-dimensional or
3-dimensional textures, nor for textures that might be rendered as
mipmaps.  The specific texture parameters depend on the nature of the
texture and the surface that it's applied to... in most cases, though
OpenGL works best with a XPM that has a geometry that is an even
multiple of 2; e.g., 512x512 or 1024x1024 pixels.

Both functions are similar, and generic enough to work with any
OpenGL toolkit - the main difference is that either of the functions
can be implemented for either a GLUT or GLX development environemnt
independently, and that the GLX version is compatible with 64-bit
machines.


@idxlibfn{__ctalkXftAscent}
@item __ctalkXftAscent (@code{void})
Returns an @code{int} with the currently selected font's height
in pixels above the baseline.

@idxlibfn{__ctalkXftDescent}
@item __ctalkXftAscent (@code{void})
Returns an @code{int} with the currently selected font's height
in pixels below the baseline.

@idxlibfn{__ctalkXftFgRed}
@idxlibfn{__ctalkXftFgGreen}
@idxlibfn{__ctalkXftFgBlue}
@idxlibfn{__ctalkXftFgAlpha}
@item __ctalkXftFgRed (@code{void})
@item __ctalkXftFgGreen (@code{void})
@item __ctalkXftFgBlue (@code{void})
@item __ctalkXftFgAlpha (@code{void})
Returns @code{int} values 0-0xffff for the selected font's red,
green, blue, and alpha values.

@idxlibfn{__ctalkXftRed}
@idxlibfn{__ctalkXftGreen}
@idxlibfn{__ctalkXftBlue}
@idxlibfn{__ctalkXftAlpha}
@item __ctalkXftRed (@code{unsigned short} @var{val})
@item __ctalkXftGreen (@code{unsigned short} @var{val})
@item __ctalkXftBlue (@code{unsigned short} @var{val})
@item __ctalkXftAlpha (@code{unsigned short} @var{val})
Set the current Xft font's foreground color channels individually.
The value of the argument must be between 0 and 65535 (0xffff hex).

@idxlibfn{__ctalkXftFontPathFirst}
@item __ctalkXftFontPathFirst (@code{char *}@var{pattern})
Return the path of the first font file that matches @var{pattern}.
If pattern is @samp{*} or an empty string (@samp{""}), return
the first path of all the fonts that are available to the library.

@idxlibfn{__ctalkXftFontPathNext}
@item __ctalkXftFontPathNext (@code{void})
Return a string containing the path of the next font file that matches
the pattern given to @cite{__ctalkXftFontPathFirst ()}, above.

@idxlibfn{__ctalkXftSelectedFontDescriptor}
@item __ctalkXftSelectedFontDescriptor (@code{void})
Return the font descriptor of the selected font as a @code{char *}.

@idxlibfn{__ctalkXftGetStringDimensions}
@item __ctalkXftGetStringDimensions (@code{char *}@var{str}, @code{int *}@var{x}, @code{int *}@var{y}, @code{int *}@var{width}, @code{int *}@var{height})
Return the x and y origin, and width and height of @var{str} in the
currently selected FreeType font.  Because the dimensions are
absolute, @var{x} and @var{y} are normally 0.  If the Xft library is
not initialized or not available, the function returns 0 for all of
the dimensions.

@idxlibfn{__ctalkXftHeight}
@item __ctalkXftHeight (@code{void})
Returns an @code{int} with the font's height above and below
the baseline in pixels, and including any additional vertical
spacing.

@anchor{ctalkXftInitLib}
@idxlibfn{__ctalkXftInitLib}
@item __ctalkXftInitLib (@code{void})
Initializes the Freetype outline font library.  If the system is not
configured to use outline fonts @xref{X11FreeTypeFont}, then the
function prints a message and exits the program.

@idxlibfn{__ctalkXftInitialized}
@item __ctalkXftInitialized (@code{void})
Returns TRUE if the FreeType font library is available and
initialized, FALSE otherwise.

@idxlibfn{__ctalkXftListFontsFirst}
@item __ctalkXftListFontsFirst (@code{char *}@var{xftpattern})
Initializes the FreeType library to list fonts and returns a
@code{char *} that contains the first font descriptor that contains
the string @var{xftpattern}.  If @var{xftpattern} is emtpy (@samp{""})
or @samp{*}, then the function returns the first font, and the
following calls to @cite{__ctalkXftListFontsNext ()} match all of the
fonts available to the FreeType library.

@idxlibfn{__ctalkXftListFontsNext}
@item __ctalkXftListFontsNext (@code{void})
Returns a @code{char *} with the next matching font descriptor of
a font listing initialized by @cite{__ctalkXftListFontsFirst ()}.

@idxlibfn{__ctalkXftListFontsEnd}
@item __ctalkXftListFontsNext (@code{void})
Cleans up after a series of list fonts function calls.

@idxlibfn{__ctalkXftMajorVersion}
@item __ctalkXftMajorVersion (@code{void})
Returns an @code{int} with the Xft library's major version number.

@idxlibfn{__ctalkXftMaxAdvance}
@item __ctalkXftMaxAdvance (@code{void})
Returns an @code{int} with the maximum horizontal dimension in pixels
of any of the selected font's characters.

@idxlibfn{__ctalkXftMinorVersion}
@item __ctalkXftMinorVersion (@code{void})
Returns an @code{int} with the Xft library's minor version number.

@idxlibfn{__ctalkXftQualifyFontName}
@item __ctalkXftQualifyFontName (@code{char *}@var{pattern})
Return the qualified font name string for @var{pattern}.

@idxlibfn{__ctalkXftRevision}
@item __ctalkXftRevision (@code{void})
Returns an @code{int} with the Xft library's revision number.

@idxlibfn{__ctalkXftSelectedFamily}
@item __ctalkXftSelectedFamily (@code{void})
Returns a @code{char *} string that contains family of the selected
font.

@idxlibfn{__ctalkXftSelectedPointSize}
@item __ctalkXftSelectedPointSize (@code{void})
Return the point size of the selected font as a C @var{double}.

@idxlibfn{__ctalkXftSelectedSlant}
@item __ctalkXftSelectedSlant (@code{void})
Returns an @code{int} that contains slant of the selected
font.

@idxlibfn{__ctalkXftSelectedWeight}
@item __ctalkXftSelectedSlant (@code{void})
Returns an @code{int} that contains slant of the selected
font.

@idxlibfn{__ctalkXftSelectedFontDescriptor}
@item __ctalkXftSelectedFontDescriptor (@code{void})
Returns a @code{char *} string that contains the descriptor of the
selected font.

@idxlibfn{__ctalkXftSelectedFontPath}
@item __ctalkXftSelectedFontDescriptor (@code{void})
Returns a @code{char *} string that contains the file path descriptor
of the selected font.

@idxlibfn{__ctalkXftSelectFont}
@item __ctalkXftSelectFont (@code{char *}@var{family}, @code{int} @var{slant}, @code{int} @var{weight}, @code{int} @var{dpi}, @code{double} @var{point_size})
Selects the FreeType font that matches the arguments.  Returns 0 if
successful in matching the font given by the arguments.  If no
matching font is found, the current font does not change, and the
method returns -1. The @mnm{selectFont} method (class
@code{X11FreeTypeFont} contains a description of the parameters
recognized by the function.  @xref{X11FreeTypeFont-selectFont}.

@idxlibfn{__ctalkXftSelectFontFromXLFD}
@item __ctalkXftSelectFontFromXLFD (@code{char *}@var{xlfd})
Selects fonts in the FreeType font library using a XLFD specification.
When selecting outline fonts: the libraries use the fields: family,
weight, slant, dpi-x, and pixel height. An example XLFD would be the
following.

@example

-*-Nimbus Sans L-medium-r-*-*-12-72-*-*-*-*-*-*

@end example

Note that the function does not translate between bitmap and outline
font families - the font libraries pick the closest match to the font
metrics given in the XLFD, regardless of type style.

Also, the outline font libraries use a single dpi metric for both the
vertical and horizontal resolution, so only the @samp{resx} field of
the XLFD is actually used.

@idxlibfn{__ctalkXftSetForeground}
@item __ctalkXftSetForegrounc (@code{int} @var{red}, @code{int} @var{green}, @code{int} @var{blue}, @code{int} @var{alpha})
Sets the red, green, blue, and alpha values for the selected font.  The
values are @code{ints} and have a range of 0-0xffff.

@idxlibfn{__ctalkXftSetForgroundFromNamedColor}
@item __ctalkXftSetForegroundFromNamedColor (@code{String} @var{colorName})
Sets the selected outline font's red, green, and blue values from
the named X11 color given as the argument.

@idxlibfn{__ctalkXftVersion}
@item __ctalkXftVersion (@code{void})
Returns an @code{int} with the Xft library's version number,
which is (__ctalkXftMajorVersion () * 10000) + (__ctalkXftMinorVersion * 100) +
__ctalkXftRevsion ().

@idxlibfn{__ctalk_arg}
@item __ctalk_arg (@code{char *}@var{rcvr}, @code{char *}@var{method},@code{void *}@var{arg})
Define an argument for the following @code{__ctalk_method ()} call.  

@idxlibfn{__ctalk_arg_cleanup}
@item __ctalk_arg_cleanup (@code{OBJECT *}@var{result})
Remove an argument used by the previous method call.  If used within
an expression, then @var{result}, the return object of the previous
method call, may not be NULL.  If used after a @code{__ctalk_method
()} call, then @var{result} may be NULL.

@idxlibfn{__ctalk_arg_internal}
@item __ctalk_arg_internal (@code{int} @var{n_th_arg})
Return the @var{n_th_arg} that method was called with, as an
@code{OBJECT *.}  The first argument's index on the stack is 0 within
the caller's argument frame, and the last argument is @var{method ->
n_params} - 1.

@idxlibfn{__ctalk_arg_value_internal}
@item __ctalk_arg_value_internal (@code{int} @var{n_th_arg})
Return the value object of the @var{n_th_arg} that method was called
with, as an @code{OBJECT *,} if available.  If it isn't (for example, if 
the value instance variable is used as an argument alone, and not the parent
object), then the function returns the argument object.

As with @code{__ctalk_arg_internal (),} The first argument's index on
the stack is 0 within the caller's argument frame, and the last
argument is @var{method -> n_params} - 1.

@idxlibfn{__ctalk_arg_pop}
@idxlibfn{__ctalk_arg_pop_deref}
@item __ctalk_arg_pop (@code{void})
@item __ctalk_arg_pop_deref (@code{void})
Removes and returns the last object pushed onto the argument stack.
@cite{__ctalk_arg_pop_deref} also decreases the object's reference
count by one.

@idxlibfn{__ctalk_class_initialize}
@item __ctalk_class_initialize (@code{void})
Called by __ctalk_init () to perform any neeeded initialization the
before any classes are defined.

@idxlibfn{__ctalk_define_class}
@item __ctalk_define_class (@code{ARG**}@var{args})
The primitive method that Ctalk executes when it encounters the
@samp{class} keyword.

@idxlibfn{__ctalk_dictionary_add}
@item __ctalk_dictionary_add (@code{OBJECT*}@var{object})
Add an object to the Ctalk global dictionary, or, if the object
is a class object, to the class library.

@idxlibfn{__ctalk_exitFn}
@item __ctalk_exitFn (@code{int} @var{app_exit})
Called just before a @code{return} statement when returning from a C
function.  If the function is @code{main}, then @var{app_exit} should
be non-zero, to indicate that the program is finished, and to clean up
the global objects and the class library.

@idxlibfn{__ctalk_initFn}
@item __ctalk_initFn (@code{void})
Called at the beginning of a function to register the function's
name.

@idxlibfn{__ctalk_initLocalObjects}
@item __ctalk_initLocalObjects (@code{void})
Called during method or function initialization to delete
old local objects before creating new objects.

@idxlibfn{__ctalk_get_object}
@item __ctalk_get_object (@code{char *}@var{name}, @code{char *}@var{classname})
Retrieves the object @var{name}.  If @var{classname} is non-null,
retrieves the object by name and class.

@idxlibfn{__ctalk_init}
@item __ctalk_init (@code{char *}@var{program_name})
Initialize the Ctalk class libraries when the program starts.  The argument,
@var{program_name} is normally @code{argv[0]}.

@idxlibfn{__ctalk_method}
@item __ctalk_method (@code{char *}@var{rcvr_object_name}, @code{OBJECT *}@var{(method_fn *)()}, @code{char *}@var{method_name})
Perform a simple Ctalk method call, in places where the call can be
used after one or more calls to @cite{__ctalk_arg} and followed by
@cite{__ctalk_arg_cleanup}.  For complex expressions or expressions
occurring within control structures, Ctalk normally uses
@cite{__ctalkEvalExpr} instead.

@idxlibfn{__ctalk_new_object}
@item __ctalk_new_object (@code{ARG **}@var{args})
The primitive function that is called by the @samp{new} method.

@idxlibfn{__ctalk_primitive_method}
@item __ctalk_primitive_method (@code{char *}@var{rcvr_name}, @code{char *}@var{method_name}, @code{int} @var{attrs})
Call primitive method @var{method_name} with receiver
@var{rcvr_name}. The @var{attrs} argument can be METHOD_SUPER_ATTR,
which uses the receiver's superclass as the receiver redirects the
method's arguments to a superclass method.

@idxlibfn{__ctalk_process_exitFn}
@item __ctalk_process_exitFn (@code{int} @var{app_exit})
Similar to @cite{__ctalk_exitFn}, above, except that the function is
meant to be invoked by child processes on exit, so it does not try to
manage other child processes.

@idxlibfn{__ctalk_receiver_pop}
@item __ctalk_receiver_pop (@code{void})
Pops the most recent receiver object off the receiver stack
and returns it.

@idxlibfn{__ctalk_receiver_push}
@item __ctalk_receiver_push (@code{OBJECT *}@var{object})
Push @var{object} onto the receiver stack, without changing
its reference count.  This can be useful in conjunction with
@cite{__ctalk_receiver_pop} to quickly retrieve the current
receiver object.

@example

 currentReceiver = __ctalk_receiver_pop ();
 __ctalk_receiver_push (currentReceiver);

@end example

@idxlibfn{__ctalk_register_c_method_arg}
@item __ctalk_register_c_method_arg (@code{char *}@var{decl}, @code{char *}@var{type}, @code{char *}@var{qualifier}, @code{char *}@var{qualifier2}, @code{char *}@var{storage_class}, @code{char *}@var{name}, @code{int} @var{type_attrs}, @code{int} @var{n_derefs}, @code{int} @var{initializer_size}, @code{int} @var{scope}, @code{int} @var{attrs}, @code{void *}@var{var})
Registers a C variable for use as an argument in the following method
call.  The arguments provide the information given by the variable's
declaration so that it can be re-created by Ctalk.  The last
parameter, @var{var}, contains the address of the actual C variable in
memory.

There are also abbreviated versions of
@cite{__ctalk_register_c_method_arg},
__ctalk_register_c_method_arg_b|c|d, which work similarly but don't
try to handle syntax elements that aren't present in the variable's
declaration.

@idxlibfn{__ctalk_self_internal}
@item __ctalk_self_internal (@code{void})
Return the current method's receiver object as an @code{OBJECT *}.

@idxlibfn{__ctalk_self_internal_value}
@item __ctalk_self_internal (@code{void})
Return the current method receiver's @code{value} instance variable as
an @code{OBJECT *} if it exists, or the receiver object otherwise (for
example, if the receiver is the @code{value} instance variable itself
instead of the parent object).

@idxlibfn{__ctalk_set_global}
@item __ctalk_set_global (@code{char *}@var{name}, @code{char *}@var{classname})
Adds the object @var{name} of class @var{classname} to ctalk's global
dictionary.  This function is normally called during program initialization.

@idxlibfn{__ctalk_set_local}
@idxlibfn{__ctalk_set_local_by_name}
@item __ctalk_set_local (@code{OBJECT *}@var{obj})
@item __ctalk_set_local_by_name (@code{char *}@var{obj_name})
Make @var{obj} a method- or function-local object.  This function is
normally called during a method or function's initialization when the
local objects are created with a @code{new} method.  The
@cite{__ctalk_set_local_by_name} function is similar, except that it
retrieves the global object by looking up its name in the global
dictionary.

@idxlibfn{__ctalk_to_c_char}
@item __ctalk_to_c_char (@code{OBJECT *}@var{obj})
Returns the value of @var{obj} as a C @code{char} if possible.  If the
value is an ASCII code, converts the value to the actual @code{char}.

@idxlibfn{__ctalk_to_c_char_ptr}
@item __ctalk_to_c_char_ptr (@code{OBJECT *}@var{obj})
Returns the value of @var{obj} as a C @code{char *}.  This
function has been mostly replaced by @cite{__ctalkToCCharPtr},
which you should use instead.

@idxlibfn{__ctalk_to_c_double}
@item __ctalk_to_c_double (@code{OBJECT *}@var{obj})
Returns the value of @var{obj} as a C @code{double}.  This function
performs the conversion with the C library function @cite{strtod}.
Currently only supports the translation of base 10 values.

@idxlibfn{__ctalk_to_c_int}
@item __ctalk_to_c_int (@code{OBJECT *}@var{obj})
Returns the value of @var{obj} as a C @code{int}.  This function
handles values in hexadecimal, octal, using the C library function
@cite{strtol}, and binary, using Ctalk's internal routines.  Also
handles ASCII-to-char conversions if the argument is a
@code{Character} object.

@idxlibfn{__ctalk_to_c_longlong}
@item __ctalk_to_c_longlong (@code{OBJECT *}@code{obj})
Returns the value of @var{obj}, which is normally an
instance of @code{LongInteger} class, as a C @code{long long int}.
This function uses the C library function @cite{strtoll} to perform
the conversion.  Currently only handles @code{LongInteger} object
values in base 10.

@idxlibfn{__ctalk_to_c_ptr}
@item __ctalk_to_c_ptr (OBJECT *@var{o})
Translate the value of an object into a C @code{void *.}  If the
value isn't a pointer, then return the address of the value in memory.

@idxlibfn{__ctalk_to_c_ptr_u}
@item __ctalk_to_c_ptr_u (OBJECT *@var{o})
Translate the value of an object into a C @code{void *.}  This
is an unbuffered verson of @cite{__ctalk_to_c_ptr ()}, above.  That
is, if the value of the object is an empty string, @samp{(NULL)}, or
@samp{0x0}, it returns @code{NULL}. This allows you to compare objects to 
@code{NULLs} in C expressions without the generating compiler warnings.

@idxlibfn{__edittext_insert_at_point}
@idxlibfn{__edittext_xk_keysym}
@idxlibfn{__edittext_prev_char}
@idxlibfn{__edittext_next_char}
@idxlibfn{__edittext_prev_line}
@idxlibfn{__edittext_next_line}
@idxlibfn{__edittext_line_start}
@idxlibfn{__edittext_line_end}
@idxlibfn{__edittext_next_page}
@idxlibfn{__edittext_prev_page}
@idxlibfn{__edittext_delete_char}
@idxlibfn{__edittext_text_start}
@idxlibfn{__edittext_text_end}
@idxlibfn{__edittext_point_to_click}
@idxlibfn{__edittext_rol_col_from_mark}
@idxlibfn{__edittext_index_from_pointer}
@idxlibfn{__edittext_index_from_pointer}
@idxlibfn{__edittext_insert_str_at_click}
@idxlibfn{__edittext_insert_str_at_point}
@idxlibfn{__edittext_recenter}
@idxlibfn{__edittext_scroll_down}
@idxlibfn{__edittext_scroll_up}
@idxlibfn{__edittext_set_selection_owner}
@idxclscite {X11TextEditorPane}
@cindex Text editing
@cindex Editing, text

@item __edittext_delete_char (OBJECT *x11texteditorpane_object)
@item __edittext_insert_at_point (OBJECT *x11texteditorpane_object, int keycode, int shift_state, int keypress)
@item __edittext_line_end (OBJECT *x11texteditorpane_object)
@item __edittext_line_start (OBJECT *x11texteditorpane_object)
@item __edittext_xk_keysym (@code{int} @var{keycode}, @code{int} @var{shift_state}, @code{int} @var{keypress})
@item __edittext_next_char (OBJECT *x11texteditorpane_object)
@item __edittext_next_line (OBJECT *x11texteditorpane_object)
@item __edittext_next_page (OBJECT *x11texteditorpane_object)
@item __edittext_prev_char (OBJECT *x11texteditorpane_object)
@item __edittext_prev_line (OBJECT *x11texteditorpane_object)
@item __edittext_prev_page (OBJECT *x11texteditorpane_object)
@item __edittext_scroll_down (OBJECT *x11texteditorpane_object)
@item __edittext_scroll_up (OBJECT *x11texteditorpane_object)
@item __edittext_text_start (OBJECT *x11texteditorpane_object)
@item __edittext_text_end (OBJECT *x11texteditorpane_object)
@item __edittext_point_to_click (OBJECT *x11texteditorpane_object, int pointer_x, int pointer_y)
@item __edittext_index_from_pointer (OBJECT *x11texteditorpane_object, int pointer_x, int pointer_y)
@item __edittext_insert_str_at_click (OBJECT *x11texteditorpane_object, int click_x, int click_y, char *)
@item __edittext_insert_str_at_point (OBJECT *x11texteditorpane_object, char *)
@item __edittext_get_primary_selection (OBJECT *x11texteditorpan_eobject, void **buf_out, int *size_out)
@item __edittext_set_selection_owner (OBJECT *x11texteditorpane_object)
@item __edittext_recenter (OBJECT *x11texteditorpane_object)
Text editing functions used by @code{X11TextEditorPane} objects.
For more information, refer to @code{X11TextEditorPane} class..
@xref{X11TextEditorPane}.

@anchor{errorfuncs}
@cindex _error function
@item _error (@code{char *}@var{fmt}, @code{...})
Display an error message and exit the program.

@idxlibfn{__inspector_trace}
@idxlibfn{__inspect_get_receiver}
@idxlibfn{__inspect_get_global}
@idxlibfn{inspect_get_local}
@idxlibfn{__inspect_globals}
@idxlibfn{__inspect_locals}
@idxlibfn{__receiver_trace}
@idxlibfn{__inspect_short_help}
@idxlibfn{__inspect_long_help}
@cindex @mnm{inspect} instance method @idxclscite{ObjectInspector}
@item __inspector_trace (@code{int} @var{stack_index})
@item __inspect_get_arg (@code{int} @var{stack_index})
@item __inspect_get_receiver (@code{int} @var{stack_index})
@item __inspect_get_global (@code{char *}@var{obj_name})
@item __inspect_get_local (@code{int} @var{stack_index}, @code{char *}@var{obj_name})
@item __receiver_trace (@code{int} @var{stack_index})
@item __inspect_globals (@code{void})
@item __inspect_locals (@code{void})
@item __inspect_short_help (@code{void})
@item __inspect_long_help (@code{void})
Functions used internally by Ctalk's object inspector.  The function
parameters are designed to be consistent with the syntax of the
inspector commands, although not every function makes use of them.
For details refer to the @cite{inspect(3ctalk)} manual page, the
@cite{inspectors} section of the @flnm{ctalktools.info} Texinfo
manual, and the @mnm{inspect} method in @code{ObjectInspector} class.

@idxlibfn{__rt_init_library_paths}
@item __rt_init_library_paths (@code{void})
Initialize Ctalk's library paths.  The function first checks the value
of the @samp{CLASSLIBDIRS} environment variable for a colon-separated
list of directories, then adds the location of @var{classlibdir} which
is configured when Ctalk is built, and @var{classlibdir}@flnm{ctalk}.

@idxlibfn{__warning_trace}
@item __warning_trace (@code{void})
A generic stack trace function that prints a trace of the call
stack wherever it is inserted in a program.

@idxlibfn{__xalloc}
@item __xalloc (@code{int} @var{size})
Allocates a block of memory of @var{size} characters and returns
a pointer to the memory.  If the alloc call fails, generates an
@code{_error} message and exits the program.

@idxlibfn{__xfree}
@item __xfree (@code{void **}@var{addr})
Frees the block of memory pointed to by @var{*addr}, then sets
the @var{addr} to to NULL.  @var{*addr} must be a block of memory
previously allocated by @cite{__xalloc}, above, or a similar @cite{malloc}
call.  When used in a program, wrapping @var{addr} in the @samp{MEMADDR()}
macro provides the correct dereferencing for the allocated memory and its
pointer.  The example shows how the @samp{MEMADDR()} macro is used.

@example

char *my_ptr;

my_ptr = (char *)__xalloc (BUF_SIZE);

@emph{... do stuff ...}

__xfree (MEMADDR(my_ptr));

@end example

@idxlibfn{__xrealloc}
@item __xrealloc (@code{void **}@var{addr}, @code{int} @var{size})
Re-allocates the block of memory pointed to by @var{*addr} to size.
If @var{size} is larger than the original block of memory, the contents
of @var{addr} are preserved.  As with @cite{__xfree}, above, the
@samp{MEMADDR} macro provides the correct dereferencing for the
reference to @var{addr}.

@cindex _warning function
@item _warning (@code{char *}@var{fmt}, @code{...})
Print a warning message.

@cindex __objRefCntInc function
@item __objRefCntInc (@code{obj_ref})

Increment the reference count of an object and its instance variables.
This function takes an object reference as its argument.  You can use the
@code{OBJREF} macro to cast the object to an object reference.

@cindex __objRefCntDec function
@item __objRefCntDec (@code{obj_ref})

Decrement the reference count of an object and its instance variables.
As with all of the @code{__objRefCnt*} functions,
@code{__objRefCntDec} takes an object reference as its argument.  You
can use the @code{OBJREF} macro to cast the object to an object
reference.

@anchor{objRefCntSet}
@cindex __objRefCntSet function
@item __objRefCntSet (@code{obj_ref}, @code{int} @var{refcount})

Set the reference count of an object and its instance variables to
@var{refcnt}.  As with all of the @code{__objRefCnt*} functions,
@code{__objRefCntDec} takes an object reference as its argument.  You
can use the @code{OBJREF} macro to cast the object to an object
reference.

@emph{Note:} @code{__objRefCntSet} will not set an object's reference
count to zero.  That is, if you give @samp{0} as the second argument,
the call has no effect.  Use @code{__objRefCntZero} instead.  That
might sound silly, but it's much more reliable overall, in a
programming-by-contract way.

@cindex __objRefCntZero function
@item __objRefCntZero (@code{obj_ref})

Set the reference count of an object and its instance variables to
0 (zero).  As with all of the @code{__objRefCnt*} functions,
@code{__objRefCntZero} takes an object reference as its argument.  You
can use the @code{OBJREF} macro to cast the object to an object
reference.  

You should not need to use this function unless you're
@emph{completely} deleting an object.  Refer to the
@code{__ctalkDeleteObject} function for more information.


@idxlibfn{__refObj}
@cindex OBJREF_T data type
@cindex OBJREF macro
@item __refObj (@code{OBJECT **}@var{obj1}, @code{OBJECT **}@var{obj2})
Assign @var{obj2} to @var{obj1}.  If @var{obj1} already points to an
object, decrement its reference count.  Increment the reference count
of @var{obj2} by 1.  When calling functions that use @code{OBJECT **}
arguments, they correspond to the OBJREF_T typedef, and Ctalk defines
the macro OBJREF() to cast an object to an OBJREF_T.

@idxlibfn{_store_int}
@item _store_int (@code{OBJECT *}@var{receiver}, @code{OBJECT *}arg)
This is a primitive that stores the value of @var{arg} in
@var{receiver}, which is an @code{Integer}.  Checks the class of @code{arg},
and if @var{arg} is not an @code{Integer}, converts it to an @code{Integer}
value.  If @var{receiver} a pointer to a value, then it stores @var{arg}
as a fully-fledged object.

@idxlibfn{BOOLVAL macro}
@item BOOLVAL(@var{IntegerOrBoolValue})
This macro returns the value of an @code{Integer} or @code{Boolean}
object, or any of @code{Boolean's} subclasses (or just about any other
scalar value), as a C @code{bool}.  For an example of its use, refer to
the entry for the @xref{INTVAL_Macro}.

@anchor{INTVAL_Macro}
@idxlibfn{INTVAL macro}
@item INTVAL(@var{IntegerObjectValue})
A macro that returns the value of an @code{Integer} object, or any of
@code{Integer's} subclasses, as a C @code{int}.  Uses an @code{OBJECT
*'s} @code{__o_value} member directly, as in this example.

@example

OBJECT *my_int_object_alias = myInt;

int a = INTVAL(my_int_object_alias -> __o_value);

@end example

@cindex is_zero_q function
@item is_zero_q (char *str)
Returns a @code{bool} if the number represented by the string
evaluates to zero, false otherwise.

@idxlibfn{LLVAL macro}
@item LLVAL(@var{LongIntegerValue})
A macro that returns the value of a @code{LongInteger} object, or any
of @code{LongInteger's} subclasses, as a C long long int. For an
example of its use, refer to the entry for the @xref{INTVAL_Macro}.

@cindex obj_ref_str function
@item obj_ref_str (@code{char *}@var{str})
If @var{str} contains a formatted hexadecimal number of the
format @samp{0x@var{nnnnnn}} that points to an object,
return an @code{OBJECT *} reference to the object,
@code{NULL} otherwise.

@cindex str_is_zero_q function
@item str_is_zero_q (@code{char *}@var{str})
Like @cite{is_zero_q}, above, except that it also checks for an empty
string (and returns true), as well as a string that contains only the
digit @samp{0}, which causes the function to return false.

@cindex substrcat function
@item substrcat (@code{char *}@var{dest}, @code{char *}@var{src}, @code{int} @var{start_index}, @code{int} @var{end_index})
Concatenate the substring of @var{src} from @var{start_index} to
@var{end_index} to @var{dest}.

@cindex substrcpy function
@item substrcpy (@code{char *}@var{dest}, @code{char *}@var{src}, @code{int} @var{start_index}, @code{int} @var{end_index})
Copy a substring of @var{src} from @var{start_index} to
@var{end_index} to @var{dest}.

@idxlibfn SYMTOOBJ macro
@item SYMTOOBJ (@var{SymbolValue})
This is another macro that converts a @code{Symbol's} reference to an
@code{OBJECT *}.  This macro can be used on the right-hand side of an
assignment statement. 

@example

if ((value_object =
    SYMTOOBJ((self_object -> instancevars) ? 
             (self_object -> instancevars -> __o_value) : 
             (self_object -> __o_value))) != NULL) @{
      return value_object;
    @}

@end example

@idxlibfn SYMVAL macro
@item SYMVAL(@var{SymbolValue})
A macro that returns the value of a @code{Symbol} object, or any of
@code{Symbol's} subclasses, as a C @code{uintptr_t *}, which is guaranteed
to be valid for 32- and 64-bit machines.

However, due to the way that pointers work in C, @code{SYMVAL} only
works on the left-hand side of an assignment; you just need a cast
(for example to @code{OBJECT *}) in order to avoid compiler warnings
when it appears on the right-hand side of an assignment. Here is an
example:

@example

SYMVAL(object_alias->__o_value) = (OBJECT *)some_ptr;

@end example

However, if he label on the right-hand side is also a @code{Symbol},
the @code{Symbol} class duplicates the address that the operand points
to, not the operand itself.

@example

SYMVAL(object_alias->__o_value) = SYMVAL(some_ptr -> __o_value);

@end example

For another, perhaps more basic, example of the macro's use, refer to
the entry for the @xref{INTVAL_Macro}.


@cindex OBJREF macro
@item OBJREF(@var{obj})
Creates a reference to an object.  This macro returns an @code{OBJECT
**}, but using the macro allows the definition of an object reference
to change without affecting too much code.  @code{OBJREF} is used with
the @code{__objRefCnt*} functions, and in other places.

@cindex TRIM_LITERAL macro
@item TRIM_LITERAL(@var{s})
A macro that trims the quotes from a literal string.  It expands to 
@code{substrcpy (@var{s}, @var{s}, 1, strlen (@var{s}) - 2)}.

@cindex TRIM_CHAR macro 
@item TRIM_CHAR(@var{c})
A macro that trims the quotes from a literal character.  It expands to 
@code{substrcpy (@var{c}, @var{c}, 1, strlen (@var{c}) - 2)}

@cindex TRIM_CHAR_BUF macro 
@item TRIM_CHAR_BUF(@var{s})
A macro that trims nested single quotes from a literal character.
@code{TRIM_CHAR_BUF} also checks whether a single quote (@samp{'}) is
the actual character.

@idxlibfn{xfopen}
@idxlibfn{xfprintf}
@idxlibfn{xfscanf}
@idxlibfn{xmemcpy}
@idxlibfn{xmemmove}
@idxlibfn{xmemset}
@idxlibfn{xsprintf}
@idxlibfn{xstrcpy}
@idxlibfn{xstrncpy}
@idxlibfn{xstrcat}
@idxlibfn{xstrncat}
@item xfopen (const char *path, const char *mode)
@item xfprintf (FILE *stream, const char *fmt, ...)
@item xfscanf (FILE *stream, const char *fmt, ...)
@item xmemcpy (void *s, const void *s, size_t)
@item xmemmove (void *s, const void *s, size_t)
@item xmemset (void *s, int c, size_t n)
@item xsprintf (char *s, const char *fmt, ...)
@item xstrcat (char *d, const char *s)
@item xstrncat (char *d, const char *s, size_t)
@item xstrcpy (char *d, const char *s)
@item xstrncpy (char *d, const char *, size_t)
These are portable wrappers for systems that #define their own
(possibly more secure) versions of library functions.  For the exact
prototype and definition, you should consult the system's manual page
for the corresponding library function (e.g., @cite{strcpy(3)} for the
definition of @cite{xstrcpy}).

@c LIB-DOC-END-COOKIE ***

@end table

@node C, Copying, Methods, Top
@iftex
@chapter Ctalk Language Featues
@end iftex
@ifnottex
@heading Ctalk Language Features
@end ifnottex
@cindex Ctalk language features

@iftex
This chapter describes @command{ctalk}'s language features and
its low-level application programming interface.
@end iftex
@ifnottex
This section describes @command{ctalk}'s C language features and
its low-level application programming interface.
@end ifnottex

@menu
* Preprocessor::        Compatibility with @command{cpp}.
* C statements::        How to use objects and C in the same programs.
* Externs::             Working with multiple input files.
* Class casting::       How to tell Ctalk which class an object is.
* Control structures::  Objects in loops and conditional statements.
* OBJECT typedef::      Ctalk's @code{OBJECT} type.
* Attributes::          Attributes help identify an object's context.
* C library functions:: How to use objects with C library functions.
* GNU tools::           Using automake, etc., with Ctalk programs.
@end menu


@node Preprocessor, C statements, , C
@iftex
@section @command{ctpp,} the @command{ctalk} Preprocessor
@end iftex
@ifnottex
@subheading @command{ctpp,} the @command{ctalk} Preprocessor
@end ifnottex
@cindex Preprocessor
@cindex @command{ctpp} preprocessor
@cindex Include files
@cindex Header files

Information about @command{ctpp}, the Ctalk preprocessor, is contained
in its Texinfo manual, @flnm{ctpp.info}.

The preprocessor is compatible with GNU @command{cpp} and supports ISO
C99 preprocessing features.  This allows you to include C header files
in Ctalk programs and class libraries.  Ctalk caches macros from
include files, so it can use, in the GNU compiler's terminology,
@emph{include once} header files. 

If you have a header file called, for example, @flnm{myheader.h}, you
would wrap the definitions with the following preprocessor directives.

@example

#ifndef _MYHEADER_H
#define _MYHEADER_H
.
. <Your definitions appear here.>
.
#endif /* _MYHEADER_H */
@end example

This makes certain that the preprocessor defines macros, data types,
and other library definitions only once, no matter how many times the
input includes the header file.

@node C statements, Externs, Preprocessor, C

@iftex
@section Pragmas
@end iftex
@ifnottex
@subheading Pragmas
@end ifnottex
@cindex Pragmas

Ctalk recognizes GCC, G++, and C99 pragmas.  

Pragmas that apply to floating point operations and code generation
are ignored and elided, unless the @samp{--keeppragmas} command line
option is given.  @xref{Invoking}.

Inclusion of a file that contains G++ pragmas causes the preprocessor
to issue a warning if the @samp{-v} option is given, and
@command{ctalk} ignores the file. @xref{Invoking}.

Here is the effect of the GCC and C99 pragmas.

@table @code

@cindex #pragma interface
@cindex #pragma implementation

@item #pragma interface
@item #pragma implementation
The include file is not processed.

@cindex #pragma GCC dependency

@item #pragma GCC dependency @var{file}
Issues a warning if the source file is more recent than @var{file}.

@cindex #pragma GCC poison

@item #pragma GCC poison @var{identifier} ...
@command{ctalk} issues an error and discontinues processing if the
source file contains an identifier given as an argument.

@cindex #pragma GCC system header

@item #pragma GCC system header
The @command{ctalk} preprocessor processes all input files in the
same manner and ignores this pragma.

@cindex #pragma GCC pack
@cindex #pragma STDC FP_CONTRACT
@cindex #pragma STDC FENV_ACCESS
@cindex #pragma STDC CX_LIMITED_RANGE

@item #pragma GCC pack
@item #pragma STDC FP_CONTRACT
@item #pragma STDC FENV_ACCESS
@item #pragma STDC CX_LIMITED_RANGE
@command{ctalk} ignores and elides these pragmas, which apply to
floating point and code generation options, unless the
@samp{--keeppragmas} option is used. @xref{Invoking}.

@end table

@iftex
@section C Expressions
@end iftex
@ifnottex
@subheading C Expressions
@end ifnottex
@cindex C expressions

In version @value{VERSION}, you can use simple constant expressions as
receivers, as in this example.

@example
printf ("%s", "/home/users/joe" subString 1, self length - 1);
@end example

@emph{Warning} - This use of @code{self} is experimental in version
@value{VERSION} and should be used with caution.

You can use a C constant in place of any receiver whose class
corresponds to a basic C data type.  These classes include
@code{Character}, @code{String}, @code{Float}, @code{Integer}, and
@code{LongInteger}.

Expressions like the following work.
@example
if (99 == myInt)
 ...

if ('c' == myInt asCharacter)
 ...

if (3.1416 == pi)
 ...
@end example

The following code examples are equivalent.

@example
myString = "This is a string.";
printf ("%d\n", myString length);
@end example

and,

@example
printf ("%d\n", "This is a string" length);
@end example

However, if you try to use a C variable on the left side of a method
that overloads a C operator, the expression might simply be
interpreted as C code, as in this example.

@example
  String new progName;

  progName = "myprog";

  if (argv[0] == progName) @{
    ...
  @}
@end example

This is because Ctalk does not interpret @code{argv[0]} as a receiver
object, and then interprets @code{==} as a C operator.

@iftex
@section Objects in Function Parameters
@end iftex
@ifnottex
@subheading Objects in Function Parameters
@end ifnottex
@cindex Function parameters

Programs cannot, at this time, use objects as parameters to C 
functions.  If you need to use an object as a parameter, you need
to use a method instead of a function, or translate the object's value
to C. @xref{Translating}.

@iftex
@section Objects in Function Arguments
@end iftex
@ifnottex
@subheading Objects in Function Arguments
@end ifnottex
@cindex Function arguments
@anchor{Objects in Function Arguments}

You can use of Ctalk expressions as C function arguments, but the
values should be treated as read-only, as in this example.

@example
Integer new myIndex;
char buf[255];

myIndex = 0;

/*
 *   This statement works correctly. 
 */
sprintf (buf, "%d", __ctalk_to_c_int (myIndex));

/*
 *   This statement does not work correctly.
 */
sscanf (myString, "%s %s", mySubString1, mySubString2);
@end example

If you need to read a string into objects, try @mnm{readFormat} (class
@code{String}) instead.

@cindex @code{Unimplemented C type} warning
@cindex @code{Symbol} class
If you receive an @code{Unimplemented C type} warning, it means that
Ctalk does not implement a class that corresponds to the data type.
In these cases, you can generally assign the C variable to an instance
of class @code{Symbol,} and use that as the argument to a function.

The Classes that implement C data types are described in the next
section. 

@iftex
@section C Data Type Classes
@end iftex
@ifnottex
@subheading C Data Type Classes
@end ifnottex

These classes correspond to the basic C types.

@table @code

@cindex @code{char **} C data type
@item Array
@code{char **}

@cindex @code{char} C data type
@item Character
@code{char}

@cindex @code{float} C data type
@cindex @code{double} C data type
@item Float
@code{float} and @code{double}

@cindex @code{int} C data type
@cindex @code{long int} C data type
@item Integer
@code{int} and @code{long int}

@cindex @code{long long int} C data type
@item LongInteger
@code{long long int}

@cindex @code{char *} C data type
@item String
@code{char *}

@end table

@iftex
@section Typedefs in Function Arguments
@end iftex
@ifnottex
@subheading Typedefs in Function Arguments
@end ifnottex
@cindex Typedefs
@cindex @code{time_t} type

Ctalk resolves many of the derived types defined in C99, as well as
incomplete types; however, variables that are of derived types can
still cause unpredictable results, if the variable is of an unusual or
complex type.
 
If you encounter a case where a derived type confuses the parser or
run-time library, the workaround is to declare the type as an
equivalent C type.  For example, if a variable is of type
@code{time_t,} you could equivalently declare it as type @code{long
long int.}

@iftex
@section C Functions in Complex Expressions
@end iftex
@ifnottex
@subheading C Functions in Complex Expressions
@end ifnottex

You can use C functions in complex expressions within conditionals,
as in this example.
@example
int int_fn1 (void) @{
  return 10;
@}

char *add_int_fn_as_string (int a, int b, int c) @{
  static char buf[30];
  sprintf (buf, "%d", a + b + c);
  return buf;
@}

int main () @{

  String new myString1;

  if ((myString1 = add_int_fn_as_string (int_fn1 (), 20, 30)) != "60")
    exit(1);
    
  printf ("%s\n", myString1);

@}
@end example
As long as your function returns one of the C data types @code{int,
char, char *,} or @code{double,} Ctalk can translate the function
output to an object, as well as call the function at run time using
a method call.

If you try to use a C function that returns a complex or derived type,
Ctalk prints a warning and uses @code{Integer} as the default return
class.  In these cases, you should consider writing a method instead.

@emph{Note:} When you use functions in complex expressions, the
function's arguments must also be C variables or expressions.  If you
want to use objects as the arguments to a function, then you must
perform the object-to-C translation manually.

@anchor{Debugging}
@iftex
@section Debugging
@end iftex
@ifnottex
@subheading Debugging
@end ifnottex
@cindex Debugging

@iftex
@subsection Object Inspectors
@end iftex
@ifnottex
@subsubheading Object Inspectors
@end ifnottex
@cindex Inpectors

@cindex @mnm{inspect} instance method @idxclscite{Object}
Ctalk provides a basic set of methods that can inspect and print
the contents of objects.  

The @mnm{inspect} method in @code{Object} class is an interactive
utility that lets you examine a program's objects as the program
is running.

To inspect an object, simply send it the message, @mnm{inspect} - it's
a shortcut for the @mnm{inspect} method in @code{ObjectInspector}
class, which a program can also call directly.  


@example

String new globalString;

int main () @{
  Integer new i;

  globalString = "global string";

  i inspect;
@}

@end example

In either case, the program stops execution when it reaches the
@mnm{inspect} method, and presents a prompt where you can type commands.

Here's a transcript of a brief inspector session.

@example

$ ./inspect 
> p
p
name:       i
class:      Integer (0x48bf4958)
superclass: Magnitude (0x48bf29f0)
value:      (null) (Integer)

> p g globalString
p g globalString
name:       globalString
class:      String (0x48cce8d0)
superclass: Character (0x48c8acc0)
value:      global string (String)

> c
c
$ 

@end example

At the inspector prompt, @samp{> }, the command @samp{p} prints
the inspector's receiver object, and @samp{p g globalString} prints
the named global object, @code{globalString}.  The @samp{c} command
exits the inspector and continues running the program.

There are several commands that the inspector recognizes.  Typing
@samp{?,} @samp{h,} or @samp{help} at the prompt displays a list of them.

@cindex @mnm{dump} instance method @idxclscite{Object}
@cindex @mnm{formatObject} instance method @idxclscite{Object}
@cindex @code{ObjectInspector} class
@cindex __ctalkPrintObject function
The inspector uses the method @mnm{formatObject} to print the contents
of individual objects.  

If you want to print a formatted object directly, without stopping the
program, Ctalk also has the method @mnm{dump} in @code{Object} class,
which simply calls @mnm{formatObject} with its receiver object to
print the object and then returns so the program can continue running.


@iftex
@subsection Using @command{gdb} for Debugging
@end iftex
@ifnottex
@subsubheading Using @command{gdb} for Debugging
@end ifnottex

@cindex @code{ctdb} command
@cindex @code{gdb} command
@cindex @mnm{inspect} instance method @idxclscite{Object}
The GNU @command{gdb} debugger allows you to trace through Ctalk
applications as well as the compiler and the run-time libraries,
at the level of Ctalk's source code.

In order to debug Ctalk programs with @command{gdb}, the source
must be compatible with the debugger; that means that you can
debug Ctalk programs using the intermediate C code to get source
level debugging within Ctalk apps.

You can also examine the contents of objects and their run-time
environment with the @mnm{inspect} method (in @code{Object} class),
which doesn't use line number information. @xref{Object_inspect}.
There's a tutorial on using object inspectors in the @cite{ctalktools}
Texinfo manual, and yet more information in the @cite{inspect.3ctalk}
manual page.

The @samp{-P} command line option disables line numbering.  You can
then debug the intermediate output, which is normal C that
@command{gdb} can interpret correctly.

This means that method line numbers are calculated from the start of
all of the input, which includes all other classes and header files.
So when you give the @samp{-P} option to Ctalk, it reports the line if
possible, although without line number information, the compiler can't
track line numbers of preprocessor output; like for example, by
adjusting line numbers after including a file with the @samp{#include}
directive.

The @command{ctdb} command builds Ctalk programs with the correct
arguments for debugging.  Then you can use @command{gdb} to debug the program.

@example
$ ctdb -k myprog.c -o myprog
@end example

If you need to debug either @command{ctalk} or the @code{libctalk}
library, then you need to build and install Ctalk without
optimization.  You can do that by adding the
@samp{--without-optimization} option to @command{configure} when
building Ctalk.  Compiler optimization often removes lines of code
(and variables) from the binary, so the output often doesn't
correspond to the source code.  Also, it often helps to add the
@samp{--without-inline-functions} option to @command{configure}.

@cindex Optimization
@example

$ ./configure --without-inline-functions --without-optimization

@end example

Then build and install Ctalk with @code{make} and @code{make install.}

Ctalk also provides other build options.  Typing 
@example 
$ ./configure --help
@end example
at the shell prompt prints a list of them.

Ctalk is compatible at the machine code level with C programs.  That
means you use most of @command{gdb's} functions, like peek into a
running program and examine core dumps.  The @command{gdb}
documentation describes the debugger's extensive set of options.


@node Externs, Class casting, C statements, C
@iftex
@section Externs
@end iftex
@ifnottex
@subheading Externs
@end ifnottex
@cindex Prototypes, methods
@cindex Method prototypes

Ctalk provides a few facilities to help when compiling code in
several input modules.  

There are also a few caveats when dealing with C variables in multiple
input modules, which are described below.

Ctalk allows you to prototype methods.  That is, you can declare a
method in a source code module before compiling another module later
where the method is actually defined.

Prototypes are similar to method declarations, except that the
prototype omits the method body.  For example, a method prototype
before the method is first used would look like this.

@example
String instanceMethod myLength (void);
@end example

You can also define a different return class in the prototype, as in
this example.

@example
String instanceMethod myLength (void) returnClass Integer;
@end example

For example, if the input file module1.ca looks like this:

@example

String instanceMethod trimStrLength (void) returnObjectClass Integer;

int main () @{

  String new myStr;

  myStr = "Hello, world!";

  printf ("%s\n", myStr subString 0, myStr trimStrLength 2);
@}

@end example

and the file module2.ca, which contains the definition of
@mnm{trimStrLength}, looks like this:

@example

String instanceMethod trimStrLength (void) @{
  returnObjectClass Integer;
  return self length - 1;
@}

@end example

Then you can build the program with a command line like the following,
and Ctalk will have the definition of @mnm{trimStringLength} while
compiling module1.ca, before it actually compiles the method in
module2.ca.

@example

$ ctcc module1.ca module2.ca -o myprog

@end example

@subsubheading C Variables and @code{extern} Declarations
@cindex Externs and C variables

When using a global C variable in several input modules, you only need to
declare it once, before it is first used.  Ctalk combines the C code
of all of the input files with one copy of the class libraries, so
it isn't necessary to declare a C variable in the first module and then
declare it as extern in the modules that get compiled later.

@node Class casting, Control structures, Externs, C
@iftex
@section Class casting
@end iftex
@ifnottex
@subheading Class casting
@end ifnottex

In many cases, it's obvious which class an object is, even when the
object's defition is removed from the place where a program needs to
perform an operation on it, or the object is aliased to @code{self} or
to a C variable, or you need to use a different type of language
semantics with an object.

If a program has a set of expressions, as in this hypothetical
example:

@example

Integer new myInt;
myList new myList;
Key new myKey;
Symbol new *intPtr;

*intPtr = Integer new "Int 1", "1";
myList push *intPtr;
*intPtr = Integer new "Int 2", "2";
myList push *intPtr;

myKey = myList + 1;

myInt = *myKey;

myInt += 3;

@emph{... do stuff with myInt ...}

myList map @{
  printf ("%d\n", self value);
@}

@end example

When run, the program would produce output like this.

@example

$ ./myProg
1
2

@end example

That's because the changes to @code{myInt} would not take effect for
the member of @samp{myList}, because @code{Integer} objects, when a
program assigns values to them, normally assigns the value of one
@code{Integer} to another.  However, in the example above, you might
want to work on the original list member - that is, you want the
assignment to treat @code{myInt} as if it were a reference.

One way to notify Ctalk of this is to use an @code{Object} to refer to
the list element, and use a @emph{class cast} to notify Ctalk that the
@code{Object} is actually an @code{Integer}.

Then the program example above looks like this.

@example

Object new myIntObject;
myList new myList;
Key new myKey;
Symbol new *intPtr;

*intPtr = Integer new "Int 1", "1";
myList push *intPtr;
*intPtr = Integer new "Int 2", "2";
myList push *intPtr;

myKey = myList + 1;  

myIntObject = *myKey;

(Integer *)myIntObject += 3;  /* The cast tells Ctalk to treat myIntObject,
                                 which is declared as an Object,
                                 as an Integer, so it can work correctly
                                 with the first element of myList. */

@emph{... do stuff with myIntObject ...}

myList map @{
  printf ("%d\n", self value);
@}

@end example

Other places that you can use class casting is when a program uses
a C @code{OBJECT *}.  In that case, you can tell Ctalk what class
the object is.  Here's an abbreviated example from a @code{map} method in
@code{TreeNode} class.

@example

  OBJECT *t, *list_elem;

  /* rcvr_obj is a TreeNode object. */
  for (t = __LIST_HEAD(rcvr_obj), have_break = NULL; 
       t && !have_break; t = t -> next) @{
    list_elem = obj_ref_str ((t -> instancevars) ? 
			     t -> instancevars -> __o_value :
			     (IS_VALUE_INSTANCE_VAR(t) ? 
			      t -> __o_p_obj -> instancevars -> __o_value :
			      "0x0"));

  @emph{... do stuff ...}

  (TreeNode *)list_elem children __mapChildren methodfn;

  (TreeNode *)list_elem siblings __mapSiblings methodfn;

  @}
@end example

This is a convenient way for a program to tell Ctalk that @code{list_elem}
is a @code{TreeNode} object.  It's up to the program to ensure that the
C variable actually does point to an object of that class, or the program
won't work correctly at run time.

Programs can also cast @code{self} to a class, in cases where Ctalk
cannot determine @code{self's} class from its context, like in this
example

@example

myList map @{

  (Float *)self = 0.01f;

@}

@end example

This feature is still experimental, and you should use it with
caution; in particular, it's up to the program to insure that the
object actually is a member of the class that you cast it to.
However, on the occasions when a program needs to excercise some
control over a set of expressions' semantics, then class casting can
be useful.

@c
@c  Control structures
@c
@node Control structures, OBJECT typedef, Class casting, C

@iftex
@section Control Structures
@end iftex
@ifnottex
@subheading Control Structures
@end ifnottex
@cindex @code{if} statements
@cindex @code{for} statements
@cindex @code{while} statements
@cindex @code{do} statements
@cindex @code{!} operator

Generally, Ctalk objects work the same as C variables when they appear
in @code{if}, @code{for}, @code{while}, @code{switch}, and @code{do-while}
statements.

If Ctalk cannot figure out a way to resolve an expression that contains
both C variables or functions and objects, it will try to warn you.

One exception to these rules are the methods that perform logical
negation operator, which generally overload the @samp{!} math operator.
When you place a @samp{!} operator at the beginning of a conditional,
Ctalk checks whether the class of the expression's result overloads the
operator.  In that case, Ctalk treats @samp{!} as a method.  If a
class does not overload the operator, then Ctalk treats it as a C 
operator.

That way, you can overload @samp{!} in classes that define complex
objects, which provides a flexible way to determine if an object has
been initialized or contains valid data.

For example, in @code{X11Font} class, you can overload the @samp{!}
operator to check whether or not an object's @code{fontId} instance
variable is zero to determine whether or not the object refers to a
valid font.

If a class doesn't overload @samp{!}, then Ctalk uses the C semantics
for the operator - that is, it simply checks whether an operand is zero
(or NULL) or non-zero, and inverts the logical true or false value
of the operand.

In addition, Ctalk provides many methods to iterate over collections
of objects.  These methods include @code{map}, @code{mapInstanceVariables},
@code{mapClassVariables}, and overloaded math operators like those in
@code{Key} class.

For a complete description of the control structures Ctalk uses, refer
to the @cite{Ctalk Tutorial}.

@node OBJECT typedef, Attributes, Control structures, C

@heading @code{OBJECT} typedef

@cindex OBJECT typedef

At the lowest level, ctalk declares objects as pointers to an
@code{OBJECT} struct.  You can access an object's members if you
assign an object's value to a C variable of the type @code{OBJECT *},
as in this example.

@example
Object new myObject;
OBJECT *myObjectValue;

myObjectValue = myObject value;

if (!strcmp (myObjectValue -> CLASSNAME, "Object"))
   printf ("myObjectValues class is, \"Object.\"\n");
@end example

The declaration of the OBJECT type is contained in @flnm{include/object.h}.

@example
typedef struct _object OBJECT;
. . .
struct _object @{
  char sig[16];
  char __o_name[MAXLABEL];
  char __o_classname[MAXLABEL];
  OBJECT *__o_class;
  char __o_superclassname[MAXLABEL];
  OBJECT *__o_superclass;
  OBJECT *__o_p_obj;
  VARTAG *__o_vartags;
  char *__o_value;
  METHOD *instance_methods,
    *class_methods;
  int scope;
  int nrefs;
  int attrs
  struct _object *classvars;
  struct _object *instancevars;    
  struct _object *next;
  struct _object *prev;
@};
@end example

Note that @code{__o_name}, @code{__o_classname},
@code{__o_superclassname}, and @code{__o_value} are all @code{char *},
even if the object belongs to a class like @code{Integer} or
@code{Float}.  The struct members @code{__o_class} and
@code{__o_superclass} contain pointers to the library class and
superclass entries, which are also objects.

For numeric classes, the @code{value} member contains a formatted
representation of a numeric value.  Examples of directly assigning
values to objects are given in the section about writing methods.
@xref{Method API}.

Ctalk uses the members @code{instance_methods,} @code{class_methods,}
@code{classvars} for class objects.

The @code{sig} member contains a numeric stamp that verifies
that the @code{OBJECT *} refers to a valid object.

The @code{scope} member describes an object's scope.  The scope can be
one of @code{GLOBAL_VAR}, @code{LOCAL_VAR}, @code{ARG_VAR},
@code{RECEIVER_VAR}, @code{PROTOTYPE_VAR}, or @code{BLOCK_VAR.}

The @code{nrefs} member keeps track of the number of references that
exist to an object at run time.  Every time ctalk creates a reference
to an object, internally ctalk increments @code{nrefs}.  When ctalk
deletes a reference, it decrements @code{nrefs}.  When 
@code{nrefs} drops to zero, @command{ctalk} deletes the object.

The @code{attrs} member is a combination of one or more object attributes.
The next section describes object attributes in more detail.

The @code{tag} member is an abbreviation for the
@code{__o_vartags -> tag -> var_decl -> name} member; that is,
the object's primary label.

@node Attributes, C library functions, OBJECT typedef, C
@iftex
@section Object Attributes
@end iftex
@ifnottex
@subheading Object Attributes
@end ifnottex
@cindex Attributes, object
@cindex Object attributes

The Ctalk API defines a number of object attributes.  The attributes
help identify the context that the object appears in.  Many of the
attributes are only meaningful internally; some are also useful in the
method API.

@cindex @cite{__ctalkSetObjectAttr ()} function
The attributes are defined in @file{ctalkdefs.h}, which you can
include in class libraries.  To set an object's attribute, it's
generally convenient to use the @cite{__ctalkSetObjectAttr ()}
library function, which has the prototype:

@example

__ctalkSetObjectAttr (@code{OBJECT *}@var{object}, @code{int} @var{attr})

@end example

Many attributes are only used by Ctalk internally.  The attributes
that are useful in methods are defined in @flnm{ctalkdefs.h}.  Those
attributes, and their values and uses, are listed here.

@table @code

@item OBJECT_IS_VALUE_VAR    (1 << 0)
The object is the @code{value} instance variable of its
parent object.
@item OBJECT_VALUE_IS_C_CHAR_PTR_PTR     (1 << 1)
Used to indicate that an object refers to a @code{char **} C
array.
@item OBJECT_IS_NULL_RESULT_OBJECT      (1 << 2)
Indentifies an object that is created when an operation produces a
NULL result.
@item OBJECT_HAS_PTR_CX     (1 << 3)
Set when an object appears on the left-hand side of an equation
with a pointer reference; e.g.,
@example

*mySymbol = __ctalk_self_internal ().

@end example

@cindex @code{OBJECT_IS_GLOBAL_COPY} attribute;
@item OBJECT_IS_GLOBAL_COPY     (1 << 4)
Set when a program copies a global object.

@cindex @code{OBJECT_IS_I_RESULT} attribute;
@item OBJECT_IS_I_RESULT      (1 << 5)
Identifies temporary objects that are the result of an operation
that sets the object tag's pointer references.

@cindex @code{OBJECT_IS_STRING_LITERAL} attribute;
@item OBJECT_IS_STRING_LITERAL     (1 << 6)
Used to identify an object created to represent a string literal.

@cindex @code{OBJECT_IS_MEMBER_OF_PARENT_COLLECTION} attribute;
@item OBJECT_IS_MEMBER_OF_PARENT_COLLECTION     (1 << 7)
Indicates that an object (generally a @code{Key} object) is a member
of a parent collection.  Normally used to identify individual collection
members.

@cindex @code{OBJECT_HAS_LOCAL_TAG} attribute;
@cindex @cite{__ctalkAddBasicNewTag ()} function
@item OBJECT_HAS_LOCAL_TAG     (1 << 8)
Indicates that an object's tag was created as a placeholder for an
ad-hoc object; for example, objects created by a @code{basicNew}
method.  The local tag is not necessarily the primary tag - the
object can also acquire other tags when being assigned.  Normally
this attribute is set by the @cite{__ctalkAddBasicNewTag ()} library
function.

@cindex @code{OBJECT_IS_DEREF_RESULT} attribute;
@cindex @mnm{->} instance method @idxclscite{Object}
@item OBJECT_IS_DEREF_RESULT
Set by the @code{Object : ->} method.  The attribute is used to
indicate that the receiver of @code{->} is the result of a previous
call to @code{->}; i.e., the expression contains several dereference
operators; for example, @samp{myObject -> instancevars -> __o_value}.

@end table

@node C library functions, GNU tools, Attributes, C
@iftex
@section C Library Functions
@end iftex
@ifnottex
@subheading C Library Functions
@end ifnottex
@cindex C library functions

You can assign the result of a C library function to a Ctalk object,
provided that the return type of the function has a corresponding 
Ctalk class.  

All C functions must have prototypes.  The library functions in this
section already have their prototypes defined in the C library
headers.  If a function in a program does not have a prototype, Ctalk
prints an error and exits.  

Generally, if Ctalk has a method that is analogous to a C library
function, you can use the method with Ctalk objects, although in many
cases you can mix objects and C variables.  Of course, you can still
use any C library function with C data types.

@cindex Xt object classes
@cindex X Window System
@cindex C library compatibility

There are some incompatibilities with more specialized libraries.  For
example, you should take care when using the X Window System Xt
widgets in Ctalk programs, because the widget classes use the some of
the same class names as the Ctalk library.

The following sections describe the C library functions that Ctalk can
use directly.

@menu
* abs::
* acos::
* acosh-asinh-atanh::
* asctime::
* asin::
* atexit::
* atof::
* atoi::
* atol::
* atoll::
* calloc::
* cbrt::
* ceil::
* chdir::
* clock::
* copysign::
* cos::
* cosh::
* ctime::
* difftime::
* erf::
* erfc::
* exp::
* expm1::
* fabs::
* fclose::
* fegetround::
* feholdexcept::
* feof::
* ferror::
* fesetround::
* fetestexcept::
* fflush::
* fgetc::
* fgetpos::
* fgets::
* floor::
* fmod::
* fopen::
* fprintf::
* fputc::
* fputs::
* fread::
* free::
* freopen::
* frexp::
* fscanf::
* fseek::
* fsetpos::
* fstat::
* ftell::
* fwrite::
* getc::
* getchar::
* getcwd::
* getenv::
* getpid::
* gmtime-localtime::
* index-function::
* isalnum-isxdigit::
* labs::
* llabs::
* llrint::
* llround::
* log::
* log10::
* log1p::
* lrint::
* lround::
* malloc::
* memchr::
* memcmp::
* memcpy::
* memmove::
* memset::
* mkdir::
* modf::
* nearbyint::
* perror::
* pow::
* printf::
* raise::
* rand::
* realloc::
* remove::
* rename::
* rindex::
* rint::
* rmdir::
* round::
* scanf::
* sin::
* sinh::
* snprintf::
* sprintf::
* sqrt::
* srand::
* sscanf::
* strcat-strcpy::
* strchr::
* strcoll::
* strspn::
* strerror::
* strftime::
* strlen::
* strncat-strncpy::
* strpbrk::
* strrchr::
* strstr::
* strtod::
* strtok::
* strtoll::
* strxfrm::
* system::
* tan::
* tanh::
* tmpnam::
* tolower::
* toupper::
* trunc::
* ungetc::
* vfprintf::
* vfscanf::
* vprintf::
* vscanf::
* vsnprintf::
* vsprintf::
* vsscanf::
@end menu

@c Need classes:
@c atexit, btowc, bsearch, calloc, localeconv,
@c lroundf, lroundl, mktime, nearbyintf,
@c nearbyintl, qsort, rewind, rintf, rintl, roundf, roundl, setjmp,
@c sigsetjmp, strtof, strtold, strtol, strtoul, strtoull, time, tmpfile, 
@c truncf, truncl
@c
@c Unsupported or inapplicable functions:
@c On Linux - cabs, cacos, cacosh, carg, casin, casinh, catan, catanh,
@c  ccos, ccosh, cerf, cexp, cexp2, cexpm1, cgamma, cimag, clearerr,
@c  clgamma, clog, clog10, clog1p, clog2, conj, cpow, cproj, creal,
@c  csin, csinh, csqrt, ctan, ctanh, exp2, ilogb, mkxtime, nan,
@c  nextafter, remainder, remquo, scalbln, scalbn, strfxtime,
@c  strtoimax, strtoumax, tgamma, zonetime
@c ceilf, ceill, div, fdim, feclearexcept, fegetenv, fegetexceptflag,
@c feraiseexcept, fesetenv, fesetexceptflag, feupdateenv, fgetwc,
@c fgetws, fma, fmax, fputwc, fputws, fwide, fwprintf, fwscanf,
@c iswalnum, iswalpha, iswcntrl, iswctype, iswdigit, iswgraph, 
@c iswlower, iswprint, iswpunct, iswspace, iswupper, iswxdigit
@c lldiv, log2, logb, mblen, mbrlen, mbrtowc, mbsinit, mbsrtowcs,
@c mbstowcs, mbtowc, swprinft, swscanf, towctrans, towlower, towupper,
@c unwgetc, vfwprintf, vfwscanf, vswprintf, vswscanf, vwprintf,
@c vwscanf, wcrtomb, wcschr, wcscmp, wcscoll, wcscpy, wcscspn,
@c wcsftime, wcsfxtime, wcslen, wcsncat, wcsncmp, wcsncpy, wcspbrk,
@c wcsrchr, wcsrtombs, wcsspn, wcsstr, wcstod, wcstof, wcstoimax,
@c wcstok, wcstol, wcstold, wcstoll, wcstombs, wcstoul, wcstoull,
@c wcstoumax, wcsxfrm, wcstob, wctomb, wctrans, wctype, wmemchr,
@c wmemcmp, wmemcpy, wmemmove, wmemset, wprintf, wscanf
@c
@c Superfluous at least for now.
@c setbuf, setvbuf



@node abs, acos, ,C library functions

@subheading @code{abs} Function
@cindex @idxfncite{abs(3)}
@example

#include <stdlib.h>

Integer new i;

i = abs (3);

@end example

@node acos, acosh-asinh-atanh, abs, C library functions
@subheading @code{acos} Function
@cindex @idxfncite{acos(3)}

@example

#include <math.h>

Integer new i;

i = acos (0.5);

@end example

Ctalk does not check if the argument is outside the range -1 to 1 and
does not check for an error.  Refer to the, @code{acos}, manual page.

@node acosh-asinh-atanh, asctime, acos, C library functions
@subheading @code{acosh,} @code{asinh,} and @code{atanh} Functions
@cindex @idxfncite{acosh(3)}
@cindex @idxfncite{asinh(3)}
@cindex @idxfncite{atanh(3)}

@example

#include <math.h>

Float new myFloat;

myFloat = acosh (2.0);

@end example

Ctalk does not check the range of the arguments or errors.
Refer to the, @cite{acosh(3), asinh(3),} and @cite{atanh(3)}
manual pages.

@node asctime, asin, acosh-asinh-atanh, C library functions

@subheading @code{asctime} Function

@cindex @idxfncite{asctime(3)}

@example

#include <time.h>

time_t t;
struct tm *time_struct;
String new s;

time (&t);
time_struct = localtime (&t);
s = asctime (time_struct);

@end example

@emph{Note:} Ctalk does not have a class corresponding to a
@code{struct tm *.}  An explicit assignment of a @code{struct tm *} to
a @code{Symbol} passes the address to @code{asctime.} @xref{Objects in
Function Arguments}.

@node asin, atexit, asctime, C library functions

@subheading @code{asin} Function

@cindex @idxfncite{asin(3)}

@example
#include <math.h>

Float new f;

f = asin (0.5);
@end example

Note that ctalk does not perform any range checking of the argument.

@node atexit, atof, asin, C library functions
@subheading @code{atexit} Function
@cindex @idxfncite{atexit(3)}
@example 
#include <stdlib.h>

Integer new i;

i = atexit (exitfunc);

@end example

@node atof, atoi, atexit, C library functions
@subheading @code{atof} Function
@cindex @idxfncite{atof(3)}

@example
#include <stdlib.h>

Float new pi;

pi = atof ("3.1416");
@end example

@node atoi, atol, atof, C library functions

@subheading @code{atoi} Function

@cindex @idxfncite{atoi(3)}

@example
#include <stdlib.h>

Integer new i;

i = atoi ("35");
@end example

@node atol, atoll, atoi, C library functions

@subheading @code{atol} Function

@cindex @idxfncite{atol(3)}

@example
#include <stdlib.h>

Integer new i;

i = atol ("35");
@end example

Note that, @code{Integer}, class corresponds to the C types,
@code{int}, and, @code{long int}.

@node atoll, calloc, atol, C library functions

@subheading @code{atoll} Function

@cindex @idxfncite{atoll(3)}

#include <stdlib.h>

LongInteger new i;

i = atoll ("35");

@emph{Note:} The @cite{atoll(3)} function is not implemented by
the OS X or DJGPP C libraries.  Use @cite{atol(3)}, @cite{strtoll(3)}, 
or a method instead.

@node calloc, cbrt, atoll, C library functions

@subheading @code{calloc} Function

@cindex @idxfncite{calloc(3)}

@example
#include <stdlib.h>

Integer new n;
Integer new size;
int *intbuf;

n = 10;
size = sizeof (int);

intbuf = calloc (n, size);
@end example

@node cbrt, ceil, calloc, C library functions
@subheading @code{cbrt} Function
@cindex @idxfncite{cbrt(3)}

#include <math.h>

Float new f;

f = cbrt (9.0);

@node ceil, chdir, cbrt, C library functions
@subheading @code{ceil} Function
@cindex @idxfncite{ceil(3)}

#include <math.h>

Float new f;

f = ceil (3.5);

@node chdir, clock, ceil, C library functions
@subheading @code{chdir} Function
@cindex @idxfncite{chdir(3)}

Integer new result;
String new dirName;

dirName = "mySubdir";

result = chdir (mySubdir);

@node clock, copysign, chdir, C library functions
@subheading @code{clock} Function
@cindex @idxfncite{clock(3)}

@example
#include <time.h>

Integer new i;

i = clock ();
@end example

@node copysign, cos, clock, C library functions
@subheading @code{copysign} Function
@cindex @idxfncite{copysign(3)}

@example
#include <math.h>

Float new f;

f = copysign (3.0, -1.0);
@end example

@node cos, cosh, copysign, C library functions
@subheading @code{cos} Function
@cindex @idxfncite{cos(3)}

@example
#include <math.h>

Float new f;

f = cos (45.0);
@end example

@node cosh, ctime, cos, C library functions
@subheading @code{cosh} Function
@cindex @idxfncite{cosh(3)}

@example
#include <math.h>

Float new f;

f = cosh (45.0);
@end example

@node ctime, difftime, cosh, C library functions
@subheading @code{ctime} Function
@cindex @idxfncite{ctime(3)}

@example
#include <time.h>

time_t t;
String new s;

time (&t);
s = ctime (&t);
@end example

@cindex @mnm{cTime} instance method @idxclscite{CTime}
@emph{Note:} There is not a portable way to take the address
of an object with @samp{&}, although it may be possible to
perform the translation manually in some cases.  If the
argument must be an object, then use the @mnm{cTime} 
(class @code{CTime}) method instead.

@node difftime, erf, ctime, C library functions
@subheading @code{difftime} Function
@cindex @idxfncite{difftime(3)}

@example

#include <time.h>

Float new f;

f = difftime (time1, time0);

@end example

@node erf, erfc, difftime, C library functions
@subheading @code{erf} Function
@cindex @idxfncite{erf(3)}

@example

#include <math.h>

Float new f;

f = erf (0.5);

@end example

@node erfc, exp, erf, C library functions
@subheading @code{erfc} Function
@cindex @idxfncite{erfc(3)}

@example

#include <math.h>

Float new f;

f = erfc (0.5);

@end example

@node exp, expm1, erfc, C library functions
@subheading @code{exp} Function
@cindex @idxfncite{exp(3)}

@example

#include <math.h>

Float new f;

f = exp (2);

@end example

@node expm1, fabs, exp, C library functions
@subheading @code{expm1} Function
@cindex @idxfncite{expm1(3)}

@example

#include <math.h>

Float new f;

f = expm1 (1.05);

@end example

@node fabs, fclose, expm1, C library functions
@subheading @code{fabs} Function
@cindex @idxfncite{fabs(3)}

@example

#include <math.h>

Float new f;

f = fabs (-1.05);

@end example

@node fclose, fegetround, fabs, C library functions
@subheading @code{fclose} Function
@cindex @idxfncite{fclose(3)}

@example

#include <stdio.h>

Integer new i;

i = fclose (fileHandle);

@end example

@node fegetround, feholdexcept, fclose, C library functions
@subheading @code{fegetround} Function
@cindex @idxfncite{fegetround(3)}

@example

#include <fenv.h>

Integer new i;

i = fegetround ();

@end example

@node feholdexcept, feof, fegetround, C library functions
@subheading @code{feholdexcept} Function
@cindex @idxfncite{feholdexcept(3)}

@example

#include <fenv.h>

Integer new i;

i = feholdexcept (fe_envp);

@end example

@node feof, ferror, feholdexcept, C library functions
@subheading @code{feof} Function
@cindex @idxfncite{feof(3)}

@example

#include <stdio.h>

Integer new i;

i = feof (fileStream);

@end example

@node ferror, fesetround, feof, C library functions
@subheading @code{ferror} Function
@cindex @idxfncite{ferror(3)}

@example

#include <stdio.h>

Integer new i;

i = ferror (fileStream);

@end example

@node fesetround, fetestexcept, ferror, C library functions
@subheading @code{fesetround} Function
@cindex @idxfncite{fesetround(3)}

@example

#include <math.h>

Integer new i;

i = fesetround (mode);

@end example

@node fetestexcept, fflush, fesetround, C library functions
@subheading @code{fetestexcepts} Function
@cindex @idxfncite{fetestexcepts(3)}

@example

#include <math.h>

Integer new i;

i = fetestxcept (exceptions);

@end example

@node fflush, fgetc, fetestexcept, C library functions
@subheading @code{fflush} Function
@cindex @idxfncite{fflush(3)}

@example

#include <stdio.h>

Integer new i;

i = fflush (fileStream);

@end example

@node fgetc, fgetpos, fflush, C library functions
@subheading @code{fgetc} Function
@cindex @idxfncite{fgetc(3)}

@example

#include <stdio.h>

Integer new i;

i = fgetc (fileStream);

@end example

@node fgetpos, fgets, fgetc, C library functions
@subheading @code{fgetpos} Function
@cindex @idxfncite{fgetpos(3)}

@example

#include <stdio.h>

Integer new i;

i = fgetpos (fileStream, pos);

@end example

@node fgets, floor, fgetpos, C library functions
@subheading @code{fgets} Function
@cindex @idxfncite{fgets(3)}

@example

#include <stdio.h>

String new s;

s = fgets (s, s length, fileStream);

@end example

@node floor, fmod, fgets, C library functions
@subheading @code{floor} Function
@cindex @idxfncite{floor(3)}

@example

#include <math.h>

Float new f;

f = floor (3.01);

@end example

@node fmod, fopen, floor, C library functions
@subheading @code{fmod} Function
@cindex @idxfncite{fmod(3)}

@example

#include <math.h>

Float new f;

f = fmod (3.0, 2.0);

@end example

@node fopen, fprintf, fmod, C library functions
@subheading @code{fopen} Function
@cindex @idxfncite{fopen(3)}

@example

#include <stdio.h>

FILE *f

String new path;
String new mode;

path = "/home/user/.profile";
mode = "r";

f = fopen (path, mode);

@end example

@node fprintf, fputc, fopen, C library functions
@subheading @code{fprintf} Function
@cindex @idxfncite{fprintf(3)}

@xref{Variable arguments}.

@node fputc, fputs, fprintf, C library functions
@subheading @code{fputc} Function
@cindex @idxfncite{fputc(3)}

@example

#include <stdio.h>

Integer new myInput;

myInput = fgetc (stdin);
fputc (myInput, stdout);

@end example

@node fputs, fread, fputc, C library functions
@subheading @code{fputc} Function
@cindex @idxfncite{fputc(3)}

@example
#include <stdio.h>

String new myInput;

fgets (myInput, 255, stdin);
fputs (myInput, stdout);
@end example

@node fread, free, fputs, C library functions
@subheading @code{fread} Function
@cindex @idxfncite{fread(3)}

@example
#include <stdio.h>

String new myInput;

myInput = "";

fread (myInput, 255, sizeof (char), stdin);
@end example

@node free, freopen, fread, C library functions
@subheading @code{free} Function
@cindex @idxfncite{free(3)}

Do not use @code{free} with objects.  Use the
@code{__ctalkDeleteObject} library function instead.

@cindex __objRefCntZero function
@cindex __ctalkDeleteObject function
Also, calling @cite{__objRefCntZero} before @cite{__ctalkDeleteObject}
insures that the object will be completely deleted.  You can do this
in two ways: first, by sending the object a @mnm{delete} message; or
by casting the object to a C @code{OBJECT *} and then giving the
@code{OBJECT *} as an argument to @cite{__objRefCntZero} and
@cite{__ctalkDeleteObject}.

@example
Object new myObject;
OBJECT *myObject_alias;

myObject_aliast = myObject;

__objRefCntZero (OBJREF (myObject_alias));
__ctalkDeleteObject (myObject_alias);
@end example

@node freopen, frexp, free, C library functions
@subheading @code{freopen} Function
@cindex @idxfncite{freopen(3)}

@example
#include <stdio.h>

FILE *f;

String new path;
String new mode;

path = "/home/user/.profile";
mode = "r";

f2 = freopen (path, mode, stdin);
@end example

@node frexp, fscanf, freopen, C library functions
@subheading @code{frexp} Function
@cindex @idxfncite{frexp(3)}

@example
#include <math.h>

int i_exp_val;
Integer new expInt;
Float new myFloat;
Float new myFraction;

myFloat = "2.5";

myFraction = frexp (myFloat, &i_exp_val);

expInt = i_exp_val;
@end example

@node fscanf, fseek, frexp, C library functions
@subheading @code{fscanf} Function
@cindex @idxfncite{fscanf(3)}

@xref{Variable arguments}.

@cindex @code{stdin}
@cindex @code{stdout}
@cindex @code{stderr}
@cindex @code{stdinStream} @idxclscite{ReadFileStream}
@cindex @code{stdoutStream} @idxclscite{WriteFileStream}
@cindex @code{stderrStream} @idxclscite{WriteFileStream}
@emph{Note:} The C99 standard requires that @code{stdin,}
@code{stdout,} and @code{stderr} should be implemented as
macros, which on some systems (notably Solaris) causes
problems with C-to-object translation.  If Ctalk cannot
register these macros as C variables, then either call
@idxfncite{fscanf(3)} with only C variables, or use a method
with @code{stdoutStream} or @code{stderrStream}
@xref{WriteFileStream}, or @code{stdinStream} @xref{ReadFileStream}.

@node fseek, fsetpos, fscanf, C library functions
@subheading @code{fseek} Function
@cindex @idxfncite{fseek(3)}

@node fsetpos, fstat, fseek, C library functions
@subheading @code{fsetpos} Function
@cindex @idxfncite{fsetpos(3)}

@example
#include <stdio.h>

FILE *f;
String new path;
String new mode;
Integer new offset;
  
path = "/home/user/.profile.new";
mode = "r";


f = fopen (path, mode);

offset = 0L;

fsetpos (f, offset);
@end example

@node fstat, ftell, fsetpos, C library functions
@subheading @code{fstat} Function
@cindex @idxfncite{fstat(3)}

@example
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

String new path;
Integer new result;
struct stat statbuf;

path = "/home/user/.profile";

result = fstat (path, &statbuf);

@end example

@node ftell, fwrite, fstat, C library functions
@subheading @code{ftell} Function
@cindex @idxfncite{ftell(3)}

@example
#include <stdio.h>

Integer new filePos;

filePos = ftell (file);
@end example

@node fwrite, getc, ftell, C library functions
@subheading @code{fwrite} Function
@cindex @idxfncite{fwrite(3)}

@example
#include <stdio.h>

FILE *f;
String new path;
String new mode;
String new promptLine;
  
path = "/home/user/.profile.new";
mode = "a";

f = fopen (path, mode);

promptLine = "PS1=#";

fwrite (promptLine, promptLine length, sizeof (char), f);
@end example

@node getc, getchar, fwrite, C library functions
@subheading @code{getc} Function
@cindex @idxfncite{getc(3)}

@example
#include <stdio.h>

Integer new myInput;

myInput = getc (stdin);

printf ("%c", myInput asCharacter);
@end example

@node getchar, getcwd, getc, C library functions
@subheading @code{getchar} Function
@cindex @idxfncite{getchar(3)}

@example
#include <stdio.h>

Integer new myInput;

myInput = getchar ();

printf ("%c", myInput asCharacter);
@end example

@node getcwd, getenv, getchar, C library functions
@subheading @code{getcwd} Function
@cindex @idxfncite{getcwd(3)}
@example
#include <stdio.h>
String new myString;
getcwd (myString, FILENAME_MAX);
@end example
@emph{Note:} The argument @code{myString} must already be initialized
to hold the entire directory path.  If in doubt, use @code{getCwd}
(class @code{DirectoryStream}) instead. @xref{DirectoryStream}.

@node getenv, getpid, getcwd, C library functions
@subheading @code{getenv} Function
@cindex @idxfncite{getenv(3)}

@example
String new envPath;

envPath = getenv ("PATH");

printf ("%s", envPath);
@end example

@node getpid, gmtime-localtime, getenv, C library functions
@subheading @code{getpid} Function
@cindex @idxfncite{getpid(3)} C Function

@node gmtime-localtime, index-function, getpid, C library functions
@subheading @code{gmtime,} @code{localtime} Functions
@cindex @idxfncite{gmtime(3)} C Function
@cindex @idxfncite{localtime(3)} C Function

@node index-function, isalnum-isxdigit, gmtime-localtime, C library functions
@subheading @code{index} Function
@cindex @idxfncite{index(3)}

@xref{strchr}.

@node isalnum-isxdigit, labs, index-function, C library functions
@subheading @code{isalnum,} @code{isalpha,} @code{isascii,} @code{isblank,} @code{iscntrl,} @code{isdigit,} @code{isgraph,} @code{islower,} @code{isprint,} @code{ispunct,} @code{isspace,} @code{isupper,} @code{isxdigit} Functions
@cindex @idxfncite{isalnum(3)}
@cindex @idxfncite{isalpha(3)}
@cindex @idxfncite{isascii(3)}
@cindex @idxfncite{isblank(3)}
@cindex @idxfncite{iscntrl(3)}
@cindex @idxfncite{isdigit(3)}
@cindex @idxfncite{isgraph(3)}
@cindex @idxfncite{islower(3)}
@cindex @idxfncite{isprint(3)}
@cindex @idxfncite{ispunct(3)}
@cindex @idxfncite{isspace(3)}
@cindex @idxfncite{isupper(3)}
@cindex @idxfncite{isxdigit(3)}
@cindex @mnm{isAlNum} method @idxclscite{Character}
@cindex @mnm{isAlpha} method @idxclscite{Character}
@cindex @mnm{isASCII} method @idxclscite{Character}
@cindex @mnm{isBlank} method @idxclscite{Character}
@cindex @mnm{isCntrl} method @idxclscite{Character}
@cindex @mnm{isDigit} method @idxclscite{Character}
@cindex @mnm{isGraph} method @idxclscite{Character}
@cindex @mnm{isLower} method @idxclscite{Character}
@cindex @mnm{isPrint} method @idxclscite{Character}
@cindex @mnm{isPunct} method @idxclscite{Character}
@cindex @mnm{isSpace} method @idxclscite{Character}
@cindex @mnm{isUpper} method @idxclscite{Character}
@cindex @mnm{isXDigit} method @idxclscite{Character}

Ctalk does not support @flnm{ctype.h} macros portably.  Use the
corresponding method of class @code{Character} instead. 
@xref{Character}.

@example
Ctype.h Macro          Ctalk Method
-------------          ------------
isalnum                isAlNum
isalpha                isAlpha
isascii                isASCII
isblank                isBlank
iscntrl                isCntrl
isdigit                isDigit
isgraph                isGraph
islower                isLower
isprint                isPrint
ispunct                isPunct
isspace                isSpace
isupper                isUpper
isxdigit               isXDigit
@end example

@node labs, llabs, isalnum-isxdigit, C library functions
@subheading @code{labs} Function
@cindex @idxfncite{labs(3)}

@example
#include <stdlib.h>

Integer new myValue;
Integer new myAbsValue;

myAbsValue = labs (myValue);
@end example

@node llabs, llrint, labs, C library functions
@subheading @code{llabs} Function
@cindex @idxfncite{llabs(3)}

@example
#include <stdlib.h>

LongInteger new myValue;
LongInteger new myAbsValue;

myAbsValue = llabs (myValue);
@end example

@node llrint, llround, llabs, C library functions
@subheading @code{lrint}, @code{lrintf}, @code{lrintl}, @code{llrint}, @code{llrintf}, @code{llrintl} Functions
@cindex @idxfncite{lrint(3)}
@cindex @idxfncite{lrintf(3)}
@cindex @idxfncite{lrintl(3)}
@cindex @idxfncite{llrint(3)}
@cindex @idxfncite{llrintf(3)}
@cindex @idxfncite{llrintl(3)}

@example
#include <math.h>

Float new myFloat;
LongInteger new myLongInt;

myFloat = 2.5;

myLongInt = llrint (myFloat);
@end example

Consult the manual page for @cite{lrint(3)}, etc., for detailed
information about each function.

@node llround, log, llrint, C library functions
@subheading @code{llround} Function
@cindex @idxfncite{llround(3)}

@example
#include <math.h>

Float new myFloat;
LongInteger new myLongInt;

myFloat = 2.5;

myLongInt = llround (myFloat);
@end example

@node log, log10, llround, C library functions
@subheading @code{log} Function
@cindex @idxfncite{log(3)}

@example
#include <math.h>

Float new myFloat;
Float new myLog;

myFloat = 2.5;

myLog = log (myFloat);
@end example

@node log10, log1p, log, C library functions
@subheading @code{log10} Function
@cindex @idxfncite{log10(3)}

@example
#include <math.h>

Float new myFloat;
Float new myLog;

myFloat = 2.5;

myLog = log10 (myFloat);
@end example

@node log1p, lrint, log10, C library functions
@subheading @code{log1p} Function
@cindex @idxfncite{log1p(3)}

@example
#include <math.h>

Float new myFloat;
Float new myLog;

myFloat = 2.5;

myLog = log1p (myFloat);
@end example

@node lrint, lround, log1p, C library functions
@subheading @code{lrint} Function
@cindex @idxfncite{lrint(3)}

@example
#include <math.h>

Float new myFloat;
Integer new myInt;

myFloat = 2.5;

myLog = lrint (myFloat);
@end example

@node lround, malloc, lrint, C library functions
@subheading @code{lround} Function
@cindex @idxfncite{lround(3)}

@example
#include <math.h>

Float new myFloat;
Integer new myInt;

myFloat = 2.5;

myLog = lround (myFloat);
@end example

@node malloc, memchr, lround, C library functions
@subheading @code{malloc} Function
@cindex @idxfncite{malloc(3)}

@example
#include <stdlib.h>

Integer new size;
int *intbuf

size = sizeof (int) * 10;

memblk = (int *)malloc (size);
@end example

@node memchr, memcmp, malloc, C library functions
@subheading @code{memchr} Function
@cindex @idxfncite{memchr(3)}

@example
#include <string.h>

#define BUFLENGTH 1024

Integer new searchChar;
Integer new length;
char buf[BUFLENGTH], *charptr;

length = BUFLENGTH

strcpy (buf, "Some text.");

searchChar = '.';

charptr = (char *)memchr ((void *)buf, searchChar, length);

@end example

@node memcmp, memcpy, memchr, C library functions
@subheading @code{memcmp} Function
@cindex @idxfncite{memcmp(3)}

@example
#include <string.h>

#define BUFLENGTH 1024

Integer new length;
Integer new result;
char buf1[BUFLENGTH], buf2[BUFLENGTH];

length = BUFLENGTH

strcpy (buf1, "Some text.");
strcpy (buf2, "Some other text.");

result = memcmp ((void *)buf1, (void *)buf2, length);

@end example

@node memcpy, memmove, memcmp, C library functions
@subheading @code{memcpy} Function
@cindex @idxfncite{memcpy(3)}

@example
#include <string.h>

#define BUFLENGTH 1024

Integer new length;
Integer new result;
char buf1[BUFLENGTH], buf2[BUFLENGTH], *charptr;

length = BUFLENGTH

strcpy (buf1, "Some text.");

result = (char *)memcpy ((void *)buf1, (void *)buf2, length);

@end example

@node memmove, memset, memcpy, C library functions
@subheading @code{memmove} Function
@cindex @idxfncite{memmove(3)}

@example
#include <string.h>

#define BUFLENGTH 1024

Integer new length;
Integer new result;
char buf1[BUFLENGTH], buf2[BUFLENGTH], *charptr;

length = BUFLENGTH

strcpy (buf1, "Some text.");

charptr = (char *)memmove ((void *)buf1, (void *)buf2, length);

@end example

@node memset, mkdir, memmove, C library functions
@subheading @code{memset} Function
@cindex @idxfncite{memset(3)}

@example
#include <string.h>

#define BUFLENGTH 1024

Integer new length;
Integer new fillChar;
char buf[BUFLENGTH], *charptr;

length = BUFLENGTH
fillChar = 0;

charptr = (char *)memset ((void *)buf1, fillChar, length);

@end example

@node mkdir, modf, memset, C library functions
@subheading @code{mkdir} Function
@cindex @idxfncite{mkdir(3)}
@example
Integer new r;
String new myDirName;

myDirName = "myDir";

r = mkdir (myDirName);
@end example

@node modf, nearbyint, mkdir, C library functions
@subheading @code{modf} Function
@cindex @idxfncite{modf(3)}

@example
#include <math.h>

double dptr;
Float new x;
Float new frac;

x = 2.54;

frac = modf (x, &dptr);
@end example

@node nearbyint, perror, modf, C library functions
@subheading @code{nearbyint} Function
@cindex @idxfncite{nearbyint(3)}

@example
#include <math.h>

Float new x;
Float new result;

x = 2.53;

result = nearbyint (x);
@end example

@node perror, pow, nearbyint, C library functions
@subheading @code{perror} Function
@cindex @idxfncite{perror(3)}

@example
#include <stdio.h>

String new message;

message = "Program error";

perror (message);
@end example

@node pow, printf, perror, C library functions
@subheading @code{pow} Function
@cindex @idxfncite{pow(3)}

@example
#include <math.h>

Float new x;
Float new exp;
Float new result;

x = 2.5;
exp = 2;

result = pow (x, exp);
@end example

@node printf, raise, pow, C library functions
@subheading @code{printf} Function
@cindex @idxfncite{printf(3)}

@example
#include <stdio.h>

String new message;
String new fmt;

printf (fmt, message);
@end example

@node raise, rand, printf, C library functions
@subheading @code{raise} Function
@cindex @idxfncite{raise(3)}

@example
#include <signal.h>

Integer new signal;
Integer new result;

signal = SIGTERM;

result = raise (signal);
@end example

@node rand, realloc, raise, C library functions
@subheading @code{rand} Function
@cindex @idxfncite{rand(3)}

@example
#include <stdlib.h>

Integer new random;

random = rand ();
@end example

@node realloc, remove, rand, C library functions
@subheading @code{realloc} Function
@cindex @idxfncite{realloc(3)}

@example
#include <stdlib.h>

int *intptr;
Integer new size;

size = sizeof (int *);

intptr = (int *)realloc (NULL, size);

@end example

@node remove, rename, realloc, C library functions
@subheading @code{remove} Function
@cindex @idxfncite{remove(3)}

@example
#include <stdio.h>

String new path;
Integer new result;

path = ``/home/user'';

result = remove (path);

@end example

@node rename, rindex, remove, C library functions
@subheading @code{rename} Function
@cindex @idxfncite{rename(3)}

@example
#include <stdio.h>

String new oldPath;
String new newPath;
Integer new result;

oldPath = "/home/user";
newPath = "/home/joe";

result = rename (oldPath, newPath);

@end example

@node rindex, rint, rename, C library functions
@subheading @code{rindex} Function
@cindex @idxfncite{rindex(3)}

@xref{strrchr}.

@node rint, rmdir, rindex, C library functions
@subheading @code{rint} Function
@cindex @idxfncite{rint(3)}

@example
#include <math.h>

Float new myFloat;
Float new myIntValue;

myFloat = 2.54;

myIntValue = rint (myFloat);

@end example

@node rmdir, round, rint, C library functions
@subheading @code{rmdir} Function
@cindex @idxfncite{rmdir(3)}
@example
r = rmdir (dirToRemove);
@end example

@node round, scanf, rmdir, C library functions
@subheading @code{round} Function
@cindex @idxfncite{round(3)}

@example
#include <math.h>

Float new myFloat;
Float new myIntValue;

myFloat = 2.54;

myIntValue = round (myFloat);

@end example

@node scanf, sin, round, C library functions
@subheading @code{scanf} Function
@cindex @idxfncite{scanf(3)}

@xref{Variable arguments}.

@node sin, sinh, scanf, C library functions
@subheading @code{sin} Function
@cindex @idxfncite{sin(3)}

@example
#include <math.h>

Float new x;
Float new sinX;

x = 2.5;

sinX = sin (x);
@end example

@node sinh, snprintf, sin, C library functions
@subheading @code{sinh} Function
@cindex @idxfncite{sinh(3)}

@example
#include <math.h>

Float new x;
Float new sinX;

x = 2.5;

sinX = sinh (x);
@end example

@node snprintf, sprintf, sinh, C library functions
@subheading @code{snprintf} Function
@cindex @idxfncite{snprintf(3)}

@xref{Variable arguments}.

@node sprintf, sqrt, snprintf, C library functions
@subheading @code{sprintf} Function
@cindex @idxfncite{sprintf(3)}

@xref{Variable arguments}.

@node sqrt, srand, sprintf, C library functions
@subheading @code{sqrt} Function
@cindex @idxfncite{sqrt(3)}

@example
#include <math.h>

Array instanceMethod printSquareRoot (void) @{

  Float new squareRoot;
  WriteFileStream classInit;

  /*
   *  Use Ctalk C API library function calls within a C function.
   */
  squareRoot = sqrt(__ctalk_to_c_double(__ctalk_self_internal ()));
  stdoutStream writeStream squareRoot;

  return NULL;
@}

int main () @{

  Array new floatArray;

  floatArray atPut 0, 1.0;
  floatArray atPut 1, 4.0;
  floatArray atPut 2, 9.0;
  floatArray atPut 3, 16.0;
  floatArray atPut 4, 25.0;

  floatArray map printSquareRoot;
  
@}
@end example

@node srand, sscanf, sqrt, C library functions
@subheading @code{srand} Function
@cindex @idxfncite{srand(3)}

@example
#include <stdlib.h>

Integer new seed;

seed = 2;

srand (seed);

@end example

@node sscanf, strcat-strcpy, srand, C library functions
@subheading @code{sscanf} Function
@cindex @idxfncite{sscanf(3)}

@xref{Variable arguments}.

@cindex @code{stdin}
@cindex @code{stdout}
@cindex @code{stderr}
@cindex @code{stdinStream} @idxclscite{ReadFileStream}
@cindex @code{stdoutStream} @idxclscite{WriteFileStream}
@cindex @code{stderrStream} @idxclscite{WriteFileStream}
@emph{Note:} The C99 standard requires that @code{stdin,}
@code{stdout,} and @code{stderr} should be implemented as
macros, which on some systems (notably Solaris) causes
problems with C-to-object translation.  If Ctalk cannot
register these macros as C variables, then either call
@idxfncite{sscanf(3)} with only C variables, or use a method
with @code{stdoutStream} or @code{stderrStream}
@xref{WriteFileStream}, or @code{stdinStream} @xref{ReadFileStream}.

@node strcat-strcpy, strchr, sscanf, C library functions
@subheading @code{strcat,} @code{strcasecmp}, @code{strcmp,} and @code{strcpy} Functions
@cindex @idxfncite{strcat(3)}
@cindex @mnm{cStrcat} method @idxclscite{CFunction}
@cindex @idxfncite{strcasecmp(3)}
@cindex @mnm{cStrcmp} method @idxclscite{CFunction}
@cindex @idxfncite{strcmp(3)}
@cindex @mnm{cStrcmp} method @idxclscite{CFunction}
@cindex @idxfncite{strcpy(3)}
@cindex @mnm{cStrcpy} method @idxclscite{CFunction}

The @cite{strcat(3),} @cite{strcasecmp(3),} @cite{strcmp(3),} and
@cite{strcpy(3)} functions work in most statements.  When necessary,
Ctalk uses @mnm{cStrcat}, @mnm{cStrcasecmp}, @mnm{cStrcmp}, and
@mnm{cStrcpy} (class @code{CFunction}). @xref{CFunction}.

@node strchr, strcoll, strcat-strcpy, C library functions
@subheading @code{strchr} Function
@cindex @idxfncite{strchr(3)}

@example
#include <string.h>

int main () @{

  String new s;
  String new result;

  s = "s1";

  if ((result = strchr (s, '1')) == "1") @{
    printf ("Pass\n");
  @} else @{
    printf ("Fail\n");
  @}

  exit(0);
@}
@end example

@node strcoll, strspn, strchr, C library functions
@subheading @code{strcoll} Function
@cindex @idxfncite{strcoll(3)}

@example
#include <string.h>

String new s1;
String new s2;
Integer new result;

result = strcoll (s1, s2);
@end example

@node strspn, strerror, strcoll, C library functions
@subheading @code{strspn} Function
@cindex @idxfncite{strspn(3)}


@node strerror, strftime, strspn, C library functions
@subheading @code{strerror} Function
@cindex @idxfncite{strerror(3)}


@node strftime, strlen, strerror, C library functions
@subheading @code{strftime} Function
@cindex @idxfncite{strftime(3)}


@node strlen, strncat-strncpy, strftime, C library functions
@subheading @code{strlen} Function
@cindex @idxfncite{strlen(3)}


@node strncat-strncpy, strpbrk, strlen, C library functions
@subheading @code{strncat,} @code{strncmp,} and @code{strncpy} Functions
@cindex @idxfncite{strncat(3)}
@cindex @mnm{cStrncat} method @idxclscite{CFunction}
@cindex @idxfncite{strncasecmp(3)}
@cindex @mnm{cStrncasecmp} method @idxclscite{CFunction}
@cindex @idxfncite{strncmp(3)}
@cindex @mnm{cStrncmp} method @idxclscite{CFunction}
@cindex @idxfncite{strncpy(3)}
@cindex @mnm{cStrncpy} method @idxclscite{CFunction}

The @cite{strncat(3),} @cite{strncasecmp(3),} @cite{strncmp(3),} and
@cite{strncpy(3)} functions work in most statements.  When necessary,
Ctalk uses @mnm{cStrncat,} @mnm{cStrncasecmp,} @mnm{cStrncmp,} and
@mnm{cStrncpy} (class @code{CFunction}). @xref{CFunction}.

@node strpbrk, strrchr, strncat-strncpy, C library functions
@subheading @code{strpbrk} Function
@cindex @idxfncite{strpbrk(3)}

@node strrchr, strstr, strpbrk, C library functions
@subheading @code{strrchr} Function
@cindex @idxfncite{strrchr(3)}

@example
#include <string.h>

String new s1;
Character new searchChar;
String new charptr;

searchChar = '/';
s1 = "/home/user";

charptr = strrchr (s1, searchChar);
@end example


@node strstr, strtod, strrchr, C library functions
@subheading @code{strstr} Function
@cindex @idxfncite{strstr(3)}

@node strtod, strtok, strstr, C library functions
@subheading @code{strtod} Function
@cindex @idxfncite{strtod(3)}


@node strtok, strtoll, strtod, C library functions
@subheading @code{strtok} Function
@cindex @idxfncite{strtok(3)}


@node strtoll, strxfrm, strtok, C library functions
@subheading @code{strtoll} Function
@cindex @idxfncite{strtoll(3)}


@node strxfrm, system, strtoll, C library functions
@subheading @code{strxfrm} Function
@cindex @idxfncite{strxfrm(3)}


@node system, tan, strxfrm, C library functions
@subheading @code{system} Function
@cindex @idxfncite{system(3)}

@example
#include <stdlib.h>

String new commandLine;

commandLine = "ls -lR";

system (commandLine);
@end example


@node tan, tanh, system, C library functions
@subheading @code{tan} Function
@cindex @idxfncite{tan(3)}


@node tanh, tmpnam, tan, C library functions
@subheading @code{tanh} Function
@cindex @idxfncite{tanh(3)}


@node tmpnam, tolower, tanh, C library functions
@subheading @code{tmpnam} Function
@cindex @idxfncite{tmpnam(3)}

@node tolower, toupper, tmpnam, C library functions
@subheading @code{tolower} Function
@cindex @idxfncite{tolower(3)}

The @code{tolower} function may be implemented in a non-portable
manner.  Use the @code{toLower} method instead. 
@c @xref{Character}.


@node toupper, trunc, tolower, C library functions
@subheading @code{toupper} Function
@cindex @idxfncite{toupper(3)}

The @code{toupper} function may be implemented in a non-portable
manner.  Use the @code{toUpper} method instead. 
@c @xref{Character}.


@node trunc, ungetc, toupper, C library functions
@subheading @code{trunc} Function
@cindex @idxfncite{trunc(3)}


@node ungetc, vfprintf, trunc, C library functions
@subheading @code{ungetc} Function
@cindex @idxfncite{ungetc(3)}


@node vfprintf, vfscanf, ungetc, C library functions
@subheading @code{vfprintf} Function
@cindex @idxfncite{vfprintf(3)}
@cindex @idxfncite{printf(3)}

This version of Ctalk does not support the @code{va_list} data type.
You should use @cite{printf(3)} or @code{writeStream} (class
@code{WriteFileStream}) instead.

@node vfscanf, vprintf, vfprintf, C library functions
@subheading @code{vfscanf} Function
@cindex @idxfncite{vfscanf(3)}
@cindex @idxfncite{scanf(3)}

This version of Ctalk does not support the @code{va_list} data type.
You should use @cite{scanf(3)} instead. @xref{Variable arguments}.

@node vprintf, vscanf, vfscanf, C library functions
@subheading @code{vprintf} Function
@cindex @idxfncite{vprintf(3)}

This version of Ctalk does not support the @code{va_list} data type.
You should use @cite{printf(3)} or @code{writeStream} (class
@code{WriteFileStream}) instead.

@node vscanf, vsnprintf, vprintf, C library functions
@subheading @code{vscanf} Function
@cindex @idxfncite{vscanf(3)}
@cindex @idxfncite{scanf(3)}

This version of Ctalk does not support the @code{va_list} data type.
You should use @cite{scanf(3)} instead. @xref{Variable arguments}.

@node vsnprintf, vsprintf, vscanf, C library functions
@subheading @code{vsnprintf} Function
@cindex @idxfncite{vsnprintf(3)}
@cindex @idxfncite{sprintf(3)}

This version of Ctalk does not support the @code{va_list} data type.
You should use @cite{sprintf(3)} instead. @xref{Variable arguments}.

@node vsprintf, vsscanf, vsnprintf, C library functions
@subheading @code{vsprintf} Function
@cindex @idxfncite{vsprintf(3)}
@cindex @idxfncite{sprintf(3)}

This version of Ctalk does not support the @code{va_list} data type.
You should use @cite{sprintf(3)} instead. @xref{Variable arguments}.

@node vsscanf, , vsprintf, C library functions
@subheading @code{vsscanf} Function
@cindex @idxfncite{vsscanf(3)}
@cindex @idxfncite{scanf(3)}

This version of Ctalk does not support the @code{va_list} data type.
You should use @cite{sprintf(3)} instead. @xref{Variable arguments}.

@node GNU tools, , C library functions, C
@iftex
@section Using GNU Tools with Ctalk
@end iftex
@ifnottex
@subheading Using GNU Tools with Ctalk
@end ifnottex
@cindex GNU automake
@cindex GNU autoconf
@cindex automake
@cindex autoconf
@cindex Emacs, GNU
@cindex GNU Emacs

If you want to build Ctalk programs using the GNU configuration tools; i.e, 
the @samp{./configure,} @samp{make,} @samp{make install} sequence of commands,
you need to tell the build tools about Ctalk.

Doing this mostly involves telling the utility @command{automake,}
which helps write @flnm{Makefiles} for the @command{make} program, how
to build a Ctalk source file into an executable.

The @command{make} program allows Makefiles to define rules to build
different types of input files into programs, libraries, and other
types of data files.

In order to distinguish a Ctalk file, we give it the file extension
@samp{.ca}.  This lets the build tools know that the Ctalk program
isn't a standard C input file.

Then, in @flnm{Makefile.am} (consult the @command{automake} manual if
you're not certain what this is), you can define a rule to build a @samp{.ca} 
file into an @samp{.o} object file.

@example

SUFFIXES=.ca .o

.ca.o:
	$(top_builddir)/src/ctalk -I $(top_builddir)/classes $< \
	  -o `basename $@ .o`.i ; \
	$(CC) -c $(AM_CFLAGS) $(AM_CPPFLAGS) $(DEFS) -o $@ `basename $< .ca`.i

@end example

Then, add another line to link the object file into a program.

@example

methods$(EXEEXT) : methods.o
	$(CC) methods.o $(AM_LDFLAGS) $(LDFLAGS) $(LIBS) -o methods$(EXEEXT)

@end example

Note that this example comes from the @command{methods} program in the
Ctalk distribution, where, ``methods,'' is the canonical name of the
output file, as defined in the @samp{bin_PROGRAMS} macro.  That allows
@command{make} to install the program normally when you type,
@samp{make install.}

If you're using Ctalk for another package, you'll almost certainly
want to change the paths to something that uses an already-installed
Ctalk.  In that case, @flnm{Makefile.am} might contain lines like
these.

@example

SUFFIXES=.ca .o

.ca.o:
	/usr/local/bin/ctalk -I /usr/local/include/classes $< \
	  -o `basename $@ .o`.i ; \
	$(CC) -c $(AM_CFLAGS) $(AM_CPPFLAGS) $(DEFS) -o $@ `basename $< .ca`.i

@end example

@subsubheading Cleaning Up Extra Files

Note that the @command{basename} command in these examples handles the
translation of the @command{make} targets into an intermediate Ctalk
file.  

This way @command{make} doesn't need to worry about any intermediate
files, except that the @flnm{Makefile} should clean them up. 

So to define rules to clean up the extra files after the build,
include @command{make} targets like these in @flnm{Makefile.am.}

@example

clean-local:
	rm -f *.i

distclean-local:
	rm -f *.i


@end example

@subsubheading Running Ctalk Utilities in an Emacs Window

The @code{doc/} subdirectory of the Ctalk source code distribution
contains the Emacs Lisp programs @code{classes.el},
@code{methods-brief.el}, and @code{methods-full.el}.  They define
simple Emacs Lisp functions that let you capture the output of the
Ctalk utilities in an Emacs window.

The documentation file, @code{ctalktools.info} contains descriptions
of these functions, and the files also contain instructions to install
and use them.

@node Copying, GNU Free Documentation License, C, Top
@iftex
@chapter Copying
@end iftex
@ifnottex
@heading Copying and Distributing Ctalk
@end ifnottex
@cindex Copying
@cindex GNU General Public License
@cindex GNU Lesser General Public License

Ctalk is free software.  You can copy, distribute, and modify Ctalk
under the terms of the GNU General Public License, Version 3 (see,
@flnm{COPYING}, in the Ctalk distribution).  You can also distribute
executable programs which link to the @command{ctalk} run time
libraries under the terms of the GNU Lesser General Public License,
Version 3 (@flnm{COPYING.LIB} in the Ctalk distribution).

@node GNU Free Documentation License, Index, Copying, Top
@iftex
@chapter GNU Free Documentation License
@end iftex
@ifnottex
@heading GNU Free Documentation License
@end ifnottex
@cindex GNU Free Documentation License
@example

                        Version 1.1, March 2000
     Copyright (C) 2000  Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
     
     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.



  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     written document "free" in the sense of freedom: to assure everyone
     the effective freedom to copy and redistribute it, with or without
     modifying it, either commercially or noncommercially.  Secondarily,
     this License preserves for the author and publisher a way to get
     credit for their work, while not being considered responsible for
     modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.
     We recommend this License principally for works whose purpose is
     instruction or reference.


  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work that contains a
     notice placed by the copyright holder saying it can be distributed
     under the terms of this License.  The "Document", below, refers to
     any such manual or work.  Any member of the public is a licensee,
     and is addressed as "you."

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter
     section of the Document that deals exclusively with the
     relationship of the publishers or authors of the Document to the
     Document's overall subject (or to related matters) and contains
     nothing that could fall directly within that overall subject.
     (For example, if the Document is in part a textbook of
     mathematics, a Secondary Section may not explain any mathematics.)
     The relationship could be a matter of historical connection with
     the subject or with related matters, or of legal, commercial,
     philosophical, ethical or political position regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in
     the notice that says that the Document is released under this
     License.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, whose contents can be viewed and edited directly
     and straightforwardly with generic text editors or (for images
     composed of pixels) generic paint programs or (for drawings) some
     widely available drawing editor, and that is suitable for input to
     text formatters or for automatic translation to a variety of
     formats suitable for input to text formatters.  A copy made in an
     otherwise Transparent file format whose markup has been designed
     to thwart or discourage subsequent modification by readers is not
     Transparent.  A copy that is not "Transparent" is called "Opaque."

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and
     standard-conforming simple HTML designed for human modification.
     Opaque formats include PostScript, PDF, proprietary formats that
     can be read and edited only by proprietary word processors, SGML
     or XML for which the DTD and/or processing tools are not generally
     available, and the machine-generated HTML produced by some word
     processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.


  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow
     the conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.


  3. COPYING IN QUANTITY

     If you publish printed copies of the Document numbering more than
     100, and the Document's license notice requires Cover Texts, you
     must enclose the copies in covers that carry, clearly and legibly,
     all these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the
     title equally prominent and visible.  You may add other material
     on the covers in addition.  Copying with changes limited to the
     covers, as long as they preserve the title of the Document and
     satisfy these conditions, can be treated as verbatim copying in
     other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a
     machine-readable Transparent copy along with each Opaque copy, or
     state in or with each Opaque copy a publicly-accessible
     computer-network location containing a complete Transparent copy
     of the Document, free of added material, which the general
     network-using public has access to download anonymously at no
     charge using public-standard network protocols.  If you use the
     latter option, you must take reasonably prudent steps, when you
     begin distribution of Opaque copies in quantity, to ensure that
     this Transparent copy will remain thus accessible at the stated
     location until at least one year after the last time you
     distribute an Opaque copy (directly or through your agents or
     retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of
     copies, to give them a chance to provide you with an updated
     version of the Document.


  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with
     the Modified Version filling the role of the Document, thus
     licensing distribution and modification of the Modified Version to
     whoever possesses a copy of it.  In addition, you must do these
     things in the Modified Version:

     A. Use in the Title Page (and on the covers, if any) a title
     distinct    from that of the Document, and from those of previous
     versions    (which should, if there were any, be listed in the
     History section    of the Document).  You may use the same title
     as a previous version    if the original publisher of that version
     gives permission.
     B. List on the Title Page, as authors, one or more persons or
     entities    responsible for authorship of the modifications in the
     Modified    Version, together with at least five of the principal
     authors of the    Document (all of its principal authors, if it
     has less than five).
     C. State on the Title page the name of the publisher of the
     Modified Version, as the publisher.
     D. Preserve all the copyright notices of the Document.
     E. Add an appropriate copyright notice for your modifications
     adjacent to the other copyright notices.
     F. Include, immediately after the copyright notices, a license
     notice    giving the public permission to use the Modified Version
     under the    terms of this License, in the form shown in the
     Addendum below.
     G. Preserve in that license notice the full lists of Invariant
     Sections    and required Cover Texts given in the Document's
     license notice.
     H. Include an unaltered copy of this License.
     I. Preserve the section entitled "History", and its title, and add
     to    it an item stating at least the title, year, new authors, and
       publisher of the Modified Version as given on the Title Page.
     If    there is no section entitled "History" in the Document,
     create one    stating the title, year, authors, and publisher of
     the Document as    given on its Title Page, then add an item
     describing the Modified    Version as stated in the previous
     sentence.
     J. Preserve the network location, if any, given in the Document for
       public access to a Transparent copy of the Document, and
     likewise    the network locations given in the Document for
     previous versions    it was based on.  These may be placed in the
     "History" section.     You may omit a network location for a work
     that was published at    least four years before the Document
     itself, or if the original    publisher of the version it refers
     to gives permission.
     K. In any section entitled "Acknowledgements" or "Dedications",
     preserve the section's title, and preserve in the section all the
      substance and tone of each of the contributor acknowledgements
     and/or dedications given therein.
     L. Preserve all the Invariant Sections of the Document,
     unaltered in their text and in their titles.  Section numbers
     or the equivalent are not considered part of the section titles.
     M. Delete any section entitled "Endorsements."  Such a section
     may not be included in the Modified Version.
     N. Do not retitle any existing section as "Endorsements"    or to
     conflict in title with any Invariant Section.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option
     designate some or all of these sections as invariant.  To do this,
     add their titles to the list of Invariant Sections in the Modified
     Version's license notice.  These titles must be distinct from any
     other section titles.

     You may add a section entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties-for example, statements of peer review or that the text has
     been approved by an organization as the authoritative definition
     of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end
     of the list of Cover Texts in the Modified Version.  Only one
     passage of Front-Cover Text and one of Back-Cover Text may be
     added by (or through arrangements made by) any one entity.  If the
     Document already includes a cover text for the same cover,
     previously added by you or by arrangement made by the same entity
     you are acting on behalf of, you may not add another; but you may
     replace the old one, on explicit permission from the previous
     publisher that added the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.


  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination
     all of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections entitled
     "History" in the various original documents, forming one section
     entitled "History"; likewise combine any sections entitled
     "Acknowledgements", and any sections entitled "Dedications."  You
     must delete all sections entitled "Endorsements."


  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the
     documents in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow
     this License in all other respects regarding verbatim copying of
     that document.


  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of
     a storage or distribution medium, does not as a whole count as a
     Modified Version of the Document, provided no compilation
     copyright is claimed for the compilation.  Such a compilation is
     called an "aggregate", and this License does not apply to the
     other self-contained works thus compiled with the Document, on
     account of their being thus compiled, if they are not themselves
     derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one
     quarter of the entire aggregate, the Document's Cover Texts may be
     placed on covers that surround only the Document within the
     aggregate.  Otherwise they must appear on covers around the whole
     aggregate.


  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License provided that you also include the
     original English version of this License.  In case of a
     disagreement between the translation and the original English
     version of this License, the original English version will prevail.


  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided for under this License.  Any other
     attempt to copy, modify, sublicense or distribute the Document is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.


 10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     http://www.gnu.org/copyleft/.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If
     the Document does not specify a version number of this License,
     you may choose any version ever published (not as a draft) by the
     Free Software Foundation.


ADDENDUM: How to use this License for your documents

   To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

     Copyright (C)  YEAR  YOUR NAME.
     Permission is granted to copy, distribute and/or modify this document
     under the terms of the GNU Free Documentation License, Version 1.1
     or any later version published by the Free Software Foundation;
     with the Invariant Sections being LIST THEIR TITLES, with the
     Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
     A copy of the license is included in the section entitled "GNU
     Free Documentation License."

   If you have no Invariant Sections, write "with no Invariant Sections"
instead of saying which ones are invariant.  If you have no Front-Cover
Texts, write "no Front-Cover Texts" instead of "Front-Cover Texts being
LIST"; likewise for Back-Cover Texts.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License, to
permit their use in free software.

@end example

@c
@c  INDEX
@c
@ifnottex
@node Index, , GNU Free Documentation License, Top
@subheading Index
@end ifnottex
@iftex
@chapter Index
@end iftex
@printindex cp
@bye
