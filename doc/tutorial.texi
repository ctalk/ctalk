\input style.tex @c -*-texinfo-*-
@c $Id: tutorial.texi,v 1.3 2020/07/19 07:25:10 rkiesling Exp $
@c %**start of header  
@setfilename tutorial.info
@settitle Ctalk Tutorial
@setchapternewpage odd
@paragraphindent 0
@c %**end of header

@set VERSION 0.0.56

@macro mnm{methodname}
@code{\methodname\}
@end macro

@macro idxclscite{fnname}
(@code{\fnname\} class)
@end macro

@macro flnm{filename}
@code{\filename\}
@end macro

@iftex

@chapsf
@c @shortcontrm

@end iftex

@ifinfo

@dircategory Ctalk
@direntry
* tutorial: (tutorial).	 Object oriented programming tutorial with Ctalk.
@end direntry

This file documents Ctalk version @value{VERSION}.

Copyright @copyright{} 2007-2015,  Robert Kiesling

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled,
``GNU Free Documentation License.''

@end ifinfo

@iftex
@copying
Ctalk Tutorial Version @value{VERSION}.

Copyright @copyright{} 2007-2015, Robert Kiesling

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of this license is included in the chapter entitled,
``GNU Free Documentation License.'' 
@xref{GNU Free Documentation License}.
@end copying
@end iftex


@iftex

@titlepage
@title @coversf Ctalk Tutorial
@subtitle @textsf Introduction to Object Oriented Programming with Ctalk
@author @textsf Robert Kiesling

@page
@vskip 0pt plus 1filll
@insertcopying

@end titlepage

@contents

@end iftex

@ifinfo
@node Top, , (dir), (dir)
@end ifinfo
@ifhtml
@node Top, , Top, 
@end ifhtml

@iftex 
@textsf
@chapter Preface

Ctalk helps you create programs.  The language is object orientated,
and highly extendable and scalable.  With Ctalk, you can include a
linked list in your C program, or perform regular expression searches,
or get user information from a serial terminal, simply by using the
language's class libraries.

You can also use plain old C statements within Ctalk, which allows the
language to perform any task that C can accomplish, while still saving
many hours of design and coding of tasks that programs need to perform
often.

Ctalk shares C's strengths, like the ability to write programs with a
minimal set of keywords and still access C's versatile programming
libraries, and Ctalk adds a set of object oriented rules that help you
modify and extend your code, while leveraging the system's programming
environment at any phase in the program's design.

Then, at some point, if you find that you need to write a list that
you can sort and scan, or a utility that communicates with a USB
device, or a display routine that draws complex text and graphics in a
Web browser or X window, you'll find that Ctalk can handle those
tasks, too.

The next chapter describes some of the essentials of object oriented
programming.  Ctalk's syntax is similar to C and includes a few
additions.  The chapter provides a brief description of how Ctalk adds
object oriented language rules to a basic language design and shows
how Ctalk can help extend and adapt the programming environment to
your needs.

If you're already familiar with an object oriented language, the next
section might be familiar to you.  In that case, you can go ahead and
skip to the, ``Hello, world!'' program and the following example
programs to get you started.




@chapter A Brief Introduction to Objects

@end iftex

@ifnottex
@chapheading Ctalk Tutorial
This document is an introduction and tutorial to the Ctalk programming
language.  The tutorial assumes that you have at least a basic
knowledge of the C programming language and discusses topics in object
oriented programming in the second section, and when the principles
apply to a specific example program or language feature.  This manual
is organized approximately into increasing levels of difficulty, and
does not describe all of the Ctalk language's features.  Refer to the
@cite{Ctalk Language Reference} for a complete guide to the Ctalk
language.
@end ifnottex

@ifinfo
@menu
* Preface::                 What Ctalk is good at.
* Objects::                 A gentle introduction to objects.
* Hello::                   Hello, world! and other simple programs.
* Basic classes::           How to use objects instead of C variables.
* File input and output::   How to open, close, read, and write files.
* Self and super::          Receivers and classes at run time.
* Collections::             Working with groups of objects.
* Classes::                 Defining and initializing class objects.
* Methods::                 Everything you wanted to know about methods.
* Graphics::                How to write programs that use Panes and windows.
* Debugging::               How to handle errors and debug programs.
* GNU Free Documentation License::    Copying and distributing this manual.
* Index::
@end menu


@node Preface, Objects, Top, Top
@heading Preface

Ctalk helps you create programs.  The language is object orientated,
and highly extendable and scalable.  With Ctalk, you can include a
linked list in your C program, or perform regular expression searches,
or get user information from a serial terminal, simply by using the
language's class libraries.

You can also use plain old C statements within Ctalk, which allows the
language to perform any task that C can accomplish, while still saving
many hours of design and coding of tasks that programs need to perform
often.

Ctalk shares C's strengths, like the ability to write programs with a
minimal set of keywords and still access C's versatile programming
libraries, and Ctalk adds a set of object oriented rules that help you
modify and extend your code, while leveraging the system's programming
environment at any phase in the program's design.

Then, at some point, if you find that you need to write a list that
you can sort and scan, or a utility that communicates with a USB
device, or a display routine that draws complex text and graphics in a
Web browser or X window, you'll find that Ctalk can handle those
tasks, too.

The next chapter describes some of the essentials of object oriented
programming.  Ctalk's syntax is similar to C and includes a few
additions.  The chapter provides a brief description of how Ctalk adds
object oriented language rules to a basic language design and shows
how Ctalk can help extend and adapt the programming environment to
your needs.

If you're already familiar with an object oriented language, the next
section might be familiar to you.  In that case, you can go ahead and
skip to the, ``Hello, world!'' program and the following example
programs to get you started.


@node Objects, Hello, Preface, Top
@heading A Brief Introduction to Objects
@end ifinfo

@ifhtml
@menu
* Introduction::            Basics of objects, classes, and methods.
* Hello::                   Hello, world! and other simple programs.
* Basic classes::           How to use objects instead of C variables.
* File input and output::   How to open, close, read, and write files.
* Self and super::          Receivers and classes at run time.
* Collections::             Working with groups of objects.
* Classes::                 Defining and initializing class objects.
* Methods::                 Everything you wanted to know about writing methods.
* Graphics::                How to write programs that use Panes and windows.
* Debugging::               How to debug Ctalk programs.
* GNU Free Documentation License::    Copying and distributing this manual.
* Index::
@end menu


@node Introduction, Hello, Top, Top
@heading A Brief Introduction to Objects
@end ifhtml

In Ctalk, as in all object oriented languages,
@emph{objects} are the pieces of information that define and
implement both code and data.  Look at the following
examples.  They implement the same operations in BASIC, C,
and Ctalk.

@example

10 let a = 2
20 let b = a + a
30 print b


int a, b;

a = 2;
b = a + a;
printf ("%d\n", b);


Integer new a;
Integer new b;

a = 2;
b = a + a;
stdoutStream writeStream b;

@end example

@cindex Class
The examples look similar, but there is a difference in the object
oriented example.  When a program declares new objects, in this case
@code{a} and @code{b}, Ctalk creates them as members of a
@emph{class}.  In this example, @code{a} and @code{b} are members of
the class @code{Integer}.

If this were as far a object oriented programming went, these
statements would function exactly the same as their C counterpart,
@code{int a, b;}

@cindex Class hierarchy
@cindex Subclass
@cindex Superclass
However, classes belong to a library called a @emph{class
library.}  Class libraries contain all of the routines of
the language, and declarations of different types of
objects.  A class library is organized so that the most
general classes are at the top of the hierarchy, and proceed
to more specialized @emph{subclasses.}  Each class may have
more than one subclass.  Ctalk classes each have one
@emph{superclass,} except for the class @code{Object}, the
topmost class in the class hierarchy.  More on class
hierarchies in a moment.

@iftex
@section Methods, Messages, and Receivers
@end iftex
@ifnottex
@subheading Methods, Messages, and Receivers
@end ifnottex
@cindex Method
@cindex Message
@cindex Receiver
As the previous section mentioned, classes contain both the
specification of objects and the source code of the routines or
functions that operate with each class.  These routines are called
@emph{methods.}

Look at this statement from the example above.

@example

a = 2;

@end example

In this statement, the object @code{a} is called the @emph{receiver}
of the method.  The method is the assignment operator, @code{=}.  The
number @code{2} is the @emph{argument} to the method.  When the
program tells @code{a} to use the method @code{=}, The @code{=}
character is not simply an operator, it is the name, or @emph{message}
of a method that the language provides to the receiver, @code{a}.  In
simple examples, the operation is very similar to using a math
operator or function call.  But the language treats the message as
separate from the operation it describes, which means the message is
extendable to any class that you might want to implement. We'll
describe this in more detail in a moment.


@iftex
@section Polymorphism and Overloading
@end iftex
@ifnottex
@subheading Polymorphism and Overloading
@end ifnottex
Each class can have its own implementation of @code{=}.  The class
@code{String}, for example, can have its own @code{=} method, which
would do exactly what you'd expect.

@c test/expect/examples/hello1.c
@example

String new myString;

myString = "Hello, world!";

@end example

The next line from the example above,

@example

b = a + a;

@end example

contains two methods, @code{=} and @code{+}.  The receiver of @code{=}
is @code{b}, and the receiver of @code{+} is @code{a}.  The argument
of @code{=} is the complete expression, @code{a + a}.

Programs can do the same with character strings.

@c test/expect/examples/hello2.c
@example

String new myString;

myString = "Hello, " + "world!";

@end example

@cindex Polymorphism
@cindex Operator overloading
This is a simple example of a characteristic of computer languages:
@emph{polymorphism.}  That means different types of data have a common
interface and are treated the same by the language.  When the @code{=}
and @code{+} methods work with different classes of objects, we say
that the methods @emph{overload} the operators.

@iftex
@section Class and Instance Data
@end iftex
@ifnottex
@subheading Class and Instance Data
@end ifnottex
In the next line from the example above, 

@example

stdoutStream writeStream b;

@end example

the receiver, @code{stdoutStream}, receives the message @code{writeStream}
with the argument @code{b}.  

@cindex Class variable
@cindex Instance variable
The receiver @code{stdoutStream} is a @emph{class variable.}  There is
one @code{stdoutStream} for its class, @code{WriteFileStream.}
@code{stdoutStream} represents the program's standard output.  The
argument @code{b}, however, is an @emph{instance} of class
@code{String}, and it contains an @emph{instance variable,}
@code{value,} which contains the character string itself.  A
program can create as many @emph{instances of a class} as it needs.

@cindex Instance variable
Each instance of a class contains its own data.  For @code{Integer}
and @code{String} objects, the data is simply the @code{value} of the
object, either @code{2} or @code{Hello, world!}

Class @code{WriteFileStream} objects, however, need to keep track of
more data than a basic type like an @code{Integer}, data like the
permissions of the file stream, the position in the stream, the type
of I/O device, and the memory address of the stream itself.  This
information is contained in @emph{instance variables.}  Each class
defines its own set of instance variables, and each instance of a
class has its own copy of them.

@iftex
@section Inheritance and Constructors
@end iftex
@ifnottex
@subheading Inheritance and Constructors
@end ifnottex
@cindex Inheritance
@cindex Constructor
@cindex @mnm{new} method @idxclscite{Object}
@cindex @mnm{new} method @idxclscite{WriteFileStream}
The methods that create objects, which are generally called @mnm{new,}
have a special status.  They are called @emph{constructors.}  It's
important to remember that they're methods, not keywords or operators.

The following two statements look similar, but internally they
function differently.

@example

String new myString;
WriteFileStream new myOutput;

@end example

Recall from the previous sections that the class hierarchy proceeds
from the more general objects at the top of the hierarchy, to the more
specific subclasses.  Also, instances of class @code{WriteFileStream}
contain more instance data than many other classes of objects.

What actually occurs in the above statements is that
@code{myString} is created like any other object, with its
own @code{value} instance variable.  @code{myOutput},
however, uses the @mnm{new} method of its class, which first
creates the basic @code{myOutput} object and then adds the
additional instance variables and data that we mentioned
above.

So in addition to the @code{value} instance variable, which
the method @mnm{new} obtains from the @code{Object} class,
the object @code{myOutput} also contains the instance
variables it needs to manage writing to a file.  This is
called @emph{inheritance.}  We say that instances of class
@code{WriteFileStream} inherit the @code{value} instance
variable from the @code{Object} class.  Instances of class
@code{WriteFileStream} also inherit other instance
variables, as described below.

@anchor{PositiveInteger Example}
Here is another example, which shows how classes inherit methods.
Suppose you wanted to create a class that represented positive
integers.  You would accomplish this, most likely, by creating a
subclass of @code{Integer.}

@c test/expect/examples/positiveinteger1.c
@example

Integer class PositiveInteger;

@end example

Objects of your new class could use the @code{+} method of the
@code{Integer} class.  So you could write:

@example

PositiveInteger new a;
PositiveInteger new b;

a = 2;
b = a + 2;

@end example

Ctalk, if it doesn't find a method for @code{+} in the
@code{PositiveInteger} class, then uses the @code{+} method 
of class @code{Integer}.

If you wanted to subtract two @code{PositiveInteger} objects, however,
you would need to implement the method @code{-} to insure that the
result is also positive.  The code within that method might look
something like the following.

@example

if ((b = (a - a)) < 0)
   warning ("Negative result for PositiveInteger.");

@end example

The later chapters describe the details of creating your own classes
and methods.

@iftex
@section The Class Hierarchy
@end iftex
@ifnottex
@subheading The Class Hierarchy
@end ifnottex
@cindex Superclass
@cindex Class hierarchy
@anchor{Class Hierarchy}
Let's return to the constructor example above.  You should
note that the @code{WriteFileStream} class does not actually
@emph{define} its instance variables.

@example

WriteFileStream new myOutput;

@end example

This is because the instance variables necessary for reading from
files (with class @code{ReadFileStream} objects) and writing to files
(with class @code{WriteFileStream} objects) are similar.  Instead,
Ctalk defines them in a @emph{superclass,} @code{FileStream}.

A section of the class hierarchy, showing the instance variables that
each class defines, should help explain this organization.

@example

Class                  Instance Variables Defined
-----                  --------------------------
Object                 <------  value
 Stream
  FileStream           <------  streamMode
                       <------  streamDev
                       <------  streamRdev
                       <------  streamSize
                       <------  streamAtime
                       <------  streamMtime
                       <------  streamCtime
                       <------  streamPos
                       <------  streamErrno
                       <------  streamPath
   ReadFileStream
   WriteFileStream

@end example

@iftex
@section Self and Super
@end iftex
@ifnottex
@subheading Self and Super
@end ifnottex
@cindex self
@cindex super
@anchor{Self and Super}

Ctalk does have a few keywords.  Two of them are @emph{self}
and @emph{super.}  They're mentioned here because they are
essential to the creation of new objects, as well as other
tasks.

Both @emph{self} and @emph{super} can occur only in methods.
The keyword @code{self} refers to the receiver of the method
that @code{self} occurs in.  It's functionally equivalent to
the keyword @code{this} in C++.  

The keyword @code{super} refers to the superclass of the
method's receiver.  In some cases, it can also refer to the
receiver of an enclosing scope.  This tutorial discusses the
uses of @code{super} later on.

So when a new @code{WriteFileStream} object gets its
instance variables from its class definition and the
definitions of each of its superclasses, its @mnm{new}
method can use @code{super} to refer to a superclass's
@mnm{new} method.  Very often, much of the initialization
has already been defined in the superclass methods, with
only a few tasks remaining to be done by the receiver class's
constructor.

It might not be apparent from these simple examples, but the
methods and instance data are closely tied together, and
they're independent of the methods and instance data of
other classes.  A simple operation might turn out to be more
complex that it appears at first.  But class inheritance
helps separate and define more general tasks from the tasks
that are specific to a single object.

Classes do not need to be completely separate, however.  A
method can reference some other class's methods or object's
instance data if a program or method needs it.

The @cite{Ctalk Reference Manual} describes the Ctalk class library,
and the methods and variables, that each class defines.

Ctalk shares the strengths of the C programming language. Ctalk, like
C, has very few keywords - nearly everything is an object or a
method. The the rules for defining classes are very simple and
general.  You can write any code you like, no matter how system
specific, and Ctalk can integrate the code into its class library.

As a historical note, Ctalk's language syntax and class library
organization are based very closely on the Smalltalk language, one of
the earliest truly object oriented languages.  You can find much
information about Smalltalk and its design in on-line and printed
documents.

But Ctalk is unique in that it lets you program in C when that is more
suitable to a particular chore.  The tutorial assumes that you're
fairly proficient in C.  However, if you want to read further about
the C language and object oriented programming, there are many books
and tutorials, on line and in print, that describe these subjects in
detail.

@node Hello, Basic classes, Objects, Top
@iftex
@chapter @code{Hello, world!} and Other Simple Programs
@end iftex
@ifnottex
@heading @code{Hello, world!} and Other Simple Programs
@end ifnottex

Ctalk assumes that you are familiar with the C language, and that you
have an understanding of basic object oriented programming concepts,
which we described in the previous chapter.

This chapter presents a few simple programs that demonstrate how the 
Ctalk language works.  Later chapters will describe the more advanced
features of the language in greater detail.

@cindex @code{hello} example program
@heading Printing @code{"Hello, world!"}

To learn how to write and compile a Ctalk application, this chapter 
starts with the usual @code{Hello, world!} program.

Here is the @code{Hello, world!} program listing.

@c test/expect/examples/hello3.c
@example

int main () @{

  String new helloObject;

  helloObject = "\"Hello, world!\"";

  printf ("%s\n", helloObject value);

  exit (0);
@}

@end example

@cindex @code{ctcc} command
Save this listing in a file called @flnm{hello.c.}  (It's also in the
@flnm{demos} subdirectory if you have the source code archive.) Then you
can build @flnm{hello.c} with the @code{ctcc} command.

@example

$ ctcc hello.c -o hello 

@end example

Then, you can run the program with this command, and the program
prints the output.

@example

$ ./hello
"Hello, world!"

@end example

@section Splitting a Directory Path
@cindex @code{ctpath} example program
@anchor{ctpath.c}
Here is another simple program, @flnm{ctpath.c.}  You can find the
source file in the @flnm{demos} subdirectory of the Ctalk source
code distribution.  

This program prints the directory path that you supply as an argument,
one directory to a line.

@c test/expect/examples/ctpath1.c
@example

int main (int argc, char **argv) @{

  String new path;
  Array new paths;
  Integer new nItems, i;
  Character new separator;

  if (argc != 2) @{
    printf ("Usage: ctpath <path>\n");
    exit (1);
  @}

  path = argv[1];

  separator = '/';

  nItems = path split separator, paths;

  for (i = 0; i < nItems; i = i + 1)
    printf ("%s\n", paths at i);

  exit (0);
@}

@end example

Although there is a lot of code for initializing variables and
checking the command line arguments, @code{ctpath} does the actual
work in three lines of code.

@example

nItems = path split separator, paths;

for (i = 0; i < nItems; i = i + 1)
  printf ("%s\n", paths at i);

@end example

@cindex @code{split} method @idxclscite{String}
@cindex @code{at} method @idxclscite{Array}
The method split (class @code{String}) splits the string
@code{path} at each occurrence of @code{separator} and places the
result in the array, @code{paths.}  The next two lines print each
element of the array @code{paths} with the statement, @code{paths at
i.} 

@cindex @code{ctcc} command
As with the previous example, you can compile the program using the
following commands.

@example

$ ctcc ctpath.c -o ctpath

@end example

When you run the program, the output should look like this, depending
on the directory path you provide on the command line.

@example

$ ./ctpath /home/users/joe
home
users
joe

@end example

@cindex @code{argc} C variable
@cindex @code{argv} C variable
If you're not certain of how the arguments to @code{main,} @code{argc}
and @code{argv,} function (they contain the command line, split into
individual strings, and the number of command line strings), then you
should go back and study the C language until you are comfortable with
the language.

You might note also the constructor statement in the example above,

@example

Integer new nItems, i;

@end example

This is a shorthand that is specific to constructor methods (i.e., the
methods that are named @code{new}): A @code{new} method can construct
as many objects of the receiver's class (that is, the class object
before @mnm{new}), as there are labels given in the argument list.

The expression above is exactly equivalent to this set of expressions:

@example

Integer new nItems;
Integer new i;

@end example

So anywhere in this manual that you see one or more expressions that
contain @code{new} with the same receiver class, you can use either of
the two forms and achieve the same result.

@section Printing the Time

Here is a program that uses a method to get the local time and store
it in an array.

@cindex @cite{localtime(3)} C function
@cindex @mnm{localTime} method @idxclscite{CTime}
@cindex @mnm{utcTime} method @idxclscite{CTime}
@cindex @code{CTime} class
@c test/expect/examples/gettime1.c
@example

Array instanceMethod getTime (void) @{

  CTime new timeNow;
  Array new currentLocalTime;

  timeNow utcTime;

  currentLocalTime = timeNow localTime;

  self atPut 0, (currentLocalTime at 2);
  self atPut 1, (currentLocalTime at 1);
  self atPut 2, (currentLocalTime at 0);

  return NULL;
@}

int main () @{

  Array new clockTime;

  clockTime getTime;

  printf ("%02d:%02d:%02d\n", (clockTime at 0), (clockTime at 1), (clockTime at 2));
@}

@end example

In the method @code{getTime,} @code{self} refers to the method's
receiver, @code{clockTime,} which is declared in @code{main.}

The @code{localTime} method (@code{CTime} class), returns an
@code{Array} that is filled in by the C library's call to
@cite{localtime(3).}  The @cite{Ctalk Language Reference} describes
how @code{localTime} returns time and date information.

Note that in @code{main,} the arguments to @code{printf} are enclosed
in parentheses, so there is no ambiguity in evaluating the expressions
in each argument.

@section Printing the Time, at a Higher Level

@cindex @mnm{localTime} method @idxclscite{CTime}
@cindex @mnm{utcTime} method @idxclscite{CTime}
@cindex @code{CTime} class
@cindex @code{CalendarTime} class
The @code{CalendarTime} class achieves the much the same result as the
@code{CTime} class, except that it uses named instance variables to
store elements of the current time:

@c test/expect/examples/isotime.c
@example

int main () @{
  CalendarTime new ct;

  ct utcTime;
  ct localTime;
  printf ("%02d:%02d:%02d %04d-%02d-%02d\n", ct hours, ct minutes, ct seconds,
	  (ct year + 1900), ct month, ct dom);
@}

@end example

Depending on the needs of the program, you might find this to be more
efficient than dealing with individual @code{Array} elements.

@section Opening a X Window

The program @flnm{xhello.c} in the @flnm{demos} subdirectory is too
lengthy to include here, but if you open it in a text editor, it
should look at least a little familiar if you've written programs
with the X Window System.

@flnm{xhello.c} performs the basic steps of creating and displaying a
window, and then waiting for input from the keyboard or mouse.

Building the program is similar to the other examples in this chapter.
You need to include the @samp{-x} option when building
@flnm{xhello.c}, so that Ctalk links the program with the X Window
System libraries, however.

@example

$ ctcc -x xhello.c -o xhello

@end example

And then you can run the program directly.

@example

$ ./xhello

@end example

In brief, whenever you move or resize the window, or another window
uncovers the @code{xhello} window, the program redisplays the ``Hello,
world!'' text in the center of the window.  

If you click on the ``Close'' icon or menu item in the Window's frame
(depending on the type of desktop your system has), the program closes
the window and exits.

With some desktops, you might notice that the message flickers as the
program handles events from the display system.  That's because
@code{xhello} responds to a generic set of events so that it works
with many different desktops and window system features and is simple
for beginners to build.

In addition to displaying simple text, Ctalk's classes provide
flexible support of many drawing and user interface capabilities.
That lets programs handle complex interactions with the window system.
The later chapters of the tutorial discuss these features and how to
write programs with them.  @xref{Graphics}.


@node Basic classes, File input and output, Hello, Top
@iftex
@chapter Basic Classes and Ctalk Statements
@end iftex
@ifnottex
@heading Basic Classes and Ctalk Statements
@end ifnottex

Ctalk is designed to work with C.  There are a number of classes
that correspond directly to the basic C data types.

In Ctalk, you can use instances of the classes that are shown in the
table below interchangeably with their C equivalents.
@cindex @code{Array} class
@cindex @code{Character} class
@cindex @code{Float} class
@cindex @code{Integer} class
@cindex @code{LongInteger} class
@cindex @code{String} class
@cindex @code{char} C data type
@cindex @code{double} C data type
@cindex @code{float} C data type
@cindex @code{long int} C data type
@cindex @code{long long int} C data type
@example
Ctalk Class         C Type
-----------         ------
Array               char **, int **, ...
Character           char
Float               float, double
Integer             int, long int
LongInteger         long long int
String              char *
@end example

There are a few places that you cannot use objects, like function
parameter declarations or @code{struct} members.  You'll also see a
lot of examples that translate data between objects and C variables.
The manner in which Ctalk translates between the two is a powerful
feature of the language.



@iftex
@section @code{Integer,} @code{Character,} @code{LongInteger,} and @code{Float} Classes
@end iftex
@ifnottex
@subheading @code{Integer,} @code{Character,} @code{LongInteger,} and @code{Float} Classes
@end ifnottex
@cindex @code{Character} class
@cindex @code{Integer} class
@cindex @code{LongInteger} class
@cindex @code{Float} class

@cindex Constructors
@cindex @mnm{new} method @idxclscite{Object}
Like most object oriented languages, when you declare an
object, you're actually sending a message to a constructor
method.  As we mentioned earlier, the methods that create
objects are called @emph{constructors.}  And as with many object
oriented languages, you create an object with the message
@code{new.}
@example
Integer new myInt;
@end example

Objects of class @code{Integer} work exactly the same as C variables
of type @code{int.}  You can use expressions like the following, as
though you were programming in C.
@c test/expect/examples/myintadd1.c
@example
Integer new myInt;

myInt = 2;
printf ("%d\n", myInt + myInt);
@end example
@cindex @code{invert} method @idxclscite{Integer}
@cindex @code{bitComp} method @idxclscite{Integer}
With several exceptions, you can use all of the operators that C
integers recognize.  Prefix and postfix operators, like @code{+,} @code{-,}
@code{*,} @code{&,} and so on, also work as methods.  

@code{Integer} class also defines some methods as the equivalent of
these operators, like @code{invert} for @code{!} and @code{bitComp}
for @code{~}.

This example shows how you would use the methods in C statements.
@c test/expect/examples/invert1.c
@c test/expect/examples/bitcomp1.c
@example
int i;               /* C variable.   */
Integer new myInt;   /* Ctalk Object. */

i = 2;
myInt = 2;

/* These two statements are equivalent. */
printf ("%d\n", !i);
printf ("%d\n", myInt invert);

/* These two statements are also equivalent. */
printf ("%d\n", ~i);
printf ("%d\n", myInt bitComp);
@end example

The same is also true for instances of the @code{Character,}
@code{LongInteger,} and @code{Float} classes.

@cindex @mnm{+} method @idxclscite{Character}
@cindex @mnm{toLower} method @idxclscite{Character}
For instance, you can add and subtract two characters.  This is
sometimes useful for conversions, as in the following examples.
@c test/expect/examples/tolower1.c
@example
Character new receiver;
Character new operand;

receiver = 'A';
operand = ' ';

printf ("%c\n", receiver + operand); 
@end example
The result is the lower case @samp{a}.  This has the same effect as:
@example
Character new receiver;
receiver = 'A';
printf ("%c\n", receiver toLower);
@end example
Or even:
@example
printf ("%c\n", 'A' toLower);
@end example

@cindex @mnm{-} @idxclscite{Character}
@cindex @mnm{toUpper} @idxclscite{Character}
To convert a character to uppercase, you can use either @mnm{-} or
@mnm{toUpper.}  Both are implemented by the @code{Character} class.
@c test/expect/examples/toupper1.c
@example
Character new receiver;
Character new operand;

receiver = 'a';
operand = ' ';

/* These two statements produce the same result. */
printf ("%c\n", receiver - operand);
printf ("%c\n", receiver toUpper);
@end example

@cindex @mnm{&} method @idxclscite{Character}
@cindex @mnm{|} method @idxclscite{Character}
@cindex @mnm{^} method @idxclscite{Character}
For completeness, we should note that you can also achieve the same
effect with the bit operators @mnm{&}, @mnm{|}, and @mnm{^,} although
their application can be a bit more involved.  If you're not certain how 
the operators would work, enter the ASCII value of a character in a
programmer's calculator and convert it to base 2.  Then notice the
effect of changing different bits.

For now, we'll just show an example of changing a letter's case - 
from lower to upper case, or vice versa.  

We do this by XOR'ing the fifth bit of the character value.  (Note
that @code{2^5} is @code{32,} the ASCII value of a space (@samp{ })
character.)  

Here is a simple example of the operation.
@c test/expect/examples/toupperlower1.c
@example
Character new upperCase;
Character new lowerCase;
Integer new toggleBit;  

upperCase = 'Z';
lowerCase = 'z';
toggleBit = 100000b;
  

printf ("%c\n", upperCase ^ toggleBit);
printf ("%c\n", lowerCase ^ toggleBit);
@end example

@iftex
@section @code{String} Class
@end iftex
@ifnottex
@subheading @code{String} Class
@end ifnottex
@c @subheading @code{String} Class
@cindex @code{String} class

As the introduction mentioned, Ctalk overloads many operators.  This
is especially obvious of class @code{String.}

This code shows how @code{String} class overloads some math operators.
@cindex @mnm{=} method @idxclscite{String}
@cindex @mnm{==} method @idxclscite{String}
@cindex @mnm{+} method @idxclscite{String}
@cindex @cite{strcpy(3)} C function
@cindex @cite{strcat(3)} C function
@cindex @cite{strcmp(3)} C function
@c test/expect/examples/strcpycatcmp1.c
@example
String new s1;
String new s2;
String new helloString;

/* C's strcpy () would also work here. */
s1 = "Hello, ";
s2 = "world!";

/* And strcat () could perform the same task here. */
helloString = s1 + s2;

printf ("The value of \"helloString\" is \"%s\".\n", helloString);

s1 = "s1";
s2 = "s2";

/* Test whether String objects are equal without strcmp (). */
if (s1 == s2) @{
  printf ("The strings s1 and s2 are equal.\n");
@} else @{
  printf ("The strings s1 and s2 are not equal.\n");
@}
@end example
Briefly, the @code{String} instance methods @mnm{=,} @mnm{==,} and
@mnm{+} function similarly to the C
library functions @cite{strcpy(3),} @cite{strcmp(3),} and
@cite{strcat(3),} respectively.

But these operators can also be overloaded.  For example, the @mnm{+}
method behaves like C's @cite{strcat()} function when the argument is
also a @code{String} object.  If the argument is a @code{Integer},
then the @mnm{+} method increments the reference to the receiver @code{String}
object.  This is discussed further below. @xref{String_pointer_math}.

@cindex @mnm{asString} method @idxclscite{Magnitude}
Like C, however, instances of @code{String} and @code{Character} are
not interchangeable.  If you want to use an instance of class
@code{Character} as a string, you must use the method @code{asString}
(class @code{Magnitude}) to return a @code{String} version of the
@code{Character} object.

Here is a brief example.  The two @code{printf} statements produce 
the same output.
@c test/expect/examples/charasstr1.c
@example
Character new myChar;

myChar = 'a';

printf ("%c\n", myChar);
printf ("%s\n", myChar asString);
@end example

@cindex @mnm{split} method @idxclscite{String}
@code{String} class implements several convenience methods.  The
@mnm{split} method, which we described in the previous chapter, splits
a string along a separator character and puts each substring token in
an array.

Here is the statement from the example in the previous chapter. 
@xref{ctpath.c}.
@example
nItems = path split separator, paths;
@end example
If the receiver, @code{path,} contains a string like
@samp{/home/users/joe}, and separator, a @code{Character} contains
@samp{/}, then @mnm{split} places the individual names in the 
@code{Array,} @code{paths.}  

The operation looks something like this.
@example
path    --->       "/home/users/joe"
                     /     |     \
                    /      |      \
split              /       |       \
                  v        v        v
              --------------------------------
paths   ---> |paths at 0|paths at 1|paths at 2|
             | "home"   | "users"  | "joe"    |
              --------------------------------
@end example
The expression, @code{paths at 0,} is equivalent to the @code{paths[0]}
element of a C array, and so on, for the other elements of the array.

@cindex @mnm{subString} instance method @idxclscite{String}
Another convenience method, @code{subString,} returns the part of the
receiver string beginning at the first argument.  The second argument
is the length of the substring. Here is an example.
@example
myString = "This is a string.";
mySubString = myString subString 5, 2;
@end example


@cindex @mnm{search} instance method @idxclscite{String}
@cindex @mnm{quickSearch} instance method @idxclscite{String}
Ctalk has two methods that allow you to search strings:
@mnm{search} and @mnm{quickSearch}.

The @mnm{search} method allows you to search for text
patterns within strings.  It recognizes a few
metacharacters: @samp{.}, @samp{^}, @samp{$}, and @samp{*}. 
The @mnm{quickSearch} searches for exact text only, but it
uses a much faster search algorithm.

Both methods take as their arguments the text pattern you
want to search for, and an @code{Array} object, where the
methods return the positions in the receiver where the first
character of the pattern occurs.  The first character of the
receiver is offset @code{0}.  The last element of the
offsets array is @code{-1}, which indicates that
@mnm{search} found no further matches. The methods return an
@code{Integer} that contains the number of matches.  This
example shows how a program might search a @code{String}
object with @mnm{quickSearch}.

@c ctalk/test/expect/examples/qsearch.c
@example
int main () @{
  String new string;
  String new pattern;
  Array new offsets;
  Integer new nMatches;

  pattern = "He";
  string = "Hello, world! Hello, world, Hello, world!";
  
  nMatches = string quickSearch pattern, offsets;

  printf ("nMatches: %d\n", nMatches);
  offsets map @{
    printf ("%d\n", self);
  @}
@}
@end example

When run, the program should produce output similar to this.
@example
nMatches: 3
0
14
28
-1
@end example

Here is an example of using @mnm{search} to find a pattern
in a @code{String} object.
@c ctalk/test/expect/examples/search.c
@example
int main () @{
  String new string;
  String new pattern;
  Array new offsets;
  Integer new nMatches;

  pattern = "l*o";
  string = "Hello, world! Hello, world, Hello, world!";
  
  nMatches = string search pattern, offsets;

  printf ("nMatches: %d\n", nMatches);
  offsets map @{
    printf ("%d\n", self);
  @}
@}
@end example

When run, the program should produce results like this.
@example
nMatches: 6
2
8
16
22
30
36
-1
@end example
The @code{search} method matches as much of a pattern as
possible.  It's also important to remember that a @samp{*}
metacharacter matches zero or more occurrences of the
character it follows.  So the pattern, @code{"l*o,"}
matches both @code{"llo,"} and, @code{"o."}

However, Ctalk's pattern matching does not allow the text that
matches a pattern to overlap.  So a pattern like @samp{.:} matches
the character @emph{before} each pair of colons in the string
@samp{item1::item2::item3::item4}, while the pattern @samp{:.}
matches only the first colon of each pair of colons.

@anchor{String_pointer_math}
@iftex
@subsection Using Math Operators with @code{Strings}
@end iftex
@ifnottex
@subsubheading Using Math Operators with @code{Strings}
@end ifnottex

@cindex @mnm{+} instance method @idxclscite{String}
@cindex @mnm{-} instance method @idxclscite{String}
@cindex @mnm{++} instance method @idxclscite{String}
@cindex @mnm{--} instance method @idxclscite{String}
@cindex @mnm{+=} instance method @idxclscite{String}
@cindex @mnm{-=} instance method @idxclscite{String}
@cindex @mnm{*} instance method @idxclscite{String}
As the the section above mentioned, Ctalk overloads math operators for
@code{String} and its subclasses.  These operators are @mnm{+},
@mnm{-}, @mnm{++}, @mnm{--}, @mnm{+=}, @mnm{-=}, and @mnm{*}.  For
@code{String} objects (and subclasses of @code{String} if the subclass
doesn't also overload the methods) these methods behave the same as
the equivalent C operators - that is, they increment (or decrement)
the value of the receiver @code{String} by one or more characters.

Here is an example that demonstrates a few of the methods.

@c test/expect/istring5.c
@example

int main () @{

  String new s;
  String new t;
  Integer new halfLength;
  Integer new i;

  s = "Hello, world!";

  i = 0;
  halfLength = 7;

  t = s;

  printf ("%s\n", s);

  while (i++ <= halfLength)
    printf ("%s\n", t++);

  while (t-- != NULL)
    printf ("%s\n", t);
@}

@end example

When run, this program produces the following output.

@example

Hello, world!
Hello, world!
ello, world!
llo, world!
lo, world!
o, world!
, world!
 world!
world!
world!
 world!
, world!
o, world!
lo, world!
llo, world!
ello, world!
Hello, world!
(null)

@end example

Note that @code{String} and @code{Integer} objects get iterated
separately.  There's a slight semantic difference from C because Ctalk
doesn't overload subscripts - a Ctalk program would use @code{t at i}
to refer to the @var{i}'th character in a @code{String}.

As you might expect, though, the expression @code{*str} returns the
first element of @code{str} as a @code{Character} object.

@iftex
@section @code{Array} Class
@end iftex
@ifnottex
@subheading @code{Array} Class
@end ifnottex
@c @subheading @code{Array} Class
@cindex @code{Array} class
@anchor{Array}

An @code{Array} in Ctalk is similar to arrays in every other
programming language.  Ctalk arrays are collections of objects,
indexed sequentially from index @code{0} to the last element in the
Array. 

@cindex @mnm{atPut} method @idxclscite{Array}
To add an element to an @code{Array} object, use the method
@code{atPut.} 
@c 
@example
Array new myArray;
String new myString;

myString = "Hello, world!";

myArray atPut 0, myString;
@end example

The @mnm{atPut} method has two arguments, the index of the array
element, and the object you want to store there.

@cindex @mnm{at} method @idxclscite{Array}
To retrieve an @code{Array} element, use the method @code{at.}  The
@mnm{at} method takes one argument, the index of the array element.

Using the previous example, this statement retrieves the first element
of @code{myArray} and prints it.
@c test/expect/examples/array1.c
@example
printf ("%s\n", myArray at 0);
@end example

You do not have to predeclare an array to a specific size.
Objects of @code{Array} class can hold as many objects as necessary.

@cindex @mnm{size} method @idxclscite{Array}
If you want to know how many elements an @code{Array} object contains,
use the method @code{size,} which returns the number of elements as an
@code{Integer} object.
@example
printf ("myArray has %d elements.\n", myArray size);
@end example

If you add an object to an array at an index that already contains an
object, @code{atPut} replaces the array element with the new object.
@c test/expect/examples/array2.c
@example
Array new myArray;

myArray atPut 0, "My";
myArray atPut 1, "name";
myArray atPut 2, "is";
myArray atPut 3, "Bill";

WriteFileStream classInit;

stdoutStream printOn "%s %s %s %s.\n", myArray at 0, 
  myArray at 1, myArray at 2, myArray at 3;

myArray atPut 3, "Joe";

stdoutStream printOn "%s %s %s %s.\n", myArray at 0, myArray at 1, 
  myArray at 2, myArray at 3;
@end example

The @code{WriteFileStream classInit} statement initializes the
program's standard output.  You need to include it (also run by the
@code{WriteFileStream} method @mnm{new}) before printing to the
console with Ctalk methods.  Later chapters describe file input and
output in greater detail.

@subsection Repeating Operations for Each Element of a Collection

@cindex @mnm{map} @idxclscite{Array}
@cindex Inline methods
Generally, if you want to repeat an operation on all members of an
array, you can use C's @code{for}, @code{while}, or @code{do} loops.

If you want to iterate over a class using Ctalk, many classes
implement the method @code{map.}

The @code{map} method can take the name of another method as its
argument.  @code{map} then calls the method with each element of the array
as its receiver.

Here is a more complete implementation of the example above, written
using @code{map.}
@c test/expect/examples/array3.c
@example
Array instanceMethod printArrayElement (void) @{
  printf ("%s ", self);      
  return NULL;
@}

int main () @{
  Array new myArray;

  myArray atPut 0, "My";
  myArray atPut 1, "name";
  myArray atPut 2, "is";
  myArray atPut 3, "Bill";

  myArray map printArrayElement;
  printf ("\n");

  myArray atPut 3, "Joe";
  myArray map printArrayElement;
  printf ("\n");
@}
@end example

In the @code{printArrayElement} method, @code{self} refers to each
successive element of @code{myArray} (in @code{main}.)  Each element
of @code{myArray} is an instance of class @code{String.}

However, you should note that @code{Array} elements, like elements of
any other collection, can be objects from any class, and C does not
necessarily handle classes that correspond to complex data so easily.

In this case, it is relatively easy for the program to determine how
to deal with a @code{String} object.  Mapping over other collection
types, @code{AssociativeArray}s, requires that methods examine
receivers of unknown classes.  @xref{Collections}.

If @code{Array} elements are instances of complex classes, or the
elements represent complex C data types, then the method may need to
determine the class of its receiver, which is discussed in the
following chapters, and the method may need to translate objects from
one class to another.  @xref{Variable Promotion and Type Conversion}.

@cindex Argument blocks
@anchor{ArgumentBlocks}
The @mnm{map} method can also use a block of code as its argument, as
in this example.  
@c test/expect/argblk5.c
@example
int main () @{

  List new l;
  String new sPrefix;
  String new s;

  sPrefix = "This element is ";

  l push "l1";
  l push "l2";

  l map @{
    s = sPrefix + self;
    printf ("%s\n", s);
  @}
  exit(0);
@}
@end example

You should note that the block has a different scope than the function
or method where it occurs.  Objects declared in the method are also
visible within the block, but not vice versa.  Also, @code{self}, when
it occurs inside a code block in this manner, refers to each
successive element of the receiver collection (each member of
@code{List} @var{l} in the example above), and @code{super}, is
overloaded so that, when used as a receiver, refers to the receiver of
the method that contains the block of code; i.e., the @code{self} of
the method that contains the block.

@cindex @code{break} within an argument block
While you can use a @code{break} statement to exit
that @mnm{map} block, you cannot (at least currently), @code{return}
from the method from within the block.  Otherwise, control structures
within a block work just as you would expect.  Here is an example from 
@code{Object} class.
@example
Object instanceMethod libraryPath (void) @{
  Array new searchDirs;
  Application new docApp;
  String new s;
  String new libraryPathName;
  String new receiverName;
  FileStream new f;
  returnObjectClass String;

  s = docApp classSearchPath;
  s split ':', searchDirs;
  receiverName = self value;
  searchDirs map @{
    libraryPathName = self + "/" + receiverName;
    if (f exists libraryPathName)
      break;
  @}
  return libraryPathName;
@}
@end example

Once again, @code{self} within the argument block refers to each
successive member of the @code{searchDirs} array.

You can use @code{self} in argument blocks even if a block occurs
in a C function.  Otherwise, either Ctalk or the compiler, depending
on the context, will not be able to find the receiver that @code{self}
should refer to, and Ctalk or the compiler, or both, will issue
warning or error messages.

If the program tries to use @code{super} within a C function, Ctalk
prints a warning and uses the receiver of the entire code block
itself-generally, that's the receiver of a @mnm{map} method.

@cindex __ctalkInlineMethod function
Many collection classes declare their own versions of @mnm{map}.
All of them use the @code{__ctalkInlineMethod ()} library function
to actually perform the in-line call.  Programs that implement inline
calls elsewhere can (and should) use this function.  Refer to the
@code{__ctalkInlineMethod ()} description in the @cite{Ctalk Language
Reference} for the gritty details.

It's worth noting here that @mnm{map} with an argument block does not
allow certain constructs.  You can nest argument blocks, but they
cannot be called recursively.  In addition, if the first argument to
@mnm{map} is a separate method, some classes, like @code{List}, allow
you to provide further arguments to the target
method. @xref{MapArguments}.

@cindex @mnm{mapInstanceVariables} instance method @idxclscite{Object}
Occasionally, references to @code{self} within code blocks
can be ambiguous.  This mostly happens when @code{self} is
used as an argument to a method inside the block.  Consider
the following example, which uses @mnm{mapInstanceVariables}
(defined in class @code{Object}).
@smallexample
myObject mapInstanceVariables @{
  if (self name != "value") @{
    s_element = self formatInstanceVariable self asSymbol; /* Here, "self" refers to s_element. */
    s = s + s_element;
  @}
@}
@end smallexample

Here, the statement 
@example
s_element = self localFormatInstanceVariable self asSymbol;
@end example
can cause trouble, because @code{self} refers to
@code{s_element}, not the receiver of the block.  The
program can find the @mnm{formatInstanceVariable} method
(defined in @code{ObjectInspector} class) due to the way
that @mnm{mapInstanceVariables} defines receivers, but the
@samp{self asSymbol} refers to @code{s_element} (the
receiver of @mnm{=}), instead of referring to the receiver
of the block.

To make this construct clear, the block can appear, somewhat
artificially, as the following.

@smallexample

rcvrCopy copy self;             /* Here, "self" is the method's receiver. */
myObject mapInstanceVariables @{
  if (self name != "value") @{  /* Here, "self" is the block's receiver. */
    selfVarSymbol = self;       /* Assigning to a Symbol creates a reference. */
    s_element = rcvrCopy formatInstanceVariable selfVarSymbol;
    s = s + s_element;
  @}
@}

@end smallexample

However, it's also useful to use @code{super} in the same manner.
So the example above gets slightly abbreviated.

@smallexample

myObject mapInstanceVariables @{
  if (self name != "value") @{  /* Here, "self" is the block's receiver. */
    selfVarSymbol = self;       /* Assigning to a Symbol creates a reference. */
    s_element = super formatInstanceVariable selfVarSymbol;
    s = s + s_element;
  @}
@}

@end smallexample


Use of the @mnm{mapInstanceVariable} method is discussed
further in the following sections. @xref{The -> Method}.

@subsection Using Math Operators with Arrays (More about Looping)

@cindex  @mnm{++} instance method @idxclscite{Collection}
@cindex  @mnm{--} instance method @idxclscite{Collection}
@code{Array} objects, like other subclasses of @code{Collection}, can
use overloaded math operators to loop through the collection's elements.
These methods include @mnm{--} and @mnm{++}.  Here's a brief example.

@c /***/
@example

int main (int argc, char **argv) @{

  Array new a;
  Key new k;

  a atPut 0, "value0";
  a atPut 1, "value1";
  a atPut 2, "value2";
  a atPut 3, "value3";

  k = *a;

  while (++k)
    printf ("%s\n", *k);

@}

@end example

When run the program produces output like this.

@example

value0
value1
value2
value3

@end example

There's a more complete discussion of how math operators work with
@code{Collection} objects and @code{Collection's} subclasses further
on. @xref{CollectionMathOperators}.

@iftex
@section Compound Statements
@end iftex
@ifnottex
@subheading Compound Statements
@end ifnottex
@c @subheading Compound Statements
@cindex Compound statements

The result of evaluating one message can be the receiver of another
message, as in the following example.
@c test/expect/examples/ctpath2.c
@example
int main () @{

  ReadFileStream new infileStream;
  Array new pathDirs;
  Integer new nDirs;
  SystemErrnoException new e;

  /* Substitute the path of the file here. */
  infileStream openOn "/path/name/here";
  if (e pending)
    e handle;

  nDirs = infileStream streamPath split '/', pathDirs;

  printf ("%i\n", nDirs);
  printf ("%s\n", pathDirs at 0);
  printf ("%s\n", pathDirs at 1);
  printf ("%s\n", pathDirs at 2);
@}
@end example

The receiver of the method @code{split,} in the statement
@example
nDirs = infileStream streamPath split '/', pathDirs;
@end example
is the result of sending the message @code{streamPath} to
@code{infileStream.} The result is the path name of
@code{infileStream,} a @code{String.}

The result of one message must be a member of the same class as the
receiver of the next message, or a member of a subclass if the message
refers to a method.

Note the use of the @code{SystemErrnoException} object, @code{e.}
This class is used for recording system errors from methods that 
interact with the operating system.  The later sections describe 
exception handling in more detail.

The @cite{Ctalk Language Reference} describes the class and instance
variables of each class, and the return classes of methods.

@iftex
@section Expressions as Receivers
@end iftex
@ifnottex
@subheading Expressions as Receivers
@end ifnottex
@cindex Expressions as receivers

If you enclose a simple expression in parentheses, then
Ctalk can treat the complete expression as a receiver.  This 
expression provides an example.

@example
("Hello, " + "world!") length;
@end example

This expression returns the result @code{13}, because the
expression @code{"Hello, " + "world!"} returns a
@code{String} object containing the result, the complete
@code{String}, @code{"Hello, world!"}, the receiver
of the @mnm{length} message.

C variables and objects work equivalently in receiver
expressions.  So the following example,

@example
String new s1;
String new s2;

s1 = "Hello, ";
s2 = "world!";

(s1 + s2) length;
@end example
is equivalent to the example above, as is this example:
@example
char s1[MAXLABEL];
char s2[MAXLABEL]

strcpy (s1, "Hello, ");
strcpy (s2, "world!);

(s1 + s2) length;
@end example

Method parameters and @code{self} also work normally within
simple receiver expressions.  The following example does
exactly what you would expect it to do.

@c test/expect/constrcvr17.c
@example
String instanceMethod catLengthArg (String sArg) @{
  printf ("%d\n", (self + sArg) length);
@}

int main () @{
  String new s;
  String new sArg;
  s = "Hello, ";
  sArg = "world!";
  s catLengthArg sArg;
@}
@end example

You can overload common C math operators in just about any
case where you have an expression as a receiver.  Operator
precedence in Ctalk works a little differently than C,
however, because non-operator methods bind more tightly than
math operators; that is, they have a higher precedence.

So an expression like the following doesn't do what you
expect.

@example
("Hello, " + "world ") + ("again" + "!") length;
@end example

That is because the @code{length} message has a higher
precedence that @code{+}, so @code{length} evaluates only
the subexpression, @code{("again" + "!")}, which then
generates an invalid operand exception when the second
@code{+} is evaluated, due to the fact that the
@code{length} method returns an @code{Integer}, while the
receiver of the second @code{+} message is a @code{String}.

To get @code{length} to evaluate the complete expression,
enclose the expression in parentheses.

@example
(("Hello, " + "world ") + ("again" + "!")) length;
@end example 

Here's another example of an expresison where it's necessary to add
parentheses.

@example

(*itemPtr) org x = self resources integerAt "scrollWidth" +
  self resources integerAt "leftMargin";

@end example

This expression is ambiguous because the @samp{+} operator in the
argument list is overloaded in both @code{String} and @code{Integer}
classes.  So if Ctalk is to interpret the argument list, it
might consider the first @code{integerAt} token to use the rest of the
expression as its single argument, in which case Ctalk would interpret
the argument expression like this, and try to perform an increment of
the "scrollWidth" token, which isn't (as yet) supported, and would
(probably) make no sense, because "scrollWidth" is a key in the
@code{AssociativeArray,} "resources".

@example

(*itemPtr) org x = self resources integerAt ("scrollWidth" +
  self resources integerAt "leftMargin");

@end example

Instead, what we really want is to interpret the complete argument
expression to the @samp{=} operator as this.

@example

(*itemPtr) org x = (self resources integerAt "scrollWidth") +
  (self resources integerAt "leftMargin");

@end example

This causes Ctalk to first evaluate each operand of the @samp{+}
operator, which results in @code{Integer} operands, so Ctalk evaluates
the entire expression as an integer addition, and it uses the
@code{Integer: +} method, and returns the addition of the two
@code{Integer} values that are stored in the "resources"
@code{AssociativeArray}.

@anchor{Variable Promotion and Type Conversion}
@iftex
@section Variable Promotion and Type Conversion
@end iftex
@ifnottex
@subheading Variable Promotion and Type Conversion
@end ifnottex
@c @subheading Variable Promotion and Type Conversion
@cindex Variable promotion
@cindex Type conversion

This section could also be titled @emph{When to use become, copy, or =.}

Because objects can be much more complex than C data types, variable
promotion and type conversion become much more complex operations in
object oriented languages than in C.  This will become apparent later
on.

@cindex @code{Magnitude} class
For now, because we're discussing basic object classes, it should be
sufficient to look at the methods of class @code{Magnitude}
for our examples, which is the superclass of classes like
@code{Character,} @code{String} (a subclass of
@code{Character}), @code{Integer,} and @code{LongInteger.}

@cindex @mnm{asCharacter} method @idxclscite{Magnitude}
@cindex @mnm{asInteger} method @idxclscite{Magnitude}
@cindex @mnm{asLongInteger} method @idxclscite{Magnitude}
You need to use the @code{Magnitude} methods @mnm{asCharacter,}
@code{asInteger,} and @code{asLongInteger} to perform type conversions
explicitly.  The @cite{Ctalk Language Reference} describes the type
conversion methods for each class.

@cindex @mnm{=} method @idxclscite{Integer}
@cindex @mnm{=} method @idxclscite{Character}
@cindex @mnm{=} method @idxclscite{String}
When making assignments, you can use @mnm{=} for receivers and
arguments that a function or method declares explicitly, or with
constant receivers and objects.  The classes @code{Integer,}
@code{Character,} and @code{String} each implement a @mnm{=} method,
so a program would use @mnm{=} with objects that are instances of
these classes, or with constants like @code{1,} @code{a,} or
@code{"Hello, world!"}

@cindex @mnm{become} method @idxclscite{Object}
In other cases, if a statement needs to make an assignment
and the statement contains receiver or instance variables,
or the expression contains an operand that the program
cannot determine until run time, or if the receiver or
operand are of completely different classes, then
@mnm{become} (class @code{Object}) can in most cases perform
the type conversion and assignment.  This is often the case
with classes that represent complex data, like files or
windows.

The @mnm{become} method takes into account situations where the type
of a receiver or local object may change during the course of a
program's execution.  

@cindex @code{X11PaneDispatcher} class
@cindex @code{X11TextPane} class
@strong{Warning:} However, the method @mnm{become}
@emph{alters or even deletes the original object.}  That
means you should not use it with objects that are passed as
@code{Symbol} values, or other expressions where an
application uses an object outside of it original scope.

Here's a partial example, from the @mnm{attachTo} method in
@code{X11CanvasPane}.  The @mnm{become} method mutates the
instance variables, @code{paneBuffer} and
@code{paneBackingStore} into @code{X11Bitmap} objects.
Because the front end does not know for certain that the
objects have been mutated (because there's nothing
syntactically special about a method like @mnm{become} that
indicates its function).  So when the front end encounters
the @mnm{initialize} method (which is defined in class
@code{X11Bitmap}), the language may only be able to assume
that @code{paneBuffer} and @code{paneBackingStore} are still
@code{Symbol} objects, which do not have an @mnm{initialize}
method.  So the front end generates a warning and informs
you that the statement's evaluation is going to wait until
run time.

@example
X11CanvasPane instanceMethod attachTo (Object parentPane) @{
  X11Bitmap new xPaneBuffer;
  X11Bitmap new xPaneBackingStore;
  self super attachTo parentPane;
  self paneBuffer become xPaneBuffer;
  self paneBackingStore become xPaneBackingStore;
  if (parentPane containerMode == "full") @{
    self viewWidth = parentPane size x;
    self viewHeight = parentPane size y;
    self size x = parentPane size x;
    self size y = parentPane size y;
    /*
     * These two statements generate warnings, and 
     * Ctalk waits until run time to evaluate them.
     */
    self paneBuffer initialize self size x, self size y,
      self depth;
    self paneBackingStore initialize self size x, self size y,
      self depth;
  @} else @{
    fprintf (stderr, 
	     "attachTo (class X11CanvasPane) : undefined containerMode.\n");
  @}
  return NULL;
@}
@end example

If you want better statement checking, then you can try
performing whatever operations you need first (in this
example, those are the statements that contain the
@mnm{initialize} method), and @emph{then} mutating the
objects with @mnm{become} second.
@example
X11Bitmap new xPaneBuffer;
X11Bitmap new xPaneBackingStore;
...
xPaneBuffer initialize self size x, self size y,
      self depth;
xPaneBackingStore initialize self size x, self size y,
      self depth;
...
self paneBuffer become xPaneBuffer;
self paneBackingStore become xPaneBackingStore;
@end example

Classes like @code{X11PaneDispatcher}, @code{X11CanvasPane},
and @code{X11TextPane} use a lot of object references.
There are some factors that you need to watch out for when
working with @code{Symbol} objects that refer to other
objects.  

We use @code{X11Bitmap} objects because they allow us to
maintain graphics features, like colors and fonts, within
the @code{X11Bitmap} object, which considerably simplifies
the classes of higher level objects of the @code{Pane}
subclasses.  It also helps guarantee that we need to set
graphics features only at the beginning of the program, or
once again only when the program requests that the window
display at different font or color, or some other graphics
operation.

There's more discussion about graphics further on, and the
next sections talk more about object references.

@cindex @mnm{copy} method @idxclscite{Object}
When a statement needs to duplicate objects of the same class, then it
should use the @mnm{copy} (class @code{Object}) method.
Remember, though, that the receiver of the @mnm{copy}
message is the @emph{target} of the copy operation.  The
@mnm{copy} method @emph{completely} replaces the receiver with the
source object that is @mnm{copy}'s argument.  That means the
original receiver object is no longer available.

If a class contains data that requires a special protocol to
duplicate objects, then it can implement its own versions of these
methods, or use any other way it needs to assign objects.

@iftex
@section Object References
@end iftex
@ifnottex
@subheading Object References
@end ifnottex
@anchor{Object References}
@cindex @code{Symbol} class
@cindex @mnm{*} method @idxclscite{Symbol}
@cindex @mnm{=} method @idxclscite{Symbol}
@cindex @mnm{setValue} method @idxclscite{Symbol}
@cindex @mnm{getValue} method @idxclscite{Symbol}
The @code{Symbol} class gives programs the ability to use
the same object anywhere in a program, and makes it much
easier to maintain multiple references to objects.  @code{Symbol}
objects accomplish this by maintaining, instead of a unique 
sub-object, a reference to another, original object.

From here to the end of the tutorial, you'll see a lot of
information about object references.  If the information
seems to be repetitive, it's because references are
essential to writing complex programs and add a level of
complexity to the language that you need to be aware of.

Passing objects by reference allows programs to modify
objects just about anywhere.  Then, in many cases, the
application can use an object without knowing beforehand
exactly what class the object is, or what data the object
contains, until an expression is actually evaluated.  It's
something that you need to be aware of when writing complex
programs.

The @mnm{=} method of class @code{Symbol} behaves differently depending
on its context.  It can either assign an object to a @code{Symbol's} label,
or it can duplicate the symbol's reference, depending on whether the 
@code{Symbol} object is the receiver a method like @code{*}.

The @code{*} method always provides access to the object referred to
by the receiver.  In this sense, @code{*} acts very much like C's
@code{*} operator.  It's also convenient to refer to @code{Symbols} in
this context as @emph{pointers,} following the C terminology.
The following example might make this a little clearer.

@c test/expect/examples/prefixsym.c
@example

int main () @{

  Symbol new sym1;
  Symbol new sym2;
  Symbol new sym3;
  Integer new i;
  
  i = 2;

  sym3 = sym1;   /* Save the original value of sym1. */

  sym1 = i;
  printf ("%d\n", sym1);

  *sym2 = i;     /* Pointer context - refer to the object using '*'. */ 
  printf ("%d\n", *sym2);

  sym1 = sym3;  /* Restore sym1 to the original object. */

  i = 4;
  
  *sym1 = i;    /* Pointer context again. */

  printf ("%d\n", *sym1);
@}

@end example

The @mnm{*} method is also a convenient shorthand for the
@mnm{setValue} and @mnm{getValue} methods, which can fit into places
where a prefix operator might be confusing or just plain syntactically
incorrect, and which have a higher operator precedence (remember that
method labels bind more tightly than operators).  This somewhat
hypothetical example shows one case where the precedence of an
operator can cause unpredictable behavior.

@example

TreeNode new head;
TreeNode new tChild;
Symbol new tSib;

tSib = TreeNode basicNew "Sibling Node";
head makeSibling tSib;

....                                  /* Do some stuff */

head siblings map @{
  *tSib = self;

  tChild = TreeNode basicNew "Child Node";

  ...                               /* Do some more stuff. */

  tSib getValue addChild tChild;    /* This expression
                                       evaluates correctly. */

  *tSib addChild tChild;            /* This expression doesn't 
                                       evaluate left-to-right as
                                       you might expect, because 
                                       "addChild" has a higher
                                       precedence than "*". */

  (*tSib) addChild tChild;          /* Adding parentheses causes the
                                       "*" operator to be evaluated
                                       first, so this expression
                                       evaluates left-to-right. */
@}

@end example


In some cases, object references tell Ctalk to wait until the
application actually runs before trying to evaluate an expression.
Consider another somewhat hypothetical example.

If we declare an instance variable like this:
@example
X11Pane instanceVariable container Object NULL;
@end example
And then, further down, the program contains an expression like this:
@example
self container deleteAndClose;
@end example
Ctalk cannot generate the correct code, because the value of
@code{container} is actually an @code{Object}, and it can't
determine beforehand from the @code{Object} class library
where to find the @mnm{deleteAndClose} method.  We might
assume in this case that @code{container} is also a
@code{X11Pane,} but using class membership to bind receivers
and methods raises all sorts of havoc; for example, when
performing math operations with instance variables.  And in
some cases, the application needs to take care that the
method's class--here, the @code{X11Pane} class defines the
@mnm{deleteAndClose} method--actually has been evaluated in order
to avoid an undefined forward reference.

Instead, a class might declare an instance variable like
this.
@example
X11Pane instanceVariable container Symbol NULL;
@end example
Noting that a method like @mnm{getValue} (defined in class
@code{Symbol}) returns @code{Any} class of object, Ctalk then
knows that it should wait until the program is run before
trying to evaluate the expression.  So expressions like this
example, from the @mnm{subPaneResize} method above, isn't
actually evaluated until the program runs.
@example
__subPaneRef getValue displayText;
@end example
In some cases, if you try to use an instance variable
message with an object reference, Ctalk generates a warning
that the instance variable message is ambiguous.

For example, the @code{x} and @code{y} messages in the
@cite{printf(3)} arguments are ambiguous.
@example
int main () @{
  Point new p;
  Symbol new s;

  p x = 125;
  p y = 175;

  s = p;
  /*  Ambiguous messsages, "x," and, "y." */
  printf ("%d %d\n", s getValue x value, s getValue y value);
@}
@end example
In these cases, Ctalk generates a warning message, so when 
building this program, the output looks like this (assuming
the input file is named @flnm{example.c}).
@example
$ ctcc example.c -o example
/usr/local/bin/ctalk    example.c  -o example.i && /usr/bin/gcc  example.i -o example -lctalk -L/usr/local/gcc-current/lib -L/usr/local/lib -L/usr/lib -L/usr/local/lib -L/usr/lib  
example.c:10: Ambiguous operand: Warning: Message, "x," follows method, "getValue," which returns "Any" class object.
example.c:10: Ambiguous operand: Warning: Message, "y," follows method, "getValue," which returns "Any" class object.
@end example

When evaluating references, Ctalk can generally figure out that
successive calls to @mnm{getValue} (or @mnm{*}) mean the same
reference, but a program shouldn't depend on this behavior, especially
when there are instance variable messages or other method messages in
the expression.

The following examples might help explain this.
@c ctalk/test/expect/symderef2.c
@example
Symbol new mySym;
Integer new myInt;

myInt = 1;

mySym = myInt;
printf ("%d", mySym getValue value);           /* Correct. */


mySym = myInt asSymbol;
printf ("%d", mySym getValue value);           /* Still correct. */

printf ("%d", mySym getValue getValue value);  /* Not necessarily correct. */
@end example
In the third example, Ctalk can still figure the expression
out because the receiver, @code{mySym} is the same for both
@mnm{getValue} messages.  To repeat, programs shouldn't depend
on this being the case for complex expressions.

These characteristics also apply to the subclasses of @code{Symbol;}
for example, the @code{Key} class.  @code{Key} objects are mainly used
as the indices of @code{Collection} objects and its subclasses.
@code{Keys} help simplify the task of looping through
@code{Collection} members.  They also help more specialized subclasses
extend the basic @code{Collection} object.  There's more discussion of
how to use @code{Keys} and references to them below.
@xref{Collections}.

@iftex
@subsection Multiple Indirection
@end iftex
@ifnottex
@subsubheading Multiple Indirection
@end ifnottex

The previous section described how to assign object
references in relatively simple expressions.  However, in C
it is often necessary to provide multiple levels of
indirection.  Declarations like @samp{char **argv} and
@samp{char *myvar[512]} occur frequently in C programs.

If objects need to use multiple levels of referencing and
dereferencing, We've already mentioned @code{Symbol} class's
@code{getValue} method, and its synonym, @code{*}.  Ctalk also
provides several other methods for this purpose: @mnm{addressOf}
(defined in @code{Object} class) and @mnm{deref} (defined in
@code{Symbol} class).

@cindex @mnm{addressOf} instance method @idxclscite{Object}
@cindex @mnm{deref} instance method @idxclscite{Symbol}

These two methods make it possible to construct expressions
like those in the following example.
@example
int main () @{
  Integer new i;
  Symbol new s;

  i = 1;
  s = i addressOf;
  printf ("%d\n", i);
  printf ("%d\n", s deref);
@}
@end example
When run, the output of the two @cite{printf} statements is identical.

The following examples also describe shorthands for the
methods. @mnm{addressOf} is functionally equivalent to the C
@samp{&} unary operator, and @mnm{deref} is functionally
equivalent to the unary @samp{*} operator.

If a program needs to use multiple levels of indirection, it
can use the @mnm{addresOf} and @mnm{deref} messages multiple
times, as in this example.

@example

int main () @{
  Point new p;
  Symbol new s;

  p x = 1;
  s = p x addressOf addressOf;
  printf ("%d\n", p x);
  printf ("%d\n", s deref deref);
@}

@end example

Or even,

@example

int main () @{

  Point new p;
  Symbol new s;

  p x = 1;
  s = p x addressOf addressOf addressOf;
  printf ("%d\n", p x);
  printf ("%d\n", s deref deref deref);

@}

@end example

In each case, the output of the @cite{printf} statements
is the same.

The main difference between the @mnm{addressOf} and
@mnm{deref} expressions, compared with @mnm{=} and
@mnm{getValue}, is that @mnm{=} only converts a symbol value
once, while @mnm{addressOf} always returns a @code{Symbol}
object that points to the receiver.  

In practice, it works out that @mnm{deref} allows statements
with a little more precision than a series of @mnm{getValue}
statements would allow.


@iftex
@section The @mnm{->} Method
@end iftex
@ifnottex
@subheading The @mnm{->} Method and C Object Members
@end ifnottex
@cindex @mnm{->} instance method @idxclscite{Object}
@anchor{The -> Method}

Ctalk also overloads the C language's dereference
(@mnm{->}) operator so you can obtain the value of any
object's C members by referring to the C name that Ctalk
uses internally. 

The member names of a C @code{OBJECT} typedef are:
@example
__o_name
__o_classname
__o_class
__o_superclassname
__o_superclass
__o_p_obj
__o_value
instance_methods
class_methods
instancevars
classvars
scope
nrefs
next
prev
@end example

@emph{Note:} The use of @code{__o_classname} and @code{__o_superclassname}
are being phased out.  You should use the @code{CLASSNAME} and
@code{SUPERCLASSNAME} macros instead.

If the @mnm{->} operator is a method, then Ctalk recognizes both
the old and new names.  However, if @mnm{->} is used with
an @code{OBJECT *} as a C operator, then it is necessary to
use the CLASSNAME and SUPERCLASSNAME macros.

Ctalk uses some special semantics with the @mnm{->} method.
First of all, when given a C name as an argument, Ctalk
returns a @code{Symbol}, @code{String} or @code{Integer}
object with a reference to the original object whenever
necessary.

That means, where an object contains a reference to its
class object, for example, the @mnm{->} method returns a
reference to the actual object, so you can work with the
actual object representation of the C value.

This can be a bit tricky in practice, because you need to
make sure that a program knows what class of object to expect
in return - a @code{String,} @code{Integer,} or
@code{Symbol}.

Often Ctalk can tell by the context of a statement what
class of object to expect, as in this example.

@example

int main () @{
  Integer new i;
  Integer new mbrInteger;
  String new mbrString;
  Symbol new mbrSymbol;

  mbrString = i -> __o_name;
  printf ("name: %s\n", mbrString);
  mbrString = i -> __o_classname;
  printf ("classname: %s\n", mbrString);
  mbrSymbol = i -> __o_class;
  printf ("class: %p\n", mbrSymbol);
  mbrString = i -> __o_superclassname;
  printf ("superclassname: %s\n", mbrString);
  mbrSymbol = i -> __o_superclass;
  printf ("superclass: %p\n", mbrSymbol);
  mbrSymbol = i -> __o_p_obj;
  printf ("parent: %p\n", mbrSymbol);
  mbrString = i -> __o_value;
  printf ("value: %s\n", mbrString);
  mbrInteger = i -> scope;
  printf ("scope: %d\n", mbrInteger);
  mbrInteger = i -> nrefs;
  printf ("references: %d\n", mbrInteger);
  mbrSymbol = i -> instancevars;
  printf ("instancevars: %p\n", mbrSymbol);
  mbrSymbol = i -> classvars;
  printf ("classvars: %p\n", mbrSymbol);
  mbrInteger = i -> instance_methods;
  printf ("instance methods: %p\n", mbrInteger);
  mbrInteger = i -> class_methods;
  printf ("class methods: %p\n", mbrInteger);
  mbrSymbol = i -> prev;
  printf ("prev: %p\n", mbrSymbol);
  mbrSymbol = i -> next;
  printf ("next: %p\n", mbrSymbol);
@}

@end example

That's because the @mnm{=} method of each receiver -
@code{mbrString}, @code{mbrInteger}, and @code{mbrSymbol} -
perform the necessary type conversions.

However, if you use the @mnm{->} method inline, as in this
statement:
@example
stdoutStream printOn "name: %s\n", self -> __o_name;
@end example
You need to make sure that the method @code{printOn} (from
@code{WriteFileStream} class in this example) knows what
class the argument @code{self -> __o_name} is going to
return.  For arguments that are members of common classes
like @code{String} and @code{Integer} objects, this normally
isn't a problem.

Symbol objects, however, can be trickier, because they are
references.  So to get the actual C pointer to an
@code{OBJECT}  type, a program needs to use a statement like
the following.
@example
stdoutStream printOn "superclass: %p\n", self -> __o_superclass asSymbol;
@end example

This can lead to some very convoluted statements.  To
retrieve the @code{value} instance variable of an object
reference, you would need a statement or two like these examples.
@example
__objectRef getValue -> instancevars getValue value;
@end example
Or even more confusingly,
@example
refValue become __objectRef getValue -> instancevars getValue value;
@end example

As mentioned in the last section, assigning an object to a
@code{Symbol} or using the @mnm{asSymbol} method have the
effect of dereferencing an object, similar to referencing
and dereferencing objects in C with the @samp{*}, @samp{&},
@samp{->}, and @samp{.} operators.  The effective use of these
C operators takes practice, and the same is true of Ctalk.

So you can have a series of statements like the following
example.  
@example
Symbol new varValue;
...
varValue = self -> instancevars;
myString printOn "value: %s (%s)\n",
  varValue getValue value -> __o_value,
  varValue getValue value -> __o_classname;
@end example
But you can also reference and then dereference an object
multiple times.
@example
Symbol new varValue;
...
varValue = self -> instancevars asSymbol;
myString printOn "value: %s (%s)\n",
  varValue getValue getValue value -> __o_value,
  varValue getValue getValue value -> __o_classname;
@end example

There's another, more serious issue when parsing instance
variables.  That is, if Ctalk needs to make a copy of an
instance variable, it cannot also copy the links to the
object's other instance variables.  To work reliably, Ctalk
would need to copy the entire set of objects.  That means,
normally, you would not be able to loop through a set of
instance variables to examine their contents.

Instead, you would need to create statements like these:
@example
__objectRef getValue -> instancevars -> next getValue value;
__objectRef getValue -> instancevars -> next -> next getValue value;
...
@end example 
And this is probably not what you want, and Ctalk does not
provide special handling for @mnm{->} arguments, because
@mnm{->}, as much as possible, needs to work like any other
method.  

@cindex @mnm{mapInstanceVariables} instance method @idxclscite{Object}
@cindex @mnm{mapClassVariables} instance method @idxclscite{Object}
Instead, Ctalk provides a method, @mnm{mapInstanceVariables},
defined in @code{Object} class, that performs this work for
you. (There is also a @mnm{mapClassVariables} method,
described below.)  It works similarly to the @mnm{map} methods in
@code{List} and other collection classes, except that it
works specifically on instance variable lists.  It's also
designed to handle object references differently.

For example, this program looks rather simple.
@c ctalk/test/expect/mapvars1.c
@example
int main () @{
  Symbol new sym;
  Point new p;
  p x = 100;
  p y = 150;

  sym = p;

  sym getValue mapInstanceVariables @{
    if (self -> __o_name != "value") @{
      printf ("name:  %s\n", self -> __o_name);
      printf ("value: %d\n", self value -> __o_value asInteger);
    @}
  @}
@}
@end example
Except that there is a slight pitfall - @code{sym} is a @code{Symbol},
that is a reference to a @code{Point} object, @code{p}, and Ctalk
can't determine the actual class of the block's receiver until the
program is run.  (The @mnm{=} method in the statement @code{sym = p;}
doesn't have very many special semantics, either.)

However, @mnm{mapInstanceVariables} can take this factor
into account, and it will check for possible receiver
classes and if necessary issue a warning.  

The output of the example above looks something like this.
@example
Warning: From mapInstanceVariables (class Object):
Warning: The argument block thinks the receiver's class is, "Symbol,"
Warning: when it is actually, "Point."
name:  x
value: 100
name:  y
value: 150
@end example

If you want to avoid the warning, you can rewrite the program like this.
@c ctalk/test/expect/mapvars3.c
@example
int main () @{
  Point new p;
  p x = 100;
  p y = 150;

  p mapInstanceVariables @{
    if (self -> __o_name != "value") @{
      printf ("name:  %s\n", self -> __o_name);
      printf ("value: %d\n", self value -> __o_value asInteger);
    @}
  @}
@}
@end example

@cindex @mnm{asInteger} instance method @idxclscite{String}
@cindex @mnm{asInteger} instance method @idxclscite{Magnitude}
You should also note that @mnm{->} returns the value of an object as a
@code{String} object.  That means if the program needs to perform any
numeric conversions, it should first morph the result into an
@code{Integer}, @code{Float}, or other class, using @mnm{asInteger}
(defined in @code{Magnitude} and @code{String} classes), and so on.

@cindex @mnm{printOn} instance method @idxclscite{String}
@cindex @mnm{printOn} instance method @idxclscite{WriteFileStream}
@cindex @mnm{writeFormat} instance method @idxclscite{String}
@cindex @mnm{writeFormat} instance method @idxclscite{WriteFileStream}
Here is an example of how you might manage some simple
numeric conversions, with class variable receivers provided
by the @mnm{mapClassVariables} method, defined in
@code{Object} class.  When working with objects, methods
like @mnm{printOn} and @mnm{writeFormat} (defined in
@code{String} and @code{WriteFileStream} classes) are better
at formatting the values of objects than simply using
@cite{printf(3)}.

@c ctalk/text/expect/mapvars2.c
@example
int main () @{
  WriteFileStream new w;
  String new s;
  String new s_element;
  Symbol new varRef;

  s = "";
  w mapClassVariables @{
    varRef = self;
    s_element printOn "%s (%s)\n",
      varRef getValue -> __o_name,
      varRef getValue -> __o_classname;
    s = s + s_element;
    s_element printOn "%d (%s)\n",
      varRef getValue -> __o_value asInteger,
      varRef getValue -> __o_classname;
    s = s + s_element;
  @}
  stdoutStream writeFormat "%s\n", s; 
@}
@end example
Here the use of @mnm{writeFormat} is mainly for
illustration.  It is likely that @mnm{writeFormat} will be
deprecated in future releases.

There will certainly be times when you need to work with
object references in C. and there are a number of Ctalk
library API functions that can help you translate between
object values (which are represented internally as formatted
@code{char *}'s), and C variables, and vice versa.  These
functions and others appear in many of the examples in this
this document and are described in more detail in the
@cite{Ctalk Language Reference.}
@example
void *__ctalkGenericPtrFromStr (char *);
void __ctalkObjValPtr (OBJECT *, void *);
void *__ctalkStrToPtr (char *);
char   __ctalk_to_c_char (OBJECT *);
double __ctalk_to_c_double (OBJECT *);
int    __ctalk_to_c_int (OBJECT *);
char   *__ctalk_to_c_char_ptr (OBJECT *);
void   *__ctalk_to_c_ptr (OBJECT *);
long long int __ctalk_to_c_longlong (OBJECT *);
OBJECT *obj_ref_str (char *);
@end example

@iftex
@section Default Methods and Instance Variable Messages
@end iftex
@ifnottex
@subheading Default Methods and Instance Variable Messages
@end ifnottex
@c @subheading Default Methods and Instance Variable Messages

@cindex Default method
@cindex @code{value} method @idxclscite{Object}
We should mention explicitly one other point about
methods and messages, and it is related to some of the
examples in the previous sections.  Ctalk objects also
respond to messages that name instance variables.

All Ctalk objects contain the instance variable, @code{value,} which
is inherited from class @code{Object.}  Because of this, if you use an
object without a message, Ctalk uses the @code{value} message by
default.  

In this simple example, the following two statements are equivalent.
@example
printf ("%d\n", myInt);

printf ("%d\n", myInt value);
@end example

With more complex objects, for example like those in the @code{Stream}
and @code{Pane} subclasses, statements that contain instance variable
messages can quickly become complex.  The later chapters and code
snippets in @cite{The Ctalk Language Reference} describe how to use
instance and class variable messages with complex objects.

The example from the previous section is typical.
@example
Point new p;
p x = 100;
p y = 150;
...
@end example
Here @mnm{x} and @mnm{y} are not methods, but instance
variables defined in @code{Point} class.  These messages
often work like method messages in expressions, except that
you can also assign values to them, by giving the name of
the instance variable and the object it belongs to.

@iftex
@section Assigning and Evaluating Complete Objects
@end iftex
@ifnottex
@subheading Assigning and Evaluating Complete Objects
@end ifnottex

The rules for using a default @mnm{value} method have a few exceptions.
They occur mainly when Ctalk translates between objects and C.  That's
partly because C normally assigns objects by value, while Ctalk works
with object references.  This manual discusses object references here
and in more detail later on, but here we'll mention the exceptions so
that you're aware of them.

As we'll get to, objects are represented internally as an @code{OBJECT
*} C type, and that's how programs access them using C.

So we can assign an object to a C variable with a set of statements
like the following.

@example

Object new myObj;       /* A Ctalk object. */
OBJECT *myObj_alias;    /* A C reference to an object. */

myObj_alias = myObj;    

@end example

Then you can access the object using the @code{myObj_alias} 
variable.  

In this case, Ctalk doesn't try to cast the object - it's already an
@code{OBJECT *}.  That is, Ctalk doesn't consider that there's an
implicit @mnm{value} message following the object.  (Though you can, of 
course, add a @mnm{value} message to the statement if you actually do
want the value.)

The same is true of using @code{printf ()} to print an object.  If
Ctalk sees that you want to print a pointer, and there's no message
following the object, then Ctalk does just that.  These statements 
simply print the address of an object.

@example

printf ("%p\n", myObject);
printf ("%#x\n", myObject);

@end example

The second @code{printf ()} statement might generate a warning with
some compilers, but as long as pointers are the same size as
@code{ints}, the statement should work fine.

The other case where the complete object is used on its own is in the
case of the @code{self} keyword.  Ctalk doesn't consider that it has a
default @mnm{value} message following it.  So the examples above are
true for @code{self} also.

@example

OBJECT *self_alias;    /* A C reference to an object. */

self_alias = self;

printf ("%p\n", self);
printf ("%#x\n", (unsigned int)self_alias);  /* The cast prevents 
                                                a warning from the
                                                compiler. */

@end example

@cindex @code{eval} keyword
Finally, if there's a C statement that you @emph{don't} want Ctalk to
evaluate as a value assignment, you can always use the @code{eval}
keyword to so that Ctalk interprets the statement verbatim.

@example

myObj_alias = myObj;      /* These two statements are equivalent. */
myObj_alias = eval myObj;

@end example

@iftex
@section Class Objects and Introspection
@end iftex
@ifnottex
@subheading Class Objects and Introspection
@end ifnottex

No object oriented programming manual would be complete without some
discussion of the way objects refer to themselves.  The semantics
of objects might seem obvious after a bit, but they cause Ctalk to
use another set of rules when referring to classes themselves.

For example, if a program contains the statements,

@example

myString = "Key";                     /* Select the Key class. */
printf ("%s\n", myString superclassName);

@end example

The program will display, @samp{Character,} which is the superclass
of @code{String} class, and not @code{Symbol}, which is the superclass
of @code{Key} class.

@cindex @mnm{classObject} instance method @idxclscite{Object}
For these cases, the method @mnm{classObject} (in @code{Object}
class), provides the actual class object when you give it a class
name.

With the use of @mnm{classObject}, the code sample would become
this.

@example

myString = "Key";                 
myClassObj = myString classObject;
printf ("%s\n", myClassObj superclassName);

@end example

As a general rule, if you're working with elements of an object,
it's safer to work on the actual object, and not another object
that simply contains a classes' name.  

However, if you're trying to find information that's external to an
object, for example, its file path in the class library, it's safe to
use the name of a class expressed as the value of a @code{String}
object.

@cindex @command{classdoc} program
The difference is not always clear-cut, and it might take some
checking of what kind of receiver the method expects and what its
function is in order to figure out how a class argument's semantics
are going to work.  Here's a fragment from the @command{classdoc}
program that provides a small illustration of this.  Refer to the
manual page, @cite{classdoc(1)} for more information about
@command{classdoc.}

@example
Application new classDocApp;
String new classArg;
Object new classObj;

classObj = classArg classObject;  /* classArg contains the class name
                                     supplied by the user. */

printf ("%s\n", classObj superclassName);
printf ("%s\n", classArg libraryPath);
printf ("%s\n", classDocApp classDocString classObj);

@end example

@node File input and output, Self and super, Basic classes, Top
@iftex
@chapter File Input and Output
@end iftex
@ifnottex
@heading Input and Output
@end ifnottex

This chapter describes how Ctalk performs basic file operations -
opening, closing, reading, and writing files.

@cindex @code{FileStream} class
@cindex @code{ReadFileStream} class
@cindex @code{WriteFileStream} class
@cindex @code{DirectoryStream} class
There are three classes that provide file input and output:
@code{ReadFileStream,} which implements objects and methods for
reading from files, @code{WriteFileStream,} which provides methods and
objects for writing to files, and their superclass, @code{FileStream,}
which provides methods and class definitions that are common to both
reading and writing files.  There is also a @code{DirectoryStream}
class, which this chapter describes below.

Ctalk provides many of the same facilities that C's @code{stdio.h}
library functions provide, although the language implements them as
objects.  

@cindex @mnm{openOn} method @idxclscite{ReadFileStream}
Here is an example that shows how to use the @mnm{openOn} method
(class @code{ReadFileStream}).
@example
ReadFileStream new myInput;

myInput openOn "myFileName";
@end example

If the program was able to to open the file, you can then read input
from the @code{myInput} stream.

We should note here that Ctalk also provides classes and methods that
handle file I/O errors.  We will deal with them later on.  If you
need to see how to catch file I/O errors right now, look at some of
the example programs in the Ctalk package, especially @flnm{ctwc.c.}

Opening a file for output is similar to opening a file for input,
except that the stream is an instance of class @code{WriteFileStream.}
@example
WriteFileStream new myOutput;

myOutput openOn "outputFileName";
@end example

@cindex @mnm{readChar} method @idxclscite{ReadFileStream}
@cindex @mnm{readLine} method @idxclscite{ReadFileStream}
@cindex @mnm{readAll} method @idxclscite{ReadFileStream}
@cindex @mnm{writeChar} method @idxclscite{WriteFileStream}
@cindex @mnm{writeStream} method @idxclscite{WriteFileStream}
@cindex @mnm{readRec} method @idxclscite{ReadFileStream}
After a program has opened the file streams successfully, you can read
and write from them with the following methods.
@example
Operation                           Reading    Writing
---------                           -------    -------
Read or write one character.        readChar   writeChar
Read or write one line.             readLine   -
Read or write all the data.         readAll    writeStream
Read or write formatted data.       readFormat printOn
Read fixed length data.             readRec
@end example

Here is a simple example that shows opening a file, and reading each
character.
@example
ReadFileStream new inputChars;
Character new c;

inputChars openOn "inputFileName";

while ((c = inputChars readChar) != EOF) 
  printf ("%c", c);
@end example

When @mnm{readChar} reaches the end of a file, it returns an
@code{EOF} character, which is @samp{-1} on most systems.

@cindex @mnm{streamEof} method @idxclscite{FileStream}
Using the method @code{streamEof} (class @code{FileStream}) to check for the
end of the input is slightly more reliable than looking for an
@code{EOF} character, because it distinguishes the end of the input
caused by an error from the end of the input caused by reaching the
end of a file.
@example
ReadFileStream new inputChars;
Character new c;

inputChars openOn "inputFileName";

while (TRUE) @{             /* Loop until the end of the input. */
  c = inputChars readChar;
  if (inputChars streamEof)
    break;
@}
@end example

@cindex @mnm{readAll} method @idxclscite{ReadFileStream}
If you don't need to examine each character as it is read, however,
then you can simply use @mnm{readAll} (class @code{ReadFileStream}),
which provides the complete input as a @code{String} object.
@example
ReadFileStream new inputStream;
String new inputString;

inputStream openOn "myInput";
inputString = inputStream readAll;
printf ("%s", inputString);
@end example

@cindex @mnm{readLine} method @idxclscite{ReadFileStream}
@cindex @mnm{writeStream} method @idxclscite{WriteFileStream}
Simple applications can use the methods @mnm{readLine} (class
@code{ReadFileStream}) and @mnm{writeStream} (class @code{WriteFileStream})
together to process input.

Here is a portion of the program @flnm{ctrep.c.} You find the program in
the Ctalk package.  It checks the input for occurrences of a character
string, and replaces the string before writing the output.
@example
/*
 *  Loop until the end of input.
 */
while (TRUE) @{
  line = stdinStream readLine;
  if (stdinStream streamEof)
    break;
  inputLineLength = line length;

  word = "";

  for (i = 0; i < inputLineLength; i = i + 1) @{
    inputChar = line at i;
    if (inputChar isSpace) @{
    if (word == pattern) @{
      stdoutStream writeStream replacement;
    @} else @{
      stdoutStream writeStream word;
    @}
      stdoutStream writeStream inputChar;
      word = "";
    @} else @{
      word = word + inputChar asString;
    @}
  @}
@}
@end example

@subheading Standard Input and Standard Output
@cindex @code{stdinStream} class variable @idxclscite{ReadFileStream}
@cindex @code{stdoutStream} class variable @idxclscite{WriteFileStream}

Notice that the previous example used @code{stdinStream} and
@code{stdoutStream} as its input and output streams.  

These two objects are class variables of @code{ReadFileStream} and
@code{WriteFileStream,} respectively.  They represent the program's
standard input (@code{stdin}) and standard output (@code{stdout}) file
streams.

Because @code{ctrep.c} is a filter program, it uses these two streams
instead of streams that work with normal files.

@cindex @code{stderrStream} class variable @idxclscite{WriteFileStream}
Class @code{WriteFileStream} also implements the @code{stderrStream}
class variable, which represents the application's standard error
(@code{stderr}) stream.

@cindex @cite{printf(3)} C function.
You should notice, also, that most of the examples so far have used
@code{printf} to print output.  You can accomplish the same task with
the following Ctalk statement.
@example
stdoutStream writeStream "Hello, world!\n";
@end example

This is equivalent to:
@example
printf ("Hello, world!\n");
@end example

Ctalk initializes @code{stdinStream} automatically when the program
creates the first @code{ReadFileStream} object, and it initializes
@code{stdoutStream} and @code{stderrStream} when the program creates 
the first @code{WriteFileStream} object.

@cindex @mnm{classInit} method @idxclscite{ReadFileStream}
@cindex @mnm{classInit} method @idxclscite{WriteFileStream}
If the program simply needs to use @code{stdinStream,}
@code{stdoutStream,} or @code{stderrStream} without opening files,
then it can call the class method @code{classInit} with either the
class @code{ReadFileStream} or @code{WriteFileStream} as the receiver.
@example
ReadFileStream classInit;    /* Initialize stdinStream. */
WriteFileStream classInit;   /* Initialize stdoutStream and stderrStream. */
@end example

Here is the example from the previous chapter that printed elements of
arrays.  This version uses @code{stdoutStream} to output the array
elements.
@c test/expect/examples/array4.c
@example
Array instanceMethod printArrayElement (void) @{

  WriteFileStream classInit;

  stdoutStream writeStream self;

  return NULL;
@}

int main () @{

  Array new myArray;

  myArray atPut 0, "My";
  myArray atPut 1, "name";
  myArray atPut 2, "is";
  myArray atPut 3, "Bill";

  myArray map printArrayElement;

  printf ("\n");

  myArray atPut 3, "Joe";

  myArray map printArrayElement;

  printf ("\n");
@}
@end example

The @code{printArrayElement} method initializes class
@code{WriteFileStream.}  You need to perform the class initialization 
before the class is first used in the program.  There is no problem
with calling @code{classInit} multiple times, however, because the
method checks to determine if the class is already initialized.

@subheading Directories

@cindex @code{DirectoryStream} class
@cindex Directories

@cindex @mnm{mkDir} method @idxclscite{DirectoryStream}
@cindex @mnm{rmDir} method @idxclscite{DirectoryStream}
The class @code{DirectoryStream} provides the methods @mnm{mkDir} and
@mnm{rmDir} which create and delete directories.  The methods function
exactly as their C library counterparts, except that they raise a
@code{SystemErrnoException} on error and return an @code{Integer} with
the value @code{-1}.  

@cindex @code{CTALK_DIRECTORY_MODE} macro
Ctalk uses @code{0755} (@samp{drwxr-xr-x}) as the default mode for new
directories.  Programs can change that value by redefining the macro 
@code{CTALK_DIRECTORY_MODE}.

Here is a program that creates a new directory.
@c test/expect/examples/mkdir1.c
@example
/* 
 * Define more restrictive permissions for 
 * new directories. Undefine the macro first
 * to avoid a warning message.
 */
#undef CTALK_DIRECTORY_MODE
#define CTALK_DIRECTORY_MODE 0700

int main () @{

  DirectoryStream new thisDir;

  thisDir mkDir "testDir";

@}
@end example

The @mnm{rmDir} method works similarly to the @mnm{mkDir} method.
@c test/expect/examples/rmdir1.c
@example
int main () @{

  DirectoryStream new thisDir;

  thisDir rmDir "testDir";

@}
@end example

@subheading Standard Input and Standard Output Implementations
@cindex @code{stdin}
@cindex @code{stdout}
@cindex @code{stderr}
@cindex @code{stdinStream} @idxclscite{ReadFileStream}
@cindex @code{stdoutStream} @idxclscite{WriteFileStream}
@cindex @code{stderrStream} @idxclscite{WriteFileStream}
The C99 standard requires that @code{stdin,} @code{stdout,}
and @code{stderr} should be implemented as macros, which on
some systems (notably Solaris) causes problems with
C-to-object translation.  

If Ctalk cannot register the macros as C variables, then you
must call C functions like @cite{sscanf(3)} and
@cite{fscanf(3)} with only C variables, or use a method
with @code{stdoutStream} or @code{stderrStream}
(@code{WriteFileStream} class), or @code{stdinStream}
(@code{ReadFileStream} class).

@cindex GNU Readline 
@cindex @mnm{consoleReadLine} method @idxclscite{String}
@subheading Console Input
The method @mnm{consoleReadLine} (in class @code{String}) prints a
prompt string, and then waits for you to enter a line of text.  What
makes this method special is that it uses the GNU readline library's
standard command editing and history features, if you built Ctalk with
readline support (see the options to the configure script for
details). In that case, Ctalk also defines the
@code{HAVE_GNU_READLINE} macro to @samp{1}.  Here is an simple example
of how to use @mnm{consoleReadLine}.
@example
int main (int argc, char **argv) @
  String new s;
  String new promptStr;

  if (argc > 1)
    promptStr = argv[1];
  else
    promptStr = "Prompt ";

  printf ("Readline test.  Type ^C or, \"quit,\" to exit.\n");
#if HAVE_GNU_READLINE
  printf ("Ctalk built with GNU Readline Support.\n");
#else
  printf ("Ctalk built without GNU Readline Support.\n");
#endif
  while (1) @
    s consoleReadLine promptStr;
    printf ("You typed (or recalled), \"%s.\"\n", s);
    /*
     *  Matches both, "quit," and, "quit\n."
     */
    if (s match "quit")
      break;
  @}
@}
@end example


@node Self and super, Collections, File input and output, Top
@iftex
@chapter @code{self} and @code{super}
@end iftex
@ifnottex
@heading @code{self} and @code{super}
@end ifnottex
@cindex @code{self}
@cindex @code{super}

The @code{self} and @code{super} keywords refer to receivers and
superclass methods at run time.  They allow you to write methods
without knowing beforehand what objects called them.

@iftex
@section @code{self} Is a Receiver
@end iftex
@ifnottex
@subheading @code{self} as a Receiver
@end ifnottex

Within a method, @code{self} refers to the receiver of the method that
@code{self} appears in.  Within the method, you can use self
interchangeably with other receivers.

When used as a receiver, Ctalk's @code{self} works much like
the @code{self} keyword in Smalltalk and the @code{this} keyword in C++.

In this example, @code{self} in the method @code{add2} refers to
the method's receiver, @code{myInt,} which is declared in @code{main.}
@c test/expect/examples/add2.c
@example
Integer instanceMethod add2 (void) @{
  methodReturnInteger(self + 2);
@}

int main () @{
  Integer new myInt;
  Integer new myTotal;

  myInt = 2;
  myTotal = myInt add2;
  printf ("%d\n", myTotal);
@}
@end example

You need to be careful of using @code{self} within a constructor (a
@mnm{new} method), because the method's receiver is the class object
of the instance you are creating, and not the new object itself, and
that is probably not what you want.  Ctalk prints a warning message in
this case if you enable verbose warnings with the @samp{-v} command
line option.

@iftex
@section The @code{super} Keyword
@end iftex
@ifnottex
@subheading The @code{super} Keyword
@end ifnottex
@cindex @code{super} keyword

When used before a message, @code{super} tells Ctalk that the
message refers to a method in the superclass of the receiver.  

One use of @code{super} is in constructors of subclass objects.  The
keyword allows constructor methods, which are almost always called
@code{new,} to refer to the constructor of a superclass, which allows
subclass objects to inherit the instance variables of its
superclasses.

The example in the first chapter, of how @code{FileStream} and its
subclasses inherit instance variables, describes how constructors can
call class constructors.  @xref{Class Hierarchy}.

To show how @code{super} is used, here is the @code{new} method from
class @code{WriteFileStream}.
@cindex @mnm{new} method @idxclscite{WriteFileStream}
@example
WriteFileStream instanceMethod new (char *name) @{

  WriteFileStream super new name;

  __ctalkInstanceVarsFromClassObject (name);

  WriteFileStream classInit;
  
  return name;
@}
@end example

@iftex
@section @code{super} Used as a Receiver
@end iftex
@ifnottex
@subheading @code{super} Used as a Receiver
@end ifnottex
@cindex @code{super} used as a receiver

When used within an argument block, @code{super} can refer to
the receiver of the method that contains the argument block.

This overloading of @code{super} conveniently allows methods
to refer to both the collection that maps the argument block
(by referring to @code{super} within the block), and to each
element of the collection (by referring to @code{self}
within the block).

To help make this clear, look at the following example.

@example

List instanceMethod mapPrint (void) @{
  String new sPrefix;
  String new s;
  Integer new n;
  sPrefix = "This element is ";
  n = 0;

  /* 
   *   Here, "self," refers to the receiver of the mapPrint method,
   *   the List l that was declared in main ().
   */
  self map @{  

    /* 
     *  Within the code block, though, "self," refers to each element 
     *  of List l in succession. 
     */
    s = sPrefix + self;
    printf ("%s\n", s);

    /*
     *  Here, "super," refers to the List l, because it's
     *  the receiver of the mapPrint method which contains
     *  the argument block.
     */
    super push "l3";

    /* break after printing "...l1," "... l2," and four "... l3" 
       strings. */
    n = n + 1;
    if (n >= 6)
      break;
  @}
  return NULL;
@}

int main () @{

  List new l;

  l push "l1";
  l push "l2";

  l mapPrint;

  exit(0);
@}

@end example

If you use @code{super} in an argument block within a function, which
doesn't have a receiver object, then Ctalk uses the object that is the
receiver of @mnm{map} or whatever iterative method has the code
block as its argument.  

In this case, Ctalk issues a warning so that you know which receiver the
argument block actually refers to.

@iftex
@section Determining the Class of @code{self}
@end iftex
@ifnottex
@subheading Determining the Class of  @code{self}
@end ifnottex
@cindex @code{self}, class of
@anchor{self Class Resolution}

Generally, the receiver object that @code{self} refers to belongs to
the same class as the method where it appears.  But there are many
occasions when a method cannot assume that it knows in advance the
class of @code{self}, or the result of an expression that contains
@code{self}.  This section describes a few of these situations and how
to deal with them.

In many cases, programs can use the method @mnm{is} (defined in
@code{Object} class) to determine the class of an object.  The
argument to @mnm{is} must be a declared class, and the method
returns True or False, depending on whether the receiver is
an instance of the class given as the argument.

To determine if an object is a class object, use @mnm{isClassObject}
(also defined in @code{Object} class), to determine if an object is a
class object.  

These examples illustrate the different expressions.

@example

if (self is String) @{   /* OK - String is a defined class. */
 ...
@}

if (self is Class) @{    /* Not OK - 'Class' is not a defined class. */
 ...
@}

if (self isClassObject) @{  /* OK - Just check whether the object is
 ...                           its own class object. */
@}

@end example

But there are also many cases where the class of a receiver is not
be so clear-cut.  A method might be declared in a superclass of the
receiver, or the method might need to work objects that are members of
a collection, as in this example.  A method might belong to the class
of a collection like @code{List} or @code{AssociativeArray}, but the
collection's elements may be another class entirely.

In collections, the receiver object is actually a group of @code{Key}
class objects, which is the ``glue'' class that provides the
organization of the collection's members.  Each @code{Key} object
contains a reference to an object that is part of the collection's
actual contents.

The method below is from the @flnm{ctcheckquery.c} example program,
and the receiver contains the parameters and values of a CGI query.

This method can be relatively simple because it can assume beforehand
that the values it is going to print are instances of @code{String}
class.  The actual receiver is an instance of @code{Key} class, so
@code{self} in this method understands both the @mnm{name} and
@mnm{getValue} methods, which are defined in @code{Symbol} class,
which is the superclass of @code{Key} class.

@example
AssociativeArray instanceMethod printQueryParamPair (void) @{
  printf ("<tt>%s=", self name);
  printf ("\"%s\"</tt><br>\n", self getValue);
  return NULL;
@}
@end example

If a method needs to perform more complex operations on collection
members, it can often cast the collection member to an object of a
known class with either @mnm{become} or just plain @mnm{=}, depending
on the class.  This hypothetical example shows one example of this.

@example

TreeNode new head;
TreeNode new siblingObject;

... /* Do some stuff. */

head siblings map @{
  siblingObject become self;  /* Ctalk waits until run-time to evaluate a
                                 "self" argument. */

  siblingObject children map @{

  ... /* Do some more stuff. */

  @}
@}

@end example

You can also use a @code{Symbol} object to refer to @code{self.}
Symbol class is designed to handle references of different classes,
so this example also works.

@example

TreeNode new head;
TreeNode new tChild;
Symbol new tSib;

....  /* Do some stuff. */

head siblings map @{
  *tSib = self;
  content = "Child Node";
  tChild = TreeNode basicNew content;
  tChild setContent content;
  tSib getValue addChild tChild;
@}

@end example

Still easier, but less flexible, is the @code{eval} operator, which tells
the compiler to wait until run time before actually evaluating the 
complete expression.

@example

X11Pane instanceMethod deleteAndClose (void) @{

  self children map @{
    eval self deleteAndClose;
  @}

  ...
@}

@end example

And finally, you can use a cast operator to tell the compiler the
class of @code{self}.  This feature is still experimental, but it is
often more convenient than using @code{eval} or creating an
intermediate object.

@example

TreeNode new head;

head siblings map @{

  printf ("%s\n", self content);

  (TreeNode *)self children map @{      /* Here, "(TreeNode *)" tells the
                                           compiler that we expect self
                                           to be a TreeNode object. */
    printf ("  %s\n", self content);
  @}

@}

@end example


@iftex
@subsection Method Dispatchers
@end iftex
@ifnottex
@subsubheading Method Dispatchers
@end ifnottex
@cindex @code{self}, class of

@cindex Dispatch methods
If you must use a complete, original receiver object from a collection
class, then the method cannot alias the original receiver to a local
object.  

@cindex @code{eval} keyword
In this case, the program can use another method to dispatch the
receiver's message to the correct at run time.  For this, the dispatch
method can use the @code{eval} keyword.

This situation is frequently the case with complex objects.   Here is
an example from @code{ANSIYesNoBoxPane} class that selects the highlight
of an already selected input pane.  

The receiver of the @mnm{focusButton} method's @mnm{map}
message is the widget's list of child windows (a @code{List}), and
this method checks the list element's class and dispatches the 
program to the @mnm{highlightButton} method of class
@code{ANSIButtonPane}.  

@anchor{highlightButtonExample}
@example
ANSIButtonPane instanceMethod highlightButton (void) @{
  if (self hasFocus) @{
    self focusHighlightOnOff;
  @} else @{
    self resetGraphics;
  @}
  return NULL;
@}

List instanceMethod highlightButton (void) @{
  Exception new e;
  if (self value is ANSIButtonPane) @{
    eval self highlightButton;
  @} else @{
    e raiseCriticalException INVALID_RECEIVER_X, 
      "Receiver of \"highlightButton\" is not an ANSIButtonPane object";
  @}
  return NULL;
@}

ANSIYesNoBoxPane instanceMethod focusButton (void) @{
  self children map highlightButton;
  return NULL;
@}
@end example

Note that when checking the class, the program uses
@example
if (self value is ANSIButtonPane) @{ ...
@end example

This is because the receiver, a button widget, is an instance variable
of an @code{ANSIYesNoBoxPane} object, so its member class is also
@code{ANSIYesNoBoxPane}, but its @emph{value} is
@code{ANSIButtonPane}.

@code{Exception} handling, for example the use of the
@code{Exception} object in the @code{List} implementation of
@mnm{highlightButton}, is discussed further in the section,
@cite{Error Handling and Debugging.} @xref{Debugging}.

You can also write most of a method in C, if necessary.

Here is the @mnm{asInteger} method from class @code{Magnitude.}
Generally, only the @code{Object} class is completely evaluated before
this method, so @mnm{asInteger} needs to perform many of its
operations in C.  However, it can use the method @mnm{is} from
@code{Object} class to determine the class of the receiver.

@example

Magnitude instanceMethod asInteger (void) @{
  OBJECT *self_value;
  int i;
  long long int l;

  returnObjectClass Integer;

  self_value = self value;

  if (self is Integer) @{
    return self;
  @} else @{
    if (self is LongInteger) @{
      sscanf (self_value -> __o_value, "%lld", &l);
      if (l > MAX_UINT)
	_warning ("Overflow in type conversion.\n");
      i = (int)l;
    @}
    /*
     *  Character to int conversion, plus escape sequences.
     */
    if (self is Character) @{
      if (*self_value -> __o_value == '\'') @{
	if (self_value -> __o_value[1] == '\\') @{
	  switch (self_value -> __o_value[2])
	    @{
	    case 'a':
	      i = 1;
	      break;
	    case 'b':
	      i = 2;
	      break;
	    case 'f':
	      i = 6;
	      break;
	    case 'n':
	      i = 10;
	      break;
	    case 'r':
	      i = 13;
	      break;
	    case 't':
	      i = 9;
	      break;
	    case 'v':
	      i = 11;
	      break;
	    case '0':
	      i = 0;
	      break;
	    default:
 	      i = (int) self_value -> __o_value[2];
	      break;
	    @}
	@} else @{
 	  i = (int) self_value -> __o_value[1];
	@}
      @} else @{
 	i = (int) *self_value -> __o_value;
      @}
    @}  /* if (self is Character) @{ */

    if (self is Float) @{
      /*
       *  In case Exception class isn't loaded yet, simply
       *  print a warning.
       */
      _warning ("asInteger (class Magnitude): Receiver truncated to Integer.\n");
      i = (int)atof (self);
    @}
  @}
  methodReturnInteger (i);
@}
@end example

@iftex
@section Class of a Method Return Object
@end iftex
@ifnottex
@subheading Class of a Method Return Object
@end ifnottex

Often a program can determine the class of a method's return object
from the class of the receiver.  Sometimes, however, the
@code{returnObjectClass} statement is necessary.  Consider the
following example from @code{X11TerminalStream} class.

@c /// Next example here.
@example

X11TerminalStream instanceMethod parentPane (void) @{
  OBJECT *receiver_alias,
    *parent_alias;
  returnObjectClass X11Pane;
  receiver_alias = self;
  if (receiver_alias -> __o_p_obj) @{
    parent_alias = receiver_alias -> __o_p_obj;
  @} else @{
    parent_alias = NULL;
  @}
  return parent_alias;
@}
...
self parentPane origin x = event_data1;

@end example

If Ctalk couldn't determine that @mnm{parentPane} returns a
@code{X11Pane} object, it would not be able to determine that the
class of @code{origin} (an instance variable of @code{X11Pane}) is a
@code{Point}, and that @code{x} is an instance variable of
@code{origin}.

Defining the object return class also helps in checking the class of
arguments in complex statements.  This helps Ctalk determine what is
and isn't a method argument, as in this example.

@example

Integer new intA;
Integer new intB;

if (intA + intB == 4) 
  do something;

@end example

Here, Ctalk can determine that @mnm{==} isn't part of the argument to
@mnm{+}, because it returns a @code{Boolean}, while @mnm{+} expects an
@code{Integer} or an expression that returns an @code{Integer} as its
argument. 

The method's return class does not actually need to be
defined when Ctalk encounters the @code{returnObjectClass}
statement.  Ctalk checks later, after evaluating all of the
input, that the class is defined and prints a warning if it
still can't find the class.

@iftex
@section Determining the Class of Method Arguments
@end iftex
@ifnottex
@subheading Determining the Class of Method Arguments
@end ifnottex
@cindex Arguments, class of

While we're on the subject, we should mention that methods do not
always know the class of their arguments, either.  If the class of a
method argument can vary, that makes it even more difficult to handle
complex objects that contain numerous instance variables.

One way to deal with arguments of different classes is to duplicate
the argument into the class the method needs, as in this example, 
the @mnm{=} method from @code{Integer} class.
@example
Integer instanceMethod = set_value (int __i) @{ 
  Integer new localInt;
  localInt become __i asInteger;
  __ctalkAddInstanceVariable (self, "value", localInt value);
  return self;
@}
@end example

Remember, a method can specify the class or type of an argument, but
that doesn't mean, when the program runs, that the argument actually
@emph{is} the class that the method expects.

Another issue is trying to print objects.  If you were to write a
method like the following.
@example
MyClass instanceMethod myMethod (Object myArg) @{
   printf ("%s\n", myArg myInstanceVariable);
   return NULL;
@}
@end example
Then you would need to make sure that myInstanceVariable is a
@code{String}.  If possible, Ctalk tries to match the class of an
expression with its context; in the example above, if Ctalk cannot
determine the class of @code{myInstanceVariable} from the context of
the method, it will try to translate it into a @code{char *} argument
for @code{printf}.

There are a few ways that a method can determine the class of an
expression.  One is to use the @code{Object} method @mnm{is}, as in
the @mnm{asInteger} method in the previous section.

Another solution is to ``cast'' the argument to a local object using,
for example, the @code{Object} method @mnm{become}, as in the @mnm{=}
(class @code{Integer}) example above.

Yet another way to deal with an unknown argument class is to use a
@mnm{printOn} method.  The method is better than @code{printf} at
determining an object's class at run time.
@example
MyClass instanceMethod myMethod (Object myArg) @{
   WriteFileStream classInit;        
   stdoutStream printOn "%s\n", myArg myInstanceVariable;
   return NULL;
@}
@end example

Many classes implement a @mnm{printOn} method, and it is relatively
easy for a class that you write to define a @mnm{printOn} method also.
The Ctalk libraries take care of much of the work of translating
objects of different classes and formatting them correctly.  

The @mnm{printOn} methods can also use receivers other than stream
classes, so a method could use printOn to format a String, as in this
example. 
@example
String instanceMethod myIntConv (int myArg) @{
   self printOn "%s\n", myArg myIntVariable;
   return self;
@}
@end example

@node Collections, Classes, Self and super, Top
@iftex
@chapter Collections
@end iftex
@ifnottex
@heading Collections
@end ifnottex

Collections are groups of objects.  Ctalk has the following main
classes of collections.
@cindex @code{Array} Class
@cindex @code{AssociativeArray} Class
@cindex @code{List} Class
@cindex @code{Stream} Class
@itemize
@item
@code{Array} class, which orders elements of a group by a numerical
index. 
@item
@code{AssociativeArray} class, which orders and retrieves elements 
using a key value.
@item
@code{List} class objects, which contain groups of objects that you
can treat sequentially. 
@item
@code{Stream} class objects, which are generally groups of characters
similar to @code{String} class objects, that allow reading and writing 
to the collection.
@end itemize

@cindex @code{Collection} Class
@cindex @code{FileStream} Class
@cindex @code{ReadFileStream} Class
@cindex @code{WriteFileStream} Class
@cindex @code{TerminalStream} Class
@cindex @code{ANSITerminalStream} Class
@cindex @code{Win32TerminalStream} Class
@cindex @code{X11TerminalStream} Class
@cindex @code{TreeNode} Class
These classes are subclasses of @code{Collection} class.  Here is the
section of the class library that shows the organization of 
@code{Collection} and its subclasses.
@example
 Collection
  Array
  List
   AssociativeArray
  Stream
   FileStream
    DirectoryStream
    ReadFileStream
    WriteFileStream
   TerminalStream
    ANSITerminalStream
    Win32TerminalStream
    X11TerminalStream
  TreeNode
@end example
This chapter provides a description of the basic collection classes,
@code{AssociativeArray,} @code{List,} and @code{TreeNode.}

The previous chapters described @code{Array} and @code{Stream} subclasses
(the classes @code{FileStream,} @code{ReadFileStream,} and
@code{WriteFileStream}).  

The later sections that discuss graphics also discuss the
@code{TerminalStream} subclasses in the context of providing user
input, because these classes are intended to be used for input from
devices like keyboards and mice.


@iftex
@section @code{List} Class
@end iftex
@ifnottex
@subheading @code{List} Class
@end ifnottex
@cindex @code{List} Class
@anchor{ListClass}

@code{List} objects contain, as the class's name says, lists of objects.

@cindex @mnm{push} method @idxclscite{List}
If you want to add an item to the end of a @code{List,} use the method
@mnm{push.} 
@example
List new l;
Integer new i;
Integer new i2;

l push i;
l push i2;
@end example

@cindex @mnm{pop} method @idxclscite{List}
To remove items from the end of a list and return them, use
the method @mnm{pop.}
@example
List new l;
Integer new i;
Integer new i2;
Integer new i3;
Integer new i4;

l push i;
l push i2;

i3 = l pop;
i4 = l pop;
@end example

@cindex @mnm{shift} method @idxclscite{List}
@cindex @mnm{unshift} method @idxclscite{List}
The methods @mnm{shift} and @mnm{unshift} are similar to @mnm{push}
and @mnm{pop,} respectively, but they add and remove items from the
front of the list.

Here is a simple, if slightly unwieldy, example of how these methods
work.  You can find this program in @flnm{test/basiclist.c}.
@example
int main () @{

  List new l;
  Integer new i1;
  Integer new i2;
  Integer new i3;
  Integer new i4;
  Integer new i5;
  Integer new i6;

  i1 = 1;
  printf ("%d ", i1);
  i2 = 2;
  printf ("%d ", i2);
  i3 = 3;
  printf ("%d ", i3);
  printf ("\n");

  l push i1;
  l push i2;
  l push i3;

  i4 = l pop;
  printf ("%d ", i4);
  i5 = l pop;
  printf ("%d ", i5);
  i6 = l pop;
  printf ("%d ", i6);
  printf ("\n");

  l shift i1;
  printf ("%d ", i1);
  l shift i2;
  printf ("%d ", i2);
  l shift i3;
  printf ("%d ", i3);
  printf ("\n");

  i4 = l unshift;
  printf ("%d ", i4);
  i5 = l unshift;
  printf ("%d ", i5);
  i6 = l unshift;
  printf ("%d ", i6);
  printf ("\n");

  return 0;
@}
@end example
@cindex @mnm{map} method @idxclscite{List}
Generally, however, you want to be able to work with @code{Lists} of
any length.  The basic method for working sequentially with every item
in a list is the method @mnm{map.}
@example
List instanceMethod printItem (void) @{
  Integer new element;
  element = self;
  printf ("%d ", element);
  return NULL;
@}

int main () @{

  List new l;
  Integer new i1;
  Integer new i2;
  Integer new i3;

  i1 = 1;
  i2 = 2;
  i3 = 3;

  l push i1;
  l push i2;
  l push i3;

  l map printItem;
  printf ("\n");
@}
@end example
The argument to @mnm{map,} in this example @mnm{printItem,} must be an
instance method of class @code{List,} even though the receiver of each
call to @mnm{printItem,} which is each successive member of @code{List}
@code{l} (in @code{main()}), can have its own class.

This example uses @code{Integers} as list items, so we can assume
that @code{self} in the @mnm{printItem} method is always going to
be an @code{Integer.}  But programs cannot
always make assumptions about what class of items a @code{List} stores.
@xref{self Class Resolution}, for a detailed discussion.

@anchor{MapArguments} Some classes, including @code{List}, allow you
to provide an additional argument to the target method.  In that case,
you must use that argument as the second argument to @mnm{map,} after
the name of the method that's going to do work on each @code{List}
item.  These sorts of expressions are easier to write than to
describe.  So here's a revised version of the example above which
should make this clearer.

@example
                              /* Here, "leftMargin" is passed as    */
                              /* the second argument to map, below. */
List instanceMethod printItem (String leftMargin) @{
  Integer new element;
  element = self;
  printf ("%s%d ", leftMargin, element);
  return NULL;
@}

int main () @{

  List new l;
  Integer new i1;
  Integer new i2;
  Integer new i3;
  String new leftMargin;

  leftMargin = "  ";

  i1 = 1;
  i2 = 2;
  i3 = 3;

  l push i1;
  l push i2;
  l push i3;

  l map printItem, leftMargin;  /* "leftMargin" is the first argument when */
                               /* printItem is called.                    */
  printf ("\n");
@}
@end example

This syntax works only when the argument to @mnm{map} is a separate method,
not with argument blocks. @xref{ArgumentBlocks}.

@code{List} class actually allows you to pass two additional arguments to
the method that the list maps over.  Extending the number of arguments is
beyond the scope of this tutorial, but Ctalk internally can support a range
of conventions when mapping over @code{List} and other @code{Collection}
objects.

@cindex @mnm{=} instance method @idxclscite{List}
When initializing @code{Lists}, you can also use the @mnm{=} method
to add items to the @code{List}, which you may find more convenient.
You could replace the @mnm{push} methods in the example above with
this expression.

@example

  l = i1, i2, i3;

@end example

If you also want to skip the assignment statements for @code{i1, i2,}
and @code{i3,} the example above could also be written like this.

@example

  l = 1, 2, 3;

@end example

There's more information about initializing @code{Lists} and other
types of collections later in the Tutorial. 
@xref{InitializingCollections}.

@cindex @mnm{delete} instance method @idxclscite{List}
To remove all of the items from a @code{List} and leave the list as
it was when it was first created, you can simply use the @mnm{delete} method.

@example

myList delete;

@end example

Otherwise, a method like @mnm{pop} removes the object and returns it,
leaving it up to the program to either delete the object or use it elsewhere.
So if you want to remove (and in this case delete) individual objects from
a @code{list,} you can use an expression like this.

@example

while ((item = myList pop) != NULL)
  item delete;

@end example

Or even an expression like this one.

@example

While (item = myList pop)
      item delete;

@end example

Though if you simply say,

@example

while (myList pop)
 ; 

@end example

Then the program does nothing with the objects that were formerly
stored in @code{myList,} and the expression causes memory leaks, which
is especially noticeable if the program replaces the objects in the
@code{myList} one or more times.

@iftex
@subsection Creating Multiple Objects
@end iftex
@ifnottex
@subsubheading Creating Objects on the Fly
@end ifnottex
@cindex @mnm{basicNew} method @idxclscite{Object}

It's often tedious or impractical to declare each @code{List} member
separately.  For cases like that, Ctalk has a method called
@mnm{basicNew}, which creates objects on the fly, as in this
hypothetical example.

@example

List new myList;
Integer new listMember;
Integer new i;
String new nameStr;
String new valueStr;

for (i = 0; i < 10; i = i + 1) @{

    nameStr = "List Member " + i asString;
    valueStr = i asString;   

    listMember = Integer new nameStr, valueStr;

    myList push listMember;

@}

@end example

The @mnm{basicNew} method has several flavors, which are described in
the @cite{Ctalk Reference Manual.}

@iftex
@section @code{AssociativeArray} Class
@end iftex
@ifnottex
@subheading @code{AssociativeArray} Class
@end ifnottex
@cindex @code{AssociativeArray} Class

@cindex @code{Key} class
@code{AssociativeArray} objects store their elements using a
@code{Key} object.  

Programs use the name of the @code{Key} object, normally a @code{String,}
to store and retrieve elements of the array.  The value of the
@code{Key} object is the object that you want to store in the array.

@cindex @mnm{atPut} method @idxclscite{AssociativeArray}
@cindex @mnm{at} method @idxclscite{AssociativeArray}
The @code{AssociativeArray} class does the work of assigning keys and
storing objects in the arrays for you, using the methods @mnm{at} and
@mnm{atPut}.

For example, to store an object, use a statement similar to the following.
@example
myAssociativeArray atPut "keyName", myObject;
@end example

To retrieve an object, use the method @mnm{at}.
@example
myObjectFromBefore = myAssociativeArray at "keyName";
@end example

@cindex @mnm{map} method @idxclscite{AssociativeArray}
@cindex @mnm{mapKeys} method @idxclscite{AssociativeArray}
You can also treat @code{AssociativeArray} elements
sequentially, using the methods @mnm{map} and @mnm{mapKeys}.
The @cite{Ctalk Language Reference} contains examples of
their use.

@cindex @mnm{removeAt} method @idxclscite{Collection}
If you want to remove an object from an @code{AssociativeArray} or
another subclass of @mnm{Collection}, use the @mnm{removeAt} method.
The @mnm{removeAt} method returns the object that was stored in
the collection.  

@cindex @code{Key} class
The @cite{Ctalk Language Reference} describes the details of storing
and retrieving @code{Key} object names and values.

@iftex
@section @code{TreeNode} Class
@end iftex
@ifnottex
@subheading @code{TreeNode} Class
@end ifnottex
@cindex @code{TreeNode} Class

A @code{TreeNode} object is a component of a tree data structure.
Each @code{TreeNode} object can have sibling and child objects.  The
@code{TreeNode} class provides basic methods to add objects to a tree,
set each @code{TreeNode's} content, and to traverse the tree.

The example program shows two different ways to construct trees.  It
actually builds two trees, which are identified by their head nodes,
@code{head} and @code{head2}.

@c test/expect/examples/tree1.c
@example
TreeNode instanceMethod printNode (void) @{
  printf ("%s\n", self content);
@}

int main () @{

  TreeNode new head;
  TreeNode new head2;
  TreeNode new sibling;
  String new content;
  Symbol new sib;
  Symbol new child;
  TreeNode new tSib;
  TreeNode new tChild;
  TreeNode new tChildChild;
  Integer new i;

  content = "Head Node";

  head setContent content;

  head2 setContent content;

  printf ("%s\n", head content);

  for (i = 1; i <= 10; i++) @{
    content = "1. Sibling Node " + (i asString);

    *sib = TreeNode basicNew content, content;
    *sib setContent content;
    head makeSibling *sib;

    content = "Child Node";
    tChild = TreeNode basicNew content, content;
    tChild setContent content;
    (*sib) addChild tChild;

    content = "2. Sibling Node " + (i asString);

    tSib = tSib basicNew content, "TreeNode", "Symbol", content;
    tSib setContent content;
    head2 makeSibling tSib;

    content = "Child Node";
    tChild = TreeNode basicNew content;
    tChild setContent content;
    tSib addChild tChild;

  @}

  head2 siblings map @{
    content = "Child Node 2";
    tChild = TreeNode basicNew content, content;
    tChild setContent content;
    tSib = TreeNode basicNew "Sibling of Child";
    tSib setContent "Sibling of Child";
    tChild makeSibling tSib;
    (TreeNode *)self addChild tChild;

    content = "Child of Child";
    tChildChild = TreeNode basicNew content, content;
    tChildChild setContent content;
    tChild addChild tChildChild;

  @}

  printf ("--------------------\n");

  head2 map printNode;
@}
@end example

The program uses two different methods to add nodes to a tree, both contained
within the @code{for} loop.

@example

    /* Build the first tree by using Symbol objects to refer to the
       tree's nodes. */

    content = "1. Sibling Node " + (i asString);  

    *sib = TreeNode basicNew content, content;
    *sib setContent content;
    head makeSibling *sib;

    content = "Child Node";
    tChild = TreeNode basicNew content, content;
    tChild setContent content;
    (*sib) addChild tChild;


    /* Programs can also build trees by using TreeNode objects directly,
       though for complex programs this method may be less convenient. */

    content = "2. Sibling Node " + (i asString);

    tSib = tSib basicNew content, "TreeNode", "Symbol", content;
    tSib setContent content;
    head2 makeSibling tSib;

    content = "Child Node";
    tChild = TreeNode basicNew content;
    tChild setContent content;
    tSib addChild tChild;

@end example

Referring to @code{TreeNode} objects directly and by @code{Symbol} references
produces similar results here.  Using @code{Symbol} references, however,
might be more flexible in the case of complex programs.

@cindex @mnm{basicNew} method @idxclscite{Object}
@cindex @mnm{setContent} method @idxclscite{TreeNode}
@cindex @mnm{makeSibling} method @idxclscite{TreeNode}
@cindex @mnm{addChild} method @idxclscite{TreeNode}
In each case, adding nodes to the tree uses the same four methods:
@mnm{basicNew,} @mnm{setContent,} @mnm{makeSibling,} and @mnm{addChild.}

When run, the program produces output similar to this (somewhat
shortened) example.

@example
Head Node
--------------------
2. Sibling Node 1
Child Node
Child Node 2
Child of Child
Sibling of Child
2. Sibling Node 2
Child Node
Child Node 2
Child of Child
Sibling of Child

...

2. Sibling Node 10
Child Node
Child Node 2
Child of Child
Sibling of Child

@end example

@cindex @mnm{print} method @idxclscite{TreeNode}
@cindex @mnm{format} method @idxclscite{TreeNode}
@cindex @code{levelMargin} instance variable @idxclscite{TreeNode}
@cindex @code{levelMarginLength} instance variable @idxclscite{TreeNode}
If you want each level of the tree indented, you can use either the
@mnm{print} method to print the tree to the screen, or @mnm{format} to
format the tree to a @code{String} object.  The class provides the
@code{levelMargin} and @code{levelMarginLength} instance variables,
which allow programs to specify the indentation of each level.

@iftex
@section Collection Elements as Receivers
@end iftex
@ifnottex
@subheading Collection Elements as Receivers
@end ifnottex

When using collection elements, programs often don't know until run
time exactly what the class of a receiver might be - elements of
object.  In addition methods like @mnm{map}, use each element
of a collection as a receiver.  

Collections all use @code{Key} objects to store the actual data.  
In methods that use collection elements, programs can either declare a
@code{Key} object explicitly, or it can rely on a method in a
superclass to determine whether the receivers are valid.  The
@cite{Ctalk Web Utilities} manual provides examples of both
techniques. 

@cindex @mnm{getValue} method @idxclscite{Collection}
Here is @mnm{getValue} in @code{Collection} class, which determines
that the actual receiver of a @mnm{getValue} message at run time is a
@code{Key} object and generates an exception otherwise.
@example
Collection instanceMethod getValue (void) @{
  Exception new e;

  if (self is Key) @{
    return self getValue;
  @}
  e raiseCriticalException INVALID_RECEIVER_X, 
    "Message \"getValue\" sent to a Collection object, not a Key object.";
  return NULL;
@}
@end example

Ctalk has several ways to cope with ad-hoc classes, which this tutorial
describes further on. @xref{self Class Resolution}.

@anchor{CollectionMathOperators}
@iftex
@section Using Math Operators with Collections (Still More about Looping)
@end iftex
@ifnottex
@subheading Using Math Operators with Collections (Still More about Looping)
@end ifnottex

Earlier this tutorial discussed how overloaded math operators work with
different classes.  

@cindex @mnm{+} instance method @idxclscite{Key}
@cindex @mnm{-} instance method @idxclscite{Key}
@cindex @mnm{++} instance method @idxclscite{Key}
@cindex @mnm{--} instance method @idxclscite{Key}
@cindex @mnm{+=} instance method @idxclscite{Key}
@cindex @mnm{-=} instance method @idxclscite{Key}
@cindex @mnm{*} instance method @idxclscite{Key}
@cindex @mnm{*} instance method @idxclscite{Collection}
Once again, Ctalk overloads the math operators @mnm{+}, @mnm{-},
@mnm{++}, @mnm{--}, @mnm{+=}, @mnm{-=}, and @mnm{*} operators so they
can work with collection elements.

More specifically, the operators work with @code{Key} objects, so this
section describes the @code{Collection} subclasses that use @code{Key}
objects to maintain their elements - the classes @code{List,}
@code{Array,} @code{AssociativeArray,} and any of their subclasses that
a program implements.

The methods also work with elements of @code{TreeNode} objects, with
a few extra steps, and they are discussed below.

Here's an example that saves and prints the elements of a @code{List}
object.

@c test/expect/icol9.c
@example

int main (int argc, char **argv) @{

  List new a;
  Key new k;
  Key new j;
  Integer new i;

  a push "value1";
  a push "value2";
  a push "value3";
  a push "value4";

  k = *a;
  i = 0;

  while (++k) @{
    printf ("%s\n",*k);
    if (i == 1) @{
        j = k;
        printf ("j = k: %s\n", *k);
    @}
    ++i;
  @}

  printf ("-------------------\n");
  printf ("%s\n", *j);

@}

@end example

When run, the program produces the following output.

@example

value2
value3
j = k: value3
value4
-------------------
value3

@end example

You should note that the elements get printed starting with
@code{value2}.  The reason for this is discussed in the next section.

The expression

@example

  k = *a;

@end example

sets the @code{Key} object @code{k} to the first element of @code{a},
which is a @code{List}.  When the operator @mnm{*} is used with a
@code{Collection}, it refers to the first element of the collection.
When @mnm{*} is used with a the @code{Key} object itself, though, it
refers to the contents of list element.

That means an expression like

@example

**a;

@end example

can refer to the first element of @code{a} also, so an expression
like

@example

printf ("%s\n", **a);

@end example

would print

@example

value1

@end example

Further down, the expression

@example

  while (++k) @{
    printf ("%s\n",*k);
    if (i == 1) @{
        j = k;
        printf ("j = k: %s\n", *k);
    @}
    ++i;
  @}

@end example

sets @code{k} to each successive member of the list, then prints its
value (using the expression ``@code{*k}''), and, if @code{k} refers to
the second element of the list, sets @code{j} to it, so the program
can refer to the list element later.

When @code{k} reaches the end of the list, it is set to @code{NULL}, so
the loop terminates and the program proceeds with the instructions further
down.

The main limitation of these operators is that they operate only on
objects that a program declares with @code{new} (and @mnm{basicNew} in
most cases).  That means the operators don't have any effect on
instance and class variables.

It is often possible, though, to refer to an object's instance
variable by another object, which the math operators @emph{can}
work with - so, for example, to loop through a @code{TreeNode} object,
you might use an expression like this one.

@ test/expect/examples/tree3.c
@example

TreeNode new tree;
Key new s;

@emph{... Add nodes to the tree. ...}

s = *tree siblings;

while (s++) @{

@emph{... do stuff ...}

@}

@end example

Ctalk's operator precedence evaluates method and instance
variable labels before math operators, so the expressions 
``@code{*tree siblings}'' and ``@code{*(tree siblings)}'' are
equivalent.

@iftex
@subsection Some Things to Look Out For with Math Operators
@end iftex
@ifnottex
@subsubheading Some Things to Look Out For with Math Operators
@end ifnottex

There are a few cautions that you need to observe when overloading
math operators, however.  One of the main cautions is trying to assign
a @code{Key} to an empty collection, which is almost guaranteed to
cause a program to crash.  So if you're in doubt about the contents of
the input you can check that it isn't empty, or you can check the size
of the tokenized output, as in this code.

@example

List new tokenList;

aString tokenize tokenList;

if (tokenList size > 0) @{   @emph{Make sure the list isn't empty...}

@emph{... then do stuff ...}

@}

@end example

Another very critical issue is trying to use math with @code{self}, 
if the program @code{maps} over a collection.  That's because
@code{self} is already the value of each successive item in the
collection, and it's not always guaranteed that @code{self} is going
to be a class that you can apply pointer math to.

@example

aString tokenize tokenList;

tokenList map @{

  aTok = self + 1;   @emph{Wrong... self is not a Key object.}

@}

@end example

If you must use math within an argument block, you can try storing
the tokens in an @code{AssociativeArray}, and then using @code{mapKeys}
to iterate over it.

@example

aString tokenize assocArray;

assocArray mapKeys @{

  aTok = self + 1;

@}

@end example

But this relies on what @code{self} actually refers to within the code
block, which you need to watch carefully.  And changing the value of
@code{self} is almost certain to cause the loop to behave
unpredictably.

Also, programs need to take care when trying to cast @code{self} to
particular class.

@example

aString tokenize aList;

aList map @{

  aTok = (Key *)self + 1;

@}
@end example

This example only works if @code{aList} is, for example, a list of
@code{Key} objects, which have the semantics to do what you expect
the math operators to do.

Another caveat is using @mnm{++} or @mnm{--} in a @code{while} loop.
This can cause the loop to miss members of the collection.

@example

tok = *aList;

while (tok++) @{          /* tok gets iterated after it retrieves the
                             value... */

  printf ("%s\n", *tok); /*  so here, tok points to the next member
                             of the collection.

@}

@end example

And here, if you use a prefix operator, the loop still misses members
of the collection.

@example

while (++tok) @{

  printf ("%s\n", *tok);  

@}

@end example

It's usually more correct to use a @code{do}... @code{while} loop
to iterate over a collection, as in this example.

@example

tok = *aList;

do @{

  printf ("%s\n", *tok);

@} while (++tok);

@end example

And placing the iteration at the end of a @code{while} loop also works.

@example

tok = *aList;

while (tok) @{

  printf ("%s\n", *tok);

  ++tok;
@}

@end example

Another place to exercise caution is when using complex expressions
in-line, for example, as an argument to @cite{printf ()}.  

@example

  // Trim leading spaces. 
  if (str matchRegex "^ *\"", offsets > 0)
    printf ("%s\n", str + str matchLength);   // Produces the wrong result.

@end example

Ctalk can decide to evaluate the argument separately, which can cause
the receiver to be assigned to the result before the entire expression
is evaluated.  If the operator seems to have no effect, you can try
using @code{eval} to tell Ctalk to evaluate the entire expression at
once, or simplifying the terms of the expression.  

Both of these examples produce the correct results.

@example

  if (str matchRegex "^ *\"", offsets > 0)
    printf ("%s\n", eval str + str matchLength);

  @emph{... or ...}

  if (str matchRegex "^ *\"", offsets > 0) @{
    matchStart = str matchLength;
    printf ("%s\n", str + matchStart);
  @}

@end example

Another place to be careful is when you try to assign a collection element
to a Key directly.

@example

  *destListPtr = *globalList;

  for (@emph{...}) @{
     @emph{... do stuff...}
     (*destListPtr) = (*(globalList + myInt));
  @}

@end example

This has the effect of changing the object that @code{destListPtr}
refers to; basically it reshuffles the members of @code{globalList},
so you need to be careful if an expression contains a @samp{*} on the
left-hand side of an assignment.  If you only want to iterate
@code{destListPtr} over the list, use something like this.

@example

  destListPtr = *globalList;

  for (@emph{...}) @{
     @emph{... do stuff...}
     ++destListPtr;
  @}

@end example

Here's example of how dereferencing works when using a numerical offset
to retrieve a @code{List} element.

@c test/expect/listoffset2.c
@example

Object class ListWrapper;

ListWrapper instanceVariable items List NULL;

int n = 1;


ListWrapper instanceMethod prOffset (void) @{
  String new item;
  
  self items map @{
    item = *(super items + n);
    printf ("%s\n", item);
  @}
@}

int main () @{
  ListWrapper new lw;

  lw items push "Item 0";
  lw items push "Item 1";
  lw items push "Item 2";
  lw items push "Item 3";
  lw items push "Item 4";

  lw prOffset;
@}

@end example

The main action in this case occurs in the @code{prOffset} method.
Here, we want to retrieve only the @emph{n'th} element in the receiver
list.  We've placed it inside an argument block, so the keyword
@code{super} refers to @code{prOffset's} receiver while the program is
executing in the argument block's scope.

The important thing to note is the dereference operator in this
expression.

@example

item = *(super items + n);

@end example

Here, @code{item} is a @code{String} object.  When we want to
set its value, we need to get the list element's content.

The result of the right-hand side of the expression,

@example

super items + n

@end example

is a @code{Key} object.  That's why the @samp{*} dereference operator
is there - it retrieves the object that the @emph{nth} position in the
list refers to.

Internally, the organization of a @code{Collection} object, or an
instance of one of its subclasses (like @code{List} in this example)
is this: a sequence of keys that comprise instance variables in
addition to the @code{value} instance variable (internally, it's a C
list also).  This is what an expression like @code{super items + n}
would retrieve: the @emph{n'th} key (counting from zero) from the
entire set of the collection's keys.

However, each key doesn't itself contain the collection's contents;
each of the keys contains a @emph{reference} another object, which may
be declared anywhere else in the program.  From the perspective of a
Ctalk expression, all of the target objects together comprise the
contents of the collection.

When you use a statement like @code{*(super items + n)} in a situation
like this, it instructs the class to return the object that the
@emph{n'th} key refers to.

@example

                               (super items + n)
                              n = 0         n = 1          ... etc.
 -------       -------       -------       -------
|       |     | value |     |       |     |       |
| aList | --> | inst. | --> |  Key  | --> |  Key  | -->    ...
|       |     |  var. |     |       |     |       |
 -------       -------       -------       -------

                                |             |
                                |             |

                              *(super items + n)                                
                             -------       -------
                            |       |     |       |
                            |Content|     |Content|
                            |       |     |       |
                             -------       -------
                             
@end example

Here is another, less compact way to write the @code{prOffset} method.

@example

ListWrapper instanceMethod prOffset (void) @{
  Key new item;
  String new content;
  
  self items map @{
    item = super items + l_offset;
    content = *item;
    printf ("%s\n", content);
  @}
@}

@end example

The main difference is where the dereference operator, @samp{*}, occurs
within the method.

And here is yet a third way that we can retrieve the content of the
@emph{n'th} list element.

@example

ListWrapper instanceMethod prOffset (void) @{
  Key new item;
  
  self items map @{
    item = super items + n;
    printf ("%s\n", *item);
  @}
@}

@end example

Here, the retrieval of the list's @code{String} element occurs when
the @cite{printf} statement is executed.

It's probably worth mentioning in passing that the actual @emph{names}
of the @code{Key} objects in a @code{List} aren't significant.  The
methods in @code{List} class treat each key in the collection by
referring to the object that comprises the list's contents in
succession (generally, this is referred to as each element's
@emph{value}), whether the key/value item is at the beginning or end
of the list, or by the key/value's position in the list.

However, collections like @code{AssociativeArray} and @code{Array} do
use key names that are significant.  An example is the
@code{AssociativeArray} classes' method, @code{mapKeys}, that doesn't
directly retrieve the collection's values; that is, in an argument
block that uses @code{mapKeys}, @code{self} refers to a @code{Key}
object, in addition to the more common @code{map} method.  There are
examples of this and other expressions that use collections in the
@cite{Ctalk Language Reference}.

@iftex
@section Class Casting
@end iftex
@ifnottex
@subheading Class Casting
@end ifnottex

Ctalk allows you to cast an object to any class you like.  This allows
programs to take advantage of the semantics that one class provides in
case they're needed for some other class, among having other
advantages.

For example, when iterating over collections, a cast can be useful
when you want to work with the actual collection element, instead of a
copy.  Look at this hypothetical example

@example

List new myListOfInts;
Integer new listElement;
Key new listKey;

listKey = *myListOfInts;    

while (listKey) @{

  (Object *)listElement = *listKey;  /* This causes the program to
                                        use Object : =, which assigns
                                        by reference, instead of
                                        Integer : = which assigns by
                                        value, so that listElement
                                        is the actual list item, not
                                        just a copy of its value. */

  @emph{... do stuff with listElement...}                                    

  ++listKey;
@}

@end example

Of course, it's up to you to insure that the object is valid for the
class you're casting it to.  Class casts, however, work equally well
with objects and @code{OBJECT *} C variables.  

To find out more about class casting, refer the the section titled,
@cite{Class casting} in the @cite{Ctalk Language Reference}.

@iftex
@section Initializing Collections
@end iftex
@ifnottex
@subheading Initializing Collections
@end ifnottex
@anchor{InitializingCollections}

Most of the examples in this tutorial use a series of @mnm{push} or
@mnm{atPut} methods to initialize collections.  However, several of
the subclasses of @code{Collection} class (namely, @code{List} and
@code{AssociativeArray} classes) also overload the @mnm{=} and
@mnm{+=} math operators so you can initialize a new collection or add
members to an existing collection with one expression.

@cindex @mnm{=} method @idxclscite{List}
The following example initializes @code{myList} with a group
of @code{String} objects using one statement.

@example

myList = "string1", "string2", "string3", "string4";

@end example

This statement initializes @code{myList} to contain exactly the four
@code{String} objects given as arguments.  If the program added any
members to @code{myList} before this statement, they are first removed
from the list.

@cindex @mnm{=} method @idxclscite{List}
To add members to @code{myList} without affecting the current contents
of the list, use the method, @mnm{+=.}

@example

myList = object1, object2, object3, object4;

myList += object5, object6, object7, object8;

@end example

This results in @code{myList} containing eight member objects.

Here is the example from the section discussing @code{Lists},
slightly abbreviated. @xref{ListClass}.

@example

                              /* Here again, "leftMargin" is passed as */
                              /* the second argument to map, below. */
List instanceMethod printItem (String leftMargin) @{
  Integer new element;
  element = self;
  printf ("%s%d ", leftMargin, element);
  return NULL;
@}

int main () @{

  List new l;
  String new leftMargin;

  leftMargin = "  ";

  l = 1, 2, 3;

  l map printItem, leftMargin;  /* "leftMargin" is the first argument when */
                               /* printItem is called.                    */
  printf ("\n");
@}
@end example

@code{AssociativeArray} class also overloads @mnm{=} and @mnm{+=,} but
the methods interpret the argument list as a set of @emph{key},
@emph{value} pairs.

@example

myArray = @emph{key1}, @emph{value1}, @emph{key2}, @emph{value2}, @emph{key3}, @emph{value3}, ... ;

@end example

The @code{keyN} arguments may be either a String constant or simply a label--
Ctalk interprets them as the key names regardless of their class when it
creates the receiver's keys.  The @code{valueN} argument can be whatever
the receiver @code{AssociativeArray} needs to contain.

Here's a brief example program that initializes and then prints the
contents of an @code{AssociativeArray}.

@example

int main () @{
  AssociativeArray new a;

  a = "key1", "first", "key2", "second", "key3", "third", "key4", "fourth";
  a += "key5", "fifth", "key6", "sixth", "key7", "seventh", "key8", "eighth";

  a mapKeys @{
    printf ("%s --> %s\n", self name, *self);
  @}
@}

@end example

As the tutorial mentioned above, the @code{keyN} objects do not need
to be @code{String} contsants, they can simply be objects that are
created when the argument is parsed, and can be used to name the
@code{Key} objects in the receiver collection.

That means that statements like these would work equally well to
initialize the @code{AssociativeArray} in the previous example.

@example

  a = key1, "first", key2, "second", key3, "third", key4, "fourth";
  a += key5, "fifth", key6, "sixth", key7, "seventh", key8, "eighth";

@end example

@node Classes, Methods, Collections, Top
@iftex
@chapter Defining Classes and Objects
@end iftex
@ifnottex
@heading Defining Classes and Objects
@end ifnottex

The previous chapters described some of the methods that the Ctalk
classes define.  This chapter discusses in further detail how to
define Classes and variables that belong to the classes, and discusses
some of the ways that Ctalk initializes instances of a class.

Many of the methods used in this chapter are @emph{primitive} methods.
The primitive method definitions are in the @code{Object} class, and
any class can use them.

@iftex
@section Superclasses
@end iftex
@ifnottex
@subheading Superclasses
@end ifnottex

@cindex @mnm{class} method @idxclscite{Object}
At a minimum, a class definition defines the name of the new class and
its superclass.  The primitive method @mnm{class} (@code{Object}
class) takes the name of a new class as its argument.  The new class
is defined in the class library as a subclass of the receiver's class.

This statement defines a class with the name @code{WriteFileStream} as a
subclass of the receiver, @code{FileStream.}
@example
FileStream class WriteFileStream;
@end example

Or, more generically,
@example
@var{superclassname} class @var{newclassname} <@var{docstring}>;
@end example

This declaration is necessary for Ctalk to identify the file as a
class.

The @var{superclassname} indicates where the class fits into the class
library, and that determines which methods and instance data the new
class inherits.  The only class that does not have a
@var{superclassname} is @code{Object,} the topmost class in the class
library.  @code{Object} class is loaded by default and doesn't require
a class declaration.

The @var{docstring} element is optional; it's a human readable
description of the class.  It's simply text enclosed in double quotes
between the @var{classname} and the final semicolon.  Here's the
previous example with a possible documentation string added.

@example

FileStream class WriteFileStream
"Defines the methods and instance variables that write data to files. Also
defines the class variables stdoutStream and stderrStream, which are the 
object representation of the standard output and standard error streams.";

@end example

It's necessary that the superclasses of the new class already be
defined.  That statement may seem obvious, but the definitions
of class and instance variables that the new class inherits must
already be present.  That can sometimes be tricky when defining
basic classes.

Another reason is that, when you define an instance or class variable,
the variable @emph{is a member of your new class,} unless you specify
that the variable belongs to another class.  If your class can inherit
class variables, instance variables, and methods from the class's
superclasses, then they get used by the new class also.  Any new
variables and methods only need to be referenced by the class you're
defining.


@cindex @code{require} keyword
However, you can direct Ctalk to initialize other classes if your
class needs them, by using, for example, statements like
@code{require,} as described below.

@emph{Note:} As mentioned above, when dealing with a basic class like
@code{Object} or @code{Symbol}, a method @emph{can't} always depend on
a class being defined.  During initialization, Ctalk programs
@code{require} a number of basic classes: @code{Object,}
@code{Symbol,} @code{Integer,} and @code{ArgumentList,} and their
required classes @code{Magnitude} and @code{Character.}  

If, for example, you define a method in class @code{Symbol} to print
objects, you cannot use @code{WriteFileStream} class, which needs
@code{Symbol} and its methods already defined.  That would mean
@code{Symbol} class needs to look up @code{WriteFileStream,} which
needs to look up @code{Symbol,} which needs to look up
@code{WriteFileStream} again, and so on.  

Ctalk doesn't necessarily stop you from writing programs with circular
class references - its method prototyping mechanism can often
compensate by checking definitions from different classes as needed,
but in cases where Ctalk can't resolve circular references, then it's
necessary to add methods or instance variables in subclasses.

The previous chapters have described some of the ways that you can
work with instance data using C.  Many of the Ctalk library's API
functions also check for the type and value instance data.  The method
API is described later on.

@iftex
@section Instance Variables
@end iftex
@ifnottex
@subheading Instance Variables
@end ifnottex
@anchor{Instance Variables}

@cindex @code{value} instance variable
@cindex @code{instanceVariable} method @idxclscite{Object}
We mentioned already that all objects have a default instance variable
named @code{value.}  However, many classes define other instance
variables.  Classes define instance variables with the
@mnm{instanceVariable} method.

Here is an example of an instance variable definition.
@example
MyNewClass instanceVariable textMessage String NULL;
@end example

This example declares that all instances of @code{MyNewClass} will
have an instance variable named @code{textMessage,} and that it is
an instance of class @code{String,} and it has the initial value
@code{NULL.}  

The second and third arguments of @code{instanceVariable} are
optional.  Here is the syntax of the @code{instanceVariable} method. 
@example
@var{classname} instanceVariable @var{varname} [@var{varclass}|@var{typecast_expr}] [@var{initialvalue}]
@end example

Remember that @mnm{instanceVariable} only @emph{defines} variables.
The method does not actually create them.  When you create an object
that is an instance of your class, the object gets its own copy of the
variable.

If the program declares a variable with a type cast instead of a
native class for the variable, Ctalk matches the type cast to a class.
If the type cast of the variable is a pointer to some data type that
is not commonly used in Ctalk or C programs, then Ctalk simply
translates the native type to @code{Symbol}.  This is because the
program needs to implement its own methods for handling the data, and
@code{Symbol} is the most generic class that Ctalk can use for referring
to C data in memory.

@iftex
@section Class Variables
@end iftex
@ifnottex
@subheading Class Variables
@end ifnottex
@anchor{Class Variables}

@cindex @mnm{classVariable} method @idxclscite{Object}
On the other hand, the @mnm{classVariable} method creates the single
copy of a class variable that the instances of a class (and most other
classes) can use.  Creating a class variable is similar to creating an
instance variable.
@example
MyNewClass classVariable systemError Integer 0;
@end example

For completeness, here is the @mnm{classVariable} method's syntax.
@example
@var{classname} classVariable @var{varname} [@var{varclass}|@var{typecast_expr}] [@var{initialvalue}]
@end example

Remember that if you define a variable as a different class than its
member class, then the variable responds to messages of its own class.
In these cases, you need to take care that you are working with the
variable, and not the class that it belongs to.

If the variable's native type is declared with a type cast, then Ctalk 
tries to translate the type cast into a Ctalk class, as described in
the previous section.

@iftex
@section Class Initialization
@end iftex
@ifnottex
@subheading Class Initialization
@end ifnottex

Although you can define an initial value for a class variable, in many
cases you need to wait until the program is run before setting the
actual value of a class variable.  An example of this is
@mnm{stdoutStream} (class @code{WriteFileStream}).  

In many cases, a constructor method (which in Ctalk are named
@code{new}), can call a class initialization method.

Here is a hypothetical class with @mnm{classInit} a method.  This
example simply sets the the name of the system in a class variable
called @code{hostName.}
@example

MySuperClass class MyClass;

MyClass classVariable myClassVar String NULL;

@emph{...}
@emph{Other class and instance variable definitions.}
@emph{...}

MyClass classMethod classInit (void) @{

  OBJECT *classObject_object, 
    *classInitVar_object, 
    *myClassVar_object;
  char buf[MAXLABEL];

  /*
   *  Return if we've already initialize the class.
   */
  if (self classInitDone)
    return NULL;


  /*
   *  Retrieve the class object, because we'll need it below.
   */

  classObject_object = __ctalkGetClass("MyClass");

  /*
   *  Look for myClassVar.  
   *  The third argument of __ctalkGetClassVariable instructs the 
   *  function not to print a warning if it doesn't find the 
   *  variable.  If the variable is not present, then the class
   *  is not completely initialized, so return.
   */

  if ((myClassVar_object = 
    __ctalkGetClassVariable (self, "myClassVar", FALSE)) == NULL) @{
    return NULL;
  @}

  @emph{...}
  @emph{Initialize myClassVar here.}
  @emph{...}

  classInitVar = 
    __ctalkCreateObjectInit ("classInitDone", "Integer",
                             "Magnitude", GLOBAL_VAR, "1");
  __ctalkAddClassVariable (classObject, "classInitDone", classInitVar);

  return NULL;
@}

@emph{...}
@emph{Other methods.}
@emph{...}
@end example

When writing classes, you need to remember that Ctalk initializes the
class and its methods and data in the following order.
@enumerate
@item
The class itself and its superclass.
@item
The class' instance and class methods.
@item
Instance variables.
@item
Class variables.
@end enumerate

Remember that a class definition only requires a superclass.  All of
the other elements are optional.

It is possible, when initializing complex classes, to construct
objects before the class is completely defined.  That's why
@code{classInit} above checks for the class variable @code{myClassVar}
and returns if it is not present.

However, Ctalk checks the class initialization every time it creates
an instance of @code{MyClass,} so a constructor method for MyClass
might look like the following.

@cindex @code{__ctalkInstanceVarsFromClassObject ()} function
@example
MyClass instanceMethod new (char *myObjectName) @{

  MyClass super new myObjectName;

  __ctalkInstanceVarsFromClassObject (myObjectName);

  MyClass classInit;
  
  return myObjectName;
@}
@end example

The program then initializes the class variables when the class is
completely defined.  If @code{classInitDone} is @code{TRUE,} then the
program won't initialize the class again.

@emph{Note:} Ctalk does not automatically create a copy of a class's
instance variables when creating objects.  Your program must call 
@code{__ctalkInstanceVarsFromClassObject} to create the instance 
variables in the new object.

If you simply want to initialize a class without creating a new
object, you can add a statement like this to your program.
@example
MyClass classInit;
@end example

Another example of a method that performs class initialization is the
method @mnm{initDigits} (class @code{ClockDigit}) in the program
@flnm{ltime.c.} The method is too long to list here, but you can find
@flnm{ltime.c} in the Ctalk distribution's @flnm{demos}
subdirectory.

The later chapters describe methods and library functions that perform
class initialization in more detail.  

@iftex
@section @code{require} Keyword
@end iftex
@ifnottex
@subheading @code{require} Keyword
@end ifnottex

@cindex @code{require} keyword
Ctalk programs initialize the basic classes before starting
to initialize the application's class and method
definitions.  However, if your definition needs a class that
Ctalk does not automatically include, you can initialize the
class and include its method and variable definitions before
defining your own class by using the keyword @code{require.}

@example

require Boolean;

@end example

This can be useful if you write a class and Ctalk outputs
a message like this one.

@cindex @code{Method used before it is defined} exception
@example

prefix34.c:13: Method raiseException," (class Exception)
     used before it is defined.

@end example

In that case, you might want to add @samp{require Exception;}
at the beginning of the class.

If that doesn't help, another tactic is to add a method
to the new class that duplicates the function of the yet-to-be-
defined method.  Yet another tactic is to create a unique subclass
that contains the method you need.

One issue is that the superclass of @code{require's} operand (in the
example above, that's @code{Boolean's} superclass, @code{Object}) is already
completely defined, or the definitions in the input file that contains
the @code{require} statement can cause circular class references.

However, these errors occur during compilation.  If you can write a
method that does what you want at run time, then that may be another
yet strategy that you can use.  For example, if you write
an expression like this in a basic class like @code{Symbol}, you'll
get ``Method used before definition'' errors.

@cindex @mnm{is} method @idxclscite{Object}
@example

/* The reference to Key class requires methods that aren't defined yet. */

if ((arg is Symbol) || (arg is Key)) @{  
   ...
@}

@end example

@cindex @mnm{isSubClassOf} method @idxclscite{Object}
Instead, @code{Object} class contains the method @mnm{isSubClassOf}, which
doesn't require the compiler to determine the class of @code{arg}
beforehand, because the method evaluates the class of @samp{arg} at 
run time.

@example

if (arg isSubClassOf "Symbol") @{

   ...

@}

@end example

It's useful for Ctalk to limit additions the basic classes.  You can
add a method to an existing class by defining the method in a source
file (which is evaluated after all of the basic classes are
evaluated), but you can't add another library file to an existing
class.  This requires more planning when adding subclasses and methods,
but it also makes the compiler trimmer.

@iftex
@section Where Ctalk Looks for Class Libraries
@end iftex
@ifnottex
@subheading Where Ctalk Looks for Class Libraries
@end ifnottex
@cindex Library search path
@cindex @code{CLASSLIBDIRS} environment variable
@cindex @code{-I} command line option

When compiling programs, Ctalk looks for class libraries
in the following order.
@enumerate
@item
Directories named as arguments to the @code{-I} command line
option.
@item
Directories named by the @code{CLASSLIBDIRS} environment
variable. 
@item 
Ctalk's directory for the standard libraries.
@end enumerate

Ctalk applications occasionally need to look up a class
library when they are run.  In that case, the program
searches directories in the following order.
@enumerate
@item
Directories named by the @code{CLASSLIBDIRS} environment
variable. 
@item 
Ctalk's directory for the standard libraries.
@end enumerate

The directory where the standard libraries are located is
determined when Ctalk is built and installed.  This
directory defaults to @file{/usr/local/include/ctalk} on
UNIX systems.  For more details, refer to the entry for
the @cite{__classLibraryPath()} function in the language
reference.

Ctalk expands directories to their fully qualified names, so
if you build a program with a command like this:
@example
$ ctcc -I . myprogram.c -o myprogram
@end example
Then Ctalk expands the @samp{.} to the full path of the current
directory, and searches for class libraries in the current
directory in addition to the directories it normally searches.

In addition, for each search directory, if a subdirectory named
@flnm{ctalk} exists, then Ctalk searches that subdirectory also.

@cindex @mnm{classSearchPath} instance method @idxclscite{Application}
The @mnm{classSearchPath} method, defined in @code{Application} class,
returns a @code{String} that contains the class search path.  This
example prints the search path, with each directory separated by a
colon (@samp{:}).
@c ctalk/test/expect/classsearchpath1.c
@example
int main () @{
  Application new app;
  printf ("%s\n", app classSearchPath);
@}
@end example

@cindex @code{--printlibdirs} command line option
The @samp{--printlibdirs} command line option prints the directories
that Ctalk searches, one directory per line.

@iftex
@section Instance Variables and Method Overloading
@end iftex
@ifnottex
@subheading Instance Variables and Method Overloading
@end ifnottex

One consequence of all this convenient instance data and overloaded
methods is that it is easy to confuse which method a message actually
translates into.  That is because the member class of an instance or
class variable might not be the class of the variable's own instance
data.

Here is an example.  The @mnm{openOn} message in the first statement
translates to the @mnm{openOn} method in the @code{ANSITerminalPane}
class, while the @mnm{openOn} message in the second statement
translates to the @mnm{openOn} method in the @code{ReadFileStream}
class. 
@example
ANSITerminalPane new mainWindow;

mainWindow paneStream openOn "/dev/ttyS0";               /* Correct.  */

mainWindow paneStream inputHandle openOn "/dev/ttyS0";   /* Incorrect. */
@end example

This is because @code{inputHandle} in the second statement is actually
a @code{ReadFileStream}, while the program actually wants to call is
the @mnm{openOn} method from @mnm{ANSITerminalStream}, which is the
effect of the first statement.  The @code{Stream} classes have many
classes in common.  In most cases this makes things simpler, but not
always. 

There are several ways to work around this issue.  This first is to
use stack walkbacks and exception handlers whenever a program opens a
file.  That allows you to see what methods the program's statements
actually translate into. @xref{Debugging}.

If you can't avoid an incorrect message translation in a program, you
can write your own method that only one of your program's classes
responds to.  For example, instead of yet another @mnm{openOn} method,
your program might define a method like, for example,
@mnm{openOnInputData}.  

Finally, if the program cannot determine in advance which class is
going to receive a message, you can write a method that dispatches the
receiver to a method of the correct class.  Here is an example.
@example
Stream instanceMethod openOnTerminal (String pathName) @{
  Exception new e;
  if (self is ANSITerminalStream) @{ 
    if (pathName isATty) @{
      self openOn pathName;
    @} else @{
      e raiseException NOT_A_TTY_X, pathName;
    @} 
  @} else @{
    e raiseException INVALID_RECEIVER_X, pathName;
  @}
  return self;
@}
@end example


@node Methods, Graphics, Classes, Top
@iftex
@chapter Writing Methods
@end iftex
@ifnottex
@heading Writing Methods
@end ifnottex
@cindex Methods

Languages like C identify and call functions by matching a label in
the source code against an identifier in an object module, and the
compiler (or more properly, the linker or interpreter) inserts a call
to the function in the program.

In Ctalk, like many other object oriented languages, objects
respond to @emph{messages} that refer to methods defined by the
object's class or the object's superclasses.

@emph{Note:} The following sections contain a lot of
material, the importance of which may not be immediately
clear.  If necessary, you should skip ahead to the
section, @cite{Assigning Values,} to see how these concepts
fit together. @xref{Assigning Values}.

Here is an example.  If you wanted to create a new
@code{WriteFileStream} object, you would add a statement like this to
the program.
@example
WriteFileStream new myOutputStream;
@end example

For the moment, we should also mention that most constructor
methods should first contain a @samp{super new} message like
this one. (We'll discuss the process in more detail
later on.)
@example
WriteFileStream super new fileStreamName;
@end example

When the receiver, @code{WriteFileStream,} receives the message,
@code{new,} the process of executing the methods that create a
@code{WriteFileStream} object works in the following
manner. 
@smallexample
Class                  Message    Action 
-----                  -------    ------
|- Object <-------------- new        2. Return new, generic object.
|                           ^                  |
|- Stream                    \                 |
|                             \                |
|- FileStream                  \               |
|                               \              |
|- WriteFileStream <----- new     1.Execute    |
                                  "super new." |
                                               v
                                              3. Add the instance variables 
                                              that WriteFileStream objects 
                                              need and initialize the class 
                                              if necessary.
@end smallexample

@cindex @mnm{parseQueryString} method @idxclscite{CGIApp}
@cindex @code{CGIApp} class
Here is a typical method.  This is the instance method
@code{parseQueryString} (class @code{CGIApp.})  The @code{CGIApp}
class is in the Ctalk @flnm{demos/cgi} subdirectory and is used by
the Common Gateway Interface programs in that directory.

@example
CGIApp instanceMethod parseQueryString (void) @{
  String new queryString;
  String new paramString;
  Array new queryParams;
  Array new paramArray;
  Integer new nParams;
  String new paramKey;
  String new paramValue;
  Integer new i;
  Integer new j;

  queryString = self serverEnvironment at "QUERY_STRING";

  if ((queryString length == 0) || (queryString isNull)) @{
    return NULL;
  @}

  nParams = queryString split '&', queryParams;

  for (i = 0; i < nParams; i = i + 1) @{
    paramString = queryParams at i;
    j = paramString split '=', paramArray;
    if (j == 1) @{
      self queryValues atPut (paramArray at 0), "1";
    @} else @{
      if (j == 2) @{
	self queryValues atPut (paramArray at 0), (paramArray at 1);
      @}
    @}
  @}  
  return NULL;
@}
@end example

The @code{parseQueryString} method parses the parameters of a CGI
query and places them in the application's @code{queryValues} instance
variable, an @code{AssociativeArray.}  The @code{queryValues} instance
variable then contains the key-value pairs of each of CGI
application's parameters.

If you call a CGI application with a URL like the following example
@example
http://my-web-server/cgi-bin/mysearchprog?term=ctalk&case=ignore&showresults=10
@end example
Then @code{parseQueryString} sets the application's @code{queryValues}
@code{AssociativeArray} to the following.
@example
                  Key          Value
queryValues  at   term         ctalk
queryValues  at   case         ignore
queryValues  at   showresults  10
@end example
@cindex @mnm{split} method @idxclscite{String}
The @code{parseQueryString} method uses the @code{split} method (class
@code{String}) several times to split the query string at the @samp{&}
delimiters, and then each parameter and its value at the @samp{=}
character.  If a parameter is defined but does not have a value
associated with it, @code{parseQueryString} assigns it the value of
@samp{1}.

@cindex @mnm{isNull} method @idxclscite{String}
You should also note that the method checks for both a zero-length
input value, and an @emph{uninitialized} input value with the method
@mnm{isNull}, which might occur, in this example, if the environment
variable @samp{QUERY_STRING} is not defined.

@iftex
@section Overview of the Method Application Programming Interface
@end iftex
@ifnottex
@subheading Overview of the Method Application Programming Interface
@end ifnottex

You might recall from the earlier chapters that if a program uses an
operator like @samp{+} or @samp{-} with a C variable, then Ctalk treats
the operator as a C math operator.  However, if you use a math
operator with an object as the receiver, then Ctalk uses a method to
perform the operation.

Ctalk's base classes and methods are located in Ctalk's class
library.  On UNIX systems, the class library normally resides in
@flnm{/usr/local/include/ctalk}, although the location may vary
depending on the operating system.

If you write your own methods, you might want to keep them in their
own directory.  In that case, the @samp{-I} command line option
includes the directory given as its argument in the class search path.
To include the current directory in the class search path, the command
line option @samp{-I .} is a convenient shorthand.

@iftex
@subsection Primitive Methods
@end iftex
@ifnottex
@subsubheading Primitive Methods
@end ifnottex
@cindex Primitive methods

One exception is the way Ctalk implements @emph{primitive
methods.}  Ctalk implements these methods in C, and you can call
them without worrying if a program defines a class.

@cindex @mnm{new} method @idxclscite{Object}
These methods are available to all classes, so they effectively belong
to the @code{Object} class.  You can also subclass these methods, as
is often the case with the constructor @code{new}.  The previous
chapters have described in general how to subclass methods, and this
manual describes the process in detail later on.

Here are the primitive methods that Ctalk defines.
@table @code
@item class @var{classname}
@cindex @mnm{class} method @idxclscite{Object}
Defines a new class.  The receiver is the name of the superclass, and
the argument is the name of the class that you want to create.

@item classMethod @var{alias} @var{selector} (@var{args})
@cindex @mnm{classMethod} method @idxclscite{Object}
Declares a new class method.  The next section describes the syntax of
method declarations. @xref{Method Declarations}.

@item classVariable @var{varname} @var{varclass} @var{initial-value}
@cindex @mnm{classVariable} method @idxclscite{Object}
Declare a class variable.  The receiver is the class of the variable.
You must provide a @var{name} for the class variable.  The statement
also allows you to define a class for the class variable and an
initial value.  @xref{Class Variables}.

@item instanceMethod @var{alias} @var{selector} (@var{args})
@cindex @mnm{instanceMethod} method @idxclscite{Object}
Declares a new instance method.  The next section describes the syntax of
method declarations. @xref{Method Declarations}.

@item instanceVariable @var{varname} @var{varclass} @var{initial-value}
@cindex @mnm{instanceVariable} method @idxclscite{Object}
Define an instance variable.  The receiver is the class of the
variable.  Unlike class variables, @mnm{instanceVariable} only defines
a variable's declaration.  A constructor like @code{new} creates the
actual instance variables when it creates an object. @xref{Instance Variables}.

@item new @var{newobjectname}
@cindex @mnm{new} method @idxclscite{Object}
Create a new object.  The receiver of @code{new} is the object's
class.
@end table

@emph{Note:} You might need to use only primitive methods and library
functions if you need to define a method in a basic class like
@code{Object} or @code{Symbol}, where a method can't always depend on
a class being defined.  During initialization, Ctalk programs
@code{require} a number of basic classes: @code{Object,}
@code{Symbol,} @code{Integer,} and @code{ArgumentList,} and their
required classes @code{Magnitude} and @code{Character.}  If, for
example, you define a method in class @code{Symbol} to print objects,
you cannot use @code{WriteFileStream} class, which needs @code{Symbol}
and its methods already defined.  So if you write a method that needs
classes other than these basic classes, it is better to define a
class specifically for your program.

@iftex
@subsection Instance and Class Variable Messages
@end iftex
@ifnottex
@subsubheading Instance and Class Variable Messages
@end ifnottex
For completeness, we should mention that the other exception in the
method API is the use of instance and class variable names as
messages.  

The @code{value} message is an example of a message that refers to an
instance variable.  Remember that a statement like the following
example returns only the instance variable, and not the complete
object. 
@example
return self value;
@end example

@cindex @mnm{at} method @idxclscite{Array}
Instance variable messages are useful mainly when creating C
references to objects.  Methods, on the other hand, generally work
with complete objects.  An example is the @mnm{at} method in class
@code{Array}. 
@example
myElement = myArray at 0;
@end example

The message @mnm{at} returns the @emph{0}th array element. 

When you use objects with C, you must also check to determine that the
object references are really the objects that the program expects.

The following sections describe the Ctalk interface to C, and the many
of the examples in this manual describe Ctalk's C API.

@anchor{Method Declarations}
@iftex
@section Method Declarations
@end iftex
@ifnottex
@subheading Method Declarations
@end ifnottex
@cindex Method declarations
@cindex @code{instanceMethod} keyword
@cindex @code{classMethod} keyword

As you probably noticed from the example above, you can declare
methods in much the same manner as C functions.  

However, method declarations have a different meaning, and the
declarations allow for multiple methods with the same name in 
different classes.

The following example is the basic syntax of an instance method
declaration.
@example
@var{class} @code{instanceMethod} [@var{alias}] @var{selector} (@var{args}) @{
... Method body
@} 
@end example

The third term, @var{alias}, is optional.  It is often used to alias a
method to an operator like @samp{+}, @samp{-}, or another operator
that you want to overload in @var{class}.

The syntax of a class method declaration is similar, but it uses the @code{classMethod} method.
@example
@var{class} @code{classMethod} [@var{alias}] @var{selector} (@var{args}) @{
... Method body
@} 
@end example

@iftex
@section Using Methods in Simple Statements
@end iftex
@ifnottex
@subheading How Methods Interface with C
@end ifnottex

Methods can be either labels or C operators.  Although Ctalk's
syntax is similar to C, it allows more flexibility in the construction
of statements.

As we noted earlier, you can change characters from upper case to
lower case and vice versa by toggling the fifth bit of the character.
Here is that example again.
@example
Character new upperCase;
Character new lowerCase;
Integer new toggleBit;  

upperCase = 'Z';
lowerCase = 'z';
toggleBit = 32;

printf ("%c\n", upperCase ^ toggleBit);
printf ("%c\n", lowerCase ^ toggleBit);
@end example

@cindex @mnm{^} method @idxclscite{Character}
The @mnm{^} operator in these statements is actually a method in
class @code{Character}.  

@cindex @mnm{toLower} method @idxclscite{Character}
@cindex @mnm{toUpper} method @idxclscite{Character}
Ctalk also provides two methods in @code{Character} class,
@mnm{toUpper} and @mnm{toLower}, that provide the same function, and
the methods also check that the receiver is a letter of the
appropriate case before changing the case.

Here is the @mnm{toLower} method.
@example
Character instanceMethod toLower (void) @{
  Character new result;

  if (self isAlpha && self isUpper) @{
    result = self asInteger ^ 32;
  @} else @{
    result = self;
  @}
  return result;
@}
@end example

@cindex @mnm{asInteger} method @idxclscite{Magnitude}
We could omit the @mnm{asInteger} message, but using @mnm{asInteger},
which is implemented in @code{Magnitude} class, allows us to reliably
check that the receiver of @mnm{^} is actually a valid
number, even if the receiver of @mnm{toLower} is the result
of another statement that translates its value from a completely
different receiver elsewhere in the program.

The result of @code{self asInteger} is an @code{Integer} object, so 
it uses @mnm{^} from @code{Integer} class to perform the translation.

@cindex @mnm{asCharacter} method @idxclscite{Magnitude}
The @mnm{asCharacter} method, like @mnm{asInteger}, is defined
in @code{Magnitude} class.

The @mnm{value} message in the example above is optional.  Ctalk 
sends method arguments as complete objects.  

Ctalk statements can appear in many of the places that a C expression
can appear.  Here is another simple example.
@example
int main () @{
  String new ten;
  ten = "10";
  printf ("%d\n", ten asInteger);
@}
@end example

As a general rule, keep in mind that receiver objects and other
methods that are part of complex statements work with objects.

There are many cases, however, when you need to use a message like
@mnm{value} in a statement to return an instance variable - generally
when you are using objects with C statements, which the next section
describes.

@iftex
@section The @code{value} Message and Interfacing with C
@end iftex
@ifnottex
@subheading The @code{value} Message and Interfacing with C
@end ifnottex

@cindex @mnm{value} message.
We have already described how refer to objects with C variables in
many places.  This section provides a slightly more formal definition
of how and when to use @code{value}.

If you are assigning an object to a C variable, then in most cases you
want to use the @mnm{value} message.  This message, you might remember
from previous chapters, returns the receiver's @code{value} instance
variable.

So if you want to assign an object's value to a C variable, you might
use a set of statements like the following.
@example
OBJECT *value_object;
value_object = self value;
@end example

You should @emph{not,} however, simply use an object like @code{self}
on its own, because Ctalk cannot determine exactly how you plan to use 
the result.  The following example will provide the complete object, 
which is not what you want.
@example
OBJECT *value_object;
value_object = self;
@end example

It is okay, however, to use an object name on its own when used
with other objects.
@example
Object new receiverObjectCopy;
receiverObjectCopy = self;
@end example

Once you have assigned an object to a C variable, you can treat it
as a C @code{struct}.  The next section describes the
@code{OBJECT} C @code{typedef}.

@iftex
@subsection The @code{OBJECT} Type
@end iftex
@ifnottex
@subsubheading The @code{OBJECT} Type
@end ifnottex
@cindex @code{OBJECT} typedef

Ctalk represents objects internally as an @code{OBJECT} typedef, so
when you need to use an object in a C statement, you can create a C
alias for the object by declaring and initializing a C @code{OBJECT
*}.

Here is the @code{OBJECT} type declaration, without some of the
machine-specific definitions.  It is located in the file
@flnm{classes/ctalklib}, and several other places.
@example
struct _object @{
  int sig;
  char __o_name[MAXLABEL];
  char __o_classname[MAXLABEL];
  OBJECT *__o_class;
  char __o_superclassname[MAXLABEL];
  OBJECT *__o_superclass;
  OBJECT *__o_p_obj;
  VARENTRY *__o_varentry;
  char *__o_value;
  METHOD *instance_methods,
    *class_methods;
  int scope;
  int nrefs;
  struct _object *classvars;
  struct _object *instancevars;    
  struct _object *next;
  struct _object *prev;
  int attrs;
@};
@end example

So when a program uses statements like those in the following example,
the program is actually creating a C reference to an object.
@example
OBJECT *rcvr_value;
rcvr_value = self value;
@end example
Here, @code{=} is a C operator.  Ctalk evaluates the @code{value}
message, and then determines that it doesn't need to perform 
further translation on the objects because the receiver simply needs
the @code{value} instance variable as C @code{struct}.

Generally, C programs are mainly interested in the @code{__o_value}
field of an @code{OBJECT *}, because this is where objects store their
data as C @code{char *}'s.

@cindex @cite{__ctalk_to_c_char_ptr()} function
@cindex @cite{__ctalk_to_c_int()} function
There are also API C functions, like @cite{__ctalk_to_c_char_ptr ()} and
@cite{__ctalk_to_c_int ()}, that translate objects to C.  The
@cite{Ctalk Language Reference} describes these functions.

@iftex
@section Return Values
@end iftex
@ifnottex
@subheading Return Values
@end ifnottex
Methods can return any type of value.  Ctalk can usually
figure out what how to translate a C language value into a
form that it can use internally.

These are all valid return statements.

@example

return "hello!";
return a;
return a + 2;
return TRUE;
return self;
return myObject className;

@end example

Occasionally, a method may need to return the result of a
complex expression or an expression whose result isn't known
until run time.  In that case, you can use the @code{eval}
keyword to tell Ctalk to wait until the program is run
before evaluating the expression, as in this example.
@example
return eval <expression>;
@end example

Ctalk treats methods that return arrays a little
differently.  For a method to return a C array, the array
must be explicitly declared; that is, the following
definition is translatable into an @code{Array} object,
@example
int i[10];
@end example
while this statement is not.
@example
int *i;
@end example
For a method to return a C array, the method's definition
must specify that it returns an @code{Array} class object.

Otherwise, the object might not be directly translatable to
a basic Ctalk class, and in that case you should consider
assigning the variable to a @code{Symbol} object and
returning a reference to the variable.  The same is true of
multi-dimensional arrays, like this one.
@example
int i[10][10];
@end example
Again, if a method needs to return a multi-dimensional
array, it should consider assigning to to a @code{Symbol}
object and returning a reference to the method.

The size of a returned @code{Array} is the same as the
size of the array declared in C, regardless of how the
method initializes the C array members.  You need to keep
that in mind when returning C arrays that may or may not
have their members initialized.

Ctalk treats arrays declared as @code{char[@var{size}]} as
@code{String} objects, unless the method's definition says
it returns an @code{Array}, in which case the method returns
an @code{Array} with each member being a @code{Character}
object; otherwise, methods return @code{String} objects for
@code{char[]} declarations.

Occasionally, you may find that you need to write a method
that declares a return value's class explicitly.  In these
cases, Ctalk also provides a number of method return
statements; e.g.; @code{methodReturnInteger} and
@code{methodReturnTrue}.  The @cite{Ctalk Language
Reference} contains a complete list of them.

@iftex
@section Object References within Methods
@end iftex
@ifnottex
@subheading Object References within Methods
@end ifnottex
@anchor{Working with Object References}
@cindex References to objects

In a previous section, we described a few of the principles
of object references.  @xref{Object References}.  This
section briefly mentions a few aspects of working with
actual references within methods.

There are many examples of methods that use object
references in the Ctalk class libraries.  Here, we'll
mention only a few things to keep in mind when using
references in your own methods.

@cindex @code{Symbol} class
@cindex @code{Key} class
Each member of a collection like an @code{AssociativeArray}
object, is a @code{Key} object.  A @code{Key} object has two
components: a name that is used as a @emph{key} to look up
the object, and a @emph{value} that is a reference to the
object that belongs to the collection.  @code{Key} objects
are a more specialized subclass of @code{Symbol}, and the
@code{Key} class implements several methods to work with
@code{Key} objects' labels.

The most important thing to note when working with
references, however, @emph{is that they can originate
anywhere in a program,} and your method should not make
assumptions about where that object was declared.  

However, your method can use the scope of an object to
determine how it is used.  For example, it can add or remove
a @code{VAR_REF_SCOPE} or @code{METHOD_USER_OBJECT} scope
from an object.  Object scopes are described more thoroughly 
in the @cite{Ctalk Language Reference}.

It's important to remember that the main point of using
object references is that when you change the value of an
object, that value changes for @emph{every} occurrence of
that object in a program.

This is often useful for complex objects that persist
throughout the life of a program, like @code{Pane} objects,
which are described below, but it can also cause confusing
and seemingly unrelated errors elsewhere in programs if you
are not careful.

@cindex __ctalkCreateObjectInit function
Just as often, however, you may only need to change the
value of an object within a method.  In that case, it is
often easier and safer to work with a copy of the object.
In addition to library functions like
@cite{__ctalkCreateObjectInit} that create objects, Ctalk
provides several methods that can alter or duplicate
objects.  @xref{Variable Promotion and Type Conversion}.

@iftex
@section Assigning Values
@end iftex
@ifnottex
@subheading Assigning Values
@end ifnottex
@anchor{Assigning Values}

The preceding sections contain a lot of material to digest,
and that is at least partially because there can often be
several different ways to write a method.

One basic method that many classes implement is an
overloaded @samp{=} operator, which Ctalk refers to
internally as @code{set_value}, @code{setEqual}, or another similar
identifier.  

The function of the @samp{=} method is simple--it sets the value of
the receiver object to its argument.  However, an assignment operator
needs to be able to handle any type of object it is likely to
encounter, which makes the method more complicated.  The following
sections discuss some of these factors.

@iftex
@subsection The @samp{=} Method from @code{Integer} Class
@end iftex
@ifnottex
@subsubheading The @samp{=} Method from @code{Integer} Class
@end ifnottex
@cindex @mnm{=} instance method @idxclscite{Integer}

One thing objects have in common is that they all have
@emph{values.}  Generally, the value of an object is
contained in an instance variable named, naturally enough,
@code{value.}  All new objects have a @code{value} instance
variable, though some classes (like @code{List} class) may
re-implement its value object(s) differently.

@cindex @mnm{addInstanceVariable} instance method @idxclscite{Object}
The @code{Object} class defines a method,
@mnm{addInstanceVariable}, which works nicely for this
purpose.  So a basic @mnm{=} method could simply use
@mnm{addInstanceVariable}. 
@c ctalk/test/expect/examples/setvalue1.c
@example
Integer instanceMethod = set_value (int __intArg) @{
  self addInstanceVariable ("value", __intArg value);
  return self;
@}
@end example
Note that the method declares its argument, @code{__intArg,}
as an @code{int}, not @code{Integer.}  Ctalk commonly uses C
arguments in its basic classes in order to avoid circular
object references.  (I.e., we couldn't easily define an
@code{Integer} object while the @code{Integer} class itself
is still being defined.)

The method above works fine, assuming that the argument is
also an @code{Integer} object.  However, often you might
want to assign a @code{Character}, or a @code{LongInteger}, or a
@code{Float} to an @code{Integer} object.

Ctalk methods can handle arguments of any class.
Internally, it uses the parameter definition to implement
basic argument checking, but the definition is mainly a
prototype that tells the method what sort of argument to
@emph{expect,} though the parameter definition is not a
hard-and-fast rule.  Generally, methods can implement their
own argument checking when it's necessary.

@cindex @mnm{asInteger} instance method @idxclscite{Magnitude}
Ctalk provides another method, @code{asInteger,} defined in
@code{Magnitude} class, which you can use for the purpose of
type conversion.  The @code{asInteger} method converts other
basic scalar types into @code{Integer}-compatible values.

If we add an @code{asInteger} message, our @mnm{=} method
might look like this.
@c ctalk/text/expect/examples/setvalue2.c
@example
Integer instanceMethod = set_value (int __intArg) @{
  self addInstanceVariable ("value", __intArg asInteger value);
  return self;
@}
@end example
Now we'll discuss one of the curves in the road.  Suppose
that @code{__intArg} is referred to somewhere else in the
program.  (It doesn't matter where else, it could be
@emph{anywhere} else.)

The receiver's value must be unique within its scope.  While
it sounds nice in theory to be able to refer to a single
object everywhere, the program must still regard scoping
rules.  (Though there are many classes, like the @code{Pane}
class and subclasses, where programs need to pass objects by
reference in many different places.) 

@cindex @mnm{copy} instance method @idxclscite{Object}
If that's the case, the method can work on a unique instance of
the argument.  The method does this with the @mnm{copy} (class
@code{Object}) method and a local object.  
@c ctalk/text/expect/examples/setvalue3.c
@example
Integer instanceMethod = set_value (int __intArg) @{
  Integer new localInt;
  localInt copy __intArg asInteger;
  __ctalkAddInstanceVariable (self, "value", localInt value);
  return self;
@}
@end example
The @mnm{copy} and @mnm{become} methods (both of them are
in @code{Object} class) allow you to change objects from one
class to another, but there is an important difference.  The
@mnm{copy} method creates a unique copy of its argument,
while @mnm{become} converts the original object into the
receiver.  (Variable promotion and type conversion are
discussed in detail elsewhere. @xref{Variable Promotion and
Type Conversion}.)  So in this case, the @mnm{=} method
needs to use the @mnm{copy} message.

Now we need to consider another factor.  That is, @emph{the
class of an object's value does not need to be the same
class as the object itself.}  This is often the case with
instance variables, which belong to the parent object's
class but contain values of a different class.

Let's return to an earlier example, where we defined a class
called @code{PositiveInteger}, which could hold only
positive numbers. @xref{PositiveInteger Example}.

Using the @samp{=} method above, the following program from
the earlier section does not work.  
@example
Integer class PositiveInteger;
...
int main () @{
  Exception new e;
  PositiveInteger new p;

  p = 1;   /* Wrong - p's value becomes an Integer. */

  printf ("%d\n", p + 1);

  printf ("%d\n", p - 2);
  if (e pending)
    e handle;
@}
@end example

That's because the @code{PositiveInteger} class also defines
a @mnm{-} method.  So when Ctalk sees the expression @samp{p
- 2}, it looks for @mnm{-} from @code{Integer} class,
because @code{p's} value is now an @code{Integer}.  There is
no unambiguous way to tell @code{PositiveInteger's} value
class really isn't correct, so the only alternative is to
redesign the @mnm{=} method to cope with this issue.

A program can deal with this issue by using Ctalk's library
API and work with the object directly in C.
@c ctalk/text/expect/examples/setvalue4.c
@example
Integer instanceMethod = set_value (int __intArg) @{ 
  OBJECT *self_alias;
  char buf[MAXLABEL];
  self_alias = self;
  sprintf (buf, "%d", __intArg);
  __ctalkSetObjectValueVar (self_alias, buf);
  return self;
@}
@end example
Here, we use @cite{sprintf(3)} and the Ctalk library
function @code{__ctalkSetObjectValueVar} to format the new
value and replace the C object's value directly.  Since the
method only replaces the value in the object's internal
structure, the class of the value is unchanged, and the
example program above works correctly.

However, this version of @mnm{=} does not have the ability
to perform type conversions or handle objects out of scope.
As with so much in Ctalk, a more advanced version of this method
might combine the two approaches.

Ctalk's @code{Object} class provides yet another method
@mnm{is}, that tells you if an object is a member of a
certain class.  So we'll use that in the @mnm{=} method to
determine if the value of the receiver actually is an Integer.
@example
@c ctalk/text/expect/examples/setvalue5.c
Integer instanceMethod = set_value (int __i) @{ 
  OBJECT *self_alias;
  char buf[MAXLABEL];
  Integer new localInt;
  if (self value is Integer) @{
    localInt copy __i asInteger;
    __ctalkAddInstanceVariable (self, "value", localInt value);
  @} else @{
    self_alias = self;
    sprintf (buf, "%d", __i);
    __ctalkSetObjectValueVar (self_alias, buf);
  @}
  return self;
@}
@end example
Further versions of this method need more checking than
this.  For example, methods frequently need to take into account
a receiver's context, which we'll discuss below. 

In many cases, it's either convenient or necessary (or both) to
tailor a @mnm{=} method to a particular class, as the next section
discusses.

@iftex
@subsection The @samp{setValue} Method in @code{Symbol} Class
@end iftex
@ifnottex
@subsubheading The @samp{setValue} Method in @code{Symbol} Class
@end ifnottex
@cindex @mnm{setValue} instance method @idxclscite{Symbol}

This manual often mentions the fact that programs need to
pass objects by reference.  The @code{Symbol} class handles
these chores.

When we want to assign a reference to a @code{Symbol} object,
we generally mean one of several things.
@itemize
@item
If the argument is also a @code{Symbol}, copy its value to the
receiver as a duplicate reference, after first removing a
previous reference.
@item
If the argument belongs to some other class, perform a
conversion to a @code{Symbol}-compatible value and create a
new reference to the argument.
@item 
If the argument is 0, @code{NULL}, or @code{(null)} (in
either Ctalk or C), reflect that assignment in the receiver.
@end itemize

@example

Symbol instanceMethod setValue (void *v) @{
  // Set the value of the receiver to refer to the argument.
  // If the argument is also a Symbol object, set the
  // receiver's value to refer to the same object.
  // Otherwise, set the receiver's value to refer to
  // the argument object.  The referenced object's
  // scope includes VAR_REF_OBJECT scope.
  OBJECT *rcvr_val, *arg;
  char buf[MAXLABEL];

  self removeValue;

  rcvr_val = self value;
  arg = ARG(0);
  if (arg) @{
    __ctalkSetObjectScope (arg, arg -> scope | 512);
    if (v is Symbol) @{
      __ctalkSetObjectValue (rcvr_val,
			     (arg->instancevars ? 
			      arg->instancevars : arg)->__o_value);
    @} else @{
#if defined (__GNUC__) && defined (__x86_64) && defined (__amd64__)
      sprintf (buf, "%#lx", (unsigned long int)arg);
#else
      sprintf (buf, "%#x", (unsigned int)arg);
#endif
      __ctalkSetObjectValue (rcvr_val, buf);
    @}
  @} else @{
    /* Needs to evaluate to a NULL C pointer, not a (null) object. */
    __ctalkSetObjectValue (rcvr_val, "0x0");
  @}
  return self;
@}

@end example

@iftex
@section Receiver Contexts
@end iftex
@ifnottex
@subheading Receiver Contexts
@end ifnottex
@cindex @mnm{=} method @idxclscite{Symbol}

In many cases, copying the value of one object to another is good
enough.  The number 2 and the string ``Hello, world!'' are the same no
matter where they occur.

There are many other cases, however, where you want one object to
become another object, or you want a method to refer to the same
object using multiple labels, or you want to perform some
manipulations on @code{Symbol} objects.

In that case, you can write methods that take into account the context
the receiver occurs in.  This matters mostly with @code{Symbol} objects,
which need to represent other objects, but you can use the receiver's context
with other objects as well.

In the section @cite{Object References} we presented an example of how
manipulate references to objects. @xref{Object References}.  

More briefly here, this section discusses the inner workings of
the different contexts taken from that example, like these three:

@example

  Symbol new sym1;
  Symbol new sym2;
  Symbol new sym3;
  Integer new i;

  ... 

  sym3 = sym1;

  ... 

  sym1 = i;

  ...

  *sym2 = i;

  ...

@end example

This should look a little like C, and in fact it works similarly.
The statement, @samp{sym3 = sym1} assigns the object @samp{sym1} to
the identifier @samp{sym3}.  

Likewise, the statement @samp{sym1 = i} assigns the object @samp{i}
to the identifer @samp{sym1}.

However, the statement @samp{*sym2 = i} creates a reference to @samp{i}.
@samp{sym2} is still a @code{Symbol} that points to an @code{Integer}
object.

@cindex @mnm{hasPointerContext} instance method @idxclscite{Symbol}
@cindex @cite{__ctalkAliasObject ()} function
@cindex @cite{__ctalkAliasReceiver ()} function
To determine how we want the assignment to behave, we can use the
method @mnm{hasPointerContext} (in @code{Object} class), which returns
True if the object to the left of the @mnm{=} operator has a @samp{*}
operator in front of it.  If it does, we create a reference to the
object.  In a non-pointer context, we use the library function
@cite{__ctalkAliasObject ()} (or its companion,
@cite{__ctalkAliasReceiver ()}), to assign the argument to the
identifier on the left-hand side of the @mnm{=} operator.

The method itself is actually quite simple. 

@example

Symbol instanceMethod = setEqual (OBJECT *__newObject) @{
  // Alias the argument to the receiver's indentifier. 
  // If the receiver refers to an object reference (it's
  // preceded by a '*' operator), or if the receiver wasn't 
  // declared as a global or local object (e.g., it's an 
  // instance variable), then create a reference to the 
  // argument object using Symbol : setValue .

  if (self hasPointerContext) @{
    self setValue __newObject;
  @} else @{
    if (__ctalkAliasObject (self, __newObject) != 0) @{
      self setValue __newObject;
    @}
  @}

@}

@end example

You might have noticed, after Ctalk executes a statement like
@samp{sym1 = i}, that @samp{sym1} is no longer a @code{Symbol} object;
it's an @code{Integer}.  

@cindex @mnm{=} method @idxclscite{Integer}
Basically Ctalk handles this by following the same process in 
the @mnm{=} method in @code{Integer} class as it does for @code{Symbol}
class.  That allows us to use the object's class to find the right
@mnm{=} method; we don't need to worry nearly as much about type checking
when making assignments.

@cindex @mnm{is} method @idxclscite{Object}
However, if the need arises, you can add type checking to a method.
You can do this, simply enough, by adding a check of an object's class
with the @mnm{is} method from @code{Object} class.

@example

if (arg is Float) @{
   warning ("Assigning a Float object (or value) to an incompatible receiver.");
@}

@end example

@iftex
@subsection The @samp{=} Method in @code{Integer} Class, Revisited
@end iftex
@ifnottex
@subsubheading The @samp{=} Method in @code{Integer} Class, Revisited
@end ifnottex
@cindex @mnm{=} instance method @idxclscite{Integer}

You may have noticed, from the previous examples, that the class of a
receiver can change if we assign it a new value.  The way that the
language's semantics work is that this is really only an issue when we
change from a @code{Symbol}, which is a reference, to a which is an
actual values, like @code{Integers,} @code{Characters,} @code{Floats},
and so on.

Normally, when you assign, say, a character to an @code{Integer}
object, the compiler and libraries take care of the conversion from
one type to another.  When converting from @code{Symbols} to other
classes, however, Ctalk allows us to add this support in a method.

So, for example, if we want to assign as Symbol object to a receiver
that is an @code{Integer} (this isn't so far-fetched), we might want
to look at this code again.


@example

  Symbol new sym1;
  Symbol new sym2;
  Symbol new sym3;
  Integer new i;

  ... 

  sym3 = sym1;

  ... 

  sym1 = i;  /* sym1 is now an Integer. */

  ...

  sym1 = sym3;  /* Now we want sym1 to be a Symbol again. */

  ...

@end example

In the statement, @samp{sym1 = i}, the statement would use the @mnm{=}
method from @code{Symbol} class.  But in the following statement,
@samp{sym1 = sym3}, Ctalk would use the @mnm{=} method from @code{Integer}
class.

Fortunately, we can write the @code{Integer} @mnm{=} method to support
this.  Parts of the method are similar to the @mnm{=} method in
@code{Symbol} class, and parts of it look like the previous
@code{Integer} @mnm{=} methods.  And we can add a convenient warning
message if the argument belongs to a class for which the Ctalk
libraries don't normally support type conversions.

@example
Integer instanceMethod = set_value (int __i) @{ 
  char buf[MAXLABEL];
  if (self hasPointerContext) @{
    __ctalkAliasObject (self, __i);
  @} else @{
    if (__i is Symbol) @{
      __ctalkAliasObject (self, __i);
    @} else @{
      if ((__i value is Integer) || (__i value is LongInteger) || (__i value is Character) || (__i value is Float)) @{
	sprintf (buf, "%d", __ctalkToCInteger(ARG(0), 1));
	__ctalkSetObjectValueVar (__ctalk_self_internal (), buf);
      @} else @{
	_warning 
	("Integer : = : Argument, \"__i,\" class %s is not (yet) supported.\n",
	 __i className);
      @}
    @}
  @}
  return self;
@}
@end example

@iftex
@subsection Coping with Semantic Issues
@end iftex
@ifnottex
@subsubheading Coping with Semantic Issues
@end ifnottex
@cindex @mnm{=} instance method @idxclscite{String}

It's up to the method to handle any special semantics that the class's
objects use.  For example, the following statements should function
equivalently.

@example

String new myString;
Integer new myIntArg;

myIntarg = 123;

myString = "123";             /* These two statements should produce
                                 identical results, even though one argument
                                 is a constant and the other is an expression.*/
myString = myIntArg asString;

@end example

@cindex @cite{__ctalkStringifyName ()} function
Programs generally expect @code{String} constants to be assigned to
unique objects, so Ctalk provides the @cite{__ctalkStringifyName ()}
function to help deal with this semantic peculiarity.  There may be
others, and it's up to the method to handle them.

@example

String instanceMethod = setEqual (OBJECT *__stringArg) @{
  // String assignment method. Assigns the argument  to the
  // receiver label.  Also does some String-specific
  // semantic stuff for different sorts of String objects.
  // Returns the new String object.

  __ctalkStringifyName (self, __stringArg);
  if (__ctalkAliasReceiver (self, __stringArg) != 0) @{
    self addInstanceVariable "value", __stringArg;
    return self;
  @} else @{
    return __stringArg;
  @}
@}

@end example

@iftex
@section Constructor Methods
@end iftex
@ifnottex
@subheading Constructor Methods
@end ifnottex
@anchor{Constructor Methods}
@cindex Constructor methods

Constructor methods are the methods that actually create objects.
Ctalk provides built-in constructors for basic classes, but they
can be (and often are) overridden by constructors in the class 
libraries

Nearly every program example in this tutorial uses at least
one constructor.  This section describes constructors in
more detail and discusses why and how to write them.

In many object oriented languages, and Ctalk among them,
constructor methods are almost always named @code{new.}
In an application program, their use is simple.

@iftex
@subsubsection Basic Constructors
@end iftex
@ifnottex
@subsubheading Basic Constructors
@end ifnottex
Here is an example of a simple constructor.
@example
Integer new myInt;
@end example
This statement creates a new object, @code{myInt,} that is
an instance of @code{Integer} class.

The statement performs several tasks.  First, it creates the
object @code{myInt} and makes sure it has the correct links
to @code{Integer's} class and superclass objects, and sets
the initial value to @code{(null)}.

Secondly, it registers the object and sets its scope
depending on where the statement appears.  If the statement
appears in a method or C function, the object is local to
that function, and the name @code{myInt} is visible only
within that method or function, or code blocks within the
method or function.  However, if the statement appears
outside of a method or function, then the object's scope is
global to the entire program.  (To be absolutely correct,
though, we should mention that the constructor itself does
not set an object's scope.  That happens after the
constructor is finished creating the object.)

Thirdly, if the class and its superclasses define instance
variables, the constructor creates and initializes instance
variables for the new object.

Because classes inherit methods, the constructor used by
class @code{Integer} is the constructor from @code{Object}
class.  If @code{Integer} class defined its own @mnm{new}
method, it would use that constructor instead.  This point
is important and is worth repeating.  The process is
described in the first section. @xref{Class Hierarchy}.
Here again, a diagram should help clarify this concept.
@smallexample
Class                  Defines Constructor?    Statement or Action
-----                  --------------------    -------------------
Object                 Yes                     Create object.
                                                    ^
                                                    |
Magnitude              No                      Look up method in superclass.
                                                    ^
                                                    |
Integer                No                      Integer new myInt;
                                               Look up method in superclass.
@end smallexample

@iftex
@subsubsection Initializing Objects
@end iftex
@ifnottex
@subsubheading Initializing Objects
@end ifnottex

The main reason that a class needs to define a constructor
is to initialize whatever data the classes's objects need.

Suppose we wanted to create Integers that were initialized
with the value @samp{0} instead of @samp{(null)}.  To do
this we might define a subclass of @code{Integer.}  Let's do
that and call the class @code{InitializedInteger.}

The first thing we need to do is define the class.
@example
Integer class InitializedInteger;
@end example
Then we need to write the constructor for instances of
@code{InitializedInteger}.
@example
InitializedInteger instanceMethod new (String newObjectName) @{
  InitializedInteger super new newObjectName;
  newObjectName = 0;
  return newObjectName;
@}
@end example
You should take note of the first statement.
@example
InitializedInteger super new newObjectName;
@end example
The statement does a lot of things.  First, @code{super}
(which is a keyword, not a method), looks up the @code{new}
message starting with the receiver's superclass.  It first
creates a normal instance of @code{Object} class, then
promotes it to an instance of @code{InitializedInteger}
class.  After this statement, @code{newObjectName} is no
longer simply a method parameter, but a fully fledged
object.

Now the process looks like this.
@smallexample
Class               Has Constructor?  Statement or Action
-----               ----------------  -------------------
Object              Yes               2. Create Object instance. -> 3. Return Object
                                               ^                    instance to caller.
                                               |                          |
Magnitude           No                    Look up method in superclass.   |
                                               ^                          |
                                               |                          |
Integer             No                    Look up method in superclass.   |
                                               ^                          |
                                               |                          |
InitializedInteger  Yes               InitializedInteger new myInt;       |
                                      1. Look up method in superclass.    |
                                      4. Perform initialization <---------
                                      5. Return object to application.
@end smallexample

The class definition and constructor could go in their own
class library, but this example is brief enough to include
in the main source file.  Here is the complete program.
@c ctalk/test/expect/examples/initializedinteger.c
@example
Integer class InitializedInteger;

InitializedInteger instanceMethod new (String newObjectName) @{
  InitializedInteger super new newObjectName;
  newObjectName = 0;
  return newObjectName;
@}

int main () @{
  InitializedInteger new i;
  printf ("%d\n", i);
@}
@end example

@iftex
@subsubsection Class Initialization
@end iftex
@ifnottex
@subsubheading Class Initialization
@end ifnottex

Another reason you might want to write your own constructor
is to initialize a class.  This is the case with
@code{FileStream} subclasses.  The program needs to initialize 
the standard input, standard output, and standard error file handles. 

Initializing a class variable is much like initializing an
object, except that the class variable only needs to be
initialized once.  To make sure that a program doesn't
initialize the class every time it creates an object, The
class definition needs to include a variable that tells the
constructor that class data is already initialized.  Here is
an abbreviated example from @code{ReadFileStream} class,
where the constructor @code{new} calls the method @code{classInit,} 
which initializes @code{stdin}.
@example
FileStream class ReadFileStream;
...
ReadFileStream classVariable stdinStream;
ReadFileStream classVariable classInitDone Integer 0;
...
ReadFileStream classMethod classInit (void) @{

  OBJECT *classObject,
    *stdinStreamVar,
    *classInitVar;

  if (self classInitDone)
    return NULL;

  classObject = __ctalkGetClass ("ReadFileStream");
  stdinStreamVar = __ctalkFindClassVariable ("stdinStream", TRUE);
  
  __ctalkObjValPtr (stdinStreamVar, stdin);

  classInitVar = 
    __ctalkCreateObjectInit ("classInitDone", "Integer",
			     "Magnitude",
			     classObject -> scope, "1");
  __ctalkAddClassVariable (classObject, "classInitDone", classInitVar);

  return NULL;
@}
...
ReadFileStream instanceMethod new (char *__streamName) @{

  ReadFileStream super new __streamName;

  ReadFileStream classInit;
  
  return __streamName; 
@} 
@end example

These methods contain a lot of C code.  There are several
reasons for this.  The first is that it is often easier, and
sometimes necessary, to work directly with operating system
functions and data in C.  

The second reason is that when working with complex objects,
it is possible that the program might contain a circular
class reference - when a definition requires a class that
isn't defined yet, and the second class in turn relies on
definitions from the first class.  

@iftex
@subsubsection Instance Variable Initialization
@end iftex
@ifnottex
@subsubheading Instance Variable Initialization
@end ifnottex

If the declaration of the new object contains complex instance variables,
especially instance variables that have constructor methods of their
own, your constructor needs to construct them also.  

For classes that have only a @code{value} instance variable, it is
generally okay to let Ctalk's internal object creation routines 
create a simple object.  But constructors do not automatically call
other constructors, so simply declaring instance variables of
complex classes does not mean they get constructed automatically.

If the constructor needs to create a complex instance variable, it
must call that instance variable's constructor explicitly.

@cindex @mnm{become} method @idxclscite{Object}
@cindex @mnm{new} method @idxclscite{ANSIScrollingListBoxPane}
Here's an example, somewhat abbreviated, from the
@code{ANSIScrollingListBoxPane} class, which contains several
@code{ANSILabelPane} instance variables and an @code{ANSIScrollPane}
instance variable.  The constructor creates the variables like normal
objects, then adds them to the new object using @mnm{become}
(@code{Object} class).

@example

ANSIWidgetPane class ANSIScrollingListBoxPane;

  ...

ANSIScrollingListBoxPane instanceVariable selectedContent ANSILabelPane NULL;
ANSIScrollingListBoxPane instanceVariable oldSelectedContent ANSILabelPane NULL;

  ...

ANSIScrollingListBoxPane instanceVariable scrollBar ANSIScrollPane NULL;

  ...

ANSIScrollingListBoxPane instanceMethod new (String __paneName) @{

  ANSIWidgetPane super new __paneName;
  ANSIScrollPane new scrollPane;
  ANSILabelPane new selectedContent;
  ANSILabelPane new oldSelectedContent;

    ...

  __paneName scrollBar become scrollPane;

    ...

  __paneName selectedContent become selectedContent;
  __paneName oldSelectedContent become oldSelectedContent;

    ...

  return __paneName;
@}

@end example


Note that the @code{scrollPane} is a local object, while
@code{__paneName scrollBar} is an instance variable.  The @mnm{become}
method creates separate objects for the instance variables.  The same
is true of the @code{selectedContent} and @code{oldSelectedContent} 
objects.

This procedure works with objects of any class, whether or not the
instance variable's class is related to the constructor's receiver
class.  To create the instance variables from the class's superclasses, the constructor uses the statement @code{ANSIWidgetPane super new __paneName}.

Using an expression like @code{ANSIWidgetPane super new __paneName} is
a normal way to tell the constructor to instantiate the new object's
instance variables from its superclasses.  As this section explained
earlier, this is the statement that performs a search back up the class
hierarchy and adds the instance variables that each superclass
defines.

However, it's necessary, both for reliability and to avoid serious
confusion later in the program, to use @code{super new} when the
object is first created.

@cindex @cite{__ctalkInstanceVarsFromClassObject ()} function
If, for some reason, a program needs to instantiate instance variables
from the superclasses elsewhere in a program, the 
@cite{__ctalkInstanceVarsFromClassObject ()} library function performs
the same task.  It replaces the previous instance variables with
fresh copies.  But the program should take care that both the old
and new variables are either correctly referenced or disposed of,
since the interactions between them can become quite complex.

@iftex
@section C Macros for the Method API
@end iftex
@ifnottex
@subheading C Macros for the Method API
@end ifnottex
@cindex C Macros
@cindex @flnm{ctalkdefs.h} include file.
@cindex @code{IS_OBJECT} macro
@cindex @code{FMT_0XHEX} macro
@cindex @code{STR_0XHEX_TO_PTR} macro
@cindex @cite{sscanf ()} function

Ctalk defines many macros that provide a standard interface to C
language features.  The macros are defined in the include file
@flnm{ctalkdefs.h}.  They include macros like @code{IS_OBJECT,} which
checks if a pointer is a valid object; @code{FMT_0XHEX,} which formats
a pointer into its string representation, and @code{STR_0XHEX_TO_PTR,}
which does the converse; when used with a function like
@cite{sscanf(),} it converts the string representation of a pointer
into an actual pointer.  

To include the definitions in a program, include @flnm{ctalkdefs.h} in
a source or class library file.

@example

#include <ctalk/ctalkdefs.h>

@end example

The @cite{Ctalk Language Reference} provides a complete list of the
macros that @flnm{ctalkdefs.h} defines.

@node Graphics, Debugging, Methods, Top
@iftex
@chapter Panes and Graphics
@end iftex
@ifnottex
@heading Panes and Graphics
@end ifnottex
@cindex Panes
@cindex Graphics

So far, this tutorial has used either C's @cite{printf}
function or @mnm{printOn} and other methods of various
classes to display information on a terminal.

@cindex @code{Pane} class
@ifhtml
This section describes how to use @code{Pane} class and its subclasses
to display information in windows, handle user input, and retrieve the
information.
@end ifhtml

@ifinfo
This section describes how to use @code{Pane} class and its subclasses to 
display information in windows, handle user input, and retrieve 
the information.
@end ifinfo

@iftex
This chapter describes how to use @code{Pane} class and its subclasses to 
display information in windows, handle user input, and retrieve 
information provide by Graphical User Interfaces. 
@end iftex

There are @code{Pane} subclasses for the following graphics libraries
and display types.

@table @code
@item ANSI Compatible, Text-mode Displays
Most UNIX consoles, @code{xterms}, VT-100 and many other serial RS-232
terminals, and in some cases, Win32 @samp{cmd.exe} windows and OS X
terminal apps. @xref{ANSIGraphics}.
@item X Window System
GUIs that use a X server, window manager, and Xlib libraries.
@xref{X11Graphics}.
@item GLUT
The @code{GLUTApplication} class provides support for the GLUT and
OpenGL 3-D graphics libraries and runs on many different platforms.
@xref{GLUTGraphics}
@item GLX
The @code{GLXCanvasPane} class is another toolkit that provides
OpenGL's 3-D graphics capabilities on systems that have a X
display. @xref{GLXGraphics}.
@end table

@cindex @code{Stream} class
Closely related to these @code{Pane} classes are several @code{Stream}
subclasses that handle the chores of processing keyboard and mouse
input.  Graphical User Interfaces use more sophisticated input devices
than simple text prompts, and the following sections also describe how
to process and respond to different types of input.

@anchor{ANSIGraphics}
@section @code{Hello, world!} in a Text Window

@cindex @code{ANSIMessageBoxPane}
For the sake of portability and (relative) simplicity, we'll start
with an example that uses the @code{Pane} subclass,
@code{ANSIMessageBoxPane}.  This class is a widget that pops up a
message window on a the screen of a @code{xterm} or physical serial
terminal, then waits for the user's input, and then closes the window.

The program itself is relatively simple.  Here is the listing.

@example

int main () @{
  ANSIMessageBoxPane new messageBox;
  messageBox withText "Hello, world!";
  messageBox show 10, 10;
  messageBox cleanup;
@}

@end example

The program displays the message until the user presses @kbd{Enter} to
close the window.  Pressing @kbd{Esc} also closes windows, but, for
most widget classes, @kbd{Esc} signals that the user wants
to close the window without returning any input.

As you might expect, what happens behind the scenes is a little more
involved.

@section @code{Pane} and @code{Stream} Classes

When a program creates a new instance of a widget (in this case, a
subclass of @code{ANSIWidgetPane}), the new object initializes the
instance variables it inherits from its superclasses, initializes the
storage to hold the information that is to be displayed, and a
@code{Stream} object that handles the window's input and output.  In
the case of @code{ANSIWidgetPane} subclasses, the input and output is
handled by an @code{ANSITerminalStream} object, which is also an
instance variable of the widget.

Here are the classes that handle Pane graphics, and their
corresponding @code{Stream} classes.  This organization makes it
relatively easy to add widgets and support for other text-mode and GUI
interfaces.
@example
 Pane                       Stream
  ANSITerminalPane           TerminalStream
   ANSIWidgetPane             ANSITerminalStream
    ANSIButtonPane
    ANSIMessageBoxPane
    ANSITextBoxPane
    ANSITextEntryPane
    ANSIYesNoBoxPane
  X11Pane                    X11TerminalStream
@end example

This example demonstrates a little of what @code{ANSITerminalPane} and
its subclasses can do.  There are also many other graphics classes and
methods, though.

The next sections begin relatively simply, with an app for text-mode
terminals.  The tutorial then progresses to the classes and methods
that support the X Window System's drawing and user interface
capabilities.  If you're already familiar with GUI programming, then
feel free to skip ahead, and refer back to these sections if some
concept or capability seems unfamiliar to you.


@section @code{InputEvent} Class

Ctalk uses @code{InputEvent} objects to communicate between the
@code{Pane's} stream object, which receives its information from the
serial tty device that communicates with the @code{xterm} or physical
serial terminal, and the pane objects that you see on the screen.
Ctalk uses @code{InputEvent} objects extensively, and you need to know
about them to write a graphical app.

Text-mode displays use instances of @code{ANSITerminalStream} class to
handle user input.  The input can come from either a console (if
you're the superuser or your system doesn't have a GUI), a
@code{xterm}, or a physical serial terminal.

When a program creates an @code{ANSITerminalStream} object, Ctalk
initializes its input and output to the application's standard input
and output channels.  For the sake of simplicity, the following
examples use standard input and output.

@cindex @mnm{getCh} instance method @idxclscite{ANSITerminalStream}
Text-mode displays use the @mnm{getCh} method (class
@code{ANSITerminalStream}) to receive characters and return them to the
application.  @code{ANSITerminalStream} also provides some basic
terminal capabilities, and you can also use the class independently of
a window.

Here is a brief example that echoes characters to the display.
@example
int main () @{
  ANSITerminalStream new term;  /* Initializes input and output */
                                /* to stdin and stdout.         */
  Character new c;

  term rawMode;
  term clear;
  term gotoXY 1, 1;

  while ((c = term getCh) != EOF)
    term printOn "%c", c;

  term restoreTerm;
@}
@end example

@cindex @mnm{clear} instance method @idxclscite{ANSITerminalStream}
@cindex @mnm{gotoXY} instance method @idxclscite{ANSITerminalStream}
@cindex @mnm{printOn} instance method @idxclscite{ANSITerminalStream}
There are a few things to note about this example.  The first is that
the program sets the terminal to @emph{raw} mode.  That means the
characters you type at the keyboard are received directly by the
application, without any buffering or echoing by the terminal device
itself.  All terminal output is handled by the methods @mnm{clear},
@mnm{gotoXY}, and @mnm{printOn}.

@cindex @mnm{rawMode} instance method @idxclscite{ANSITerminalStream}
@cindex @mnm{restoreTerm} instance method @idxclscite{ANSITerminalStream}
It also means that the program @emph{must} restore the terminal to its
original state before exiting.  That is the purpose of the
@mnm{restoreTerm} method.  If the application did not restore the
terminal before exiting, the display would likely be unusable, so be
sure to use @mnm{restoreTerm} whenever you use @mnm{rawMode} in your
applications.

The @code{ANSITerminalStream} version of @mnm{printOn} notes what mode
the terminal is in, so the program can display output regardless of
whether the terminal is raw mode or not.

You should note that @mnm{getCh} recognizes an @code{EOF} (@kbd{C-z})
character, but in practice it is often difficult or impossible to
enter an @code{EOF} from the keyboard.

The example above would have difficulty handling many control
characters, and it doesn't recognize terminal escape sequences; for
example, of the type generated when you press a cursor key.  

That is why applications that use panes use @code{InputEvent} objects.
@code{InputEvent} objects contain information about what type (or
@emph{class}) of input is coming from the terminal, and the actual
@emph{data}.

In the case of terminal input, there are two event classes:
@code{KBDCUR,} for terminal escape sequences, and @code{KBDKEY,} for
alphanumeric keypresses.  

The terminal stream queues these events, and the pane can retrieve
then and process them in whatever manner it needs to.

Programs that use GUI displays don't actually need to use input
events, but you will find that handling input beyond a simple press of
the @kbd{Return} key can become quite involved.  For an example, look
at the @code{ANSITerminalPane} section of the language reference.

@section Using Queued @code{InputEvents}

@cindex @mnm{handleInput} instance method @idxclscite{ANSITerminalPane}
If you're wondering how to go about adding all of this to a program,
don't worry.  All of the @code{ANSIWidgetPane} subclasses implement a
method @mnm{handleInput}, which directs the pane's
@code{ANSITerminalStream} to queue the events, and handles the events
as it receives them.

In addition, all instances of @code{ANSITerminalPane} and its
subclasses contain an instance variable (@code{paneStream}) that is an
@code{ANSITerminalStream} object.  You might recall from the previous
sections that @code{ANSITerminalStream} initializes its input and
output to @code{stdin} and @code{stdout}. Most applications need not
handle that chore themselves.

If you plan to write widgets, you might need to see to the I/O
initialization yourself.  However, if the widget is a subclass of
@code{ANSITerminalPane}, then the constructor in that class takes care
of I/O initialization anyway.  

For now, we'll just describe @code{ANSIWidgetPane}'s implementation of
the @mnm{handleInput} method. Here it is, minus a few comments omitted
for space reasons.
@cindex @mnm{handleInput} instance method @idxclscite{ANSIWidgetPane}
@example
ANSIWidgetPane instanceMethod handleInput (void) @{

  Integer new c;
  InputEvent new iEvent;

  while ((c = self paneStream getCh) != EOF) @{
    iEvent become self paneStream nextInputEvent;
    switch (iEvent eventClass)
      @{
      case KBDCHAR:
      case KBDCUR:
        switch (iEvent eventData)
          @{
          case ESC:
            self withdraw;
            self paneStream restoreTerm;
            return NULL;
            break;
          @}
        break;
      @}
  @}
  return NULL;
@}
@end example

@cindex @mnm{getCh} instance method @idxclscite{ANSITerminalStream}
@cindex @mnm{restoreTerm} instance method @idxclscite{ANSITerminalStream}
This method is very basic--it handles only one key sequence:
@kbd{ESC}, which withdraws the pane from the display (@emph{Withdraw,}
in this case, is functionally synonymous with, @emph{close,} although
it's the following methods that close the terminal connection and
delete the pane object.)  This method also uses the @mnm{getCh} and
@mnm{restoreTerm} methods that we mentioned earlier, with the pane's
@code{paneStream} instance variable as the receiver.

@cindex @mnm{openInputQueue} instance method @idxclscite{ANSITerminalStream}
More involved implementations of @mnm{handleInput} also use the
@mnm{openInputQueue} method from @code{ANSITerminalPane} to enable
event queueing.  You might want to look at the @mnm{handleInput}
methods of other classes to see how this is accomplished.

@section The Widget API

@cindex @mnm{cleanup} instance method @idxclscite{ANSIWidgetPane}
@cindex @mnm{handleInput} instance method @idxclscite{ANSIWidgetPane}
@cindex @mnm{new} instance method @idxclscite{ANSIWidgetPane}
@cindex @mnm{parent} instance method @idxclscite{ANSIWidgetPane}
@cindex @mnm{refresh} instance method @idxclscite{ANSIWidgetPane}
Ctalk widget classes generally implement a set of methods that handle 
the common chores of displaying information and handling input.  The
methods listed here are a minimum set of methods. Widget classes can 
implement additional methods as needed.  

Here we'll describe the API for the ANSITerminalPane classes
and its subclasses.  We'll discuss the API for X11 panes
later on. @xref{X Widget API}.
@table @code
@item cleanup
Clean up any additional data used by the widgets.  This includes 
the @code{paneBuffer} and @code{paneBackingStore} storage, and any
additional storage.  Deletion of the widget objects themselves is
handled by the normal object cleanup mechanisms.
@item handleInput
Receive @code{InputEvent} objects from the receiver's
@code{paneStream}, and take action based on the keyboard input.
@item new
Initializes the pane and its sub-panes, and sets whatever parameters
are necessary.
@item parent
Attach a sub-widget to its parent widget.
@item refresh
Update the pane and its child panes on the display.
@end table

@cindex @mnm{map} instance method @idxclscite{ANSITerminalPane}
@cindex @mnm{unmap} instance method @idxclscite{ANSITerminalPane}
It's also likely that a widget class needs to implement its own
@mnm{map} and @mnm{unmap} methods, similar to those in
@code{ANSITerminalStream} class.

Many @code{ANSITerminalPane} subclasses also implement a @code{show}
method, which pops up the window at a specified @code{x, y} position
on the terminal.  Strictly speaking, however, @code{show} is a
convenience method.

This section has not discussed adding shadows, borders, titles, and
other graphical effects to pane objects.  There are a lot of them, and
they are described in each class's section of the language
reference. 

There is one point that we should note about graphics effects here,
however.  In order to keep the widget classes and their libraries as
fast as possible, when refreshing subpanes, the terminal's graphics
attributes (the graphical effects other than borders and shadows;
i.e., bold, reverse, or blinking text, graphics character sets, and
so forth) are @emph{not} automatically updated when a parent window is
refreshed.  The program needs to update the subpanes individually.  As
in this example, from the @code{ANSITextBoxPane} @mnm{show} method.
@example
self refresh;                    /* Refresh the main widget.    */
self dismissButton               /* Toggle the button's focus   */
                                 /* highlight.                 */
   focusHighlightOnOff;
self dismissButton refresh;      /* Refreshes the button widget */
                                 /* independently.              */
@end example

If the method did not independently refresh the receiver's
@code{dismissButton} subwidget, the change to the button's focus
highlight would not be visible.  

Complex widgets that have more than one button or text input box need
to keep track of the input focus and its display.  There is a bit more
about these issues in the next section.

@section Serial Terminals

@cindex @mnm{openOn} instance method @idxclscite{ANSITerminalStream}
@cindex @mnm{setTty} instance method @idxclscite{ANSITerminalStream}
Applications that handle input and output for serial terminals must 
also use the @mnm{openOn} and @mnm{setTty} methods of
@code{ANSITerminalStream} class.  Their use is relatively simple.
@example
ANSIYesNoBoxPane new myWidget;  /* Initialize stdin and stdout. */

myWidget paneStream openOn "/dev/ttyS0"; /* A Linux tty device. */
myWidget paneStream setTty 9600, 8, 'n', 1;
@end example
The @code{ANSIWidgetPane} subclasses can, but don't always, handle all
of sequences defined by the ANSI, VT-100, or @code{xterm}
specifications.  It's up to each class and subclass to determine how
to handle the escape sequences it needs.

@anchor{X11Graphics}
@section @code{X11Pane} Class
@cindex @code{X11Pane} class

The @code{X11Pane} class can display text in a X window and handle a
set of X input events, both from the X server and the window manager.

The next few sections describe basic drawing with
@code{X11Pane} objects.  This provides a more gentle
introduction to all of the features of @code{X11Pane}
objects and the @code{Pen,} @code{X11Font,} @code{Point,}
@code{Line,} and @code{Rectangle} objects which provide
specific drawing features.  We'll describe the X widget API
later on.  @xref{X Widget API}.

We'll just mention here that @code{X11Pane} objects use the X window's
default visual, but they also maintain a copy of the window's graphics
context, so you can create your own visuals if necessary.  If you're
not certain what that means, it allows classes to be flexible enough
that you can still create complex windows using the Xlib API if a
class doesn't provide a specific feature that the application needs.

@section @code{Points,} @code{Lines,} and @code{Rectangles}
@cindex @code{Point} class
@cindex @code{Line} class
@cindex @code{Rectangle} class

Now that we've described how to communicate with pane objects and
windows, we can finally discuss drawing things on the screen.  The
classes @code{Point}, @code{Line}, and @code{Rectangle} provide the
ability to draw on @code{X11Pane} windows.

@cindex @mnm{draw} instance method @idxclscite{Point}
@cindex @mnm{draw} instance method @idxclscite{Line}
@cindex @mnm{draw} instance method @idxclscite{Rectangle}
Each of these classes provides a @mnm{draw} method that lets
you draw the object on a X window.  The dimensions of these
objects are determined by their instance variables, which
are all @code{Point} objects.

For example, to draw a point on a window an application
might use the following code.

@example

Point new myPoint;

myPoint x = 35;
myPoint y = 35;

myPoint draw xPane;

@end example

Note that the argument to @mnm{draw} is the @code{X11Pane}
object.  @code{X11Pane} class has its own @mnm{draw} method 
as well, so an application could also use the following
statement, and the result would be the same as the previous
example. 

@example

xPane draw myPoint;

@end example

A @code{Line} object has two @code{Point} objects as
instance variables, which describe the start and end of the
line.  
@example
Line new myLine;

myLine start x = 90;
myLine start y = 10;
myLine end x = 10;
myLine end y = 90;

xPane draw myLine;
@end example

Similarly, a @code{Rectangle} object has four @code{Line} instance
variables that describe the sides of the rectangle.

Here is the declaration from @code{Rectangle} class.

@example

Rectangle instanceVariable top Line NULL;
Rectangle instanceVariable right Line NULL;
Rectangle instanceVariable bottom Line NULL;
Rectangle instanceVariable left Line NULL;

@end example

When creating a rectangle, you might use statements like these.

@example

rectangle top start x = 10;
rectangle top start y = 10;
rectangle right end x = 80;
rectangle right end y = 80;
@emph{...}

xPane draw rectangle;

@end example

@cindex @mnm{dimension} instance method @idxclscite{Rectangle}
As a shortcut, the @mnm{dimensions} method uses the upper left and
lower right corners of the rectangle to fill in the instance
variables.

@example

rectangle dimensions 10, 10, 100, 100;

@end example

If you want to draw a solid rectangle, instead of an outline, use the
@mnm{fill} method instead of @mnm{draw}.

@example

xPane fill rectangle;

@end example

@section @code{Pens}
@cindex @code{Pen} class

If a program provides only the dimensions of a shape, the
default width of a point or line is 1 pixel, and the shape's
color is black.  

@cindex @mnm{drawWithPen} instance method @idxclscite{Point}
@cindex @mnm{drawWithPen} instance method @idxclscite{Line}
@cindex @mnm{drawWithPen} instance method @idxclscite{Rectangle}
@cindex @mnm{fillWithPen} instance method @idxclscite{Rectangle}
If you want to set the width and color of a shape; for
example, to a thick green line, you can provide a @code{Pen} object
that contains the color and width information.

@example

Line new myLine;
Pen new greenPen;

greenPen width = 10;
greenPen color = "green";

xPane drawWithPen myLine, greenPen;

@end example

Instead of using @mnm{draw} in these cases, you would use
the @mnm{drawWithPen} method (or @mnm{fillWithPen} for
solid @code{Rectangle} objects).

The @cite{Ctalk Language Reference} contains simple examples
for drawing each of these classes.  Here, however, is a 
demonstration program that draws red, green, and blue dots
inside a window.
@c ctalk/test/expect/examples-x11/dots.c
@example
int main () @{
  X11Pane new xPane;
  InputEvent new e;
  Pen new bluePen;
  Pen new redPen;
  Pen new greenPen;
  Point new redPoint;
  Point new bluePoint;
  Point new greenPoint;

  xPane initialize 10, 10, 250, 250;
  xPane map;
  xPane raiseWindow;
  xPane openEventStream;

  xPane background "yellow";
  xPane clearWindow;

  redPen width = 100;
  redPen colorName = "red";
  redPoint x = 40;
  redPoint y = 40;

  greenPen width = 100;
  greenPen colorName = "green";
  greenPoint x = 120;
  greenPoint y = 40;

  bluePen width = 100;
  bluePen colorName = "blue";
  bluePoint x = 80;
  bluePoint y = 90;

  while (TRUE) @{
    xPane inputStream queueInput;
    if (xPane inputStream eventPending) @{
      e become xPane inputStream inputQueue unshift;
      switch (e eventClass value)
        @{
        case WINDELETE:
          xPane deleteAndClose;
          exit (0);
          break;
        case EXPOSE:
        case RESIZENOTIFY:
	  xPane drawWithPen redPoint, redPen;
	  xPane drawWithPen greenPoint, greenPen;
	  xPane drawWithPen bluePoint, bluePen;
          break;
        default:
          break;
        @}
    @}
  @}
@}
@end example

The program first initializes the window and starts
receiving messages from the X server with the
@mnm{initialize} and @mnm{openEventStream} messages.  Only
then can the program perform any drawing on the window,
including setting the background and updating the window
(with the @mnm{background} and @mnm{clearWindow} messages).
It is necessary for X client programs to send and receive
window system requests in synchronization with the display
hardware.

@section Fonts
@cindex Fonts

@code{X11Pane} objects also provide simple font support.

If you set the @code{fontDesc} instance variable to a X
Logical Font Descriptor, as in this example, then text is
displayed using that font.

@example

myPane fontDesc = "-*-courier-medium-r-*-*-12-120-*-*-*-*-*-*";

@end example

Modern operating systems provide many different types of fonts.  For
now, though, this tutorial discusses the basic X fonts and their
descriptions.  If you're not familiar with them, the manual page for
@cite{xfontsel(1)} provides a good starting point.

Ctalk's libraries determine the actual font from the font descriptor
that you provide (like the descriptor given by @code{xfontsel}), and
fill in the metrics in the pane's @code{font} instance variable, which
is a @code{X11Font} object.

If you want to specify a font simply by setting the
@code{fontDesc} instance variable, then you must do it
@emph{before} the program calls the @mnm{initialize} method
and Ctalk initializes the actual window parameters.  

@cindex @mnm{useFont} instance method @idxclscite{X11Pane}
If, however, you want to change fonts in the middle of a
program, then use the @mnm{useFont} method, as in this
example.  
@example
myPane useFont "-*-courier-medium-r-*-*-12-120-*-*-*-*-*-*"
@end example

In either case, Ctalk fills in the font's dimensions: its
ascender, descender, and total height; and the width of its
widest character.

@cindex @mnm{getFontInfo} instance method @idxclscite{X11Font}
If you simply want to find the dimensions of a font without
actually using it, then you can use the @mnm{getFontInfo}
method (class @code{X11Font}), and it will fill in the 
dimensions in an X11Font's instance variables.

If the program doesn't specify a font, then text is
displayed using the system's fixed font.

@anchor{X Widget API}
@section The X Widget API

@cindex X Widget API
@cindex @code{X11PaneDispatcher} class
@cindex @code{X11CanvasPane} class
@cindex @code{X11TextPane} class
@cindex @code{X11Bitmap} class
The widget API is still in development.  So far, it is
composed of three classes: @code{X11PaneDispatcher,}
@code{X11CanvasPane,} and @code{X11TextPane.}  To do the
mechanics of actual drawing, these classes rely on the
@code{X11Bitmap} class.

Most of the information in the previous sections also
applies here.  However, the widget API also provides the
methods to dispatch events to subpanes and other methods to
handle the events.  The API's design can also allow multiple
panes within a single window, although at present only one
subpane may occupy a window.

@iftex
@subsection The Pane Hierarchy
@end iftex
@ifnottex
@subheading The Pane Hierarchy
@end ifnottex

The basic way to create an application that uses subpanes is
to attach a @code{X11PaneDispatcher} object to a
@code{X11Pane} object, and then a pane class like
@code{X11CanvasPane} to the @code{X11PaneDispatcher} object.

Each class handles specific chores for drawing in the
windows and handling input from the user and the display
system.  The following diagram should make this clearer.
@example

 ------------------
|                  |     Receives events from the display system
|    X11Pane       |     via the inputStream instance variable,
|                  |     and sends them to subpanes, if any.
 ------------------
        |
        v
 ------------------
|                  |     Defines the basic handler methods 
| X11PaneDispatcher|     for different types of events, and
|                  |     dispatches various events to subpane
 ------------------      handlers if they exist.
        |
        v
 ------------------
| X11CanvasPane,   |     Provides the methods and instance data
| X11TextPane, etc.|     used by the application for drawing text 
|                  |     or graphics in the subpane's window, 
 ------------------      and updating the main window.
        |
        v
 ------------------
| X11Bitmap        |     Contains information about the 
|                  |     resources used by the hardware and 
|                  |     system libraries for drawable surfaces,
 ------------------      colors, fonts, and so on.
@end example

As with other complex pane objects, programs attach subpanes to
their parent panes.  As an example, here is the dots program 
from earlier in this chapter.  In this case, the application
uses a @code{X11CanvasPane} object for drawing.
@c ctalk/test/expect/examples-x11/canvas-dots.c
@example
int main () @{
  X11Pane new xPane;
  InputEvent new e;
  X11PaneDispatcher new xTopLevelPane;
  X11CanvasPane new xCanvasPane;
  Application new paneApp;

  paneApp enableExceptionTrace;
  paneApp installExitHandlerBasic;

  xPane initialize 10, 10, 250, 250;
  xTopLevelPane attachTo xPane;        /* The attachTo methods also */
  xCanvasPane attachTo xTopLevelPane;  /* set the dimensions of the */
                                       /* subpanes before they are  */
                                       /* mapped and raised along   */
                                       /* with the top-level pane.  */

  xPane map;
  xPane raiseWindow;
  xPane openEventStream;               /* Before we can do any      */
                                       /* drawing on the window, we */
                                       /* need to start sending and */
                                       /* receiving events from the */
                                       /* X server.  That is what   */
                                       /* openEventStream does.     */

  xPane background "yellow";           /* Setting the background of */
  xPane clearWindow;                   /* an X11Pane object sets the*/
                                       /* background of the actual  */
                                       /* window.                   */

  xCanvasPane background "yellow";     /* Setting the background of */
                                       /* a buffered pane like a    */
                                       /* X11CanvasPane sets the    */
                                       /* background color of its   */
                                       /* buffer.                   */

  xCanvasPane clearRectangle 0, 0, 250, 250; /* In both cases, we   */
                                             /* need to update the  */
                                             /* pane before the new */
                                             /* color is visible,   */
                                             /* with either,        */
                                             /* "clearWindow," or,  */
                                             /* "clearRectangle."   */
  xCanvasPane pen width = 100;
  xCanvasPane pen colorName = "red";
  xCanvasPane drawPoint 40, 40;
  xCanvasPane pen colorName = "green";
  xCanvasPane drawPoint 120, 40;
  xCanvasPane pen colorName = "blue";
  xCanvasPane drawPoint 80, 90;

  while (TRUE) @{
    xPane inputStream queueInput;
    if (xPane inputStream eventPending) @{
      e become xPane inputStream inputQueue unshift;
      xPane subPaneNotify e;          /* We need to notify subPanes */
                                      /* e.g., xCanvasPane of the   */
                                      /* input events from the GUI. */
      switch (e eventClass value)
        @{
        case WINDELETE:
          xPane deleteAndClose;
          exit (0);
          break;
        case EXPOSE:
        case RESIZENOTIFY:
	  xCanvasPane pen width = 100;
	  xCanvasPane pen colorName = "red";
	  xCanvasPane drawPoint 40, 40;
	  xCanvasPane pen colorName = "green";
	  xCanvasPane drawPoint 120, 40;
	  xCanvasPane pen colorName = "blue";
	  xCanvasPane drawPoint 80, 90;
          break;
        default:
          break;
        @}
    @}
  @}
@}
@end example

For another example program, look at the simple drawing
program in the @code{X11CanvasPane} section of the
@cite{Ctalk Language Reference.}

@iftex
@subsection X Window System Events
@end iftex
@ifnottex
@subheading X Window System Events
@end ifnottex

Like other graphical programs, objects of @code{X11Pane}
class and its subclasses respond to events from the
keyboard, mouse, and display.  

Here are events types that the API provides.  An application
program does not need to handle all of them - only the
events that relate to the application's functions.

The table also lists the data that each event type provides,
and the data contained in each of the event's instance variables.
@smallexample
eventclass     eventdata1 eventdata2 eventdata3 eventdata4 eventdata5
-------------  ---------- ---------- ---------- ---------- ----------
BUTTONPRESS    x          y          state      button     -
BUTTONRELEASE  x          y          state      button     -
KEYPRESS       x          y          state      keycode    X11 keysym
KEYRELEASE     x          y          state      keycode    X11 keysym
MOTIONNOTIFY   x          y          state      is_hint
MAPNOTIFY      event      window id  -          -          -
EXPOSE         x          y          width      height     count
MOVENOTIFY     x          y          width      height     border width
RESIZENOTIFY   x          y          width      height     border width
WINDELETE      -          -          -          -          -
@end smallexample

Some of the data provided by these events are defined by the
window system protocol.  Other information is provided by
the Ctalk libraries.  For example, the X11 keysym
information provided by a @code{KEYPRESS} or
@code{KEYRELEASE} event translates a hardware specific keycode 
into a portable X11 keysym, so an application doesn't need to 
worry about what type of keyboard the system has.

If you're exploring the X Window System API, you might find
it useful to have the application monitor these events.  
The @flnm{demos/xhello.c} sample program provides an example of how 
applications might monitor these events.

@anchor{GLUTGraphics}
@iftex
@section @code{GLUTApplication} Class
@end iftex
@ifnottex
@subheading @code{GLUTApplication} Class
@end ifnottex
@cindex @code{GLUTApplication} class
@cindex OpenGL graphics
@cindex Graphics, OpenGL
@cindex Graphics, 3D
@cindex Modeling, 3D

The GLUT toolkit, which is available on most platforms that support
the OpenGL graphics API, is a cross-platform toolkit that greatly
simplifies writing applications for 3D modeling and graphics.

The GLUTApplication class provides methods that help you define
callbacks for the various GUI events, pointer and keystroke handlers,
background and animation callbacks, and a simplified API for creating
and managing windows that is compatible with most systems that have
GUI's.

To do the actual drawing, @code{GLUTApplication} class programs use
the OpenGL API.  OpenGL is a large library that flexibly supports
application specific graphics.  

There are many books and tutorials that describe OpenGL and the
subject of 3D graphics.  Here, we'll just show a simple program that
integrates some of the basic Ctalk methods with GLUT and OpenGL.  This
program is in the Ctalk source package, as the file,
@code{demos/glut/tetra.ca}.

@example

/*
  Demonstration that draws a tetrahedron, manually rendered with
  blended colors between vertexes. 

  Pressing [F1] toggles a full screen display.
  Pressing [Esc] exits the program.
*/

/*
  To build manually with Linux/UNIX use a series of commands like the following.

    $ ctalk tetra.ca -o tetra.i
    $ gcc tetra.i -o tetra -lctalk -lreadline -lhistory -lGL -lGLU -lglut

  or simply,

    $ ctcc -x tetra.ca -o tetra

  On OS X, to build with the GLUT framework (but with the standard GL includes):

    $ ctalk -I /usr/X11R6/include tetra.ca -o tetra.i
    $ gcc -framework GLUT tetra.i -o tetra -lctalk -lreadline \
        -L/usr/X11R6/lib -lGL -lGLU
 */

#ifndef ESC
#define ESC 27
#endif
#define WINWIDTH 640
#define WINHEIGHT 480

GLUTApplication new tetra;
Boolean new isFullScreen;

#include <ctalk/ctalkGLUTdefs.h>

float face1[3][3] = @{@{0.0f, 2.0f, 0.0f@},
		     @{-2.0f, -2.0f, 2.0f@},
		     @{2.0f, -2.0f, 2.0f@}@};
float face2[3][3] = @{@{0.0f, 2.0f, 0.0f@},
		     @{2.0f, -2.0f, 2.0f@},
		     @{2.0f, -2.0f, -2.0f@}@};
float face3[3][3] = @{@{0.0f, 2.0f, 0.0f@},
		     @{2.0f, -2.0f, -2.0f@},
		     @{-2.0f, -2.0f, -2.0f@}@};
float face4[3][3] = @{@{0.0f, 2.0f, 0.0f@},
		     @{-2.0f, -2.0f, -2.0f@},
		     @{-2.0f, -2.0f, 2.0f@}@};

float base[4][3] = @{@{2.0f, -2.0f, 2.0f@},
		    @{2.0f, -2.0f, -2.0f@},
		    @{-2.0f, -2.0f, -2.0f@},
		    @{-2.0f, -2.0f, 2.0f@}@};
float angle = 0.0f;

void mydisplay (void) @{
  glEnable (GL_NORMALIZE);
  glEnable(GL_DEPTH_TEST);
  glClearColor(0.0, 0.0, 0.0, 1.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
  glLineWidth (1.0f);

  glLoadIdentity ();
  glColor4f (1.0f, 1.0f, 1.0f, 1.0f);

  glRotatef (angle, 0.0f, 1.0f, 0.0f);
  glRotatef (10.0f, 0.0f, 0.0f, 1.0f);

  glBegin (GL_TRIANGLES);
  glColor3f (1.0f, 0.0f, 0.0f);
  glVertex3fv (face1[0]);
  glColor3f (0.0f, 1.0f, 0.0f);
  glVertex3fv (face1[1]);
  glColor3f (0.0f, 0.0f, 1.0f);
  glVertex3fv (face1[2]);

  glColor3f (1.0f, 0.0f, 0.0f);
  glVertex3fv (face2[0]);
  glColor3f (0.0f, 1.0f, 0.0f);
  glVertex3fv (face2[1]);
  glColor3f (0.0f, 0.0f, 1.0f);
  glVertex3fv (face2[2]);
			
  glColor3f (1.0f, 0.0f, 0.0f);
  glVertex3fv (face3[0]);
  glColor3f (0.0f, 1.0f, 0.0f);
  glVertex3fv (face3[1]);
  glColor3f (0.0f, 0.0f, 1.0f);
  glVertex3fv (face3[2]);
			
  glColor3f (1.0f, 0.0f, 0.0f);
  glVertex3fv (face4[0]);
  glColor3f (0.0f, 1.0f, 0.0f);
  glVertex3fv (face4[1]);
  glColor3f (0.0f, 0.0f, 1.0f);
  glVertex3fv (face4[2]);
  glEnd ();

  glBegin (GL_QUADS);

  glColor3f (1.0f, 0.0f, 0.0f);
  glVertex3fv (base[0]);
  glColor3f (0.0f, 1.0f, 0.0f);
  glVertex3fv (base[1]);
  glColor3f (0.0f, 0.0f, 1.0f);
  glVertex3fv (base[2]);
  glColor3f (1.0f, 0.0f, 1.0f);
  glVertex3fv (base[3]);

  glEnd ();

  glutSwapBuffers ();
@}

void animation (void) @{
  angle += 0.2f;
  if (angle >= 360.0f)
    angle = 0.0f;
  glutPostRedisplay();
@}

void fn_key (int keycode, int x, int y) @{
  if (keycode == GLUT_KEY_F1) @{
    if (!isFullScreen) @{
      tetra fullScreen;
    @} else @{
      tetra reshape WINWIDTH, WINHEIGHT;
    @}
  @}
  isFullScreen = !isFullScreen;
@}

void key (unsigned char c, int x, int y) @{
  if (c == ESC)
    exit (0);
@}

int main (int argc, char **argv) @{
  tetra initGLUT(argc, argv);
  tetra initWindow (WINWIDTH, WINHEIGHT);
  tetra createMainWindow ("Tetrahedron -- GLUTApplication Class");
  tetra defineDisplayFn mydisplay;
  tetra defineIdleFn animation;
  tetra defineSpecialFn fn_key;
  tetra defineKeyboardFn key;
  tetra installCallbackFns;
  tetra run;
  
@}
@end example

@anchor{GLXGraphics}
@iftex
@section @code{GLXCanvasPane} Class
@end iftex
@ifnottex
@subheading @code{GLXCanvasPane} Class
@end ifnottex
@cindex @code{GLXCanvasPane} class
@cindex GLX
@cindex OpenGL graphics
@cindex Graphics, OpenGL
@cindex Graphics, 3D
@cindex Modeling, 3D

@code{GLXCanvasPane} is another class that provides support for 3-D
graphics using OpenGL.  GLX provides visual classes that allow OpenGL
to perform 3-D modeling in a X window.  Because it is integrated with
the X server, GLX is available on nearly all modern systems that use
X desktops.

Like other OpenGL utility libraries, @code{GLXCanvasPane} doesn't
provide many of the actual drawing routines, leaving that to OpenGL
itself.  However, the class does provide a framework that facilitates
3-D modeling on as many compatible systems as possible.

Printed below is a sample @code{GLXCanvasPane} application.  This
program is included in the Ctalk distribution as
@code{demos/glx/glx.ca}.

The program is similar to the example program in the
@code{GLUTApplication} section, except that the event handling methods
that provide the callbacks are defined in @code{GLXCanvasPane}, so you
can subclass and modify application classes as necessary.

For detailed information about @code{GLXCanvasPane} class, refer to
the @code{GLXCanvasPane} section of the @cite{Ctalk Language
Reference}.


@example

#include <X11/Xlib.h>
#include <GL/glx.h>

#define DEFAULT_WIDTH 500
#define DEFAULT_HEIGHT 500

float face1[3][3] = @{@{0.0f, 2.0f, 0.0f@},
		     @{-2.0f, -2.0f, 2.0f@},
		     @{2.0f, -2.0f, 2.0f@}@};
float face2[3][3] = @{@{0.0f, 2.0f, 0.0f@},
		     @{2.0f, -2.0f, 2.0f@},
		     @{2.0f, -2.0f, -2.0f@}@};
float face3[3][3] = @{@{0.0f, 2.0f, 0.0f@},
		     @{2.0f, -2.0f, -2.0f@},
		     @{-2.0f, -2.0f, -2.0f@}@};
float face4[3][3] = @{@{0.0f, 2.0f, 0.0f@},
		     @{-2.0f, -2.0f, -2.0f@},
		     @{-2.0f, -2.0f, 2.0f@}@};

float base[4][3] = @{@{2.0f, -2.0f, 2.0f@},
		    @{2.0f, -2.0f, -2.0f@},
		    @{-2.0f, -2.0f, -2.0f@},
		    @{-2.0f, -2.0f, 2.0f@}@};

float angle = 20.0;

GLXCanvasPane instanceMethod draw (void) @{
  glEnable (GL_NORMALIZE);
  glEnable(GL_DEPTH_TEST);
  glClearColor(0.0, 0.0, 0.0, 1.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
  glLineWidth (1.0f);

  glLoadIdentity ();
  glColor4f (1.0f, 1.0f, 1.0f, 1.0f);

  glRotatef (angle, 0.0f, 1.0f, 0.0f);
  glRotatef (10.0f, 0.0f, 0.0f, 1.0f);

  glBegin (GL_TRIANGLES);
  glColor3f (1.0f, 0.0f, 0.0f);
  glVertex3fv (face1[0]);
  glColor3f (0.0f, 1.0f, 0.0f);
  glVertex3fv (face1[1]);
  glColor3f (0.0f, 0.0f, 1.0f);
  glVertex3fv (face1[2]);

  glColor3f (1.0f, 0.0f, 0.0f);
  glVertex3fv (face2[0]);
  glColor3f (0.0f, 1.0f, 0.0f);
  glVertex3fv (face2[1]);
  glColor3f (0.0f, 0.0f, 1.0f);
  glVertex3fv (face2[2]);
			
  glColor3f (1.0f, 0.0f, 0.0f);
  glVertex3fv (face3[0]);
  glColor3f (0.0f, 1.0f, 0.0f);
  glVertex3fv (face3[1]);
  glColor3f (0.0f, 0.0f, 1.0f);
  glVertex3fv (face3[2]);
			
  glColor3f (1.0f, 0.0f, 0.0f);
  glVertex3fv (face4[0]);
  glColor3f (0.0f, 1.0f, 0.0f);
  glVertex3fv (face4[1]);
  glColor3f (0.0f, 0.0f, 1.0f);
  glVertex3fv (face4[2]);
  glEnd ();

  glBegin (GL_QUADS);

  glColor3f (1.0f, 0.0f, 0.0f);
  glVertex3fv (base[0]);
  glColor3f (0.0f, 1.0f, 0.0f);
  glVertex3fv (base[1]);
  glColor3f (0.0f, 0.0f, 1.0f);
  glVertex3fv (base[2]);
  glColor3f (1.0f, 0.0f, 1.0f);
  glVertex3fv (base[3]);

  glEnd ();

  glRotatef (20.0, 0.0f, 0.0f, 1.0f);
  glRotatef (angle, 0.0f, 1.0f, 0.0f);

  self swapBuffers;
@}

GLXCanvasPane instanceMethod initGL (void) @{
  glViewport (0, 0, DEFAULT_WIDTH, DEFAULT_HEIGHT);
  glClearColor(0.0, 0.0, 0.0, 1.0);
  glLineWidth (1.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glEnable (GL_LINE_SMOOTH);
  glHint (GL_LINE_SMOOTH_HINT, GL_DONT_CARE);
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  if (DEFAULT_WIDTH <= DEFAULT_HEIGHT) @{
    glOrtho (-5.0, 5.0,
	     -5.0 * ((float)DEFAULT_HEIGHT / (float)DEFAULT_WIDTH),
	     5.0 * ((float)DEFAULT_HEIGHT / (float)DEFAULT_WIDTH),
	     -5.0, 5.0);
  @} else @{
    glOrtho (-5.0, 5.0,
	     -5.0 * ((float)DEFAULT_WIDTH / (float)DEFAULT_HEIGHT),
	     5.0 * ((float)DEFAULT_WIDTH / (float)DEFAULT_HEIGHT),
	     -5.0, 5.0);
  @}
  glMatrixMode (GL_MODELVIEW);
  glLoadIdentity ();
@}

GLXCanvasPane instanceMethod myTimerTickHandler (void) @{
  angle += 1.0;
  self draw;
@}

/* This definition comes from the machine's X11/keysymdef.h file. */
#define XK_Escape 0xff1b

GLXCanvasPane instanceMethod myKeyPressMethod (Integer xKeySym,
					       Integer keyCode,
					       Integer shiftState) @{
  if (xKeySym == XK_Escape) @{
    self deleteAndClose;
    exit (0);
  @}
@}

GLXCanvasPane instanceMethod myExposeMethod (Integer nEvents) @{
  if (nEvents == 0)
    self draw;
@}

GLXCanvasPane instanceMethod myResizeMethod (Integer width,
					     Integer height) @{
  float ar;

  glViewport (0, 0, width, height);
  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  if (width <= height)
    ar = (float)height / (float)width;
  else
    ar = (float)width / (float)height;
  glOrtho (-5.0, 5.0, -5.0 * ar, 5.0 * ar, -5.0, 5.0);
  glMatrixMode (GL_MODELVIEW);
  glLoadIdentity ();
@}

int main () @{
  GLXCanvasPane new pane;

  pane initialize (1, 150, 500, 500);
  pane title "GLXCanvasPane Demonstration";
  pane map;
  pane raiseWindow;

  pane onKeyPress "myKeyPressMethod";
  pane onExpose "myExposeMethod";
  pane onTimerTick "myTimerTickHandler";
  pane onResize "myResizeMethod";

  pane initGL;
  
  pane run;

@}


@end example



@iftex
@section Command Line Options
@end iftex
@ifnottex
@subheading Command Line Options
@end ifnottex
@cindex Options, command line
@cindex Command line options

Support for command line options in terminal programs is relatively
straightforward.  There are many examples of how to use @samp{argc}
and @samp{argv} that the system provides as arguments to the
@cite{main ()} function.

Ctalk has more support for command line options than that.  The
tutorial discusses it here because the way an application handles 
command line options helps determine how a program interacts with
the desktop.

@cindex @mnm{parseArgs} instance method @idxclscite{Application}
@cindex @code{cmdLineArgs} instance variable @idxclscite{Application}
First, the @code{Application} class provides the method,
@mnm{parseArgs}.  This method, given the @code{argc} and @code{argv}
arguments that the system provides to @code{main (),} saves them in
the Application's @code{cmdLineArgs} instance variable, which is an
@code{Array}.

Most of the time, an application parses the command line arguments
as soon as possible when starting, as in this example, which also
has a simple method for setting the application's objects from
the command line arguments.

@example

Application instanceMethod appOptions (void) @{

  Integer new i;
  Integer new nParams;
  String new param;

  nParams = self cmdLineArgs size;

  for (i = 1; i < nParams; i++) @{

    param = self cmdLineArgs at i;

    if (param  == "-g") @{
      geomString = self cmdLineArgs at i + 1;
      i = i + 1;
      continue;
    @}

    if (param  == "-fg") @{
      fgColor = self cmdLineArgs at i + 1;
      i = i + 1;
      continue;
    @}

    if (param  == "-bg") @{
      bgColor = self cmdLineArgs at i + 1;
      i = i + 1;
      continue;
    @}

    if (param  == "-h")
      exit_help ("myApp");

  @}
@}

int main (int argc, char **argv) @{

    Application new myApp;

    myApp parseArgs argc, argv;

    myApp appOptions; 
    ...
@}

@end example

@cindex @mnm{parseX11Geometry} instance method @idxclscite{Application}
That's most of the command line processing that a text-mode
application needs.  For GUI applications, unless they are very simple,
it's normal to allow the user the option of setting the window size
and position.  For that purpose, the @code{Application} class provides
the @mnm{parseX11Geometry} method.

Extending the example above, if the user provided a geometry
specification on the command line, the application can check for it,
as in this code snippet.

@example

  if (geomString length > 0) 
    myApp parseX11Geometry geomString;

@end example

A window geometry specification, if you're not familiar with them, is
a string that specifies a window's dimensions and placement.  For example,
the string

@example

300x300+100+150

@end example

places a window with a width and height of 300 pixels at 100 pixels to
the right and 150 pixels down from the screen's upper left-hand
corner.

The geometry string is only a @emph{hint} to the window manager. The
user option is called that because it's a recommendation.  When
drawing the application's window, the window manager also takes into
account the width of the window's frame, title bar, and any menus and
buttons on the window frame.  This has some implications that the
further examples take into account.

For example, if you provide a geometry like this one,

@example
+0+0
@end example

then the window manager places the window's frame at the upper left
hand corner of the screen.  The window described by our application's
@code{X11Pane} object is actually inset within the window frame.

You can also give a negative position.  In that case, the window manager
uses a different corner of the screen as its origin. 

For example, the position

@example

-0-0

@end example

places the window at the lower right-hand corner of the screen.

@cindex @mnm{initialize} instance method @idxclscite{X11Pane}
To handle this, the @code{X11Pane} class overloads the
@mnm{initialize} method.  In its simplest form, @mnm{initialize}
takes two arguments, the width and height of the window in pixels,
and lets the window system handle the window placement.

So for very simple applications, you can simply start the application
with several expressions like these.

@example

int main () @{

    X11Pane new myPane;

    myPane initialize 200, 250; // Set the window's initial size.

...
@}

@end example

For more complete applications, to set the window size and placement
with a command line option, you need to use the version of
@mnm{initialize} that takes five arguments - the position and size of
the window in pixels, and a fifth argument, the geometry flags that
that the @mnm{parseX11Geometry} method provides.

That way the window manager can handle specifications like negative positions,
and positions off the screen.  Even with this support, the window initialization
can become quite complex, depending on what options the user provided.

This example is abbreviated from the @flnm{ctxlogo} program, and takes
into account whether or not the user provided the window's size and
placement as a command line option, and tries to provide some
reasonable default values.

@example

int main (int argc, char **argv) @{
  Integer new xWindowSize;
  Integer new yWindowSize;
  Integer new xWindowOrg;
  Integer new yWindowOrg;

  X11Pane new xPane;
  X11PaneDispatcher new xTopLevelPane;
  X11CanvasPane new xCanvasPane;
  Application new ctxlogo;

  ctxlogo parseArgs argc, argv;
  ctxlogo ctxlogoOptions;
  if (geomString length > 0) 
    ctxlogo parseX11Geometry geomString;

  // The window needs to have a height and a width, so check
  // for dimensions of zero.  
  //
  // winWidth and winHeight are filled in by the parseArgs method,
  // above.

  if (ctxlogo winWidth > 0) 
    xWindowSize = ctxlogo winWidth;
  else
    xWindowSize = 230;

  if (ctxlogo winHeight > 0) 
    yWindowSize = ctxlogo winHeight;
  else
    yWindowSize = 230;

  // A zero in the x or y coordinate could also be negative,
  // so we need to wait to check the geometry flags in the
  // initialize method.
  xWindowOrg = ctxlogo winXOrg;
  yWindowOrg = ctxlogo winYOrg;


  //
  // The geomFlags instance variable is filled in by the 
  // parseX11Geometry method, above.
  //
  xPane initialize xWindowOrg, yWindowOrg, xWindowSize, yWindowSize,
    ctxlogo geomFlags;
  xTopLevelPane attachTo xPane;
  xCanvasPane attachTo xTopLevelPane;

  xPane map;
  xPane raiseWindow;


  ...
@end example


@iftex
@section X Example Programs
@end iftex
@ifnottex
@subheading X Example Programs
@end ifnottex

Because the X Window System API is still being developed, for now you
should look at the example programs provided with the Ctalk package.
The @flnm{xhello.c} program mentioned above is one of them.  The
example programs from this manual and the @cite{Ctalk Language
Reference} are in the @flnm{test/expect/examples-x11} and
@flnm{test/expect/x11-tests} subdirectories.  (They're part of the
Ctalk package.)


@node Debugging, GNU Free Documentation License, Graphics, Top
@iftex
@chapter Error Handling and Debugging
@end iftex
@ifnottex
@heading Error Handling and Debugging
@end ifnottex
@cindex Debugging

In addition to the process of debugging the internals of the
Ctalk front end and libraries, which is described in the
@cite{Ctalk Language Reference}, there are a few classes and
methods that programs can use to display diagnostic
information when they are run.

@iftex
@section @code{ObjectInspector} Class
@end iftex
@ifnottex
@subheading @code{ObjectInspector} Class
@end ifnottex
@cindex @code{ObjectInspector} class
@cindex Inspectors

The @code{ObjectInspector} class contains methods to print the contents
of objects, and an interactive object inspector.  

@cindex @mnm{inspect} instance method @idxclscite{Object}
The @mnm{inspect} method is implemented in @code{Object} class as
a convenience wrapper for the @mnm{inspect} method in @code{ObjectInspector}
class.  That allows you to open an interactive object inspector
by sending the message @mnm{inspect} to any object.

@example

int main () @{

    String new myStr;

    myStr inspect;

@}

@end example

Typing @kbd{?} or @kbd{help} at the inspector's command prompt
displays a brief list of commands.  There is a more detail description
in the @cite{inspect(3ctalk)} manual page and in the @cite{Ctalk Tools}
Texinfo manual.

@iftex
@section @code{Exception} Class
@end iftex
@ifnottex
@subheading @code{Exception} Class
@end ifnottex
@cindex @code{Exception} class

Ctalk's main error handling class is @code{Exception} class.
@code{Exception} objects contain information about errors so
that applications can handle the errors as necessary.

Here again is the method @mnm{highlightButton} from
the section, @cite{Method Dispatchers}. @xref{highlightButtonExample}.

@cindex @mnm{highlightButton} instance method @idxclscite{List}
@example
List instanceMethod highlightButton (void) @{
  Exception new e;
  if (self value is ANSIButtonPane) @{
    eval self highlightButton;
  @} else @{
    e raiseCriticalException INVALID_RECEIVER_X, 
      "Receiver of \"highlightButton\" is not an ANSIButtonPane object";
  @}
  return NULL;
@}
@end example

@cindex @mnm{raiseException} instance method @idxclscite{Exception}
@cindex @mnm{raiseCriticalException} instance method @idxclscite{Exception}
There are two methods that generate exceptions:
@mnm{raiseException} and @mnm{raiseCriticalException}.  

The first argument to these methods is the class of the
exception, which helps determine how Ctalk should handle the
exception.  There is a complete list of exception classes in
the @code{Exception} class section of @cite{Ctalk Language
Reference}.  The second argument is text that is provided by
the method, and this text is printed when the exception's
message is displayed.

The main difference between @mnm{raiseException} and
@mnm{raiseCriticalException} is that exceptions that are
generated internally by Ctalk are not treated as critical,
and Ctalk handles them automatically.  Critical exceptions,
however, are generated by methods and applications, and it
is up to an application to handle them.

@cindex @mnm{pending} instance method @idxclscite{Exception}
@cindex @mnm{handle} instance method @idxclscite{Exception}
Remember that raising an exception only @emph{records}
information about the error condition.  To report the error
condition, @code{Exception} class provides the @mnm{pending}
and @mnm{handle} methods, which provide basic error
notification and reporting.  Here a code segment that shows
a simple way to handle an exception.

@example
int main () @{
   Exception new myException;

   @emph{do something...} 

  if (myException pending)
    myException handle;
@}
@end example

If some previous operation raised an exception, then the
@code{myException handle} deals with the error, generally,
but not always, by printing an error message on the
terminal.

@iftex
@section System Errors and @code{SystemErrnoException} Class
@end iftex
@ifnottex
@subheading System Errors and @code{SystemErrnoException} Class
@end ifnottex
@cindex @code{SystemErrnoException} class

When programming with C, it is often necessary errors
generated by C functions.  This procedure is so common that
these error conditions have their own class,
@code{SystemErrnoException}.  The
@code{SystemErrnoException} class simply translates an error
as reported by the C library into a Ctalk exception.


@code{SystemErrnoException} objects work similarly to
@code{Exception} objects, but instead of providing an
exception class as an argument, @code{SystemErrnoException}
objects record the type of error automatically using the C
library's error code.  When handling a
@code{SystemErrnoException}, the error report is composed of
the system's text for that error code, and also the text
provided by the application when the exception is raised.

@cindex @mnm{openOn} instance method @idxclscite{ReadFileStream}
Here is an example of a @code{SystemErrnoException} object.
This example is part of the @mnm{openOn} method from class
@code{ReadFileStream}. 
@example
SystemErrnoException new __errnoException;

@emph{...}

if ((f = fopen (__streamPathName, "r")) != NULL) @{
  __ctalkObjValPtr (selfval, f);
  self streamPath = __streamPathName;
  self statStream;
@} else @{
  __errnoException raiseException __streamPathName;
@}
@end example

@code{SystemErrnoException} objects are always treated as
critical exceptions, so it is up to the application to
handle them by using the @mnm{pending} and @mnm{handle} methods
as described in the previous section.

@iftex
@section Printing Call Sequences for Exceptions
@end iftex
@ifnottex
@subheading Printing Call Sequences for Exceptions
@end ifnottex

While exceptions are convenient for recording error
conditions, reporting an error later can also make it
difficult to determine exactly where or when in the program
the error occurred.  For this reason, exceptions also record
the program's call stack at the time the exception occurred.

The method @mnm{enableExceptionTrace} in class @code{Object} enables
the printing of the program's call stack to the console's standard
error channel when a program deals with an exception using
@mnm{handle} (class @code{Exception}).

A program can turn off the display of the call stack with the
@mnm{disableExceptionTrace} method, also in class @code{Object}.  
The method @code{traceEnabled} in class @code{Object} returns
@code{TRUE} or @code{FALSE} depending on whether call stack displays
are enabled.

A program can print an exception's call stack using
@mnm{printExceptionTrace} in class @code{Exception}.  Here is 
the code from the @mnm{handle} method that calls
@mnm{printExceptionTrace}. 
@example
if (self traceEnabled) @{
  self printExceptionTrace;
@}
@end example

@iftex
@section Application Specific Exception Handlers
@end iftex
@ifnottex
@subheading Application Specific Exception Handlers
@end ifnottex

Sometimes simply printing an error message to the terminal
is not useful, so @code{Exception} class allows you to define
application specific exception handlers.  

When handling exceptions, Ctalk handles the
@code{Exception} object using the highest-level handler
@emph{that is installed by the application,} or the default
handler otherwise.

@cindex @mnm{installHandler} instance method @idxclscite{Exception}
Briefly, custom exception handlers are @code{Method} objects
that are defined by an application and implemented in
@code{Exception} class.  Applications use the
@mnm{installHandler} method, also from @code{Exception} class, to
install them.

There is an example of an application specific exception
handler in the @code{Exception} class section of the
@cite{Ctalk Language Reference}, as well as a discussion of
how an application might handle exceptions.

One common use of custom handlers is a Web CGI program.
Simply outputting error messages to the terminal does not
provide any useful information; instead, using a custom
exception handler, the application can print error messages
in the Web browser window.

Here is the exception handler from the @flnm{wiki.c} example
program.  
@example
Exception instanceMethod errorToBrowser (void) @{
  String new msg;
  wikiApp httpHeader;
  wikiApp htmlPageHeader "Ctalk Wiki | Error";
  wikiApp outputString "<h2>Ctalk Wiki Error:</h2>";
  msg = __ctalkPeekExceptionTrace ();
  wikiApp outputString "<pre>" + msg + "</pre><br>";
  msg = __ctalkPeekRunTimeException ();
  wikiApp outputString "<pre>" + msg + "</pre>";
  wikiApp outputString "Please contact your system adminstrator or " + 
    "the Ctalk language project at rk3314042@@gmail.com.";
  error = TRUE;
  return NULL;
@}
@end example

Then, when the application is run, it installs the handler using
statements like these.
@example
Exception new postDataException;
@emph{...}
postDataException installHandler "errorToBrowser";
@end example

@iftex
@section Examining Objects with Inspectors
@end iftex
@ifnottex
@subheading Examining Objects with Inspectors
@end ifnottex

@cindex @mnm{inspect} instance method @idxclscite{Object}
Ctalk provides a basic set of methods that can inspect and print
the contents of objects.  

The @mnm{inspect} method in @code{Object} class is an interactive
utility that lets you examine a program's objects as the program
is running.

To inspect an object, simply send it the message, @mnm{inspect} - it's
a shortcut for the @mnm{inspect} method in @code{ObjectInspector}
class, which a program can also call directly.  


@example

String new globalString;

int main () @{
  Integer new i;

  globalString = "global string";

  i inspect;
@}

@end example

In either case, the program stops execution when it reaches the
@mnm{inspect} method, and presents a prompt where you can type commands.

Here's a transcript of a brief inspector session.

@example

$ ./inspect 
> p
p
name:       i
class:      Integer (0x48bf4958)
superclass: Magnitude (0x48bf29f0)
value:      (null) (Integer)

> p g globalString
p g globalString
name:       globalString
class:      String (0x48cce8d0)
superclass: Character (0x48c8acc0)
value:      global string (String)

> c
c
$ 

@end example

At the inspector prompt, @samp{> }, the command @samp{p} prints
the inspector's receiver object, and @samp{p g globalString} prints
the named global object, @code{globalString}.  The @samp{c} command
exits the inspector and continues running the program.

There are several commands that the inspector recognizes.  Typing
@samp{?,} @samp{h,} or @samp{help} at the prompt displays a list of them.

@cindex @mnm{dump} instance method @idxclscite{Object}
@cindex @mnm{formatObject} instance method @idxclscite{Object}
@cindex @code{ObjectInspector} class
@cindex __ctalkPrintObject function
The inspector uses the method @mnm{formatObject} to print the contents
of individual objects.  

If you want to print a formatted object directly, without stopping the
program, Ctalk also has the method @mnm{dump} in @code{Object} class,
which simply calls @mnm{formatObject} with its receiver object to
print the object and then returns so the program can continue running.

You can also debug Ctalk apps (and Ctalk itself) at the source code
level with the GNU @command{gdb} debugger.  This requires that you
build Ctalk and/or its application programs with the source
information.  Refer to the ``Debugging'' section of the @cite{Ctalk
Language Reference} for more information.

@iftex
@section Exit Handlers and Error Tracing
@end iftex
@ifnottex
@subheading Exit Handlers and Error Tracing
@end ifnottex
@cindex @mnm{installExitHandlerBasic} method @idxclscite{Application}
@cindex @mnm{installAbortHandlerBasic} method @idxclscite{Application}
@cindex @mnm{enableExceptionTrace} method @idxclscite{Object}

Ctalk provides two C handlers that you can use for
debugging, @mnm{installExitHandlerBasic} and
@mnm{installAbortHandlerBasic}.  They are written in C and
are more robust, though less flexible, than signal handlers
written using @code{SignalHandler} objects.

These signal handlers provide basic cleanup of the class
dictionaries before exiting, and, if stack tracing is
enabled, optionally print a stack trace of where the program
was executing when the signal occurred.

For example, to enable the handlers with stack tracing, you
could use the following code.
@example
Application new myApp;
Object new anyObject;
...
anyObject enableExceptionTrace;
myApp installExitHandlerBasic;
myApp installAbortHandlerBasic;
@end example

The @mnm{enableExceptionTrace} method is defined in class
@code{Object}, so you can send the message to any object in
a program to enable exception tracing.

The @mnm{installExitHandlerBasic} method provides a handler
that exits a program neatly when the user presses @kbd{C-c}
in a UNIX terminal or @kbd{C-break} in a DJGPP text window.

The @mnm{installAbortHandlerBasic} method is useful for
printing traces when a system library detects an error.  

If the application enables exception tracing, these methods print a
stack trace from the point where a signal is received before causing the
application to exit.  

@cindex @flnm{timeclient.c} example program
@cindex @flnm{timesignal.c} example program
It is relatively easy to write handlers for whatever signals
a program needs to catch.  The methods in the
@code{Application} and @code{SignalHandler} classes should
provide a starting point for writing application-specific
handlers.  Also, you might want to look at
@flnm{timeclient.c} and @flnm{timesignal.c} in the
@flnm{demos} subdirectory of the Ctalk distribution.

@node GNU Free Documentation License, Index, Debugging, Top
@iftex
@chapter GNU Free Documentation License
@end iftex
@ifnottex
@heading GNU Free Documentation License
@end ifnottex
@cindex GNU Free Documentation License
@example

                        Version 1.1, March 2000
     Copyright (C) 2000  Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
     
     Everyone is permitted to copy and distribute example copies
     of this license document, but changing it is not allowed.



  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     written document "free" in the sense of freedom: to assure everyone
     the effective freedom to copy and redistribute it, with or without
     modifying it, either commercially or noncommercially.  Secondarily,
     this License preserves for the author and publisher a way to get
     credit for their work, while not being considered responsible for
     modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.
     We recommend this License principally for works whose purpose is
     instruction or reference.


  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work that contains a
     notice placed by the copyright holder saying it can be distributed
     under the terms of this License.  The "Document", below, refers to
     any such manual or work.  Any member of the public is a licensee,
     and is addressed as "you."

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied example, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter
     section of the Document that deals exclusively with the
     relationship of the publishers or authors of the Document to the
     Document's overall subject (or to related matters) and contains
     nothing that could fall directly within that overall subject.
     (For example, if the Document is in part a textbook of
     mathematics, a Secondary Section may not explain any mathematics.)
     The relationship could be a matter of historical connection with
     the subject or with related matters, or of legal, commercial,
     philosophical, ethical or political position regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in
     the notice that says that the Document is released under this
     License.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, whose contents can be viewed and edited directly
     and straightforwardly with generic text editors or (for images
     composed of pixels) generic paint programs or (for drawings) some
     widely available drawing editor, and that is suitable for input to
     text formatters or for automatic translation to a variety of
     formats suitable for input to text formatters.  A copy made in an
     otherwise Transparent file format whose markup has been designed
     to thwart or discourage subsequent modification by readers is not
     Transparent.  A copy that is not "Transparent" is called "Opaque."

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and
     standard-conforming simple HTML designed for human modification.
     Opaque formats include PostScript, PDF, proprietary formats that
     can be read and edited only by proprietary word processors, SGML
     or XML for which the DTD and/or processing tools are not generally
     available, and the machine-generated HTML produced by some word
     processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.


  2. EXAMPLE COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow
     the conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.


  3. COPYING IN QUANTITY

     If you publish printed copies of the Document numbering more than
     100, and the Document's license notice requires Cover Texts, you
     must enclose the copies in covers that carry, clearly and legibly,
     all these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the
     title equally prominent and visible.  You may add other material
     on the covers in addition.  Copying with changes limited to the
     covers, as long as they preserve the title of the Document and
     satisfy these conditions, can be treated as example copying in
     other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a
     machine-readable Transparent copy along with each Opaque copy, or
     state in or with each Opaque copy a publicly-accessible
     computer-network location containing a complete Transparent copy
     of the Document, free of added material, which the general
     network-using public has access to download anonymously at no
     charge using public-standard network protocols.  If you use the
     latter option, you must take reasonably prudent steps, when you
     begin distribution of Opaque copies in quantity, to ensure that
     this Transparent copy will remain thus accessible at the stated
     location until at least one year after the last time you
     distribute an Opaque copy (directly or through your agents or
     retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of
     copies, to give them a chance to provide you with an updated
     version of the Document.


  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with
     the Modified Version filling the role of the Document, thus
     licensing distribution and modification of the Modified Version to
     whoever possesses a copy of it.  In addition, you must do these
     things in the Modified Version:

     A. Use in the Title Page (and on the covers, if any) a title
     distinct    from that of the Document, and from those of previous
     versions    (which should, if there were any, be listed in the
     History section    of the Document).  You may use the same title
     as a previous version    if the original publisher of that version
     gives permission.
     B. List on the Title Page, as authors, one or more persons or
     entities    responsible for authorship of the modifications in the
     Modified    Version, together with at least five of the principal
     authors of the    Document (all of its principal authors, if it
     has less than five).
     C. State on the Title page the name of the publisher of the
     Modified Version, as the publisher.
     D. Preserve all the copyright notices of the Document.
     E. Add an appropriate copyright notice for your modifications
     adjacent to the other copyright notices.
     F. Include, immediately after the copyright notices, a license
     notice    giving the public permission to use the Modified Version
     under the    terms of this License, in the form shown in the
     Addendum below.
     G. Preserve in that license notice the full lists of Invariant
     Sections    and required Cover Texts given in the Document's
     license notice.
     H. Include an unaltered copy of this License.
     I. Preserve the section entitled "History", and its title, and add
     to    it an item stating at least the title, year, new authors, and
       publisher of the Modified Version as given on the Title Page.
     If    there is no section entitled "History" in the Document,
     create one    stating the title, year, authors, and publisher of
     the Document as    given on its Title Page, then add an item
     describing the Modified    Version as stated in the previous
     sentence.
     J. Preserve the network location, if any, given in the Document for
       public access to a Transparent copy of the Document, and
     likewise    the network locations given in the Document for
     previous versions    it was based on.  These may be placed in the
     "History" section.     You may omit a network location for a work
     that was published at    least four years before the Document
     itself, or if the original    publisher of the version it refers
     to gives permission.
     K. In any section entitled "Acknowledgements" or "Dedications",
     preserve the section's title, and preserve in the section all the
      substance and tone of each of the contributor acknowledgements
     and/or dedications given therein.
     L. Preserve all the Invariant Sections of the Document,
     unaltered in their text and in their titles.  Section numbers
     or the equivalent are not considered part of the section titles.
     M. Delete any section entitled "Endorsements."  Such a section
     may not be included in the Modified Version.
     N. Do not retitle any existing section as "Endorsements"    or to
     conflict in title with any Invariant Section.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option
     designate some or all of these sections as invariant.  To do this,
     add their titles to the list of Invariant Sections in the Modified
     Version's license notice.  These titles must be distinct from any
     other section titles.

     You may add a section entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties-for example, statements of peer review or that the text has
     been approved by an organization as the authoritative definition
     of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end
     of the list of Cover Texts in the Modified Version.  Only one
     passage of Front-Cover Text and one of Back-Cover Text may be
     added by (or through arrangements made by) any one entity.  If the
     Document already includes a cover text for the same cover,
     previously added by you or by arrangement made by the same entity
     you are acting on behalf of, you may not add another; but you may
     replace the old one, on explicit permission from the previous
     publisher that added the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.


  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination
     all of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections entitled
     "History" in the various original documents, forming one section
     entitled "History"; likewise combine any sections entitled
     "Acknowledgements", and any sections entitled "Dedications."  You
     must delete all sections entitled "Endorsements."


  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for example copying of each of the
     documents in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow
     this License in all other respects regarding example copying of
     that document.


  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of
     a storage or distribution medium, does not as a whole count as a
     Modified Version of the Document, provided no compilation
     copyright is claimed for the compilation.  Such a compilation is
     called an "aggregate", and this License does not apply to the
     other self-contained works thus compiled with the Document, on
     account of their being thus compiled, if they are not themselves
     derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one
     quarter of the entire aggregate, the Document's Cover Texts may be
     placed on covers that surround only the Document within the
     aggregate.  Otherwise they must appear on covers around the whole
     aggregate.


  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License provided that you also include the
     original English version of this License.  In case of a
     disagreement between the translation and the original English
     version of this License, the original English version will prevail.


  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided for under this License.  Any other
     attempt to copy, modify, sublicense or distribute the Document is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.


 10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     http://www.gnu.org/copyleft/.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If
     the Document does not specify a version number of this License,
     you may choose any version ever published (not as a draft) by the
     Free Software Foundation.


ADDENDUM: How to use this License for your documents

   To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

     Copyright (C)  YEAR  YOUR NAME.
     Permission is granted to copy, distribute and/or modify this document
     under the terms of the GNU Free Documentation License, Version 1.1
     or any later version published by the Free Software Foundation;
     with the Invariant Sections being LIST THEIR TITLES, with the
     Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
     A copy of the license is included in the section entitled "GNU
     Free Documentation License."

   If you have no Invariant Sections, write "with no Invariant Sections"
instead of saying which ones are invariant.  If you have no Front-Cover
Texts, write "no Front-Cover Texts" instead of "Front-Cover Texts being
LIST"; likewise for Back-Cover Texts.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License, to
permit their use in free software.

@end example

@c
@c  INDEX
@c
@ifnottex
@node Index, , GNU Free Documentation License, Top
@end ifnottex
@chapter Index
@printindex cp
@bye

@c 
@c just typeset using pdfetex, which gives a toc in acroread's left
@c sidebar.
@c
@c Make sure that we get the custom titles into the toc bar.
@c
@c Also look at ps2pk, because there might be some decent type 
@c 1 fonts.
@c
