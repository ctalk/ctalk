

>>>Object::! (void)
Overloads the '!' prefix operator.

>>>Object::!= (Object arg)
Returns a Boolean value of False if the receiver and the
argument are the same object, True otherwise.  Also returns False if
the receiver and argument's values both evaluate to False.

>>>Object::& (void)
When used to overload C's ``address of'' ('&') operator, is
synonymous with the addressOf method, below.

>>>Object::-> (String member_name)
Given the name of an a C OBJECT * member name, like
__o_name, __o_classname, __o_class and
so on, return a String, Integer, or
Symbol with the value of that member. @xref{OBJECT
typedef}.  

The class of the returned object depends on which OBJECT * is
selected.  Some of the results are returned as references contained in
Symbol objects, which avoids unexpectedly changing the target object.

---------------------------------------------------------
  OBJECT Member        Expression                  Class of Result Object
  -------------        ----------                  ----------------------
  __o_name             obj -> __o_name             String
  __o_classname        obj -> __o_classname        String
  __o_superclassname   obj -> __o_superclassname   String
  __o_value            obj -> __o_value            String
  __o_class            obj -> __o_class            <obj's> class
  __o_superclass       obj -> __o_superclass       <obj's> superclass
  instancevars         obj -> instancevars         Symbol 
  classvars            obj -> classvars            <obj's> class
  __o_p_obj            obj -> __o_p_obj            <obj's> parent's class
  scope                obj -> scope                Integer
  attrs                obj -> attrs                Integer
  nrefs                obj -> nrefs                Integer
---------------------------------------------------------

The method sets the OBJECT_IS_DEREF_RESULT attribute on objects that
the method creates.

The result of retrieving an object's instance or class variables
depends on the object.  If the object is not a class object, then the
classvars member will be NULL.  The class of an instance
variable is the parent object, so the Ctalk library returns the
address of the first instance variable.  If you want to check each
variable, it is much easier to use the methods
mapInstanceVariables or mapClassVariables, below.

Examples

---------------------------------------------------------
  
  /* Set a Symbol object and an Object instance to
     another object's class, and display the classes'
     name. */
  int main () {
  
    String new myObject;
    Symbol new optr;
    Object new classObj;
    
    myObject = "String"; /*Needed by classObject, below.*/
  
    printf ("%p\n", myObject -> __o_class);
    printf ("%s\n", myObject -> __o_class -> __o_name);
  
    *optr = myObject -> __o_class;
    printf ("%p\n", (*optr) -> __o_class);
    printf ("%s\n", (*optr) -> __o_class -> __o_name);
  
    classObj = (*optr) classObject;
    printf ("%p\n", classObj);
    printf ("%s\n", classObj -> __o_name);
  
    classObj = myObject classObject;
    printf ("%p\n", classObj);
    printf ("%s\n", classObj -> __o_name);
  
  }
  
  /* To print an object's value. */
  int main () {
  
    String new s;
   
    s = "StringValue";
   
    printf ("%s\n", s -> __o_value);
  
  }
  
  /* To save an object's scope to an Integer object, and
     print them. */
  int main () {
  
    String new s;
    Integer new scopeInt;
    
  
    scopeInt = s -> scope;
  
    printf ("%d == %d\n", s -> scope, scopeInt);
  
  }
  
  
  /* To save an object's attributes to an Integer and
     print them. */
  
  int main () {
  
    Integer new attrsInt;
    List new l;
    String new member1;
    String new member2;
    
  
    l = member1, member2;
  
    /* Check for an OBJECT_IS_MEMBER_OF_PARENT_COLLECTION attribute
       (currently its definition is (1 << 7), or 128), which is set
       in each of the list's Key objects. (The '->' operator in the
       expressions has a higher precedence than '*', so parentheses
       are necessary.) */
    attrsInt = (*l) -> attrs;
  
    printf ("%d == %d\n", (*l) -> attrs, attrsInt);
  }
  
  
---------------------------------------------------------

Note:  The use of __o_classname and
__o_superclassname as separate object member is
being superceded by the CLASSNAME and SUPERCLASSNAME
definitions.  The -> method recognizes both the old and
new names, but if -> is used with an OBJECT *
as a C operator, then the program must use the CLASSNAME
or SUPERCLASSNAME macros.  

>>>Object::= (Object new_object)
A basic assignment method.  Assigns new_object so that
the receiver label can refer to it.

>>>Object::== (Object arg)
Returns a Boolean value of True if the receiver and the
argument are the same object, False otherwise.

As a special case, the method returns True if the receiver and
argument's values evaluate to a C NULL.  Refer to the description
of null objects above. 

>>>Object::addInstanceVariable (char *name, OBJECT *value)
Add instance variable name with value to the receiver.

>>>Object::addressOf (void)
Return a Symbol that contains the address of the receiver.
This method is functionally equivalent to the C language '&'
operator.

>>>Object::asFloat (void)
Return a Float object with the value of the receiver.

>>>Object::asString (void)
Return a String object of the receiver.

>>>Object::asSymbol (void)
If the value of the receiver is an object reference, return
a Symbol object with that reference.  Otherwise, return a
Symbol object with a reference to the receiver.

>>>Object::backgroundMethodObjectMessage (Method method_object)
Send the message defined in method_object to the receiver as a
new process, which runs concurrently until method_object returns.

The argument, method_object, is a previously defined method
which takes no arguments.  The return value, if any is not saved when
the background process exits.

Here is a brief example that opens an ObjectInspector on a
process.

---------------------------------------------------------
  
  Object instanceMethod bgMethod (void) {
    self inspect "bgMethod> ";
    printf ("bgMethod printed this.\n");
  }
  
  int main () {
    Integer new i;
    Method new bgMethodObject;
    int status;
  
    bgMethodObject definedInstanceMethod "Object", "bgMethod";
    i backgroundMethodObjectMessage bgMethodObject;
  
    wait (&status);  /* Returns when the background */
                     /* process exits.              */
  
  }
  
---------------------------------------------------------

>>>Object::basicNew (char *name)
>>>Object::basicNew (char *name, char *value_expr)
>>>Object::basicNew (char *name, char *classname, char *superclassname, char *value_expr)
If given with one argument, the receiver must be a class object, and
the method creates a new object with the name given as the
argument and a value of '(null)'.  

With two arguments, create a new object with the name and value given
in the arguments, and with the class and superclass of the receiver,
which needs to be a class object in this case also.

If the method is used with four arguments, create a new object with
the name, class, superclass and value given by the arguments - in this
case, basicNew doesn't use the class and superclass of the
receiver.

In each case, the newly created object contains all of the instance
variables defined by the class object and has a scope of
LOCAL_VAR|METHOD_USER_OBJECT and a reference count of 1.

Note: The addition of the receiver's instance variables
means you need to be careful when the receiver is not a class
object.  The basicNew method does not check for cascading
or circular instance variables.  So if you're creating and then pushing
a lot of items, make sure the method's receiver is a class object,
and assigning the new object using a Symbol is more robust
that assigning other types of objects.

That is, a set of statements like

---------------------------------------------------------
  
  *tokSym = String basicNew "token", valuebuf;
  myList push *tokSym;
  
---------------------------------------------------------

is much more reliable than, say

---------------------------------------------------------
  
  myTok = myString basicNew "token", valuebuf;
  myList push myTok;
  
---------------------------------------------------------

>>>Object::become (OBJECT *original_object)
Make the receiver a duplicate of the argument object.

>>>Object::callStackTrace (void)
Print a call stack trace.

>>>Object::class (char *classname)
Declare a new class classname.  The class declaration
consists of a superclass name, the class keyword, the
name of the new class, and an optional documentation string.  For
example;

---------------------------------------------------------
  
  FileStream new WriteFileStream;
  
  ... or, with a docstring between the class name and semicolon ...
  
  FileStream new WriteFileStream
  "Defines the methods and instance variables that write data to files. Also
  defines the class variables stdoutStream and stderrStream, which are the 
  object representation of the standard output and standard error streams.";
  
---------------------------------------------------------

>>>Object::className (void)
Return a String object containing the class name of the receiver.

>>>Object::classObject (void)
Return the class object named by the receiver's value.  Normally the
receiver should be a String object - the method uses the C
value of the receiver to retrieve the class object by its name.  If
the receiver is a class object, the method returns the receiver
itself.

>>>Object::copy (Object source_object)
Copy source_object to the receiver.  This method
replaces the receiver, which received the message, with a
completely new copy of the source_object argument.
The original receiver object no longer exists.

>>>Object::decReferenceCount (void)
Decrease the receiver object's reference count by one.

>>>Object::delete (void)
Delete the receiver object and its instance variables.

For some of the details of how Ctalk deletes objects, refer to 
the __ctalkDeleteObject () API function.  

>>>Object::disableExceptionTrace (void)
Disable method walkback displays when handling exceptions.

>>>Object::docDir (void)
Returns a String that contains the path where the
Ctalk-specific documentation is installed on the system (i.e.,
documentation other than man pages and Texinfo manuals).

>>>Object::dump (void)
Create an ObjectInspector object and print the object's
contents on the terminal.  This is a convenience method for the
ObjectInspector : formatObject method.

>>>Object::enableExceptionTrace (void)
Enable method walkback displays when handling exceptions.

>>>Object::getReferenceCount (void)
Return an Integer with the receiver's reference count.

>>>Object::hasPointerContext (void)
Returns a Boolean value of True if the receiver appears
in a pointer context; i.e., on the left-hand side of an assignment
operator in an expression with some dereferencing method (usually
a ``*''), as in this example.

---------------------------------------------------------
  
  Symbol new myNewObjectPtr;
  Symbol new myOldObjectPtr;
  
  
  *myNewObjectPtr = myOldObjectPtr;
  
---------------------------------------------------------

>>>Object::incReferenceCount (void)
Increase the receiver object's reference count by one.

>>>Object::inspect (void)
>>>Object::inspect (String promptStr)
Open an inspector on the receiver object.  At the prompt, typing
'?' or 'help' displays a list of the inspector's commands.
If given a String object as its argument, displays the string as the
inspector's command prompt.  This method is a shortcut for
inspect in ObjectInspector
class. 

>>>Object::is (char *className)
Return TRUE if the receiver is a member of the class given in
the argument, FALSE otherwise.  Note: Don't use an
expression like, 'obj is Class'.  The argument must be a valid,
defined class, which simplifies the method considerably.

To determine if an object is a class object, use isClassObject,
which is mentioned below.  This example illustrates the difference.

---------------------------------------------------------
  
  if (myObject is String) {   /* OK - String is a defined class. */
   ...
  }
  
  if (myObject is Class) {    /* Not OK - 'Class' is not a defined class. */
   ...
  }
  
  if (myObject isClassObject) {  /* OK - Just check whether the object is
   ...                              its own class object. */
  }
  
---------------------------------------------------------



>>>Object::isClassMethod (char *classMethodName)
Return TRUE if the receiver's class defines an
instance method named classMethodName, FALSE
otherwise.  If the receiver is an instance or class
variable, look for the method in the class of the receiver's 
value.

>>>Object::isClassObject (void)
Returns a Boolean value of True if the receiver is a class object,
False otherwise.

>>>Object::isInstanceMethod (char *instanceMethodName)
Return TRUE if the receiver's class defines an
instance method named instanceMethodName, FALSE
otherwise.  If the receiver is an instance or class
variable, look for the method in the class of the receiver's 
value.

>>>Object::isInstanceVariable (char *instanceVariableName)
Return TRUE if the receiver has an instance variable named
instanceVariableName, FALSE otherwise.

>>>Object::instanceMethod (char *alias, char *name, (args)
Declare a method of the receiver's class with the name name, 
with the arguments args, and, optionally, with the alias
alias.  

>>>Object::isNull (void)
Return TRUE if the receiver is a null result object,
FALSE otherwise.

>>>Object::isNullValue (void)
Return TRUE if the receiver's value is NULL,
'(null)', or '0', FALSE otherwise.  Note that this
method is here for compatibility with older programs.  New programs
should not need it.

>>>Object::isSubClassOf (String classname)
Returns True if the reciever's is a member of classname
or one of its subclasses, False otherwise.

>>>Object::libraryPath (void)
Return the file path name of the receiver's class library.

>>>Object::mapClassVariables (OBJECT *(*fn)())
Apply the argument, fn to each of the class variables
in the receiver's class object.  The argument may be either
a method or a code block.  Refer to the @cite{Ctalk
Tutorial} for examples of inline method messages using
methods like map and mapInstanceVariables.

>>>Object::mapInstanceVariables (OBJECT *(*fn)())
Apply the argument, fn, to each of an object's
instance variables.  The argument may be either a method or
a code block.  Refer to the Ctalk Tutorial for
examples of inline method messages using methods like
map and mapInstanceVariables.

>>>Object::methodObjectMessage (Method method_object)
>>>Object::methodObjectMessage (Method method_object, Object arg1, Object arg2)
Perform a method call with a Method class object.  The
method_object argument and its own arguments must have been
previously defined.  

With three arguments, the method uses the second and third arguments
as the method instance's arguments, without previous calls to
the withArg method (defined in Method class).

Method instances with two arguments are commonly used in graphical
event dispatchers.  They're found mostly in X11PaneDispatcher
class, and the three-parameter form of methodObjectMessage
allows the method instance calls to be more efficient.

The following examples of method calls shows how to call
method instances with and without using the withArg
method first.

This example is from X11PaneDispatcher class.

---------------------------------------------------------
  
    /* This example pushes the arguments separately. */
  __subPane handleKbdInput withArg __subPane;
  __subPane handleKbdInput withArg __event;
  __subPane methodObjectMessage __subPane handleKbdInput;
  
    /* The three-argument form of methodObjectMessage allows
       passing two arguments to a method instance with only
       a single expression. */
  __subPane methodObjectMessage __subPane handleKbdInput,
    __subPane, __event;
  
---------------------------------------------------------

This example is the demos/ipc/sockproc.c demonstration program,
which shows how to define and start a method instance as a separate
process.

---------------------------------------------------------
  
  #define SOCK_BASENAME "testsocket.$$"
  
  String new gSocketPath; /* The socket path is common to both
  			   processes. */
  
  Object instanceMethod startTimeServer (void) {
    UNIXNetworkStreamReader new reader;
    String new utcTimeString;
    CalendarTime new timeNow;
    SystemErrnoException new ex;
  
    reader openOn gSocketPath;
    if (ex pending) {
      ex handle;
      return ERROR;
    }
  
    while (1) {
      utcTimeString = reader sockRead;
      if (ex pending) {
        ex handle;
        return ERROR;
      }
      if (utcTimeString length > 0) {
        timeNow = utcTimeString asInteger;
        timeNow localTime;
        printf ("%s\n", timeNow cTimeString);
      }
    }
  }
  
  int main (int argc, char **argv) {
  
    CTime new thisTime;
    CTime new prevTime;
    UNIXNetworkStream new strObject;
    UNIXNetworkStreamWriter new client;
    Method new timeServerInit;
    Integer new childPID;
    SystemErrnoException new ex;
    Object new procRcvr;
  
    gSocketPath = strObject makeSocketPath SOCK_BASENAME;
  
    timeServerInit definedInstanceMethod "Object", 
      "startTimeServer";
    childPID = 
      procRcvr backgroundMethodObjectMessage timeServerInit;
  
    client openOn gSocketPath;
    if (ex pending) {
      ex handle;
      return ERROR;
    }
  
    prevTime utcTime;
  
    while (1) {
  
      thisTime utcTime;
  
      if (thisTime != prevTime) {
  
        client sockWrite (thisTime asString);
  
        if (ex pending) {
  	ex handle;
  	return ERROR;
        }
        
        prevTime = thisTime;
  
      }
      usleep (1000);
    }
    exit (0);
  }
  
---------------------------------------------------------

>>>Object::methods (Boolean findClassMethods)
Return a string containing the methods defined by the receiver's
class, one method per line.  If findClassMethods is True, return
a list of class methods in the class.  If the argument is False,
return a list of the class's instance methods.

>>>Object::name (void)
Return the name of the receiver as a String object.

>>>Object::new (newObject1, newObject2, newObject3...)
Create an object or object's of the receiver's class with the names
newObject1, etc.  For example:

---------------------------------------------------------
  
  String new myString1, myString2, myString3;
  
---------------------------------------------------------

>>>Object::printSelfBasic (void)
Print the contents of the receiver to the program's standard error
output. 

>>>Object::setReferenceCount (Integer refCnt)
Set the receiver's reference count to the value given as the argument.
Note, however, that the reference count given as the argument does
not include any changes in the reference count as this method is
executed.  If you're unsure about how to adjust the reference count
it's safer to use incReferenceCount and decReferenceCount
instead, or use the __objRefCntSet () library function directly.


>>>Object::sizeof (Object)
Overloads the C sizeof operator when the argument is an
object.  If the argument is a C variable or a type expression, then
Ctalk uses the compiler's sizeof operator.

>>>Object::superclassName (void)
Return a String that contains the name of the object's
superclass, or '(null)' if the receiver is an instance of
Object class, which has no superclass.

>>>Object::traceEnabled (void)
Return TRUE if exception walkback displays are enabled,
FALSE otherwise.

>>>Object::value (void)
Returns the value of the receiver object.  When you use an object
without a method, ctalk uses the value message to return the
object's value.  For example,

---------------------------------------------------------
    printf ("%s", stringObject);
---------------------------------------------------------

is the same as,

---------------------------------------------------------
    printf ("%s", stringObject value);
---------------------------------------------------------



>>>X11Font::getFontInfo (String fontDesc)
Fills in the font metrics (height, maxWidth, ascent, descent, X font
ID) for the font named by fontDesc.  Also fills in the
receiver's fontDesc instance variable with the string
given as the argument.

>>>X11Font::textWidth (String text)
Returns an Integer with the width of text in
pixels when rendered in the reciever's font.  The program
should call the getFontInfo method before calling
this method.



>>>X11Cursor::arrow (void)
Sets the cursor to the upward-left pointing arrow that is the default
for most new windows.

>>>X11Cursor::grabMove (void)
Creates a grab cursor.

>>>X11Cursor::scrollArrow (void)
Creates a scrollbar vertical double arrow cursor.

>>>X11Cursor::watch (void)
Creates a cursor that displays a small watch.

>>>X11Cursor::xterm (void)
Creates a xterm cursor. That is, the vertical bar used for editing
text.



>>>X11FreeTypeFont::alpha (Integer value)
Set the current Xft font's foreground alpha channel.  The argument
value must be an unsigned short int; i.e., in the
range 0 - 65535 (0xffff hex).

>>>X11FreeTypeFont::blue (Integer value)
Set the current Xft font's foreground blue channel.  The argument
value must be an unsigned short int; i.e., in the
range 0 - 65535 (0xffff hex).

>>>X11FreeTypeFont::currentDescStr (void)
Returns a String containing a font descriptor for the currently
selected font.  The descriptor contains the attributes that the Ctalk
libraries use to select fonts: family, point size, slant, and weight.

For the complete descriptor that the Freetype library derives from the
selected font's pattern, refer to the @code{X11FreeTypeFont :
selectedFont} method.

>>>X11FreeTypeFont::errors (void)
This is a shortcut for

---------------------------------------------------------
  
  myFont notifyLevel XFT_NOTIFY_ERRORS
  
---------------------------------------------------------

Refer the the X11FreeTypeFont : notifyLevel method for
more information.

>>>X11FreeTypeFont::green (Integer value)
Set the current Xft font's foreground green channel.  The argument
value must be an unsigned short int; i.e., in the
range 0 - 65535 (0xffff hex).

>>>X11FreeTypeFont::initFontLib (void)
Initializes the font library and sets the reciever's instance
variables to the default selected font.  Apps need to use this method before
most of the other other methods in this class.

If the system is not configured to use outline fonts then the library
prints a message and exits the program with a non-zero value.


>>>X11FreeTypeFont::isMonospace (void)
Returns a read-only Boolean value of true if the application's
selected font is monospace, false otherwise.

>>>X11FreeTypeFont::libIsInitialized (void)
Returns a non-zero Integer value if the Xft libraries are
initialized and a font is selected.

>>>X11FreeTypeFont::listFonts (String pattern)
List the font descriptors in the FreeType library that contain pattern.
If pattern is an empty string '""' or a '*', match
every font descriptor.

>>>X11FreeTypeFont::loadNotify (void)
This is a shortcut for

---------------------------------------------------------
  
  myFont notifyLevel XFT_NOTIFY_LOAD
  
---------------------------------------------------------

This causes methods like selectFont to display the family
and size given to them, and a brief font descriptor that contains
the font parameters that Ctalk uses to select fonts: family, point
size, slant, and weight.

Refer to the X11FreeTypeFont : notifyLevel method for a
description of information and error message levels.  To return a
string containing the font descriptor that the Freetype libraries
derive from the selected font's pattern, refer to the
X11FreeTypeFont : selectedFont method.

>>>X11FreeTypeFont::namedX11Color (String colorName)
Sets the selected font's red, green, and blue values from the
X11 color name given as the argument.

Note: For a list of the colors that the X Window System
recognizes, consult the file rgb.txt, which is often stored
with the server's configuration files when the GUI is installed.

>>>X11FreeTypeFont::notifyLevel (Integer level)
Set the Xft libraries' notification level to level.  Ctalk
defines the following constants in /ctalk/ctalkdefs.h.

---------------------------------------------------------
  
  XFT_NOTIFY_NONE
  XFT_NOTIFY_ERRORS
  XFT_NOTIFY_LOAD
  XFT_NOTIFY_VERBOSE
  
---------------------------------------------------------

These definitions produce the following information and warning
messages.

  
>>>X11FreeTypeFont::XFT_NOTIFY_NONE
  The font libraries produce no output when the program is run.
>>>X11FreeTypeFont::XFT_NOTIFY_ERRORS
  The font libraries display a warning if the library's selected font
  does not match the user or appication defined font specification.
>>>X11FreeTypeFont::XFT_NOTIFY_LOAD
  The font library displays a message containing information about
  the requested font, and a brief font descriptor that contains the
  attributes that the Ctalk libraries use to select fonts: family,
  point size, slant, and weight.
>>>X11FreeTypeFont::XFT_NOTIFY_VERBOSE
  The font library displays a message that contains information
  about the requested font, and the complete font descriptor that
  the font libraries derive from the selected font's patterm.
  


Note: programs should call this method before launching any processes.
Generally this is before the X11Pane : openInputStream method.
Otherwise, the program only displays font loads for the process it was
called from.

>>>X11FreeTypeFont::qualifyName (String xftpattern)
Returns a fully qualified String containing a fully qualified
Xft font descriptor that matches xftpattern.

>>>X11FreeTypeFont::quiet (void)
Sets the font libraries' reporting level to XFT_NOTIFY_NONE.  For a
description of the libraries' notification levels, refer to the
notifyLevel method.

>>>X11FreeTypeFont::red (Integer value)
Set the current Xft font's foreground red channel.  The argument
value must be an unsigned short int; i.e., in the
range 0 - 65535 (0xffff hex).

>>>X11FreeTypeFont::saveSelectedFont (void)
This method does the work of setting the receiver's instance variables
to the values of the selected font.

>>>X11FreeTypeFont::selectedFont (void)
Returns the String with the descriptor of the selected font.
Because a complete font descriptor contains a lot of information, this
method can generate a lot of output.

>>>X11FreeTypeFont::RGBAColor (void)
>>>X11FreeTypeFont::RGBAColor (int red, int green, int blue, int alpha)
If given with no arguments, sets the current font's color to the values
of the receiver's 'ftRed, fgGreen, fgBlue,' and 'fgAlpha' values.
If the method is used with arguments, set's the current font's color to
their values.  The values are Integers and can have a range of 0-0xffff.

>>>X11FreeTypeFont::selectFont (void)
>>>X11FreeTypeFont::selectFont (String family, Integer slant, Integer weight, Integer dpi, Float pointSize)
If used without arguments, selects the font named by the receiver's
instance variables.  If the statement provides arguments, only the
family argument needs to describe an actual font family; that
is, it has no default value.  Defaults for the other arguments are
described below.  In this case, the method sets the receiver's instance
variables to the selected font.

For the slant and weight arguments, the Xft library
defines the constants and their meanings as the following.

---------------------------------------------------------
        SLANT
   0    Roman
   100  Italic
   110  Oblique
  
        WEIGHT
   0    Light
   100  Medium
   180  Demibold
   200  Bold
   210  Black
---------------------------------------------------------

The dpi parameter should be set to the resolution of the display.

An easier way to describe a font may be to use the
selectFontFromFontConfig method, which takes a FontConfig
format font specification as its argument. 

Refer to the X11FreeTypeFont : notifyLevel method for a
description of information and error message levels.  To return a
string containing the font descriptor that the Freetype libraries
derive from the selected font's pattern, refer to the
X11FreeTypeFont : selectedFont method.

>>>X11FreeTypeFont::selectFontFromXLFD (String xlfd)
Similar to selectFont, above, except that its argument is
a string in XLFD format.  That is, the method translates the XLFD argument
into the Xft library's font metrics.  This makes possible font descriptions
like the following.

---------------------------------------------------------
  
  -*-DejaVu Sans-medium-r-*-*-12-72-72-*-*-*-*-*
  
---------------------------------------------------------

As with all of the selectFont* methods, refer to the
X11FreeTypeFont : notifyLevel method for a description of
information and error message levels.  To return a string containing
the font descriptor that the Freetype libraries derive from the
selected font's pattern, refer to the @code{X11FreeTypeFont :
selectedFont} method.

>>>X11FreeTypeFont::selectFontFromFontConfig (String font_config_string)
Selects a font using the FontConfig specification given as its argument.

Refer to the beginning of the X11FreeTypeFont section for a description
of Fontconfig descriptors.

Again, as with all of the selectFont* methods, refer to the
X11FreeTypeFont : notifyLevel method for a description of
information and error message levels.  To return a string containing
the font descriptor that the Freetype libraries derive from the
selected font's pattern, refer to the @code{X11FreeTypeFont :
selectedFont} method.

>>>X11FreeTypeFont::textHeight (String text)
Return an Integer with the height in pixels of text in the
currently selected FreeType font.  If the Xft library is not available
or not initialized, the method returns 0.

>>>X11FreeTypeFont::textRBearing (String text)
Return an Integer with the right bearing (the distance between
the rightmost segment of a character glyph and the right edge of its
character box) in pixels of text in the currently selected
FreeType font.  If the Xft library is not available or not initialized,
or the application has not selected a font, the method returns 0.

>>>X11FreeTypeFont::textWidth (String text)
Return an Integer with the width in pixels of text in the
currently selected FreeType font.  If the Xft library is not available
or not initialized, the method returns 0.

>>>X11FreeTypeFont::verbose
Causes the Ctalk libraries to output verbose information about font
selection and loading, like the complete font descriptor that the
Freetype libraries derive from the currently selected font's pattern.
Refer to the X11FreeTypeFont : notifyLevel method for more
information about this class' notification levels..

>>>X11FreeTypeFont::verbosity (void)
Returns an Integer with the Xft libraries' reporting level.
The possible values, which are defined in ctalk/ctalkders.h,
are:

---------------------------------------------------------
  
  XFT_NOTIFY_NONE
  XFT_NOTIFY_ERRORS
  XFT_NOTIFY_LOAD
  XFT_NOTIFY_VERBOSE
  
---------------------------------------------------------


>>>X11Bitmap::background (String color)
Set the background color of the receiver to color.
Note: When changing foreground and background color,
make sure that an application has is receiving and
processing events, using the openEventStream method in
class X11Pane.

Clear the receiver to the background color.

>>>X11Bitmap::clearRectangle (Integer x, Integer y, Integer width, Integer height)
Clear the specified area to the background color.

Copies the contents of srcBitmap to the receiver's drawing
surface.  The source dimensions are determined by srcX,
srcY, srcWidth, and srcHeight.  The method draws the
source bitmap's contents with the source's upper left-hand corner at
destX, destY.

>>>X11Bitmap::initialize (void *displayPtr, int parentWindow, int width, int height, int depth)
Create a X11Bitmap object and its graphics data.

>>>X11Bitmap::delete (void)
Delete a pixmap and its graphics data.

>>>X11Bitmap::drawCircle (Circle aCircle, Integer filled, String bgColor)
>>>X11Bitmap::drawCircle (Circle aCircle, Pen aPen, Integer filled, String bgColor)
Draw the circle defined by aCircle in the receiver's paneBuffer.
If filled is true, draws a filled circle.  If the aPen
argument is given, draws the circle with the color and the line width
defined by the aPen, and fills the interior of the circle with
bgColor.

>>>X11Bitmap::drawFilledRectangle (Rectangle aRect, Pen aPen)
Draw a filled rectangle with the dimensions given in aRect, using
the color given by aPen.  For other variations on this method
refer to drawRectangle.

>>>X11Bitmap::drawLine (Integer xStart, Integer yStart, Integer xEnd, Integer yEnd, Pen aPen)
>>>X11Bitmap::drawLine (Line aLine, Pen aPen)
Draw a point on the receiver's drawing surface between the points
xStart,yStart and xEnd,yEnd using the color,
width, and transparency defined by the argument aPen. 

If a program uses the two-argument form of the method, aLine
is a member of class Line.  

>>>X11Bitmap::drawPoint (Integer x, Integer y, Pen aPen)
Draw a point on the receiver's drawing surface at x,y using
the color, width, and transparency defined by the argument aPen.


>>>X11Bitmap::drawFilledRectangle (Rectangle aRect, Pen aPen)
>>>X11Bitmap::drawFilledRectangle
Integer fill, Integer corner_radius)
>>>X11Bitmap::drawFilledRectangle
Integer line_width, String color,
Integer corner_radius) Draw a rectangle on the receiver
bitmap.  The fill argument, if given, draws a filled rectangle
if the argument is true.  If fill is false, use the
pen_width argument to determine the line width.  If radius
is non-zero, draw the rectangle with rounded corners with the radius
in pixels given by the argument.

>>>X11Bitmap::faceRegular (void)
>>>X11Bitmap::faceBold (void)
>>>X11Bitmap::faceItalic (void)
>>>X11Bitmap::faceBoldItalic (void)
Selects the typeface of the currently selected font.  The font should
have been selected by a previous call to font, below, which
loads the regular, bold, italic (or oblique), and bold italic flavors
of the selected font if they are available.

>>>X11Bitmap::font (String font_desc)
Set the font of the receiver.

>>>X11Bitmap::foreground (String color)
Set the foreground color of the receiver.
Note: When changing foreground and background color,
make sure that an application has is receiving and
processing events, using the openEventStream method in
class X11Pane.

>>>X11Bitmap::icon (int iconID)
>>>X11Bitmap::iconStop (void)
>>>X11Bitmap::iconCaution (void)
>>>X11Bitmap::iconInfo (void)
These methods draw a 64x64 dialog icon on the receiver's drawing
surface.  In the case of the icon method, the iconID
argument can be one of the following.

---------------------------------------------------------
  
  ICON_NONE
  ICON_STOP
  ICON_CAUTION
  ICON_INFO
  
---------------------------------------------------------

Before calling any of these methods, a program must have created
the pane's drawing surface with the create method.  It is
also generally necessary to set the pane's background color to
that of the surrounding window.  Here is an example.

---------------------------------------------------------
  
  myIcon create aPane displayPtr, aPane paneBuffer xID,
    ICON_WIDTH_PX, ICON_HEIGHT_PX, pPane paneBuffer depth;
  myIcon background "blue";
  
---------------------------------------------------------

Because icons are generally rendered off-screen, the program should
use the parent pane's display connection, paneBuffer xID, and
depth.  Then the program can use the X11Bitmap : copy method
to draw the bitmap on the surround pane's buffer.  Here's another example.

---------------------------------------------------------
  aPane paneBuffer copy myIcon, 0, 0, ICON_WIDTH_PX, ICON_HEIGHT_PX,
        iconLeftOrigin, iconTopOrigin;
  
---------------------------------------------------------

The constants ICON_WIDTH_PX and ICON_HEIGHT_PX are defined
in ctalkdefs.h, so programs and classes that use icons should
add this line near the top of the source module.

---------------------------------------------------------
  
  #include <ctalk/ctalkdefs.h>
  
---------------------------------------------------------

>>>X11Bitmap::putStr (Integer x, Integer y, String text)
>>>X11Bitmap::putStr (Integer x, Integer y, String text, String font_desc)
>>>X11Bitmap::putStr (Integer x, Integer y, String text, String font_desc, String colorName)
Print text on the receiver's drawable X resource, at
x,y.  If font_desc, a, X logical font descriptor, is
given, use that font to display the text. If colorName is also
given, render the text using that color.

>>>X11Bitmap::pixmapFromData (int x_org, int y_org, char *xpm_data[])
Draw the X pixmap defined by xpm_data with the upper left 
corner at x_org,y_org on the receiver's pane buffer.

The xpm_data argument is the name of the array declared at the 
start of a xpm file's data array.

In Ctalk's standard libraries, the image will appear on a
X11CanvasPane object, and programs can use the
pixmapFromData method in X11CanvasPane instead of calling
this method directly. 

>>>X11Bitmap::resize (Integer parentVisual, Integer new_width, Integer new_height)
Resize the receiver Pixmap.  This method is normally called by an
event handler in a parent class (typically, that's a
X11CanvasPane).  If you need to resize a graphics pane's buffers,
then the program should also call subPaneNotify (class X11Pane),
which invokes the handler for a RESIZENOTIFY event.

Here is the X11CanvasPane classes' RESIZENOTIFY
event handler.

---------------------------------------------------------
  
  X11CanvasPane instanceMethod subPaneResize (Object __subPane, 
  					  InputEvent __event) {
    "Resize the receiver pane.  This is the resize event
    handler called by the parent window's pane
    dispatcher."
  
    if (__ctalkX11ResizeWindow (__subPane, __event xEventData3,
  			      __event xEventData4,
  			      __subPane depth) > 0) {
      /* refreshReframe uses viewWidth and viewHeight, refresh uses size x
         and size y */
      __subPane viewWidth = __event xEventData3;
      __subPane viewHeight = __event xEventData4;
      __subPane size x = __event xEventData3;
      __subPane size y = __event xEventData4;
      (X11Bitmap *)self paneBuffer resize self xWindowID,
        __event xEventData3, __event xEventData4;
      (X11Bitmap *)self paneBackingStore resize self xWindowID,
        __event xEventData3, __event xEventData4;
    }
  
    return NULL;
  }
  
---------------------------------------------------------

For an example of how a program can handle RESIZENOTIFY events,
refer to the examples in the X11CanvasPane section.


>>>X11Bitmap::xpmInfoFromData (char **xpm_data, Array dataReturn)
Fills in the Array dataReturn with the information from the
X pixmap data referred  to by xpm_data: [width, height, colors, characters_per_color];

>>>X11Bitmap::xpmCharsPerColorFromData (char **xpm_data)
Returns an Integer with the number characters per color in the
X pixmap referred to by xpm_data.

>>>X11Bitmap::xpmColorsFromData (char **xpm_data)
Returns an Integer with the number of colors in the X pixmap referred to
by xpm_data.

>>>X11Bitmap::xpmHeightFromData (char **xpm_data)
Returns an Integer with the height of the X pixmap referred to
by xpm_data.

>>>X11Bitmap::xpmWidthFromData (char **xpm_data)
Returns an Integer with the width of the X pixmap referred to
by xpm_data.



>>>Boolean::!= (Integer i)
Return a Boolean value of 'True' if the values of
the receiver and the argument are different, 'False' otherwise.

>>>Boolean::&& (Boolean b)
Returns a Boolean value of 'True' if both the receiver and
the method's operand evaluate to true.

>>>Boolean::= (Integer i)
Sets the value of the receiver to True or False.  The method uses
the Ctalk library to perform the numeric conversion of the argument 
to a C int, then casts the result to True or False.


>>>Boolean::== (Integer i)
Return a Boolean value of 'True' if the values of
the receiver and the argument are the same, 'False' otherwise.

>>>Boolean::|| (Boolean b)
Returns a Boolean value of 'True' if either the receiver or
the method's operand evaluate to true.




>>>Collection::* (void)
When used as a unary operator to overload C's dereference ('*')
prefix operator, returns the first element of the array or Collection.
This method is actually a shortcut for the method head, below.

>>>Collection::+ (Integer n)
Returns the nth member of the receiver Collection.  This
method is actually a shortcut for the following expressions.

---------------------------------------------------------
  
  Collection new myCollection;
  
  .....  /* Add members to the collection. */
  
  if (*(myCollection + 1)) {
  ...
  }
  
  Collection instanceMethod + nth (Integer new n) {
    Key new k;
  
    k = *self;
    k += n;
    return k;
  }
  
---------------------------------------------------------


>>>Collection::at (char *keyString)
Retrieve the element of the receiver Collection at keyString.

>>>Collection::atPut (char * keyString, OBJECT *elemObject)
Add elemObject to the receiver with the key keyString.

>>>Collection::delete (void)
Remove all of the items in the receiver collection, leaving an empty
collection.  If any of the items are temporary (for example, a C
variable alias), delete the item also.

>>>Collection::getValue (void)
Return the value of the receiver, a Key object.

>>>Collection::isEmtpy (void)
Return TRUE if the receiver collection is emtpy, FALSE otherwise.

>>>Collection::head (void)
Return the first Key in the receiver collection, or NULL if
the collection is empty.

>>>Collection::keyExists (String keyName)
Return an Integer value of True if the key given as the
argument is present in the receiver collection, False otherwise.

>>>Collection::map (OBJECT *(*method)())
Execute method, an instance method of class
AssociativeArray, for each key/value pair of the receiver
array.  The receiver of method is a Key object with
the parent class of AssociativeArray.  The return value of
mapKeys is NULL.

>>>Collection::removeAt (String key_name)
Remove the object stored at key_name from the receiver
collection and return it.  Returns NULL if the entry isn't
present in the receiver collection.  In that case, the method
does not create a new entry, so programs should then call the
atPut method.

>>>Collection::replaceAt (String key_name, Object new_value)
Replace the value at key_name in the receiver collection.
Returns the old value object, or NULL if the key doesn't exist.  In
that case, the method does not create a new entry, so in that case
it's necessary to add the key/value entry to the receiver collection
using atPut.

>>>Collection::size (void)
Return an Integer with the number of items in the receiver
collection.

>>>Collection::tail (void)
Return the last Key object that was added to the receiver
collection.






>>>Array::= (Array a)
Set the receiver array's elements equal to the argument array's
elements.

>>>Array::asString (void)
Returns the contents of the receiver Array as a String
object.  If any member of the receiver is a Character object,
unquotes the Character object's value and concatenates the
character to the result string.  Otherwise the method concatenates
each of the receiver Array's values into the result string.

>>>Array::at (int n)
Retrieve the nth element of the receiver array.

>>>Array::atPut (int index, OBJECT *item)
Add item to the receiver at index.

>>>Array::map (method)
Executes method with each element of the receiver.

The argument, method, is a method that should belong to the same
class as the receiver. When method is executed, its receiver is
each successive array element, and method can refer to it with
self.

>>>Array::size (void)
Return the number of elements in the receiver.



>>>List::+= (Object obj1, ...)
Add the items given in the argument to the receiver List.
For example:

---------------------------------------------------------
  int main () {
    List new l;
  
    l = "first", "second", "third", "fourth";
    l += "fifth", "sixth", "seventh", "eighth";
  
    l map {
      printf ("%s\n", self);
  v  }
  }
---------------------------------------------------------

>>>List::= (Object obj1, ...)
Push the arguments on to the receiver List.  The arguments are a
comma separated list of objects.  For example:

---------------------------------------------------------
  int main () {
    List new l;
  
    l = "first", "second", "third", "fourth";
  
    l map {
      printf ("%s\n", self);
    }
  }
---------------------------------------------------------

The = method initializes a list with only the objects that are
given as arguments.  The memthod deletes any previous list contents.

>>>List::append (Object obj1, ...)
Add the objects given in the argument to the receiver List.
This is a synonym for the += method, above.

>>>List::init (Object obj1, ...)
This is a synonym for the = method, above.

>>>List::map (OBJECT *(*method)())
>>>List::map (OBJECT *(*method)(), Object argument)
>>>List::map (OBJECT *(*method)(), Object argument1, Object argument2)
Execute method, an instance method of class List, for
each member of the receiver List.  Within method, self
refers to each successive list element.  Here is an example.

---------------------------------------------------------
  
  List instanceMethod printElement (void) {
    printf ("%s\n", self);  /* Here, for each call to the printElement
                               method, "self" is each of myList's
                               successive members, which are String
                               objects. */
  }
  
  int main () {
  
    List new myList;
  
    myList = "item1", "item2", "item3";  /* Initialize the List with
                                            three String objects. */
    myList map printElement;
  
  }
  
---------------------------------------------------------

The map method can also use a code block as its argument.
The example above, written with a code block, would look like
this.

---------------------------------------------------------
  
  int main () {
  
    List new myList;
  
    myList = "item1", "item2", "item3";  /* Initialize the List with
                                            three String objects. */
    myList map {
      printf ("%s\n", self);
    }
  
  }
  
---------------------------------------------------------

If given with two arguments, method's parameter list must have
one parameter.  The parameter's class is significant within method;
that is, map can use any class of object for argument.
Here is the example above with one argument for the printElement
method;

---------------------------------------------------------
  
  List instanceMethod printElement (String leftMargin) {
    printf ("%s%s\n", leftMargin, self);
  
  }
  
  int main () {
  
    List new myList;
    String new leftMargin;
  
    myList = "item1", "item2", "item3";  /* Initialize the List with
                                            three String objects. */
    leftMargin = "- ";
  
    myList map printElement, leftMargin;
  
  }
  
---------------------------------------------------------

Calling map with three arguments works similarly.
The map methods in List class all return NULL.

>>>List::mapRev (OBJECT *(*method)())
Like map, except that it executes method for the last
member that was added to the receiver List, then the previous member,
and so on until the mapRev executes method for the first
member of the list before returning.

>>>List::new (list1, list2, list3, ...;)
Create the List objects list1, etc.  For example:

---------------------------------------------------------
  
  List new list1, list2, list3;
  
---------------------------------------------------------

>>>List::pop (void)
Remove the object from the end of the receiver's list and return the
object.

>>>List::popItemRef (void)
Here for backward compatibility; it is now the same as pop.

>>>List::push (OBJECT *(*object)(int))
Add object to the end of the receiver's list contents.

>>>List::pushItemRef (OBJECT *(*object)(int))
Also here for backward compatibility, this method is now the same
as push.

>>>List::shift (OBJECT *(*object)(int))
Add object as the first element of the receiver's list contents.

>>>List::sortAscending (void)
>>>List::sortDescending (void)
>>>List::sortAscendingByName (void)
>>>List::sortDescendingByName (void)
Sorts the receiver list based on either the members' values or names,
in ascending or descending order.  The sort algorithm is very simple
minded, but due to the mechanics of determining earlier/later
List members, the methods are as fast for small and medium
Lists as more complex sort algorithms.

If possible, you should try to add members in order rather than try
to re-arrange a List later.  For this, refer to the
methods in SortedList class 

>>>List::unshift (void)
Remove the first object from the receiver's list and return the
object.

>>>List::value (void)
Class List objects have no value instance variable.
Instead, return the List object's contents, or NULL if
the list is empty.


>>>AssociativeArray::at (char *key)
Retrieve the element of the receiver array stored at key.

>>>AssociativeArray::atPut (char *key, OBJECT *item)
Add item to the receiver at key.

>>>AssociativeArray::keyAt (String keyName)
Returns the Key object named by keyName.

>>>AssociativeArray::map (OBJECT *(*method)())
Execute method, an instance method of class
AssociativeArray, for each member of the receiver array.  Each
time method is executed, self refers to the object stored
in the associativeArray.  This method returns NULL.

>>>AssociativeArray::setValue (void)
A wrapper method for getValue in class Key. If received
by an instance of Collection or its subclasses instead of a
Key object, this method generates an exception.

>>>SortedList::+= (Object obj1, ...)
Add the items given in the argument to the receiver list.
For example:

---------------------------------------------------------
  int main () {
    SortedList new l;
  
    l = "first", "second", "third", "fourth";
    l += "fifth", "sixth", "seventh", "eighth";
  
    l map {
      printf ("%s\n", self);
    }
  }
---------------------------------------------------------

>>>SortedList::= (Object obj1, ...)
Push the arguments on to the receiver list.  The arguments are a
comma separated list of objects.  For example:

---------------------------------------------------------
  int main () {
    SortedList new l;
  
    l = "first", "second", "third", "fourth";
  
    l map {
      printf ("%s\n", self);
    }
  }
---------------------------------------------------------

The = method initializes a list with only the objects that are
given as arguments.  The memthod deletes any previous list contents.

>>>SortedList::append (Object obj1, ...)
Add the objects given in the argument to the receiver list.
This is a synonym for the += method, above.

>>>SortedList::init (Object obj1, ...)
This is a synonym for the = method, above.

>>>SortedList::pushAscending (Object new_item)
>>>SortedList::pushDescending (Object new_item)
Adds new_item to the receiver list at the point where its value
maintains the receiver list items' ascending or descending sort order.


>>>FileStream::= (arg)
Assign the value of the file stream in the argument to the receiver.  
This method does not duplicate the file handle.

>>>FileStream::closeStream (void)
Close the receiver's input file stream.  Note that closeStream does 
not delete the receiver object.  You must call delete 
(Class Object) to delete the object explicitly.  Deleting global 
and local objects is still not complete - you must check the receiver
and argument stacks, and the local variables of the function or
method, to make sure that the object is removed from its dictionary.

>>>FileStream::deleteFile (String file_path)
Deletes the file given as the argument.  If the deletion is not
successful, the method raises a SystemErrnoException which
an application can check for.

>>>FileStream::exists (char *__path_name)
Return TRUE if the file exists, FALSE otherwise.

>>>FileStream::isDir (void)
Return an Integer object that evaluates to TRUE if the
receiver is a directory, FALSE otherwise.

>>>FileStream::renameFile (String oldname, String newname)
Renames the file named by oldname to newname.  Raises
a SystemErrnoException if renaming the file causes an error.

>>>FileStream::seekTo (Integer file_pos)
Reposition the file's reading and writing position indicator at
file_pos.  If the request is unsuccessful, the method raises a
SystemErrnoException that a program can check for.

>>>FileStream::seekToBeginning (void)
Reposition the file's reading and writing position indicator at the 
beginning of a file.  If the request is unsuccessful, the method
raises a SystemErrnoException that a program can check for.

>>>FileStream::seekToEnd (void)
Reposition the file's reading and writing position indicator at the 
end of a file.  If unsuccessful, the method
raises a SystemErrnoException that programs can check for.

>>>FileStream::size (void)
Returns the size of the receiver's file as a LongInteger.

>>>FileStream::statFile (String file_path)
A wrapper method for the C stat(2) function.  This method fills
in the receiver stream's streamMode, streamDev,
StreamRdev, streamSize, streamAtime,
streamMtime, and streamCtime instance variables.
The stream does not need to be opened on the file given by
file_path.

The method returns an Integer with a value of '0' on
success, or if an error occurs, returns '-1' and raises a
SystemErrnoException.

>>>FileStream::statStream (void)
Another wrapper method for the C stat(2) function.  The method
fills in the streamMode, streamDev, StreamRdev,
streamSize, streamAtime, streamMtime, and
streamCtime instance variables of the receiver, an open file
stream.

The method returns an Integer with a value of '0' on
success, or if an error occurs, returns '-1' and raises a
SystemErrnoException.

>>>FileStream::streamEof (void)
Returns a non-zero Integer object if at the end of the receiver's
file stream, a zero-value Integer otherwise.


@subheading Class Methods

None.


>>>DirectoryStream::chDir (char *dir)
Change to the directory dir.

>>>DirectoryStream::directoryList (char *dirname, List dirlist)
List directory dirname, and store it in the List dirlist.
The order of the elements in the list depends on the operating system.
To expressly create a sorted directory listing, see the
sortedDirectoryList method.

>>>DirectoryStream::getCwd (void)
Return the current directory as a String object.

>>>DirectoryStream::globPattern (String file_name_pattern, List matching_file_names)
Adds the file names that match file_name_pattern to
matching_file_names.  This method uses the machine's glob
library call, if it is available, to do the pattern matching.  If the
system doesn't support filename pattern matching in its C library, the
method prints a warning message and returns.  For more information
about how the machine expands file globbing patterns into file names,
refer to the glob(3) and glob(7) manual pages.

>>>DirectoryStream::hasMeta (String file_name_pattern)
Returns a Boolean value of True if file_name_pattern
contains one of the opening metacharacters '*', '?',
or '[', False otherwise.

>>>DirectoryStream::mkDir (char *directoryname)
Create the directory directoryname.

>>>DirectoryStream::rmDir (char *directoryname)
Delete the directory directoryname.

>>>DirectoryStream::sortedDirectoryList (char *dirname, SortedList dirlist)
List directory dirname, and store it in the SortedList dirlist.
The members of the directory listing are stored in ascending order.




>>>ReadFileStream::new (stream1, stream2, stream3,...)
Creates one or more new ReadFileStream objects with the
names given in the argument list; e.g.,

---------------------------------------------------------
  
  ReadFileStream new stream1, stream2, stream3;
  
---------------------------------------------------------


>>>ReadFileStream::openOn (String path)
Open file path with mode 'r' and set the receiver's 
value to the file input stream.

>>>ReadFileStream::readAll (void)
Returns a String with the contents of the receiver's file stream.

>>>ReadFileStream::readChar (void)
Returns a Character from the stream defined by the receiver, or 
'EOF' at the end of the input.

>>>ReadFileStream::readFormat (char *fmt, ...)
Read formatted input from the receiver and store in the objects given
as arguments.

>>>ReadFileStream::readLine (void)
Returns a String of characters up to and including the next
newline of the stream defined by the receiver, or a String 
containing 'EOF' at the end of the input.

>>>ReadFileStream::readRec (Integer record_length)
Return a String that contains record_length
characters from the receiver's input stream.

>>>ReadFileStream::readVec (LongInteger data_length)
Reads data_length bytes from the receiver stream and returns a
new Vector object that points to the data.  This is useful for
reading binary data which may have embedded NULLs and other non-human
readable characters.  

>>>ReadFileStream::value
Returns the receiver's value instance variable.



@subheading Class Methods

>>>ReadFileStream::classInit
Called automatically by new when the first
ReadFileStream object is created.  Initializes 
stdinStream.



>>>WriteFileStream::new (stream1, stream2, stream3, ...;)
Creates one or more new WriteFileStream objects with
the names given in the argument list; e.g.,

---------------------------------------------------------
  
  WriteFileStream new stream1, stream2, stream3;
  
---------------------------------------------------------

>>>WriteFileStream::openOn (String path_name)
Open file path and set the receiver's value to the file output
stream.  The file is created if it does not exist.  Raises a
systemErrnoException if an error occurs.

>>>WriteFileStream::printOn (char *fmt, ...)
Format and print the method's arguments to the receiver, which must be
a WriteFileStream object that has been opened with openOn.

>>>WriteFileStream::value
Returns the receiver's value instance variable.

>>>WriteFileStream::writeChar
Writes char to the receiver's output file stream.

>>>WriteFileStream::writeFormat (char *fmt, ...)
Writes its arguments to the receiver using format fmt.

>>>WriteFileStream::writeStream
Write string to the receiver's output file stream.

>>>WriteFileStream::writeVec (Vector vector_object)
Write the contents of vector_object to the receiver stream.
The length of the data written is determined by vector_object's
length instance variable.  This allows the method to write
binary data that may contain NULLs and other non-human readable
characters. 

>>>TerminalStream::inputPending (void)
Returns TRUE if a terminal stream has pending input 
objects.

>>>TerminalStream::isATty (void)
Return TRUE if the receiver's stream is a tty device,
FALSE otherwise.

>>>TerminalStream::nextInputEvent (void)
Return the next InputEvent object from the stream's 
input queue.

>>>TerminalStream::queueInput (void)
Turn on queueing of input events.      

>>>TerminalStream::queueInputEvent (void)
Queue this input event.


>>>ANSITerminalStream::clear (void)
Clear the terminal stream.

>>>ANSITerminalStream::closeStream (void)
Close a terminal stream that was previously opened with openOn,
below. 

>>>ANSITerminalStream::cursorPos (int row, int column)
Set the cursor position to row, column.  The upper
left-hand corner of screen is 1,1.

>>>ANSITerminalStream::getCh (void)
Get a character from the terminal without echoing it.  This method
handles @kbd{C-c}, @kbd{C-d}, and @kbd{C-z} control characters by
exiting.  This method calls rawMode, so the application must
call restoreTerm before exiting.

>>>ANSITerminalStream::gotoXY (int row, int column)
Set the cursor position to row, column.  The upper
left-hand corner of screen is 1,1.  This method is a synonym for 
cursorPos, above.

>>>ANSITerminalStream::new (stream1, stream2, ... streamN; )
Create one or more new ANSITerminalStream objects and initialize
their input and output handles to stdinStream.
 and stdoutStream. 
For example,

---------------------------------------------------------
  
  ANSITerminalStream new stream1, stream2;
  
---------------------------------------------------------

>>>ANSITerminalStream::openInputQueue (void)
Begin queueing input events.  

>>>ANSITerminalStream::openOn (char *tty_device_name)
Open a tty device for the receiver.

>>>ANSITerminalStream::printOn (char *fmt, ...)
Print the formatted output to the receiver's output stream.

>>>ANSITerminalStream::rawMode (void)
Set the terminal input and output streams to raw mode.  

>>>ANSITerminalStream::readChar (void)
Read a character from the receiver's input stream.

>>>ANSITerminalStream::readLine (void)
Read a line of text from the receiver's input stream and return
a String object with the text.

>>>ANSITerminalStream::restoreTerm (void)
Restore the terminal parameters to the values when the
ANSITerminalStream object was created.  Applications must call this
method after using the getCh and rawMode methods, or the
terminal may be unusable after the the application exits.

>>>ANSITerminalStream::setGraphics (char attribute)
Set the graphics attribute for the following characters.  The 
attribute argument can be one of the following characters.
---------------------------------------------------------
  0       Attributes Off
  1       Bold
  4       Underscore
  5       Blink
  7       Reverse
---------------------------------------------------------

>>>ANSITerminalStream::setTty (int speed, int data_bits, char parity, int stop_bits)
Set the communication parameters of a terminal device opened with 
openOn, above.



Waits for a key and returns the scan code of a BIOS Int 16h, function
0 call.  Also sets the shift state in the receiver's shiftState
instance variable.  See the getShiftState method, below.

>>>Win32TerminalStream::cGetStr (void)
Returns a String object that contains input typed by
the user.  The input is echoed to the console.

>>>Win32TerminalStream::clear (void)
Clears the terminal window and moves the cursor to the upper 
left-hand corner.

>>>Win32TerminalStream::cPutStr
Prints str to the console at the current cursor position.

>>>Win32TerminalStream::cusorPos (int x, inty)
Positions the cursor at character position x, y.  
The upper left-hand corner of the screen is row 1, column 1.
This is a synonym for gotoXY, below.

>>>Win32TerminalStream::getCh (void)
Essentially a wrapper for the BDOS character input without echo
function.  This method handles @kbd{C-c}, @kbd{C-d}, and @kbd{C-z} by
exiting the application.

>>>Win32TerminalStream::getShiftState (void)
Get the state of the keyboard's modifier keys with by calling
BIOS Int 0x16, function 12h.  Stores the result in the receiver's 
shiftState instance variable.

>>>Win32TerminalStream::gotoXY (int x, inty)
Positions the cursor at character position x, y.  
The upper left-hand corner of the screen is row 1, column 1.

>>>Win32TerminalStream::openInputQueue (void)
Begin queueing input events.  

>>>Win32TerminalStream::printOn (char *fmt, ...)
Print the formatted output to the receiver's output stream.

>>>Win32TerminalStream::screenColor (char *fgcolor, char*bgcolor)
Sets the window's foreground and background colors for following 
writes using cPutStr, above.  The arguments are class
String, and may have the following values.
---------------------------------------------------------
  black
  blue
  green
  cyan
  red
  magenta
  brown
  lightgray
  darkgray
  lightblue
  lightgreen
  lightcyan
  lightred
  yellow
  white
---------------------------------------------------------


>>>X11TerminalStream::openInputClient (void)
Open the X input handler.  This method is normally used by
X11Pane class's openEventStream method. 

>>>X11TerminalStream::parentPane (void)
Return the receiver's X11Pane parent object if present.

>>>X11TerminalStream::queueInput (void)
Queue window system events as InputEvent
objects in the receiver's inputQueue instance
variable.  The inputQueue instance variable is
inherited from TerminalStream class. 

>>>TCPIPNetworkStream::addrInfo
Performs a lookup of hostName's IP addresses.  If the lookup is
successful, returns the host's canonical name in canonNameOut
and each of the host's addresses as a string in addrsOut.  The
method's return value is an Integer with the number of
addresses found.

If the lookup causes an error, the method raises an Exception
(not a SystemErrnoException) and returns 0.


>>>TCPIPNetworkStream::closeSock (void)
>>>TCPIPNetworkStream::closeSock (Integer sock_fh)
With no arguments, closes the receiver's socket.  With one
argument, closes the socket given as the argument.  If
closing a socket causes an error, the method raises a
SystemErrnoException.

>>>TCPIPNetworkStream::createSocketBasic (void)
Creates a socket with the domain AF_INET and the protocol SOCK_STREAM,
and sets the receiver's sock instance variable to the new socket's
file handle number, an Integer, and then returns the socket's file
handle number.  If not successful, the method raises a
SystemErrnoException and returns 0.

>>>TCPIPNetworkStream::hostToAddress (String hostname)
Given the name of a network host as the argument, the method returns
a String containing the host's dotted quad Internet address.

If the hostname lookup doesn't return any results, the method raises
an Exception (not a SystemErrnoException) and
returns an empty String.

---------------------------------------------------------
  
  #include <stdio.h>   /* contains printf prototype */
  
  int main () {
    TCPIPNetworkStream new net;
    String new address;
  
    address = net hostToAddress "MyHostName"; /* Substitute your host's name. */
  
    printf ("%s\n", address);
  }
  
---------------------------------------------------------


>>>TCPIPNetworkStream::readText (void)
>>>TCPIPNetworkStream::readText (Integer sock_fh)
Reads a socket's input and returns the input as a String object.
With no arguments, the method uses the receiver's socket file handle,
which is normally assigned by createSocketBasic, above.

If a socket file handle is given as the argument, then the method
performs the read on that handle.  This is useful when performing
reads after a call to acceptSock or a similar
method. 

If an error occurs while reading, the methods raise a
SystemErrnoException.

>>>TCPIPNetworkStream::readVec (Integer sock_fh, Vector data_vec_out)
Reads binary data from the socket given as the first argument and
returns the data in the Vector object give as the second
argument.

The method raise a SystemErrnoException if an error occurs
while reading.

This example is a simple server that receives image data and writes
it to a file.

---------------------------------------------------------
  
  int main () {
    TCPIPNetworkStreamReader new server;
    SystemErrnoException new ex;
    Vector new output;
    WriteFileStream new writeF;
    int newsocket;
    char *socket_out;
  
    server openOn;
  
    newsocket = server acceptSock;  /* INADDR_ANY */
  
    if (newsocket > 0) {
      server readVec newsocket, output;
      if (ex pending) {
        ex handle;
      }
      server closeSock newsocket;
    } else if (ex pending) {
      ex handle;
    } else {
      printf ("Connection timed out.\n");
    }
  
    server closeSock;
  
    writeF openOn "image-copy.jpeg";
    writeF writeVec output;
    writeF closeStream;
  }
  
---------------------------------------------------------

Here is the corresponding client program that transmits the image
data.

---------------------------------------------------------
  
  int main () {
    SystemErrnoException new ex;
    TCPIPNetworkStreamWriter new client;
    ReadFileStream new readF;
    Vector new photo;
    LongInteger new imageSize;
  
    readF openOn "image.jpeg";
  
    readF statStream;
    imageSize = readF streamSize;
  
    photo = readF readVec imageSize;
  
    readF closeStream;
  
    client openOn "127.0.0.1"; /* Edit with the reciever's actual network
                                  address. */
  
    client writeVec photo;
    if (ex pending) {
      ex handle;
    }
  
    client closeSock;
  }
---------------------------------------------------------

>>>TCPIPNetworkStream::readText (String text)
Writes the text given as the argument to the reciever's socket.
If the number of bytes actually written isn't equal to the length
of text, then the method raises a SystemErrnoException.

>>>TCPIPNetworkStream::readText (Vector data)
Writes the data contained in the argument to the receiver's socket.
The method raises an Exception if the argument is not a Vector,
or a SystemErrnoException if an error occurs while writing.

Examples of client and server programs which handle binary data
are given in the entry for readVec, above.


>>>TCPIPNetworkStreamReader::acceptSock (void)
Waits for an incoming connection on the receiver's socket, and if
a connection is pending, returns the number of the socket that
communications will take place on.

If the connection times out, then the method returns 0.  The length
of time the method should wait for incoming connections is given
by the receiver's timeout instance variable.

If an error occurs, the method returns 0 and also raises a
SystemErrnoException.

Note: The method can handle peer connections if the operating
system supports it - binding listening sockets to specific addresses
is not uniformly supported among operating systems.  In these cases,
the method can also wait for connections using the constant
INADDR_ANY.

This is done by using the openOn method (below) with no network
address.

---------------------------------------------------------
  
    mySock openOn "127.0.0.1";   /* bind the socket to the
                                    local network connection. */
       
    mySock openOn;               /* bind a socket to listen for
                                    connections from any network
                                    address. */
  
---------------------------------------------------------

In the second case, the acceptSock method can also function as
the core of a more conventional network server.

>>>TCPIPNetworkStreamReader::openOn (void)
>>>TCPIPNetworkStreamReader::openOn (String address)
>>>TCPIPNetworkStreamReader::openOn (String address, Integer port)
Creates the receiver's socket and binds it to receive messages from
the network address given as the argument.  If no network
address is given, the receiver's socket is bound to the constant
INADDR_ANY.

If no port argument is given, the socket is bound to
DEFAULT_TCPIP_PORT, which is defined in classes/ctalkdefs.h,
and which you can set depending on the the systems' needs.

These methods raise an Exception if any of the networking
functions return an error.



>>>TCPIPNetworkStreamWriter::openOn (String address)
>>>TCPIPNetworkStreamWriter::openOn (String address, Integer port)
Creates a socket and connects it to the network address given as
the argument.

If a port argument is given, the socket connects over that port;
otherwise, the socket connects via DEFAULT_TCPIP_PORT, which is defined
in classes/ctalkdefs.h, which you can adjust to suit the network's
needs.

These methods raise a SystemErrnoException if any of
the networking functions return an error.



>>>TCPIPV6NetworkStream::addrInfo (String hostname, String canonnameout, List addrsOut)
Performs a lookup of hostname's IPv6 addresses.  If the lookup
is successful, returns the host's canonical name in canonnameout
and each of the host's addresses as a string in addrsOut.  The
method's return value is an Integer with the number of
addresses found.

If the lookup causes an error, the method raises an Exception
(not a SystemErrnoException) and returns 0.

>>>TCPIPV6NetworkStream::closeSock (void)
>>>TCPIPV6NetworkStream::closeSock (Integer sockNum)
With no arguments, closes the receiver's socket.  If a socket file
handle number is given as the argument, closes that socket. If closing
the socket causes an error, the method raises a
SystemErrnoException.

>>>TCPIPV6NetworkStream::createSocketBasic
Creates a new IPv6 socket and sets the receiver's sock instance
variable, an Integer, to the system-assigned file number, and
returns the sock instance variable. If an error occurs while
creating a socket, the method raises a SystemErrnoException
and returns 0.

>>>TCPIPV6NetworkStream::readText (void)
>>>TCPIPV6NetworkStream::readText (Integer sock_fn)
Read text from a network connection.  With no arguments, the value
of the receiver's sock instance variable provides the socket
file handle.  If one argument is given, the argument, an Integer,
provides the file handle number.

These methods return a String with the contents of the received
message.  If an error occurs while reading, the methods raise a
SystemErrnoException and return NULL.

>>>TCPIPV6NetworkStream::readVec (Integer sock_fn, Vector resultVec)
Reads binary data from the socket handle sock_fn into
resultVec, and returns resultVec.  The method raises
a SystemErrnoException if an error occurs.

>>>TCPIPV6NetworkStream::writeText (String textArg)
Writes the String given as the argument to the
receiver's socket.  If the number of bytes written does not
match the length of textArg, the method raises a
SystemErrnoException.

>>>TCPIPV6NetworkStream::writeVec (Vector dataVec)
Writes the contents of DATAVEC to the receiver's socket.  If
the number of bytes written does not match the length of the data,
the method raises a SystemErrnoException.


>>>TCPIPV6NetworkStreamReader::acceptSock (void)
Listens for incoming connections on the socket that is bound to
a network address and port by a previous call to openOn.

If the program receives an incoming connection, acceptSock
creates a new socket to read data from the connection and returns the
socket number, an Integer, to the calling program.

If the method times out, it returns 0 to the calling program.  The
timeout instance variable determines the number of seconds
the method should wait for incoming connections.  The default is
10 seconds.

If an error occurs, the method returns -1 and raises a
SystemErrnoException.

>>>TCPIPV6NetworkStreamReader::openOn (void)
>>>TCPIPV6NetworkStreamReader::openOn (Integer port)
>>>TCPIPV6NetworkStreamReader::openOn (String hostName, Integer port)
Binds a TCPIPV6NetworkStreamReader object to the hostname and
port given as the arguments, if any.  The return value is the socket
handle number of the receiver, an Integer.

If no hostname or port is given, the method binds the socket to the
system constant in6addr_any, and the port defined by
DEFAULT_TCPIP_PORT, defined by the Ctalk library in the ctalkdefs.h
header file.

If an error occurs, these methods raise an Exception
and return 0.

>>>UNIXNetworkStream::closeSocket (void)
Shuts down the receiver's socket (defined in the sock instance
variable) and deletes the socket's file entry (which is defined in the
socketPath instance variable), if present.

>>>UNIXNetworkStream::makeSocketPath (String basename)
Constructs a fully qualified socket path from basename and
the prefix given by socketPrefix (described above).
If basename contains the characters '$$', the method
replaces the character with the program's process ID.

After constructing the fully qualified name, the method
fills in the receiver's socketBaseName and
socketPath instance variables, and returns
the value of the socketPath instance variable.

The small program here constructs and prints the file pathname of a
program's UNIX socket, which includes the process ID of the program.

---------------------------------------------------------
  
  int main () {
    UNIXNetworkStream new un;
    String new sockName;
  
    sockName = "myprogsocket.$$";
  
    un makeSocketPath sockName;
    printf ("%s\n", un socketPath);
  }
  
---------------------------------------------------------

>>>UNIXNetworkStream::removeSocket (void)
Deletes the socket's file entry by its name, which is defined by
makeSocketPath, above.



>>>UNIXNetworkStreamReader::open (void)
Creates a socket to read data from the socket name by the
receiver's socketPath instance variable, which is
defined in UNIXNetworkStream class. 

The method returns the file number of the socket, or -1 if there
is an error, and raises a SystemErrnoException if an error
occurred in the network library routines.

>>>UNIXNetworkStreamReader::openOn (String socketpath)
Creates a new reader socket and binds it to socketpath.  Sets
the receiver's socketPath instance variable to the argument.
Returns an Integer with the file number of the newly created
socket.

>>>UNIXNetworkStreamReader::sockRead (void)
Returns a String containing data received from the socket
previously created by the open method, above, and sets
the charsRead instance variable to the number
of characters read.

If no data is waiting, the method returns an empty string and sets the
receiver's charsRead instance variable to 0.

If an error occurs during one of the system calls, the method
raises a SystemErrnoException.


>>>UNIXNetworkStreamWriter::open (void)
Creates a machine-local UNIX socket connection with the socket
name given by the socketPath instance variable, which
is defined in UNIXNetworkStream class. 

If successful, the method returns the file handle number of the
new socket.  If an error occurs, the method returns -1 and raises
a SystemErrnoException if the error occured in a library
call.

>>>UNIXNetworkStreamWriter::openOn (String socketpath)
Creates a new writer socket and binds it to socketpath.  Sets
the receiver's socketPath instance variable to the argument.
Returns an Integer with the file number of the newly created
socket.

>>>UNIXNetworkStreamWriter::sockWrite (String data)
Writes data to the socket created by a previous call to
the open method, above.  Sets the receiver's charsWritten
instance variable to the number of characters written.  If
successful, returns 0, or if an error occured, returns -1 and
raises a SystemErrnoException.

>>>TreeNode::addChild (TreeNode child)
Add child to the end of the receiver's children list.

>>>TreeNode::format (void)
Print the receiver tree to a String object.  This method uses
two other methods, __formatChildren and __formatSiblings
to traverse each TreeNode object in the receiver tree.  Returns
a String object.

>>>TreeNode::makeSibling (TreeNode sib)
Add sib to the end of the receiver's sibling list.

>>>TreeNode::map (OBJECT *(method)())
Execute method over each member of the receiver tree.  As
with map methods in other classes, method must also
belong to TreeNode class and takes no arguments.

>>>TreeNode::print (void)
Print the receiver tree to the terminal.  This method uses
two other methods, __printChildren and __printSiblings
to traverse each TreeNode object in the receiver tree.

>>>TreeNode::search (String searchString)
Return the first node in the receiver tree whose content
matches searchString.  Returns only the first node
that contains searchString.  Does not look for multiple
matches.

>>>TreeNode::setContent (String str)
Sets the receiver TreeNode's content instance variable
to str, a String object. 



>>>Application::__handleAppExit (__c_arg__ int signo)
A standard, user installable SIGINT (@kbd{Ctrl-C}) signal handler.  If
the application has enabled exception traces, print a stack trace and
then call the default SIGINT handler.  The signo argument
contains the number of the signal that calls the method.

The application must first call the installExitHandler method
(below) to define this method as a signal handler - then this method
is called when the application receives a SIGINT, which is normally
generated when the user presses Control-C.

This method does not return.

>>>Application::__handleSigAbrt (__c_arg__ int signo)
A standard, user installable SIGABRT handler.  The application must first
call installAbortHandler, below.  If the application has enabled
exception traces, print a stack trace before exiting.  This method does
not return.

>>>Application::classSearchPath (void)
Returns a String that contains Ctalk's class library search
path, with each directory separated by a colon (':').  The
default is usually /usr/local/include/ctalk.  

If there are any directories given as arguments to the '-I'
command line option, and any directories named in the
'CLASSLIBDIRS' environment variable, Ctalk includes those
directories as well, and searches them first.

>>>Application::execC (String commandLine)
>>>Application::execC (String commandLine, String commandOutput)
Execute the command and arguments given by commandLine and wait
for the program to finish.  The method displays the standard
output of the subprocess.

If a second argument is given, the program's standard output
is saved in the commandOutput object, which should normally
be a String object.  Here is a simple example program.

---------------------------------------------------------
  
  int main () {
    Application new myApp;
    String new str, output;
    
    str = "/bin/ls -l";
    myApp execC str, output;
    printf ("%s\n", output);
  }
  
---------------------------------------------------------

For any number of arguments, if the command redirects the
standard outut, then the output is sent to the file that
is the operand of a '>' or '>>' redirection operator.

If commandLine is the name of a shell script, the shell script
is executed by a sub-shell using the system(3) library call.

>>>Application::getPID (void)
Returns an Integer with the program's process ID.

>>>Application::installAbortHandlerBasic (void)
Installs a C handler for SIGABRT signals.  The C
handlers are more reliable, though less
flexible, than handlers that use SignalHandler class.

This method catches a SIGABRT, and prints a walkback trace if tracing
is enabled, before the application exits.

>>>Application::installExitHandler (void)
Install a SIGINT (@kbd{C-c}) handler in a Ctalk program that
performs cleanup before exiting the application.

>>>Application::installExitHandlerBasic (void)
Installs a C handler for SIGINT signals (@kbd{C-c} or
@kbd{C-break} for DJGPP) that is slightly more robust and
reliable, though less flexible, than the
SignalHandler classes.

This method causes the application to exit when receiving a signal,
and prints a walkback trace if tracing is enabled.

>>>Application::installPrefix (void)
Returns a String with the name of the top-level directory
where Ctalk's various component subdirectories are located.  For
example, in relative terms, this is where Ctalk's various components
get installed.

---------------------------------------------------------
  
  Executables:            prefixdir/bin
  Libraries:              prefixdir/lib
  Class Libraries:        prefixdir/include/ctalk
  Texinfo Manuals:        prefixdirshare/info
  Manual Pages:           prefixdir/share/man
  Searchable Docs:        prefixdir/share/ctalk
  
---------------------------------------------------------

>>>Application::membervars (void)
Returns a String with the member variable declarations
of the class named by the receiver.  If the receiver is a String
object, membervars returns the variables for the class given
by the String's value.  If the receiver is a class object,
membervars returns the member variables for that class.  For
nany other type of object, membervars returns the variables
declared in the object's class. 

Membervars returns the complete documentation of the instance or
class variable, if the declaration also contains a documentation string.


>>>Application::methodDocString (String method-source)
Returns the documentation string from the source of the method
given as the argument. 

>>>Application::methodPrototypes (String input)
If input is a method's source or a class library, returns a String
containing the prototypes of the methods; that is, the declaration and the
argument list.

>>>Application::methodSource (String className, String methodName)
Returns a String object with the source code of the method(s)
that match the declarations, The methodSource method does not
distinguish methods by the number of arguments, so it returns the code
of any method in a class that matches the methodName arguement.

---------------------------------------------------------
  
  className instanceMethod methodName
  className classMethod methodName
  
---------------------------------------------------------

The method generates a SystemErrnoException if it can't find
the class file. 

The methodSource method is built to be as fast as possible and
has a rather simple minded view of what constitutes a method
declaration.

The method only recognizes declarations that appear on a single line,
in order to keep the regular expressions that do the matching as
simple as possible, and it only matches spaces between tokens, and not
tabs, at least at the moment.  It can also be fooled by things that
even look like a method declaration within the method body.
For example, a phrase like,

---------------------------------------------------------
  
  className instanceMethod <some-method-name>
  
---------------------------------------------------------

in the method's documentation, causes methodSource to signal the
start of the next method.

>>>Application::parseArgs (Integer argc, Array argv)
Takes the argv and argc parameters to main () and 
sets each element of the cmdLineArgs instance variable (above)
to a String that contains each element of the system's argv
array.

>>>Application::parseX11Geometry (String geometryString)
Parses a X Window System geometry string.  If the string specifies
any of the x, y, width, or height values for a window, the method
sets the winXOrg, winYOrg, winWidth, or 
winHeight instance variables.  If the geometry string omits
any of the values, the method sets the corresponding instance variable
to zero.  The method sets the geomFlags instance variable to
the geometry flags provided by the window system.

This method only parses the geometry string.  It does not make any
adjustments for the display dimensions, or the window dimensions or
placement.

For information about the format of a X geometry string, refer to the
XParseGeometry(3) manual page.

>>>Application::spawnC (String command, Integer restrict)
Starts the program given by the argument command, and resumes
execution of the main program.  The method returns an Integer
with the process ID of the child process.

The child process becomes a daemon process, which means it has no
interaction with the parent process.  If you want the parent process
to handle the child processes' output, refer to the execC
method, above.  Otherwise, communication between the parent and child
process should be handled by UNIX's interprocess communication
facilities.

If the restrict argument is non-zero, the method also changes
the child processes' working directory to '/' and its umask to
'0'.

The spawnC method does not use a shell when executing the child
process, which means that the method doesn't handle shell facilities
like IO redirection or file globbing.  It's also necessary to provide
the full path name of the program to be launched in the background.

The process that handles the session management when the daemon
process is launched remains executing until the parent process
exits.  This means there can be three entries in the
system's process table, but it helps minimize creating zombie
processes in case any part of the program quits unexpectedly.

>>>Application::uSleep (long long int usecs)
Sleep for usecs microseconds.

>>>Application::useXRender (Boolean b)
If b is true, draw graphics using the X Render extension
if it is available. If b is false, use Xlib for graphics
drawing.  The default is to draw using the X Render extension
if it is available.

>>>Application::usingXRender (void)
Returns a Boolean value of True if the program is
using the X Render extension for drawing, False otherwise.


>>>ClassLibraryTree::init (TreeNode tree, Boolean printDots)
Creates a a tree of the class library with tree as the root node
of the tree.  If printDots is true, prints the method's progress
on the terminal.



>>>GLUTApplication::createMainWindow (String title)
Create the main window.  The argument, a String contains
the window's title.

>>>GLUTApplication::cone (Float base, Float  height, Integer slices, Integer  stacks, Integer fill)
Draw a cone with a base of size base, height height, with
slices longitudinal slices and stacks lateral slices.  If
fill is True, draw a filled cone; otherwise, draw a wireframe cone.

>>>GLUTApplication::cube (Float size, Integer fill)
Draw a cube with sides of size length.  If fill is True,
draw a filled cube; otherwise draw a wirefame cube.

>>>GLUTApplication::defineAnimationFn (Symbol fn)
>>>GLUTApplication::defineButtonBoxFn (Symbol fn)
>>>GLUTApplication::defineDialsFn (Symbol fn)
>>>GLUTApplication::defineDisplayFn (Symbol fn)
>>>GLUTApplication::defineEntryFn (Symbol fn)
>>>GLUTApplication::defineIdleFn (Symbol fn)
>>>GLUTApplication::defineKeyboardFn (Symbol fn)
>>>GLUTApplication::defineMenuStateFn (Symbol fn)
>>>GLUTApplication::defineMenuStatusFn (Symbol fn)
>>>GLUTApplication::defineMotionFn (Symbol fn)
>>>GLUTApplication::defineMouseFn (Symbol fn)
>>>GLUTApplication::defineOverlayDisplayFn (Symbol fn)
>>>GLUTApplication::definePassiveMotionFn (Symbol fn)
>>>GLUTApplication::defineSpaceballMotionFn (Symbol fn)
>>>GLUTApplication::defineSpaceballRotateFn (Symbol fn)
>>>GLUTApplication::defineSpecialFn (Symbol fn)
>>>GLUTApplication::defineTabletButtonFn (Symbol fn)
>>>GLUTApplication::defineTabletMotionFn (Symbol fn)
>>>GLUTApplication::defineVisibilityFn (Symbol fn)
>>>GLUTApplication::defineTimerFn (Integer msec, Symbol fn, Integer argValue)
Define callback functions for window system events.  The argument is
the name of the C function that handles the event.  Refer to the
method's documentation and the GLUT API's documentation for information
about each callback function's parameters.

Note: defineAnimationFn and defineTimerFn both use
the glutTimerFunc () callback, so the actual callback is the
last function defined (before calling installCallBackFns).

The difference is that defineAnimationFn executes its callback
24 times per second, while defineTimerFn uses an application
defined interval, and takes three arguments: the timer interval in
milliseconds, the name of the callback function, and an integer that
is passed to the callback function as an argument.

>>>GLUTApplication::defineReshapeFn (Symbol fn)
Defines the function used to reshape the window's 3D viewing space.
The default is an orthographic projection, 5 grid units wide on each
axis.  If you need to duplicate the default viewing area in a
program, here is the code that defines it.  The variables
'width' and 'height' are provided by the GLUT application
as arguments to the reshape function.

---------------------------------------------------------
  
  void defualt_reshape_fn (int width, int height) {
    float ar = (float)width / (float)height;
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho (-5.0 * ar, 5.0 * ar, -5.0, 5.0, 5.0, -5.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
  }
  
---------------------------------------------------------

>>>GLUTApplication::dodecahedron (Integer fill)
Draw a dodecahedron.  If fill is True, draw a solid dodecahedron;
otherwise draw a wireframe dodecahedron.

>>>GLUTApplication::fullScreen (void)
Resize the main window so that it occupies the entire screen.  A call
to reshape (the method, not the callback) or position
returns the window to its normal state.

>>>GLUTApplication::icosahedron (Integer fill)
Draw a icosahedron.  If fill is True, draw a solid icosahedron;
otherwise draw a wireframe icosahedron.

>>>GLUTApplication::initGlut (Integer argc, Array argv)
Initialize the GLUT window system.  If there are any GLUT specific
command line arguments, this method parses them and uses then uses the
options to configure the window system.  This method also calls
Application method parseArgs, so the command line
arguments are available in the cmdLineArg instance variable (an
Array). 

>>>GLUTApplication::initWindow (Integer width, Integer  height)
>>>GLUTApplication::initWindow (Integer xOrg, Integer yOrg, Integer width, Integer  height)
Initialize the main window's size or, with four arguments, its size
and position.

>>>GLUTApplication::installCallBackFns (void)
Install the callback functions defined by previous calls to define*Fn
methods.

>>>GLUTApplication::octahedron (Integer fill)
Draw a octahedron.  If fill is True, draw a solid octahedron;
otherwise draw a wireframe octahedron.

>>>GLUTApplication::tetrahedron (Integer fill)
Draw a tetrahedron.  If fill is True, draw a solid tetrahedron;
otherwise draw a wireframe tetrahedron.

>>>GLUTApplication::run (void)
Enter the GLUT API's main event loop.  When this method returns, the
program typically exits.  Note: GLUT does not provide any
events to terminate program.  To exit a program normally, use C's
exit (3) function and on_exit(3) (or onexit(3))
to handle any program specific exit processing.

>>>GLUTApplication::sphere (Float radius, Integer slices, Integer stacks, Integer fill)
Draw a sphere with radius with slices longitudinal
sections and stacks lateral sections.  If fill is True, draw
a filled sphere; otherwise draw a wireframe sphere.

>>>GLUTApplication::teapot (Integer fill)
Draw the classic teapot demonstration.  If fill is True, draw
a solid teapot; otherwise draw a wireframe teapot.

>>>GLUTApplication::torus (Float inner_radius, Float outer_radius, Integer size, Integer rings, Integer fill)
Draw a torus with the inner and outer radii given by the arguments, with a section size and rendered in rings sections.  If fill is True, draw a solid torus; otherwise draw a wireframe torus.

>>>GLUTApplication::windowID (String window_title)
Return an Integer with the X window ID of the window with the title
window_title. Note: Some OS's, like  OSX/Darwin, don't
use Xlib to draw windows; in that case, this method won't be able
to provide a lower level window ID.

>>>GLUTApplication::xpmToTexture (char **xpm_data, Integer width_out, Integer height_out, Symbol texture_data_out)
>>>GLUTApplication::xpmToTexture (char **xpm_data, Integer alpha, Integer width_out, Integer height_out, Symbol texture_data_out)
Translates a XPM pixmap into an OpenGL texture.  The argument
xpm_data is the pixmap's char *pixmap_name[] declaration.
If no alpha argument is given, then '1.0' is used to
create an opaque texture.  Alpha values can range from 0.0 (completely
transparent) - 1.0 (completely opaque).

The method sets the arguments width_out, height_out, and texel_data_out with the height, width and data of the texture.

The resulting texture has the format GL_RGBA and the data type GL_UNSIGNED_INT_8_8_8_8, so you can create a 2D texture from a pixmap with statements like these.

---------------------------------------------------------
  
  Integer new xpmWidth;
  Integer new xpmHeight;
  Symbol new texData;
  
  /*
   *  Note that the xpm_data argument should not normally need a
   *  translation from C.
   */
  myGLUTApp xpmToTexture xpm_data, xpmWidth, xpmHeight, texData;
  glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, xpmWidth, xpmHeight, 0,
                GL_RGBA, GL_UNSIGNED_INT_8_8_8_8, texData);
  
---------------------------------------------------------

The xpmToTexture method does not do any setup of the OpenGL texture
environment.  For basic textures, OpenGL works better with textures
that have a geometry that is an even multiple of 2; e.g., 128x128 or
256x256 pixels.  

Individual applications can add parameters for interpolation,
blending, mipmap creation, and material rendering based on the
program's requirements, though.

The Ctalk library only stores the data for one texture at a time, so
if a program uses multiple textures, it should save the texture data
to a separate Symbol, in orderq to avoid regenerating the texture each
time it's used.

For an example of how to draw with textures, refer to the
@file{texture.ca} and @file{texblend.ca} programs in the Ctalk
distribution's @file{demos/glut} subdirectory.


>>>ObjectInspector::formatClassVariable (Symbol objectRef)
Return a String containing the contents of an object
and its instance variables.  The argument is a reference to 
the object to be formatted.  Both formatClassVariable
and formatInstanceVariable are used by
formatObject, below.

>>>ObjectInspector::formatInstanceVariable (Symbol objectRef)
Return a String containing the contents of an object
and its instance variables.  The argument is a reference to 
the object to be formatted.

>>>ObjectInspector::formatObject (Symbol objectRef)
Return a String containing the contents of an object
and its instance variables.  The argument is a reference to 
the object to be formatted.

>>>ObjectInspector::inspect (Symbol objectRef)
>>>ObjectInspector::inspect (Symbol objectRef, String promptStr)
Suspends execution of the program and enters the Object inspector.
This allows you to examine the object pointed to by objRef,
continue execution, or exit the program.  Typing '?' or 'help'
at the prompt prints a list of the inspector's commands.  With a
String object as the second argument, the inspector displays
the string as its command prompt.

The manual page, inspect(3ctalk), contains a description the
inspector's commands and a brief tutorial.


>>>LibrarySearch::cAPIFunctionSearch (String docPath, String search_pattern)
Returns a String that contains the results of a search for the
C API function or functions that match search_pattern.

>>>LibrarySearch::methodSearch (String docPath, String search_pattern)
Search the class library's method prototypes for search_pattern.
Returns a String object with the results.  Note that this
function is designed to be rather inclusive; it searches the
entire method prototype for a pattern, which may include the
receiver class's name or any parameter name(s).  So including the
receiver class name is a search is perfectly valid - the syntax of a
method prototype in the documentation is:

---------------------------------------------------------
  
  <receiver_class>::<method_selector> (param_list)
  
---------------------------------------------------------






>>>Exception::deleteLastException (void)
Delete the last generated exception from Ctalk's internal exception list.

>>>Exception::handle (void)
Execute the exception handler for the next pending method.
If a program calls enableExceptionTrace (class Object),
then handle also displays a walkback of the exception's copy of
the program call stack.  

>>>Exception::exceptionHandler (void)
Handle an exception either with Ctalk's default exception
handler or a user defined handler.  If the program has
called the traceEnabled method (class Object), 
print a stack trace also. 

>>>Exception::installHandler (char *handler_method_name)
Install a user-defined method to handle exceptions.  The
method's receiver class must be of the same class as the exception; i.e.,
either Exception or SystemErrnoException.

>>>Exception::peek (void)
Returns a String containing the text of the first pending
exception, if any.

>>>Exception::pending (void)
Return TRUE if any exceptions are pending, FALSE otherwise.

>>>Exception::raiseCriticalException (EXCEPTION ex, char *text)
Raise a critical exception.  A critical exception is similar to a
normal exception, below, except that it is not caught internally.  The
application must catch the exception with pending and handle.

You should use one of the EXCEPTION macros defined above
as the argument ex.

Print a trace of the methods in the current exception's copy of 
the program's call stack.

>>>Exception::raiseException (EXCEPTION ex, char *text)
Raise an exception.  You should use one of the EXCEPTION macros
defined above as the argument ex.


>>>SystemErrnoException::raiseException (char *data)
Sets the value of the sysErrno class variable and raises an
exception if the C library's errno variable or macro returns a
nonzero value.


>>>SignalEvent::getPID (void)
Set the SignalEvent object's pid instance variable to
the program's process ID.

>>>SignalEvent::new (event1, event2, ... event3;)
Create one or more new SignalEvent objects with the names
given in the argument lists.

---------------------------------------------------------
  
  SignalEvent new event1;
  SignalEvent new event1, event2;
  
---------------------------------------------------------

>>>SignalEvent::nextEvent (void)
Return the next signalEvent object from the class'
pendingEvents queue.

>>>SignalEvent::pending (void)
Return TRUE if the class' pendingEvents queue contains
SignalEvent event objects, FALSE otherwise.

>>>SignalEvent::queueEvent (void)
Add the receiver to the class' pendingEvents queue.



>>>SignalHandler::defaultHandler (void)
Install the operating system's default handler for the receiver's 
signal number sigNo.  The operating system's documentation
describes how it handles signals.

>>>SignalHandler::ignoreSignal (void)
Set the receiver signal handler to ignore a signal.

>>>SignalHandler::installHandler (OBJECT *(*method)(int))
Install method as the receiver's signal handler.  The method
must be callable as a C function.  

>>>SignalHandler::new (char *name)
Create new SignalHandler objects with the name(s)
given in the argument list.

>>>SignalHandler::raiseSignal (void)
Send the signal of the receiver's sigNo variable to the 
current program.

>>>SignalHandler::setSigAbrt (void)
Set the signal of the receiver's handler to SIGABRT.

>>>SignalHandler::setSigAlrm (void)
Set the signal of the receiver's handler to SIGALRM.

>>>SignalHandler::setSigChld (void)
Set the signal of the receiver's handler to SIGCHLD.

>>>SignalHandler::setSigCont (void)
Set the signal of the receiver's handler to SIGCONT.

>>>SignalHandler::setSigFpe (void)
Set the signal of the receiver's handler to SIGFPE.

>>>SignalHandler::setSigHup (void)
Set the signal of the receiver's handler to SIGHUP.

>>>SignalHandler::setSigIll (void)
Set the signal of the receiver's handler to SIGILL.

>>>SignalHandler::setSigInt (void)
Set the signal of the receiver's handler to SIGINT.

>>>SignalHandler::setSigNo (int signum)
Set the signal number of the receiver to signum.

>>>SignalHandler::setSigPipe (void)
Set the signal of the receiver's handler to SIGPIPE.

>>>SignalHandler::setSigQuit (void)
Set the signal of the receiver's handler to SIGQUIT.

>>>SignalHandler::setSigSegv (void)
Set the signal of the receiver's handler to SIGSEGV.

>>>SignalHandler::setSigTerm (void)
Set the signal of the receiver's handler to SIGTERM.

>>>SignalHandler::setSigTstp (void)
Set the signal of the receiver's handler to SIGTSTP.

>>>SignalHandler::setSigTtin (void)
Set the signal of the receiver's handler to SIGTTIN.

>>>SignalHandler::setSigTtou (void)
Set the signal of the receiver's handler to SIGTTOU.

>>>SignalHandler::setSigUsr1 (void)
Set the signal of the receiver's handler to SIGUSR1.

>>>SignalHandler::setSigUsr2 (void)
Set the signal of the receiver's handler to SIGUSR2.

>>>SignalHandler::signalProcessID (int processid)
Send the signal sigNo of the receiver to process processid.

>>>SignalHandler::sigName (Integer signal_number)
Return a String with the name of the signal whose
number is given as the argument.

>>>SignalHandler::sigNum (String signal_name)
Return an Integer with the value of the signal whose
name is given as the argument.

>>>SignalHandler::waitStatus (Integer child_pid, Integerchild_return_val, Integer child_signal, Integer errno)
Checks for a change in the status of the child process given by
child_pid.

The return value is an Integer with the value 0, which
indicates that the child process has not changed status, an Integer
equal to child_pid, or -1.

If the return value is equal to child_pid, then the processes'
return code is returned in child_return_val if the process exited
normally.  If the child process was terminated by an uncaught signal,
the signal's number is returned in child_signal.

If the return value is -1, the system errno is returned in
errno, which indicates an error when the parent process called
waitStatus.

Here is an example.

---------------------------------------------------------
  
  SignalHandler new s;
  Integer new r, childProcessID, child_retval, child_sig,
          child_errno;
  
   ... do stuff ...
  
   r = s waitStatus childProcessID,
  	child_retval, child_sig, child_errno;
  
   if (r == childProcessID) {
      if (child_sig) {
         printf ("Child received signal %s - exiting.\n",
  		  s sigName child_sig);
  	  exit (1);
      }
   }
  
   ... do more stuff ...
  
   exit (0);
   
---------------------------------------------------------




>>>Magnitude::! (void)
When used as a prefix operator, overloads C's '!' operator in 
expressions that contain objects.  

>>>Magnitude::* (void)
When used as a prefix operator, overloads C's '*' dereference
operator and returns the first element of an int, @code{long
int,} long long int, or double array as an Integer,
LongInteger, or Float object.

>>>Magnitude::- (void)
Overloads the unary '-' prefix operator.  Returns the 
negated value of an Integer, LongInteger, or Float,
receivers.

>>>Magnitude::asCharacter (void)
Return an object with the receiver's value as a Character object.

>>>Magnitude::asFloat (void)
Return the value of an Integer or LongInteger receiver
as a Float object.  If the receiver is a Float object,
returns the receiver.  For all other classes, prints a warning
and returns 0.0f.

>>>Magnitude::asInteger (void)
Return an object with the receiver's value as an Integer object.

>>>Magnitude::asLongInteger (void)
Return an object with the receiver's value as a LongInteger object.



>>>Character::! (void)
Return a character value of true if the receiver evaluates
to zero, false otherwise.

>>>Character::!= (char character)
Returns true if the receiver is not equal to character.

>>>Character::& (char character)
Returns a bitwise AND of the receiver and the argument.

>>>Character::&& (char character)
Returns TRUE if both operands are TRUE, FALSE otherwise.

>>>Character::* (char c)
Multiply the receiver and the operand.  The result is a Character
object. 

>>>Character::*= (char c)
Multiply the receiver by the operand, and return the receiver.

>>>Character::+ (char c)
Add the receiver and the operand.  The result is a Character
object. 

>>>Character::++ (void)
The prefix and postfix increment operators for Character objects.

>>>Character::+= (char c)
Add the operand to the receiver and the operand and return the
receiver.

>>>Character::- (char c)
Subtract the receiver and the operand.  The result is a Character
object. 

>>>Character::-- (void)
The prefix and postfix decrement operators for Character
objects.

>>>Character::-= (char c)
Subtract the operand from the receiver and return the receiver.

>>>Character::/ (char c)
Divide the receiver and the operand.  The result is a Character
object. 

>>>Character::/= (char c)
Divide the receiver by the operand and return the receiver.

>>>Character::< (char character)
Returns TRUE if the receiver is less than the operand, FALSE
otherwise.

>>>Character::<< (int i)
Shift the receiver left by the number of bits in the operand, which
must be an Integer.

>>>Character::<= (char character)
Returns TRUE if the receiver is less than or equal to the operand,
FALSE otherwise.

>>>Character::= (char character)
Set the value of the receiver object to character.

>>>Character::> (char character)
Returns TRUE if the receiver is greater than the operand, FALSE
otherwise.

>>>Character::>> (int i)
Shift the receiver right by the number of bits in the operand, which
must be an Integer.

>>>Character::>= (char character)
Returns TRUE if the receiver is greater than or equal to the operand,
FALSE otherwise.

>>>Character::== (char character)
Returns true if the receiver is equal to character.

>>>Character::^ (char character)
Returns a bitwise XOR of the receiver and the argument.

Returns a Character object that is the bitwise
complement of the receiver.  This method simply
calls bitComp, below.

>>>Character::bitComp (void)
Perform a bitwise complement of the receiver.

>>>Character::invert (void)
Returns TRUE if the receiver evaluates to FALSE,
FALSE if the receiver evaluates to TRUE.

>>>Character::isASCII (void)
Returns TRUE if the receiver is a 7-bit ASCII character '0-127',
FALSE otherwise.

>>>Character::isAlNum (void)
Returns TRUE if the receiver is an alphanumeric character '0-9',
'A-Z', 'a-z', FALSE otherwise.

>>>Character::isAlpha (void)
Returns TRUE if the receiver is an alphabetic character
'A-Z', 'a-z', FALSE otherwise.

>>>Character::isBlank (void)
Returns TRUE if the receiver is a space ' ' or horizontal
tab '\t' character, FALSE otherwise.

>>>Character::isCntrl (void)
Returns TRUE if the receiver is a control character, FALSE otherwise.

>>>Character::isDigit (void)
Returns TRUE if the receiver is a character '0-9', FALSE otherwise.

>>>Character::isGraph(void) (void)
Returns TRUE if the receiver is any character except a space, FALSE
otherwise.

>>>Character::isLower (void)
Returns TRUE if the receiver is a lower case character, FALSE
otherwise.

>>>Character::isPrint (void)
Returns TRUE if the receiver is a printable character, FALSE
otherwise.

>>>Character::isPunct (void)
Returns TRUE if the receiver is a printable non-alphanumeric
character, FALSE otherwise. 

>>>Character::isSpace (void)
Returns TRUE if the receiver is a space, horizontal tab (\t),
newline (\n), vertical tab (\v), form feed (\f),
or carriage return (\r) character, FALSE otherwise.

>>>Character::isUpper (void)
Returns TRUE if the receiver is an upper case letter, FALSE otherwise.

>>>Character::isXDigit (void)
Returns TRUE if the receiver is a character '0-9',
'a-f', or 'A-F', FALSE otherwise.

>>>Character::toLower (void)
If the receiver is an upper case letter, returns the lower case
version. 

>>>Character::toUpper (void)
If the receiver is a lower case letter, returns the upper case 
version.

>>>Character::| (char character)
Returns a bitwise OR of the receiver and the argument.

>>>Character::|| (char character)
Returns TRUE if either operand is TRUE, FALSE otherwise.




>>>String::* (void)
When used as a prefix operator, overloads C's '*' dereference
operator and returns the first element of the receiver, a
Character object.

>>>String::= (char *s)
Set the value of the receiver object to s.

>>>String::== (char *s)
Return TRUE if s and the receiver are identical, 
FALSE otherwise.

>>>String::=~ (char *pattern)
Returns a Boolean value of true if the receiver contains
the regular expression pattern, false otherwise.


>>>String::!~ (char *pattern)
Returns a Boolean value of false if the receiver
does not contain the argument, pattern, which may
contain regular expression metacharacters.  


>>>String::!= (char *s)
Return FALSE if s and the receiver are not identical, 
TRUE otherwise.

>>>String::!= (char *s)
Return FALSE if s and the receiver are not identical, 
TRUE otherwise.

>>>String::+ (String s)
>>>String::+ (Integer i)
If the argument is a String, concatenate the receiver and
s and return the new String.  If the argument is an
Integer, return a reference to the receiver plus i.

>>>String::++ (void)
Increment the value of the receiver as a char *.  This method
uses __ctalkIncStringRef () to handle the pointer math.  

In other words, this method effectively sets the receiver
String's value from, for example, 'Hello, world!' to
'ello, world!'.  If the receiver is incremented to the end of its
contents, then its value is NULL.

>>>String::+= (String s)
>>>String::+= (Integer i)
If the argument is an Integer, increment the reference to the
receiver by that amount.  If the argument is a String or any
other class, concatenate the argument to the receiver and return the
receiver, formatting it as a string first if necessary.

>>>String::- (Integer i)
Return a reference to the receiver String minus i.
If the reference is before the start of the string, return NULL.
That means the method is only effective after a call to ++
or a similar method.

---------------------------------------------------------
  
  String new str;
  
  str = "Hello, world!";
  
  str += 1;
  
  printf ("%s\n", str);    /* Prints, "ello, world!" */
  
  --str;
  
  printf ("%s\n", str);    /* Prints, "Hello, world!" */
  
  
---------------------------------------------------------
>>>String::-- (void)
Decrement the value of the receiver as a char *.  The effect is
the converse of ++, above.  The method doesn't decrement the
reference so that it points before the beginning of the String
object's contents.  That means, like - above, the method only
returns a pointer to somewhere in the receiver's value after a
previous call to ++ or a similar method.  For example,

---------------------------------------------------------
  
  String new str;
  
  str = "Hello, world!";
  
  ++str;
  
  printf ("%s\n", str);    /* Prints, "ello, world!" */
  
  --str;
  
  printf ("%s\n", str);    /* Prints, "Hello, world!" */
  
  
---------------------------------------------------------

>>>String::-= (Integer i)
If the argument is an Integer, decrement the reference
to the receiver's value by the amount given as the argument, 
an Integer.  Like the other methods that decrement 
the reference to the receiver's value, the program must first
have incremented it further than the start of the string.

>>>String::asInteger (void)
Return an Integer object with the value of the receiver.

>>>String::asList (List newList)
Store each character of the receiver String as
Character object members of newList.

>>>String::at (int index)
Return the character at index.  The first character of the 
string is at index 0.  If index is greater than the length
of the string, return 'NULL'.

>>>String::atPut (int n, char c)
Replace the n'th character of the receiver with c.  
Has no effect and returns NULL if n is greater than the length
of the receiver.  

The atPut method interprets the following character sequences
(with their ASCII values)

---------------------------------------------------------
  
  Sequence   ASCII Value
  \0         0
  \a         7
  \b         7
  \n         10
  \e         27
  \f         10
  \r         13
  \t         9
  \v         11
  
---------------------------------------------------------

The '\e' escape sequence is an extension to the C language
standard.

The method returns the receiver (with the new value) if successful.

You should note that the method does not do any conversion of the argument;
that is, if c isn't a Character object, then the results
are probably not going to be what you want.  For example, if you try
to store an Integer in a String, like this:

---------------------------------------------------------
  
  myInt = 1;
  
  myString atPut 0, myInt + '0';
  
---------------------------------------------------------

The results aren't going to be what you want; adding ASCII ''0''
doesn't convert myInt to a Character object.  You
still need to use the asCharacter method from Magnitude
class to create a Character object, as in this example.

---------------------------------------------------------
  
  myInt = 1;
  
  myString atPut 0, (myInt + '0') asCharacter;
  
---------------------------------------------------------

The parentheses in the second argument are necessary; otherwise,
asCharacter would use ''0'' as its receiver because
asCharacter, which is a method message, has a higher precedence
than '+'.  Instead, asCharacter's receiver should be the
value of 'myInt + '0'', so we enclose the first part expression
in parentheses so it gets evaluated first.

>>>String::callStackTrace (void)
Print a call stack trace.

>>>String::charPos (char c)
Return an Integer with the position of c in the receiver.
Returns an Integer between 0 (the first character) and the
receiver's length, minus one (the last character).  If the receiver
does not contain c, returns -1.

>>>String::charPosR (char c)
Return an Integer with the position of the last occurence of 
c in the receiver. Returns an Integer between 0 
(the first character) and the receiver's length, minus one 
(the last character).  If the receiver does not contain c, 
returns -1.

>>>String::chomp (void)
Removes a trailing newline character ('\n') if the receiver
contains one.  Named after Perl's very useful string trimming function.

>>>String::consoleReadLine (String promptStr)
Print the promptStr on the terminal and wait for the user to
enter a line of text.  If Ctalk is built with the GNU readline
libraries, adds readline's standard line editing and command history
facilities.  In that case, Ctalk also defines the
HAVE_GNU_READLINE preprocessor definition to '1'.  You can
build Ctalk with or without readline; see the options to
./configure for further information.

Here is a sample program that shows how to use consoleReadLine.
---------------------------------------------------------
  int main (int argc, char **argv) @
    String new s;
    String new promptStr;
  
    if (argc > 1)
      promptStr = argv[1];
    else
      promptStr = "Prompt ";
  
    printf ("Readline test.  Type ^C or, \"quit,\" to exit.\n");
  #if HAVE_GNU_READLINE
    printf ("Ctalk built with GNU Readline Support.\n");
  #else
    printf ("Ctalk built without GNU Readline Support.\n");
  #endif
    while (1) @
      s consoleReadLine promptStr;
      printf ("You typed (or recalled), \"%s.\"\n", s);
      /*
       *  Matches both, "quit," and, "quit\n."
       */
      if (s match "quit")
        break;
    }
  }
---------------------------------------------------------

>>>String::contains (String pattern)
>>>String::contains (String pattern, Integer starting_offset)
Returns a Boolean value of True if the receiver string contains
an exact match of the text in pattern, False otherwise.

With a second argument n, an Integer, the method begins its
search from the n'th character in the receiver string.

>>>String::envVarExists (char *envVarName)
Test for the presence of an environment variable.  Return
TRUE if the variable exists, FALSE otherwise.

>>>String::getEnv (char *envVarName)
Return the value of environment variable envVarName as
the value of the receiver, or (null).  Note that this
method generates an internal exception of the environment
variable does not exist.  To test for the presence of an
environment variable without generation an exception, see
envVarExists, above.

>>>String::getRS (void)
Returns a Character with the current record separator.

The record separator determines whether the regular expression
metacharacters '^' and '$' recognize line endings.
The default value of the record separator is a newline '\n'
character, which means that a '^' character will match
an expression at the start of a string, or starting at
the beginning of a text line.  Likewise, a '$' metacharacter
matches both the end of a line and the end of the string.

To match only at the beginning and end of the string, set
the record separator to a NUL character ('\0').


>>>String::isXLFD (void)
Returns a Boolean value of True if the receiver is
a XLFD font descriptor, False otherwise.  For more information
about font selection, refer to the X11Font class 
and the X11FreeTypeFont class 

>>>String::length (void)
Return an object of class Integer with the length of the 
receiver in characters.

>>>String::map (OBJECT *(*method)())
Execute method, an instance method of class String, for
each character of the receiver object.  For example,
---------------------------------------------------------
  
  String instanceMethod printSpaceChar (void) {
    printf (" %c", self);  /* Here, for each call to the printSpaceChar
                               method, "self" is each of myString's
                               successive characters. */
  }
  
  int main () {
  
    String new myString;
  
    myString = "Hello, world!";
  
    myString map printSpaceChar;
  
    printf ("\n");
  }
  
---------------------------------------------------------

The argument to map can also be a code block:

---------------------------------------------------------
  
  int main () {
  
    String new myString;
  
    myString = "Hello, world!";
  
    myString map {
      printf (" %c", self);
    }
  
    printf ("\n");
  }
  
---------------------------------------------------------


>>>String::match (char *pattern)
Returns TRUE if pattern matches the receiver
String regardless of case, false otherwise.  Both
match and matchCase, below, are being superceded
by matchRegex and quickSearch, also below.

>>>String::matchAt (Integer idx)
Returns the text of the idx'th parenthesized match
resulting from a previous call to matchRegex, =~,
or !~. 

>>>String::matchCase (char *pattern)
Returns TRUE if pattern matches the receiver
case- sensitively, false otherwise.  Like match,
above, matchCase is being superceded by matchRegex
and quickSearch, below.

>>>String::matchIndexAt (Integer idx)
Returns the character position in the receiver String of the
idx'th parenthesized match resulting from a previous call to
matchRegex, =~, or !~. 

>>>String::matchLength (void)
Returns the length of a regular expression match from the
previous call to the matchRegex method, below.

>>>String::matchRegex (String pattern, Array offsets)
Searches the receiver, a String object, for all occurrences of
pattern.  The matchRegex method places the positions
of the matches in the offsets array, and returns an
Integer that contains the number of matches. @xref{Pattern
Matching}.

The quickSearch method, below, matches exact text
only, but it uses a much faster search algorithm.

>>>String::nMatches (void)
Returns an Integer with the number matches from
the last call to the matchRegex method.

>>>String::printMatchToks (Integer yesNo)
If the argument is non-zero, print the tokens of regular expression
patterns and the matching text after each regular expression match.
This can be useful when debugging regular expressions. 

>>>String::printOn (char *fmt, ...)
Format and print the method's arguments to the receiver.

>>>String::quickSearch (String pattern, Array offsets)
Searches the receiver, a String object, for all occurrences of
pattern.  The quickSearch method places the positions
of the matches in the offsets array, and returns an
Integer that contains the number of matches.

Unlike matchRegex, above, quickSearch matches exact
text only, but it uses a much faster search algorithm.

>>>String::readFormat (char *fmt, ...)
Scan the receiver into the arguments, using fmt.  

>>>String::search (String pattern, Array offsets)
This method is a synonym for matchRegex, above, and is here for
backward compatibility.

>>>String::setRS (char record_separator_char)
Sets the current application's record separator character, which
determines how regular expression metacharacters match line endings,
among other uses.  

>>>String::split (char delimiter, char ** resultArray)
Split the receiver at each occurrence of delimiter, and save the
result in resultArray.  The delimiter argument can be
either a Character object or a String object.  If
delimiter is a String, it uses Ctalk's pattern matching
library to match the delimiter string.  

However, the pattern matching library only records the length of the
last match, so if you use a pattern like '" *"' then the results
may be inaccurate if all of the delimiters are not the same length.

>>>String::subString (int index, int length)
Return the substring of the receiver of length characters
beginning at index.  String indexes start at 0.  If index
+ length is greater than the length of the receiver, return 
the substring from index to the end of the receiver.

>>>String::sysErrnoStr (void)
Sets the receiver's value to the text message of the last
system error (the value of errno(3)).

>>>String::tokenize (List tokens)
Splits the receiver String at each whitespace character
or characters (spaces, horizontal and vertical tabs, or newlines)
and pushes each non-whitespace set of characters (words, numbers,
and miscellaneous punctuation) onto the List given as the
argument.  The method uses ispunct(3) to separate punctuation,
except for '_' characters, which are used in labels.

Note that this method can generate lists with hundreds or even
thousands of tokens, so you need to take care with large (or
even medium sized) input Strings as receivers.

>>>String::tokenizeLine (List tokens)
Similar to tokenize, above.  This method also treats newline
characters as tokens, which makes it easier to parse input that relies
on newlines (for example, C++ style comments, preprocessor directives,
and some types of text files).

>>>String::vPrintOn (Stringcalling_methods_fmt_arg)
This function formats the variable arguments of its calling method
on the receiver String object.

The argument is the format argument of the calling method.  When
vPrintOn is called, it uses the argument as the start of the
caller's variable argument list.

Here is an example of vPrintOn's use.

---------------------------------------------------------
  
  Object instanceMethod myPrint (String fmt, ...) {
    String new s;
    s vPrintOn fmt;
    return s;
  }
  
  int main () {
    Object new obj;
    Integer new i;
    String new str;
  
    i = 5;
  
    str = obj myPrint "Hello, world no. %d", i;
  
    printf ("%s\n", str);
  }
  
---------------------------------------------------------

>>>String::writeFormat (char *fmt,...)
Write the formatted arguments using fmt to the receiver.
Note that Ctalk stores scalar types as formatted strings.


@iftex
@subsection String Searching and Pattern Matching
@end iftex
@ifnottex
@subsubheading String Searching and Pattern Matching
@end ifnottex

String class defines a number of methods for searching and
matching String objects.  The matchRegex method
recognizes some basic metacharacters to provide regular expression
search capabilities.  The quickSearch method searches
String objects for exact text patterns, but it uses a much
faster search algorithm.

The operators, =~ and !~ return true or false depending on
whether the receiver contains the pattern given as the argument.  If
the argument contains metacharacters, then Ctalk conducts a regular
expression search; otherwise, it tries to match (or not match, in the
case of !~) the receiver and the pattern exactly.

If you want more thorough information about the search, the
matchRegex and quickSearch methods allow an additional
argument after the text pattern: an Array object that the
methods use to return the character positions of the matches within
the receiver.  After the method is finished searching, the second
argument contains the position of the first character wherever the text
pattern matched text in the receiver.  The last offset is '-1',
indicating that there are no further matches.  The methods also return
an Integer object that contains the number of matches.

Here is an example from LibrarySearch class that contains
the additional 'offsets' argument.

---------------------------------------------------------
  
  if ((inputLine match KEYPAT) && 
         (inputLine matchRegex (pattern, offsets) != 0)) {
  
  ...
  
  }
  
---------------------------------------------------------

Searches can provide even more information than this, however.
Pattern strings may contain backreferences, which save the text
and position of any of the receiver string's matched text that the
program needs.  The sections just below describe backreferences in
detail.

All of these methods (except quickSearch) recognize a few
regular expression metacharacters.  They are:

>>>String::.
Matches any single character.
>>>String::^
Matches text at the beginning of the receiver
String's text.
>>>String::$
Matches text at the end of the receiver String's text, or
the end of a line (that is, the character before a '\n' or '\r'
newline character).
>>>String::*
Matches zero or more occurrences of the character or expression it follows.
>>>String::+
Matches one or more occurences of the character or expression it follows.

>>>String::?
Matches zero or one occurrence of the character or expression it follows.

>>>String::\
Escapes the next character so it is interpreted literally; e.g., the
sequence '\*' is interpreted as a literal asterisk.  Because
Ctalk's lexical analysis also performs the same task, so if you want a
backslash to appear in a pattern, you need to type, '\\', for
example,

---------------------------------------------------------
  
  myPat = "\\*";   /* The '\\' tells Ctalk's lexer that we really
                      want a '\' to appear in the pattern string,
                      so it will still be there when we use myPat
                      as a regular expression. */
  
---------------------------------------------------------

However, Ctalk also recognizes patterns, which only need to be
evaluated by the regular expression parser.  Patterns do not get
checked immediately for things like for balanced quotes and ASCII
escape sequences; instead, they get evaluated by the regular expression
parser when the program actually tries to perform some pattern
matching.  Otherwise, patterns are identical to Strings.
Expressed as a pattern, myPat in the example above would look
like this.

---------------------------------------------------------
  
  myPat = /\*/;
  
---------------------------------------------------------

Pattern strings are described in their own section, below.


>>>String::(
>>>String::)
Begin and end a match reference (i.e., a
backreference). Matched text between '(' and ')' is
saved, along with its position in the receiver String, and can
be retrieved with subsequent calls to the matchAt and
matchIndexAt methods.  The match information is saved until the
program performs another pattern match.

>>>String::\W
>>>String::\d
>>>String::\p
>>>String::\w
>>>String::\l
In patterns, these escape sequences match characters of different
types.  The escape sequences have the following meanings.

---------------------------------------------------------
  
  Character Class      Matches
  ---------------      ------
  \W                   'Word' Characters (A-Z, a-z)
  \d                   Decimal Digits (0-9)
  \w                   White Space (space, \t, \n, \f, \v)
  \p                   Punctuation (Any other character.)
  \l                   'Label' Characters (A-Z, a-z, 0-9, and _)
  \x                   Hexadecimal Digits (0-9, a-f, A-F, x, and X)
  
---------------------------------------------------------

The following program contains a pattern that looks for
alphabetic characters, punctuation, and whitespace.

---------------------------------------------------------
  
  int main (int argc, char **argv) {
    String new str;
  
    str = "Hello, world!";
  
    if (str =~ /e(\W*\p\w*\W)/) {
      printf ("match - %s\n", str matchAt 0);
    }
  }
  
---------------------------------------------------------

When run, the expression,

---------------------------------------------------------
  
  str =~ /e(\W*\p\w*\W)/
  
---------------------------------------------------------

Produces the following output.

---------------------------------------------------------
  
  match - llo, w
  
---------------------------------------------------------

>>>String::|
Matches either of the expressions on each side of the '|'.
The expressions may be either a character expression, or a
set of characters enclosed in parentheses.  Here are some examples
of alternate patterns.

---------------------------------------------------------
  a|b
  a*|b*
  a+|b+
  \W+|\d+
  (ab)|(cd)
  
---------------------------------------------------------

When matching alternate expressions, using '*' in the
expressions can produce unexpected results because a '*'
can provide a zero-length match, and the '|' metacharacter
is most useful when there is some text to be matched.

If one or both expressions are enclosed in parentheses, then
the expression that matches is treated as a backreference, and
the program can retrieve the match information with the matchAt
and matchIndexAt methods.


The following example shows how to use some of the matching featues in
an actual program.  This program saves the first non-label character
(either a space or parenthesis) of a function declaration, and its
position, so we can retrieve the function name and display it
separately.

---------------------------------------------------------
  
  int main (argc, argv) {
    String new text, pattern, fn_name;
    List new fn_list;
  
    fn_list = "strlen ()", "strcat(char *)", "strncpy (char *)",
      "stat (char *, struct stat *)";
  
    /* Match the first non-label character: either a space or a
       parenthesis.  The double backslashes cause the content of
       'pattern' (after the normal lexical analysis for the string) to
       be,
       
         "( *)\("
  
       So the regular expression parser can check for a backslashed
       opening parenthesis (i.e., a literal '(', not another
       backreference delimiter).
    */
  
    pattern = "( *)\\(";
  
    fn_list map {
      if (self =~ pattern) {
        printf ("Matched text: \"%s\" at index: %d\n",
  	      self matchAt 0, self matchIndexAt 0);
        fn_name = self subString 0, self matchIndexAt 0;
        printf ("Function name: %s\n", fn_name);
      }
    }
  
    return 0;
  }
  
---------------------------------------------------------

When run, the program should produce results like this.

---------------------------------------------------------
  
  Matched text: " " at index: 6
  Function name: strlen
  Matched text: "" at index: 6
  Function name: strcat
  Matched text: " " at index: 7
  Function name: strncpy
  Matched text: " " at index: 4
  Function name: stat
  
---------------------------------------------------------

Note that the first backreference is numbered '0', in the
expression 'self matchAt 0'.  If there were another set of
(unescaped) parentheses in pattern, then its text would be
refered to as 'self matchAt 1'.

You should also note that the second function match saved an empty
string.  That's because the text that the backreferenced pattern
referred to resulted in a zero-length match. That's because '*'
metacharacters can refer to zero or more occurrences of the
character that precedes it.

The program could also use the charPos method to look for the
' ' and/or '(' characters, but using a regular expression
gives us information about which non-label character appears first
more efficiently.

Here's another example.  The pattern contains only one set of
parentheses, but Ctalk saves a match reference every time the pattern
matches characters in the target string.

---------------------------------------------------------
  
  int main () {
    String new string, pattern;
    Array new offsets;
    Integer new nMatches, i;
  
    pattern = "(l*o)";
    string = "Hello, world! Hello, world, Hello, world!";
    
    nMatches = string matchRegex pattern, offsets;
  
    printf ("nMatches: %d\n", nMatches);
    offsets map {
      printf ("%d\n", self);
    }
    for (i = 0; i < nMatches; ++i) {
      printf ("%s\n", string matchAt i);
    }
  }
  
---------------------------------------------------------

When run, the program produces output like this.

---------------------------------------------------------
  
  nMatches: 6
  2
  8
  16
  22
  30
  36
  -1
  llo
  o
  llo
  o
  llo
  o
  
---------------------------------------------------------

The character classes match anywhere they find text in a
target string, including control characters like '\n'
and '\f', regardless of the record separator character.
For a brief example, refer to the section, @cite{The Record
Separator Character,} below.

This example matches one of two patterns joined by a '|'
metacharacter.

---------------------------------------------------------
  
  int main () {
    String new s, pat;
    Array new matches;
    Integer new n_matches, n_th_match;
  
    pat = "-(mo)|(ho)use";
  
    s = "-mouse-house-";
  
    n_matches = s matchRegex pat, matches;
  
    for (n_th_match = 0; n_th_match < n_matches; ++n_th_match) {
      printf ("Match %d. Matched %s at character index %ld.\n",
  	    n_th_match, s matchAt n_th_match, s matchIndexAt n_th_match);
    }
  
    matches delete;
  
  }
  
---------------------------------------------------------

When run, the program should produce output like this.

---------------------------------------------------------
  
  Match 0. Matched mo at character index 0.
  Match 1. Matched ho at character index 6.
  
---------------------------------------------------------

You should note that if a pattern in a backreference results in a zero
length match, then that backreference contains a zero length
string. While not incorrect, it can produce confusing results when
examining matched text.  The following program shows one way to
indicate a zero-length backreference.  It prints the string '(null)'
whenever a backreference contains a zero-length string.

---------------------------------------------------------
  
  int main () {
    String new s;
    String new pat;
    Integer new n_matches;
    Array new offsets;
    Integer new i;
  
    s = "1.mobile 2mobile mobile";
    pat = "(\\d\\p)?m";
    
    n_matches = s matchRegex pat, offsets;
    
    for (i = 0; i < n_matches; ++i) {
      printf ("%Ld\n", offsets at i);
    }
  
    for (i = 0; i < n_matches; ++i) {
      if ((s matchAt i) length == 0) {
        printf ("%d: %s\n", s matchIndexAt i, "(null)");
      } else {
        printf ("%d: %s\n", s matchIndexAt i, s matchAt i);
      }
    }
  }
  
---------------------------------------------------------

When run, the program should produce output that looks like this.

---------------------------------------------------------
  
  0
  10
  17
  0: 1.
  17: (null)
  22: (null)
  
---------------------------------------------------------

@iftex
@subsubsection Pattern Strings
@end iftex
@ifnottex
@subsubheading Pattern Strings
@end ifnottex

When writing a regular expression, it's necessary to take into account
all of the processing that String objects encounter when they
are evaluated, before they reach the Ctalk library's regular
expression parser.  To help facilitate lexical analysis and parsing,
Ctalk also provides pattern strings, which allow Ctalk to
defer the evaluation of a pattern until the regular expression parser
actually performs the text matching.

Ctalk also provides operators that provide shorthand methods to match
patterns with text, the =~ and !~ operators.

Pattern constants at this time may only follow the =~ and !~
operators, but you can use the matchAt and matchIndexAt,
and nMatches methods to retrieve the match information.  You
must, as with Strings that are used as patterns, enclose the
pattern in '(' and ')' metacharacters in order to create
a backreference.

Here is a simple string matching program that matches text against
a pattern constant.

---------------------------------------------------------
  
  int main () {
  
    String new s;
    Integer new n_offsets;
    Integer new i;
    
    s = "Hello?";
  
    if (s =~ /(o\?)/) {
      printf ("match\n");
      i = 0;
      n_offsets = s nMatches;
      while (i < n_offsets) {
        printf ("%d: %s\n", s matchIndexAt i, s matchAt i);
        ++i;
      }
    }
  }
  
---------------------------------------------------------

The most obvious example of how a pattern provides an advantage for
text matching is when writing backslash escapes.  To make a backslash
appear in a pattern string, you need to write at least two backslashes
in order for a backslash to appear when it's needed to escape the
following character.  If you want to match an escaped backslash, then
you need to write at least four backslashes.

---------------------------------------------------------
  
  String         Pattern
  "\\*"          /\*/        # Matches a literal '*'.
  "\\\\*"        /\\*/       # Matches the expression '\*'.
  
---------------------------------------------------------

To create a pattern, you delimit the characters of the pattern with
slashes ('//') instead of double quotes.  Other delimiters can
signify patterns also if the pattern starts with a 'm' character,
followed by the delimiter character, which must be non-alphanumeric.

---------------------------------------------------------
  
  String         Pattern     Alternate Pattern
  "\\*"          /\*/        m|\*|
  "\\\\*"        /\\*/       m|\\*|
  
---------------------------------------------------------

There is no single rule that governs how often String objects
are evaluated when a program runs.  So writing patterns helps take
some of the work out of testing an application's pattern matching
routines.

@iftex
@subsubsection Debugging Pattern Matches
@end iftex
@ifnottex
@subsubheading Debugging Pattern Matches
@end ifnottex

Ctalk allows you to view the parsed pattern tokens, and the
text that each token matches.  Token printing is enabled using the
printMatchToks method, like this.

---------------------------------------------------------
  
  myString printMatchToks TRUE;
  
---------------------------------------------------------

When token printing is enabled, then Ctalk's pattern matching routines
print the tokens of the pattern and the text that each token matches
after every pattern match attempt.

If we have a program like the following:

---------------------------------------------------------
  
  int main () {
  
    String new s;
  
    s printMatchToks TRUE;
  
    s = "192.168.0.1";
  
    if (s =~ /\d+\.(\d+)\.\d+\.\d+/) {
      printf ("match!\n");
    }
  
  }
  
---------------------------------------------------------

Then, when this program is run with token printing enabled, the
output should look similar to this.

---------------------------------------------------------
  
  joeuser@@myhost:~$ ./mypatprogram 
  PATTERN: /\d+\.(\d+)\.\d+\.\d+/         TEXT: "192.168.0.1"
  TOK: d+         (character class)               MATCH: "192"
  TOK: .          (literal character)             MATCH: "."
  TOK: (          (backreference start)           MATCH: ""
  TOK: d+         (character class)               MATCH: "168"
  TOK: )          (backreference end)             MATCH: ""
  TOK: .          (literal character)             MATCH: "."
  TOK: d+         (character class)               MATCH: "0"
  TOK: .          (literal character)             MATCH: "."
  TOK: d+         (character class)               MATCH: "1"
  match!
  joeuser@@myhost:~$ 
  
---------------------------------------------------------

The processed token text is followed by any attributes that the
regular expression parser finds (for example, then a pattern like
'\d+' becomes the token 'd+' with the attribute of a
character class identifier, or the '(' and ')' characters'
backreference attributes).  Then, finally, the library prints the text
that matches each token.

Successful matches have text matched by each token in the
pattern (except for zero-length metacharacters like '(',
')', '^', or '$').

Unsuccessful matches, however, may display text that matches where you
don't expect it.  That's because the regular expression parser scans
along the entire length of the text, trying to match the first pattern
token, then the second pattern token, and so on.

Although this doesn't always pinpoint the exact place that a match
first failed, it can provide a roadmap to help build a complex pattern
from simpler, perhaps single-metachar patterns, which shows what the
regular expression parser is doing internally.

@iftex
@subsubsection The Record Separator Character
@end iftex
@ifnottex
@subsubheading The Record Separator Character
@end ifnottex

Ctalk uses a record separator character to determine how the
metacharacters '^' and '$' match line endings, among other
uses.

The default record separator character is a newline ('\n').
In this case a '^' metacharacter in an expression matches
the beginning of a string as well as the character(s) immediately
following a newline.  Similarly, a '$' metacharacter anchors
a match to the characters at the end of a line and at the end
of a string.

Setting the record separator character to NUL ('\0') causes
'^' and '$' to match only the beginning and the end
of a string.

Here is an example that prints the string indexes of matches with the
default newline record separator and with a NUL record separator
character.  

When the record separator is ''\n'', the '$' metacharacter
in our pattern matches the text immediately before a '\n'
character, as well as the text at the end of the string.

---------------------------------------------------------
  
  int main () {
  
    String new s;
    Integer new n_indexes;
    Array new match_indexes;
    String new pattern;
    
    printf ("\tMatch Indexes\n");
  
    /* Begin with the default record separator ('\n'). */
  
    s = "Hello, world!\nHello, wo\nHello, wo";
    pattern = "wo$";
    n_indexes = s matchRegex pattern, match_indexes;
  
    printf ("With newline record separator:\n");
    match_indexes map {
      printf ("%d\n", self);
    }
  
    s setRS '\0';   /* Set the record separator to NUL ('\0'). */
  
    match_indexes delete; /* Remember to start with an empty Array again. */
  
    n_indexes = s matchRegex pattern, match_indexes;
  
    printf ("With NUL record separator:\n");
    match_indexes map {
      printf ("%d\n", self);
    }
  }
  
---------------------------------------------------------

When run, the program should produce output like this.

---------------------------------------------------------
  
          Match Indexes
  With newline record separator:
  21
  31
  -1
  With NUL record separator:
  31
  -1
  
---------------------------------------------------------

Likewise, a '^' metacharacter matches text immediately after
the '\n' record separator, or at the beginning of a string.

It's also possible, though, to match newlines (and other ASCII escape
characters) in patterns, either with a character class match, or by
adding the escape sequence to the pattern. To do that, the program
should use a double backslash with the ASCII escape sequence, as with
the newline escape sequence in this example.

---------------------------------------------------------
  
  int main () {
    String new s;
  
    s = "Hello,\nworld!";
  
    if (s =~ /(\W\p\\n)/)
      printf ("%s\n", s matchAt 0);
    
  }
  
---------------------------------------------------------


>>>Float::&& (double d)
Return an Integer that evaluates to TRUE if both operands are
TRUE, FALSE otherwise.

>>>Float::= (double d)
Set the value of the receiver object to d.

>>>Float::+ (double d)
Add d to the receiver.

>>>Float::+= (double d)
Add d to the receiver's value.  Set the receiver to
the new value, and return the receiver.

>>>Float::- (void)
>>>Float::- (double d)
Subtract d from the receiver. When used as a prefix operator,
negate the receiver.

>>>Float::-= (double d)
Subtract d from the receiver's value.  Set the receiver to
the new value, and return the receiver.

>>>Float::* (double d)
Multiply the receiver by d.

>>>Float::*= (double d)
Multiply d by the receiver's value.  Set the receiver to
the new value, and return the receiver.

>>>Float::* (double d)
Divide the receiver by d.

>>>Float::/= (double d)
Divide d by the receiver's value.  Set the receiver to
the new value, and return the receiver.

>>>Float::< (double d)
Return an Integer that evaluates to TRUE if the receiver is
less than the argument, FALSE otherwise.

>>>Float::<= (double d)
Return an Integer that evaluates to TRUE if the receiver is
less than or equal to the argument, FALSE otherwise.

>>>Float::> (double d)
Return an Integer that evaluates to TRUE if the receiver is
greater than the argument, FALSE otherwise.

>>>Float::>= (double d)
Return an Integer that evaluates to TRUE if the receiver is
greater than or equal to the argument, FALSE otherwise.

>>>Float::asInteger (void)
Return the integer portion of the receiver.

>>>Float::|| (double d)
Return an Integer that evaluates to TRUE if either operand is
TRUE, FALSE otherwise.



>>>Integer::!= (int i)
Return TRUE if the receiver and the argument are not equal, FALSE
otherwise.

>>>Integer::& (int i)
As a binary operator, perform a bitwise and of the receiver
and the argument.  The Object class's & method
overloads C's unary ``address of'' prefix operator.  

>>>Integer::% (int i)
Return an Integer that is the modulus of the receiver and the
argument. 

>>>Integer::%= (int i)
Perform a modulus of the receiver and its argument,
and store the result in the receiver.  Returns  the
receiver.

>>>Integer::&& (int i)
Return TRUE if the receiver and the argument evaluate to TRUE.

>>>Integer::&= (Integer i)
Perform a bitwise and of the receiver and the argument, and assign
the result to the receiver.

>>>Integer::+ (int i)
Add i and the receiver, as in this example.

>>>Integer::++ (void)
Postfix and prefix increment operators for Integer objects.

>>>Integer::+= (int arg)
Add the value of arg to the receiver.

>>>Integer::- (int i)
Subtract i from the receiver.

>>>Integer::- (void)
When used as a unary minus prefix operator, negate the
expression.

>>>Integer::-- (void)
Postfix and prefix decrement operators for Integer objects.

>>>Integer::-= (Integer arg)
Subtract the value of arg from the receiver.

>>>Integer::* (int i)
Multiply the receiver by i.

>>>Integer::*= (int arg)
Multiply the receiver by arg.

>>>Integer::/ (int i)
Divide the receiver by i.

>>>Integer::/= (int arg)
Divide the receiver by arg.

>>>Integer::< (int i)
Return TRUE if the receiver is less than the argument, FALSE
otherwise.

>>>Integer::<< (int i)
Perform an arithmetic left shift on the receiver by the number of 
bits in the argument.

>>>Integer::<= (int i)
Return TRUE if the receiver is less than or equal to the argument,
FALSE otherwise.

>>>Integer::= (int i)
Set the value of the receiver object to i.  Also checks for
Symbol pointer contexts and other aliases.

---------------------------------------------------------
  intObject = 2;
  
  resultInt = intObject + intObject;
---------------------------------------------------------

>>>Integer::== (int i)
Return TRUE if the receiver and the argument are equal, FALSE
otherwise.

>>>Integer::> (int i)
Return TRUE if the receiver is greater than the argument, FALSE
otherwise.

>>>Integer::>= (int i)
Return TRUE if the receiver is greater than or equal to the argument,
FALSE otherwise.

>>>Integer::>> (int i)
Perform an arithmetic right shift on the receiver by the number of
bits in the argument.

>>>Integer::^ (int i)
Return the result of a bitwise xor of the receiver and
its argument.

>>>Integer::^= (int i)
Preform a bitwise xor of the receiver with its argument, and
assign the value to the receiver.  Returns the receiver.

>>>Integer::bitComp (int i)
Return the bitwise complement of the receiver.

>>>Integer::invert (void)
Return TRUE if the receiver evaluates to FALSE, FALSE if the receiver
evaluates to TRUE.

>>>Integer::| (int i)
Perform a bitwise or of the receiver and the argument.

>>>Integer::|= (Integer i)
Perform a bitwise or of the receiver and the argument, and
assign the result to the receiver.

>>>Integer::|| (int i)
Return TRUE if either the receiver or the argument, or both,
evaluate to TRUE.

>>>Integer::^ (int i)
Perform a bitwise exclusive or of the receiver and the argument.

Returns a String formatted as a decimal or hexadecimal integer.
The asString method is a synonym for asDecimalString.

>>>Integer::~ (void)
When used to overload C's '~' operator, is synonymous
with the bitComp method, above.



@c
@c

>>>CTime::cTime (void)
Returns a formatted String with the date and time of the 
receiver.

The return String of a cTime call is formatted as in
this example.
---------------------------------------------------------
  "Sun Jan 6 13:04:00 2008\n" 
---------------------------------------------------------

>>>CTime::gmTime (void)
Returns an Array with the values described above for the
current Greenwich Mean Time.

>>>CTime::haveDST (void)
Return an Integer that evaluates to True if the system provides
daylight savings time information, False otherwise.

>>>CTime::isAM (void)
Returns an Integer that evaluates to True or False depending
on whether the local time is a.m. or p.m.

>>>CTime::localTime (void)
Returns an Array with the values described above for the
current local time.

>>>CTime::timeZoneName (void)
Return a String with the name of the time zone provided by the
system.

>>>CTime::timeZoneOffset (void)
Return an Integer with the time zone offset in seconds from
GMT.  Not all systems provide this information.

>>>CTime::utcTime (void)
Return an Integer object containing the current UTC time.




>>>CalendarTime::cTimeString (void)
Returns a formatted string with the date and time given
by the receiver.  

The returned String is formatted similarly to the output of the
ctime(3) C function, except that the string does not include a
trailing newline.

Programs should call the utcTime method to get the current
UTC time, and then either the localTime or gmTime method to
convert the UTC time into calendar day and date information, before
calling this method.

>>>CalendarTime::dayName (void)
Returns a String with the three-letter abbreviation of
the current day: 'Sun', 'Mon', 'Tue', 'Wed',
'Thu', 'Fri', and 'Sat'.

>>>CalendarTime::gmTime (void)
Fills in the receiver's instance variables with the elements
of the UTC calendar time.

Programs should call the utcTime method to get the current
UTC time before calling this method.

>>>CalendarTime::isoTimeString (void)
Returns a formatted string with the date and time given by the
receiver. The returned String has the format of an ISO date and time
string.

Programs should call the utcTime method to get the current
UTC time, and then either the localTime or gmTime methods to
convert the UTC time into calendar day and date information, before
calling this method.

>>>CalendarTime::localTime (void)
Fills in the receiver's instance variables with the elements
of the local calendar time, as determined by the system's
time zone setting.

Programs should call the utcTime method to get the current
UTC time before calling this method.

>>>CalendarTime::monName (void)
Returns a String with the three-letter abbreviation
of the current time's month: 'Jan', 'Feb', 'Mar',
'Apr', 'May', 'Jun', 'Jul', 'Aug',
'Sep', 'Oct', 'Nov', and 'Dec'.

>>>CalendarTime::zoneInfo (void)
Fills in the receiver's timeZone, tzStd, tzDst,
gmtOff, and haveDst with information about the machine's
current time zone.




>>>LongInteger::!= (long long int l)
Return TRUE if the receiver is not equal to l.

>>>LongInteger::= (long long int l)
Set the value of the receiver to l.

>>>LongInteger::== (long long int l)
Return TRUE if the receiver is equal to l.

>>>LongInteger::+ (long long int l)
Add l to the the receiver.

>>>LongInteger::++ (void)
Implements both the C prefix and postfix increment operators for
LongInteger objects.  

>>>LongInteger::- (long long int l)
Subtract l from the receiver.

>>>LongInteger::- (void)
When used as a prefix operator, negate the argument.

>>>LongInteger::-- (void)
The C decrement operator, both prefix and postfix, for
LongInteger objects.

>>>LongInteger::% (long long int l)
Return a LongInteger that is the modulus of the receiver and the
argument. 

>>>LongInteger::%= (int i)
Perform a modulus of the receiver and its argument, and
store the result in the receiver.  Returns the receiver.

>>>LongInteger::& (long long int l)
Perform a bitwise AND of the receiver and the operand.  The
Object class's & operator overloads C's unary
``address of'' prefix operator. 


>>>LongInteger::&& (long long int l)
Return TRUE if both the receiver and the operand evaluate to
TRUE. 

>>>LongInteger::& ( int i)
Perform a bitwise AND of the receiver and the operand, and
store the result in the receiver.  Returns the receiver.

>>>LongInteger::* (long long int l)
Multiply the receiver by l.

>>>LongInteger::/ (long long int l)
Divide the receiver by l.

>>>LongInteger::< (long long int l)
Return TRUE if the receiver is less than the operand,
FALSE otherwise.

>>>LongInteger::<= (long long int l)
Return TRUE if the receiver is less than or equal to the
operand, FALSE otherwise.

>>>LongInteger::<< (int i)
Shift the receiver left by the number of bits in the operand, an
Integer. 

>>>LongInteger::> (long long int l)
Return TRUE if the receiver is greater than the operand,
FALSE otherwise.

>>>LongInteger::>= (long long int l)
Return TRUE if the receiver is greater than or equal to the
operand, FALSE otherwise.

>>>LongInteger::>> (int l)
Shift the receiver right by the number of bits in the operand, an
Integer. 

>>>LongInteger::^ (long long int l)
Perform a bitwise XOR of the receiver and the operand.

>>>LongInteger::^= (int i)
Perform a bitwise XOR of the receiver and the operand, and
store the result in the receiver.  Returns the receiver.

>>>LongInteger::bitComp (void)
Return a bitwise complement of the receiver.

>>>LongInteger::invert (void)
Return TRUE if the receiver evaluates to FALSE, 
FALSE if the receiver evaluates to TRUE.

>>>LongInteger::| (long long int l)
Perform a bitwise OR of the receiver and the operand.

>>>LongInteger::|= (int i)
Perform a bitwise OR of the receiver and the operand, and
store the result in the receiver.  Returns the receiver.

>>>LongInteger::| (long long int l)
Return TRUE if either the receiver or the operand evaluate to
TRUE. 

>>>LongInteger::~ (void)
When overloading C's unary '~' operator, is synonymous
with the bitComp method, above.


>>>Point::draw (X11Pane pane_object)
Draw the receiver on pane_object at the coordinates
given by the receiver's x and y instance
variables.

This method draws to the X11Pane objects buffer.  To draw
offscreen to a separate X11Bitmap, object refer to the method
drawPoint in class X11Bitmap. 

>>>Point::drawWithPein (X11Pane pane_object, Pen pen_object)
Draw the receiver on pane_object at the coordinates
given by the receiver's x and y instance
variables, with the diameter and color supplied by the
pen_object argument. 

This method also draws to the X11Pane object's buffer.  To draw
offscreen to a separate X11Bitmap object, refer to the method
drawPoint in class X11Bitmap. 


---------------------------------------------------------
  
  int main () {
    X11Pane new xPane;
    InputEvent new e;
    X11PaneDispatcher new xTopLevelPane;
    X11CanvasPane new xCanvasPane;
    Application new paneApp;
  
    paneApp enableExceptionTrace;
    paneApp installExitHandlerBasic;
  
    xPane initialize 10, 10, 250, 250;
    xPane inputStream eventMask =        /* Tell the main window's event */
      WINDELETE|EXPOSE;                  /* object, a X11InputStream,    */
                                         /* which types of events we     */
                                         /* plan to use.                 */
    
    xTopLevelPane attachTo xPane;        /* The attachTo methods also */
    xCanvasPane attachTo xTopLevelPane;  /* set the dimensions of the */
                                         /* subpanes before they are  */
                                         /* mapped and raised along   */
                                         /* with the top-level pane.  */
  
    xPane map;
    xPane raiseWindow;
    xPane openEventStream;               /* Before we can do any      */
                                         /* drawing on the window, we */
                                         /* need to start sending and */
                                         /* receiving events from the */
                                         /* X server.  That is what   */
                                         /* openEventStream does.     */
  
    xPane background "yellow";           /* Setting the background of */
    xPane clearWindow;                   /* an X11Pane object sets the*/
                                         /* background of the actual  */
                                         /* window.                   */
  
    xCanvasPane background "yellow";     /* Setting the background of */
                                         /* a buffered pane like a    */
                                         /* X11CanvasPane sets the    */
                                         /* background color of its   */
                                         /* buffer.                   */
  
    xCanvasPane clearRectangle 0, 0, 250, 250; /* In both cases, we   */
                                               /* need to update the  */
                                               /* pane before the new */
                                               /* color is visible,   */
                                               /* with either,        */
                                               /* "clearWindow," or,  */
                                               /* "clearRectangle."   */
    xCanvasPane pen width = 100;
    xCanvasPane pen colorName = "red";
    xCanvasPane drawPoint 40, 40;
    xCanvasPane pen colorName = "green";
    xCanvasPane drawPoint 120, 40;
    xCanvasPane pen colorName = "blue";
    xCanvasPane drawPoint 80, 90;
  
    while (TRUE) {
      xPane inputStream queueInput;
      if (xPane inputStream eventPending) {
        e become xPane inputStream inputQueue unshift;
        xPane subPaneNotify e;          /* We need to notify subPanes */
                                        /* e.g., xCanvasPane of the   */
                                        /* input events from the GUI. */
        switch (e eventClass value)
          {
          case WINDELETE:
            xPane deleteAndClose;
            exit (0);
            break;
          case EXPOSE:
          case RESIZENOTIFY:
  	  xCanvasPane pen width = 100;
  	  xCanvasPane pen colorName = "red";
  	  xCanvasPane drawPoint 40, 40;
  	  xCanvasPane pen colorName = "green";
  	  xCanvasPane drawPoint 120, 40;
  	  xCanvasPane pen colorName = "blue";
  	  xCanvasPane drawPoint 80, 90;
            break;
          default:
            break;
          }
      }
    }
  }
  
---------------------------------------------------------


>>>Line::draw (X11Pane paneObject)
Draw a line on the paneObject's visible area at the receiver's
start and end coordinates, using a default pen
width of one pixel and default color of black.

This method is mainly used for drawing on a buffer already attached to
a X11Pane object.  To draw offscreen to a separate
X11Bitmap object, use drawLine in class X11Bitmap.


>>>Line::drawWithPen (X11Pane paneObject, Pen penObject)
Draw a line on the paneObject's visible area at the receiver's
start and end coordinates.  The penObject argument
contains the width and color of the line. 

This method is also used mainly for drawing on a buffer already attached to
a X11Pane object.  To draw offscreen to a separate
X11Bitmap object, use drawLine in class X11Bitmap.




>>>Rectangle::clear (X11Pane paneObject)
Clear the rectangle defined by the receiver to the background color of
paneObject.  This method requires that the dimensions of the
rectangle be completely defined.  The easiest way to do this is with
the dimensions method, below.

>>>Rectangle::draw (X11Pane paneObject)
Draw an outline of the receiver's rectangle dimensions on
paneObject's display area, using a line width of one
pixel and the color black.

>>>Rectangle::drawWithPen (X11Pane paneObject, Pen penObject)
pDraw an outline of the receiver's rectangle dimensions on
paneObject's display area, using the line width and color given
by penObject.

>>>Rectangle::dimensions (Integer xOrigin, Integer yOrigin, Integer xSize, Integer ySize)
A convenience method that fills in the dimensions of each of the
receiver's sides from the arguments, which specify the origin, height,
and width of the receiver.

>>>Rectangle::fill (X11Pane paneObject)
Draw a solid rectangle on paneObject's display area,
using a default line width of one pixel and the default
color, black.

>>>Rectangle::fillWithPen (X11Pane paneObject, Pen penObject)
Draw a solid rectangle on paneObject's display area, using the
color given by penObject.

>>>Circle::draw (Pane paneObject, Integer filled, String bgColor)
>>>Circle::draw (Pane paneObject, Pen penObject, Integer filled, String bgColor)
Draw the receiver circle on the display.  If a Pen argument is
given, use the Pen object's color and line width to draw the
circle. If a Pen argument is not given use a default Pen,
and fill the interior of the circle with bgColor if filled
is false.

>>>Method::definedClassMethod (String classname, String name)
Initialize the receiver with the class method named by the arguments.
>>>Method::definedInstanceMethod (String classname, String name)
Initialize the receiver with the instance method named by the arguments.
>>>Method::withArg (Object method_argument)
Define an argument for the receiver method.

This method normally precedes a methodObjectMessage call.  For
examples of its use, refer to the methodObjectMessage section.


>>>Method::setCallbackName (String name)
Sets the receiver object's name to the name of the callback, which
is generally set when the program is compiled.  This does not
change the name of the actual method, only the name by which the
Method object that represents it is referred to.

Here is a slightly hypothetical example of the steps that use
setCallbackName to set up a callback method.

---------------------------------------------------------
  
  /*
   * 1. In MyClass, the callback here is defined as an instance
   * variable.
   */
  MyClass instanceVariable myCallback Method NULL;
  
  ...
  
  /*
   * 2. Also in MyClass, define a method to configure the callback.
   */
  MyClass instanceMethod onEvent (String methodClassName,
                                  String methodName) {
    Method new callbackMethod;
  
    callbackMethod definedInstanceMethod methodClassName, methodName;
  
    /* This sets the class and name of callbackMethod to the name
        of the callback instance variable defined above, at the
        start of the class. */
    callbackMethod setCallbackName "myCallback";
  
    self addInstanceVariable "myCallback", callbackMethod;
  }
  
  /*
   * 3. In the program's source file, define the callback method
   * itself.
   */
  MyClass instanceMethod callbackMethod (void) {
    ... do something ...
  }
  
  ...
  
  /*
   * 4. Also in the program's source file, set up the callback
   * method during program initialization.
   */
  int main () {
    MyClass new myProgram;
  
    ...
  
    myProgram onEvent "MyClass", "callbackMethod";
  
    ...
  }
  
---------------------------------------------------------

For a working example, refer to the class GLXCanvasPane, which
uses this process to assign callbacks.


>>>Pane::attach (Pane childPane)
Attach childPane to the receiver.  If mapped, then the child
pane is displayed the next time the parent pane and its children are
updated.  If childPane is an ANSITerminalPane object, the
child pane inherits the parent's input and output stream handles.

>>>Pane::deletePaneBuffer
Deletes the paneBuffer backing store memory that constructors 
should allocate when creating subclass objects.  Subclasses
should also use this message in destructor or cleanup methods.



>>>ANSITerminalPane::blinkOnOff (void)
Toggle the pane's blinking graphics attribute; if enabled, display
blinking text; if disabled, display normal text.  Blinking text is not
supported on all terminals.

>>>ANSITerminalPane::boldOnOff (void)
Toggle the pane's bold graphics attribute; if enabled, display bold
text; if disabled, display normal text.

>>>ANSITerminalPane::childRefresh (void)
Refresh the receiver, a child pane.  This method is called by 
refresh for each of a parent pane's children.

>>>ANSITerminalPane::cursorPos (int x, inty)
Position the software cursor at coordinates x, y within
the pane's content area.  This method is a synonym for gotoXY,
below. 

>>>ANSITerminalPane::delete
The class destructor.  This method performs the extra 
cleanup that the ANSITerminalPane class requires.

>>>ANSITerminalPane::gotoXY (int x, inty)
Position the software cursor at coordinates x, y within
the pane's content area.

>>>ANSITerminalPane::initialize (int x_org, int y_org, int x_size, int y_size)
Initialize the receiver pane's coordinate instance variables, and
screen buffers.

>>>ANSITerminalPane::map (ANSITerminalPane __child)
Enable the display of a child pane, and buffer any screen contents.
The receiver should be a pane that completely encloses the child
pane's content region and shadow if any.  The pane is displayed when
the parent pane receives a refresh message.

>>>ANSITerminalPane::new (char *__paneName)
Create a new ANSITerminalPane object.  If more than one label
is given in the argument list, create new ANSITerminalPane
objects with those names.  This method also creates and initializes
the paneStream (class ANSITerminalStream) instance
variable.  

>>>ANSITerminalPane::printOn (char *__fmt, ...)
Print the arguments to the pane's content area at the software cursor
position.  The output is displayed after the receiver pane receives a
refresh message.

>>>ANSITerminalPane::putCharXY (intx, inty, charc)
Put character c at coordinates x,y of the pane's
content area.  The character is displayed immediately using the pane's
current graphics mode.

>>>ANSITerminalPane::refresh (void)
Display the receiver pane content and decorations like borders and
shadows on the screen. This method also calls childRefresh for
each child pane that is attached (with attach, class
Pane) to the receiver pane.  

>>>ANSITerminalPane::resetGraphics (void)
Reset the pane's graphics attributes to normal text; i.e., bold,
underline, reverse, and blink attributes are turned off.

>>>ANSITerminalPane::reverseOnOff (void)
Toggle the pane's reverse graphics attribute; if enabled, display
text in inverse video; if disabled, display normal text.

>>>ANSITerminalPane::terminalHeight
Returns an Integer with the terminal's height in character rows.

Note: If an operating system has a terminal interface that
Ctalk doesn't know about, then the method returns 0.

>>>ANSITerminalPane::terminalWidth
Returns an Integer with the terminal's width in character columns.

See the note about terminal compatibility in the terminalHeight entry,
above.

>>>ANSITerminalPane::underlineOnOff (void)
Toggle the pane's underline graphics attribute; if enabled, display
text underlined; if disabled, display normal text.  Underlined text is
not supported on all terminals.

>>>ANSITerminalPane::unmap (ANSITerminalPane __child)
Hide a child pane, and restore any screen contents that were obscured
when the child pane was displayed.  The child pane is withdrawn when
the parent pane receives the next refresh message.

>>>ANSITerminalPane::withBorder (void)
Enable the display of a border around the edges of the pane's content
area, using ANSI line drawing characters.  The border is within the
pane's content area and can obscure text at the edges of the pane.

>>>ANSITerminalPane::withShadow (void)
Enable the display of a shadow underneath the pane.  The shadow is
outside of the pane's content area, and should be within the clipping
area of the parent pane.

>>>ANSIWidgetPane::addBuffer
Integer cellSize)
A convenience method that creates the receiver pane's buffers
with the width, height and character cell size given as the
arguments.  The cellSize argument should almost always be
'1'.  If the pane has buffers created previously by another
method, addBuffer deletes the old buffers first.

>>>ANSIWidgetPane::handleInput
Process InputEvent objects from the receiver's
paneStream input handle.  This handleInput definition 
provides only basic functionality.  Subclasses should re-implement
this method with the additional functions that the widget needs.

>>>ANSIWidgetPane::map (void)
Maps the receiver widget pane over another pane that was
defined by a previous parent message (below).

>>>ANSIWidgetPane::mapSubWidget (ANSIWidgetPane subPane)
Maps the receiver widget pane over another pane that was defined by a
previous parent message (below), and sets the subPane's
mapped instance variable to TRUE, and adds
subWidgetPane, to the parent pane's children list.
subPane may be any subclass of ANSIWidgetPane.

>>>ANSIWidgetPane::new (paneName1, paneName2, ... paneNameN;)
Create one or more new ANSIWidgetPane objects.  The object
is similar to an ANSITerminalPane object, but it 
contains the additional instance variables listed in the previous 
section.  This method also relies on the ANSITerminalPane
methods withShadow and withBorder, and the
ANSITerminalStream method openInputQueue.

>>>ANSIWidgetPane::parent (ANSITerminalPane parentPaneObject)
Sets the receiver's parentPane instance variable to the main
ANSITerminalPane (or subclass) object that the receiver is to
be mapped over.  This method also provides the subWidget with copies
of the parent's input and output stream handles.

>>>ANSIWidgetPane::title (String titleString)
Set the receiver's title string to the argument.

>>>ANSIWidgetPane::unmap (void)
Unmaps the receiver from its parent pane.  Used after previous
parent and map messages (above).


>>>ANSIButtonPane::focusHighlightOnOff
Toggle the button's highlight.  

>>>ANSIButtonPane::handleInput (void)
Wait for input from the receiver's paneStream object.
Withdraws the receiver if the the user types an escape (0x1b)
or carraige return (0x0d) character, or the paneStream
object receives these characters from another input source.

The paneStream instance variable (which is declared in
ANSITerminalPane class), contains a reference to an
ANSITerminalStream object. 

This method sets the value of the outputBuffer instance
variable, as described above.

>>>ANSIButtonPane::new (button1_name, button2_name, ...;)
Create one or more new ANSIButtonPane object, with border and
shadow decorations, for each name given in the argument list.  The
buttons' exact sizes are determined by the withText method,
below.

>>>ANSIButtonPane::show (Integer x_origin, Integer y_origin)
Display the button or map it to a parent widget.  The x_origin
and y_origin are relative to the upper left of the display if
the button is displayed independently, or relative to the upper
left-hand corner of a parent pane.

This method returns the outputBuffer instance
variable, which contains the result of input from the user
or another source, as described above.

>>>ANSIButtonPane::withText (String button_text)
Set the text that will appear inside the button.  The method adjusts
the button dimensions to fit the text.


>>>ANSILabelPane::appendLine (String text)
>>>ANSILabelPane::appendLine (String text, Integer width, Integer height)
Add a line of text to the label's contents.  If given with a width and
height, specify the size of the label.  Otherwise, the label is drawn
large enough to display the contents.  

If the label contains multiple lines of text, then the dimensions given
(or calculated) for the last line determine the size of the label.

>>>ANSILabelPane::cleanup (void)
Delete the buffers associated with the pane object.

>>>ANSILabelPane::display (Integer x, Integer y)
Display the pane at x,y on the display or parent
pane.  Unlike show, below, does not wait for user input.

>>>ANSILabelPane::handleInput (void)
Process input for the pane.  This method is normally called by the
Show method, below.  When the pane is displayed by itself, pressing
Escape or Enter returns from the method, and the Show method
withdraws the pane from the display.

>>>ANSILabelPane::new (label1, label2, label3,...;)
Create new ANSILabelPane objects for each member of the
argument list.  The arguments specify the names of the new object.

>>>ANSILabelPane::refresh (void)
Draw the pane's contents on the terminal.

>>>ANSILabelPane::show (Integer x, Integer y)
Display the pane at the position x, y on the terminal.
This method also calls the handleInput method, above, and
waits for the user's input before returning.

>>>ANSILabelPane::sizePane (Integer width, Integer height)
Set the size of the pane object and its buffers.  This method is
normally called by the appendLine method, above.


>>>ANSIListBoxPane::appendLine (String text)
Creates a new ANSILabelBox object with the contents text,
then adds the ANSILabelBox to the items list.

>>>ANSIListBoxPane::cleanup (void)
Deletes the buffers associated with the ANSIListBoxPane object
and its items.

>>>ANSIListBoxPane::handleInput (void)
Waits for input from the user and processes it.  Pressing a cursor
key or an Emacs or vi next/previous line key shifts the selection.
Pressing Escape or Enter causes the method to return.

>>>ANSIListBoxPane::new (listPane1, listPane2, ...;)
The ANSIListBoxPane constructor.  The argument contains the
names of one or more new ANSIListBoxPane objects.

>>>ANSIListBoxPane::refresh (void)
Draw the list pane and items on the terminal.

>>>ANSIListBoxPane::refreshSelectionFirst (void)
Highlight the initially selected item.  Should only be called after
a call to refresh.

>>>ANSIListBoxPane::refreshSelection (void)
Redraw the highlightd selected item, and un-highlight the previously
selected item.  Should only be called after a call to selectNext
or selectPrev

>>>ANSIListBoxPane::selectedText (void)
Returns the text of the selected item as a String object.

>>>ANSIListBoxPane::selectNext (void)
>>>ANSIListBoxPane::selectPrev (void)
Select the next or previous item of the list box's contents.  Also
saves the index and contents of the previously selected item.




>>>ANSIMessageBoxPane::cleanup (void)
Delete the receiver's extra data before deletion.  The receiver
objects themselves are deleted normally.

>>>ANSIMessageBoxPane::new (String message_box_name)
Create one or more new ANSIMessageBox objects.

>>>ANSIMessageBoxPane::withText (String text)
The argument is the text that will appear in the message box.  The
method adjusts the pane's dimensions to fit the text.

>>>ANSIMessageBoxPane::show (int x_origin, int y_origin)
Display the receiver at x_origin, y_origin.  If the
receiver is displayed independently, the origin is relative to the
upper left-hand corner of the display, or if the receiver is to
be displayed over a parent pane, it is mapped to the parent pane 
with the origin relative the the parent pane's upper left-hand
corner. 




>>>ANSIProgressBarPane::dimension (Integer width, Integer height)
Set the width and height of the pane in character columns.

>>>ANSIProgressBarPane::show (Integer x, Integer y)
Display the pane at row and column x,y, and return
immediately.

>>>ANSIProgressBarPane::handleInput (void)
Wait for the user's input.  Pressing @kbd{Esc} or @kbd{Enter} closes
the pane. and returns.

>>>ANSIProgressBarPane::new (String paneName)
Create new ANSIProgressBarPane objects, one for each label
given in the method's argument list.

>>>ANSIProgressBarPane::percent (Float percent)
Set the percent of the progress bar's highlighted area.  This method
adjusts for the width of the progress bar and sets the text for the
percent logo.

>>>ANSIProgressBarPane::refresh (void)
Redraw the progress bar on the terminal.

>>>ANSIProgressBarPane::show (Integer x, Integer y)
Display the pane at row and column x,y, and wait for
the user's input.




>>>ANSIScrollingListBoxPane::appendLine (String item_text)
Adds item_text to the list's contents.

>>>ANSIScrollingListBoxPane::cleanup (void)
Deletes the display buffers associated with the list box and scroll bar.

>>>ANSIScrollingListBoxPane::handleInput (void)
Waits for the user's input.  Changes the selected item when the user
cursors through the list using the terminal's cursor keys, Emacs compatible
@kbd{C-n}/@kbd{C-p}, or vi compatible @kbd{j}/@kbd{k}.  Restores the
terminal and returns when the user presses @kbd{Enter} or @kbd{Escape}.

>>>ANSIScrollingListBoxPane::noBorder (void)
>>>ANSIScrollingListBoxPane::withBorder (void)
Set or unset the border for the main scroll pane and the scroll bar.  These
methods are equivalent to the following expressions.

---------------------------------------------------------
  
    /* To display borders. */
    listPane border = 1;
    listPane scrollBar border = 1;
  
    /* To hide the borders. */
    listPane border = 0;
    listPane scrollBar border = 0;
  
---------------------------------------------------------

Note that not all terninals support line drawing characters.

>>>ANSIScrollingListBoxPane::noBorder (void)
>>>ANSIScrollingListBoxPane::withBorder (void)
Set or unset the shadow for the main scroll pane and the scroll bar.  The
methods are a shortcut for these statements.

---------------------------------------------------------
  
    /* To display shadows. */
    listPane shadow = 1;
    listPane scrollBar shadow = 1;
  
    /* To hide the shadows. */
    listPane shadow = 0;
    listPane scrollBar shadow = 0;
  
---------------------------------------------------------

>>>ANSIScrollingListBoxPane::new (String object_name)
Constructs a new ANSIScrollingListBoxPane for each label given
in the argument list.  Sets the dimensions for the viewable
areas, decorations, and creates the display buffers for the list box
and the scroll bar.

>>>ANSIScrollingListBoxPane::refresh (void)
Redraws the list box.

>>>ANSIScrollingListBoxPane::refreshSelection (void)
Un-highlights the previously selected item and highlights the currently
selected item.

>>>ANSIScrollingListBoxPane::refreshSelectionFirst (void)
Highlights the currently selected item, which is normally the first item in the
list when first drawing the widget--i.e., when there is no previously
selected item.

>>>ANSIScrollingListBoxPane::scrollThumbSize (void)
Sets the scrollBar instance variable's thumbHeight instance
variable based on which portion of the list is visible. 

>>>ANSIScrollingListBoxPane::scrollThumbStart (void)
Sets the scrollBar instance variable's thumbStartLine instance
variable based on which portion of the list is visible. 

>>>ANSIScrollingListBoxPane::selectedText (void)
Returns a String containing the text of the selected item. 

>>>ANSIScrollingListBoxPane::selectNext (void)
Sets the next selectedLine and selectedContent instance 
variables to the next item in the list.  If the selected item is already
the last item in the list, the method does nothing.

>>>ANSIScrollingListBoxPane::selectPrev (void)
Sets the next selectedLine and selectedContent instance 
variables to the previous item in the list.  If the selected item is
already the first item in the list, the method does nothing.

>>>ANSIScrollingListBoxPane::show (Integer x, Integer y)
Displays the widget an character row and column x,y on
the terminal display, then calls the handleInput method to
process user input.




>>>ANSIScrollPane::cleanup (void)
Delete the buffers associated with the pane object.

>>>ANSIScrollPane::dimension (Integer width, Integer height)
Set the width and height of the receiver pane.  Also adjusts the width
of the viewWidth and viewHeight instance variables.

>>>ANSIScrollPane::display (Integer x, Integer y)
Draw the pane on the terminal at row and column x,y, and
return immediately.

>>>ANSIScrollPane::handleInput (void)
Waits for user input from the pane's ANSITerminalStream object.
Pressing Enter or Escape withdraws the pane from the display and returns.
Pressing the Up or Down arrow keys moves the scroll thumb.

>>>ANSIScrollPane::new (String paneName)
Create a new ANSIScrollPane object, with the name paneName.
If more than one name is given in the argument list, create new
ANSIScrollPane objects with the arguments' names.

>>>ANSIScrollPane::refresh (void)
Draw the pane on the terminal.

>>>ANSIScrollPane::show (Integer x, Integer y)
Draw the pane on the terminal at row and column x,y, and
wait for the user's input.



>>>ANSITextBoxPane::appendLine (String text)
Append a line to the widget's text (class List) instance
variable.  The text will be visible after the next refresh message.

>>>ANSITextBoxPane::cleanup (Integer lineNumber)
Delete the extra buffers that the receiver uses for screen data.  
The normal object cleanup routines delete the receiver pane itself.

>>>ANSITextBoxPane::clearLine (Integer lineNumber)
Erase the line lineNumber in the pane's view area.

>>>ANSITextBoxPane::handleInput (void)
Wait for the user's input from the keyboard and redisplay or withdraw
the receiver widget depending on which key the user presses.

>>>ANSITextBoxPane::new (String paneName)
Constructs a new ANSITextBoxPane object.  The object's
dimensions are 40 columns wide by 20 rows high, with a ``Dismiss''
button at the bottom of the window, and with a border and shadow.

If more that one name is given in the argument list, construct
new ANSITextBoxPane objects with the labels' names.

>>>ANSITextBoxPane::refresh (void)
Redraws the receiver object and any text to be displayed in the pane's
visible area.

>>>ANSITextBoxPane::resize (Integer xSize, Integer ySize)
Resize the pane to the dimensions xSize, ySize.

>>>ANSITextBoxPane::show (Integer xOrigin, Integer yOrigin)
Pop up the pane's window at the terminal coordinates xOrigin,
yOrigin, and wait for the user's input.


>>>ANSITextEntryPane::handleInput (void)
Process InputEvent objects from the receiver's 
paneStream input handle.  

>>>ANSITextEntryPane::inputWidth (Integer width)
Set the width, in characters, of the input entry box.  The
default is 20.

>>>ANSITextEntryPane::new (String paneName)
Creates a new ANSITextEntryPane object.  Also uses the
withShadow and withBorder messages from
ANSITerminalPane class, and the openInputQueue message
from ANSITerminalStream class.

If more that one argument is given in the argument list, create
new ANSITextEntryPane objects with the arguments' names.

>>>ANSITextEntryPane::show (int x_origin, int y_origin)
Display the receiver pane and return input from the user.  

>>>ANSITextEntryPane::withdraw
Remove the receiver widget from the display.  If the widget is drawn
over another pane object, unmap the receiver from the parent pane.  If
the receiver is displayed independently, clear the display before
returning.

>>>ANSITextEntryPane::withPrompt (String promptText)
Set the receiver's prompt to promptText. 

>>>ANSIYesNoBoxPane::cleanup (void)
Delete the widget's data before exiting.

>>>ANSIYesNoBoxPane::getFocusWidgetText (void)
Return the text associated with the button that has the input focus.

>>>ANSIYesNoBoxPane::handleInput (void)
Wait for the user's input and return the response from the widget.

>>>ANSIYesNoBoxPane::new
Create a new ANSIYesNoBox object with the name given as
an argument.  If the argument list contains more than one name,
create ANSIYesNoBoxPane objects for each argument.

---------------------------------------------------------
  
  ANSIYesNoBoxPane new yesnobox1, yesnobox2;
  
---------------------------------------------------------

>>>ANSIYesNoBoxPane::nextFocus (void)
Set the input focus to the next button widget.

>>>ANSIYesNoBoxPane::noBorder (void)
>>>ANSIYesNoBoxPane::withBorder (void)
Set or unset the border for the main pane and the button labels.  These
methods are equivalent to the following expressions.

---------------------------------------------------------
  
    /* To display borders. */
    yesnoBox border = 1;
    yesnoBox button1 border = 1;
    yesnoBox button2 border = 1;
  
    /* To hide the borders. */
    yesnoBox border = 0;
    yesnoBox button1 border = 0;
    yesnoBox button2 border = 0;
  
---------------------------------------------------------

Note that not all terninals support line drawing characters.

>>>ANSIYesNoBoxPane::noBorder (void)
>>>ANSIYesNoBoxPane::withBorder (void)
Set or unset the shadow for the main pane and the buttons.  The
methods are a shortcut for these statements.

---------------------------------------------------------
  
    /* To display shadows. */
    yesnoBox shadow = 1;
    yesnoBox button1 shadow = 1;
    yesnoBox button2 shadow = 1;
  
    /* To hide the shadows. */
    yesnoBox shadow = 0;
    yesnoBox button1 shadow = 0;
    yesnoBox button2 shadow = 0;
  
---------------------------------------------------------

>>>ANSIYesNoBoxPane::show (int x_origin, int y_origin)
Display the ANSIYesNoBoxPane object at x_origin,
y_origin.  If displayed over another pane, the origin is
relative to the parent pane's origin.  If displayed independently, the
origin is relative the the upper left-hand corner of the terminal.

>>>ANSIYesNoBoxPane::withText (char *text)
Defines the text that is to appear within the pane.  This method
adjust's the pane's size to fit the text.




>>>GLXCanvasPane::alpha (Float alpha)
Sets the alpha channel (opacity) when rendering outline fonts.  Values
should be between 0.0 (transparent) and 1.0 (opaque).  The Ctalk
library's default value is 1.0.  Calling this method also sets
the value of the receiver pane's ftFontVar fgAlpha instance
variable.

>>>GLXCanvasPane::deleteAndClose (void)
Releases the receiver pane's GLX context and deletes the X11 window,
and shuts down the application's X11 input client.


>>>GLXCanvasPane::displayHeigth (void)
>>>GLXCanvasPane::displayWidth (void)
These methods return an Integer with the display height and
width in pixels, respectively.

>>>GLXCanvasPane::drawFmtText (Float xOrg, Float yOrg, String fmt, ...)
Draws the text given by fmt and its arguments at the matrix
position given by xOrg,yOrg.


>>>GLXCanvasPane::drawFmtTextFT (Float xOrg, Float yOrg, String fmt, ...)
Display the string given by fmt and its arguments at the matrix
coordinates xOrg, yOrg in the currently selected Freetype
font.  This call, like all calls that render text, should be preceded
by a call to useFTFont.

>>>GLXCanvasPane::drawFmtTextW (Integer xOrg, Integer yOrg, String fmt, ...)
Draws the formatted text of fmt and its arguments at the pixel
position given by xOrg, yOrg.  OpenGL uses the lower
left-hand corner of the window as the origin for pixel coordinates.

>>>GLXCanvasPane::drawText (Float xOrg, Float yOrg, String text)
>>>GLXCanvasPane::drawText (Float xOrg, Float yOrg, Float red, Float green, Float blue, String text)
Draws text at the matrix position given by xOrg,yOrg.

The program must have registered a X font for drawing with a previous
call to the useXFont method.

If the red, green, and blue arguments are given, the
method draws the text in that color.  Otherwise, the method (via OpenGL)
draws the text using the last OpenGL color setting.

>>>GLXCanvasPane::drawTextFT (Float xOrg, Float yOrg, String text)
>>>GLXCanvasPane::drawTextFT (Float xOrg, Float yOrg, Float red, Float green, Float blue, Float alpha, String text)
Draws the string given by text at the matrix coordinates
xOrg, yOrg.

The red, green, blue, and alpha arguments, if used, should
be between the values of 0.0 and 1.0, so they can be passed along to
the OpenGL API directly, and also to set the receiver's
ftFontVar instance variable (a X11FreeTypeFont values
for its instance variables: fgRed, fgGreen, fgBlue, and
fgAlpha 

>>>GLXCanvasPane::drawTextW (Float xOrg, Float yOrg, String text)
>>>GLXCanvasPane::drawTextW (Float xOrg, Float yOrg, Float red, Float green, Float blue, String text)
Draws text using the window's xOrg,yOrg pixel as the
origin.

If the red, green, and blue arguments are given, the
method draws the text in that color.  Otherwise, the method (via OpenGL)
draws the text using the last OpenGL color setting.

This method allows text to be positioned relative to the window's
pixels, which avoids the need for programs to translate a matrix
position into a pixel position manually.  This allows a program to
position text more easily when it is necessary to measure spaces using
the dimensions of the text and font that are being displayed.

The coordinates' origin (0,0) is at the lower left-hand corner of
the window, and the pixel coordinates increase as the position moves
toward the top and right of the window.

The GL function glWindowPos2i, which this method uses internally,
is an extension in many GL implementations.  Ctalk checks for the function
when building the Ctalk libraries.  If glWindowPos2i is not
present in the machine's GL libraries, then programs that try to
use these methods display an error message on the terminal and exit.

>>>GLXCanvasPane::extensions (void)
Returns the supported GLX extensions from the display server as a
String object.

>>>GLXCanvasPane::frameRate (void)
Returns the rate that the program updates the display, in frames
per second.  The algorithm that calculates the frame rate measures
frames over a five-second interval.

>>>GLXCanvasPane::freeFTFont (void)
Releases the Freetype font in use.

>>>GLXCanvasPane::freeXFont (void)
Frees the font data that was allocated by a previous call to useXFont.
Programs should call this method when cleaning up before program exit,
or when switching fonts by a subsequent call to useXFont.

>>>GLXCanvasPane::initialize (Integer x, Integer y, Integer width, Integer height, Integer geomFlags)
>>>GLXCanvasPane::initialize (Integer x, Integer y, Integer width, Integer height)
>>>GLXCanvasPane::initialize
Creates the receiver pane's window and configures the window for
display. The initialize method also fills in the receiver's
visualInfoPtr instance variable with a pointer the X visual
info structure specified by the receiver, which is provided by
the receiver's instance variables.

With two arguments, the method initializes the receiver window with
the width and height given as arguments.

With four arguments, the method initializes the receiver window with
the window's x and y origin and the width and height given as
arguments.

With five arguments, the geom_flags argument provides placement
hints for the window's initial position.  It has the format provided
by the parseX11Geometry method in Application class.


When used, the x and y parameters can be given directly if
the program sets the window position itself.  If these arguments are
zero, then the window manager or the user supplied window geometry
determines the window placement.

>>>GLXCanvasPane::hasExtension (String extensionName)
Returns a Boolean value of true if the system's OpenGL
library supports the GLX extension extensionName, false
otherwise.

>>>GLXCanvasPane::map (void)
Maps the GLXCanvasPane's window to the display, and
internally creates a GLXContext for the window, and
makes the GLXContext current.

This method fills in the receiver's glxContextPtr instance
method.

>>>GLXCanvasPane::namedColorFT (String colorName, Float redOut, Float greenOut, Float blueOut)
Return the GLX compatible color values for colorName; i.e., the
red, green, and blue values are Floats between 0.0 and 1.0.
The colorName argument can be any of the colors supported by the
X11 display server. Refer to showrgb(1) for a list of colors.

>>>GLXCanvasPane::onAnimation (String animationHandlerName)
Installs the callback method that the program calls 24 times a second.
The method needs to have the prototype:

---------------------------------------------------------
  
  GLXCanvasPane instanceMethod <methodName> (void);
  
---------------------------------------------------------

>>>GLXCanvasPane::onButtonPress (String buttonPressHandlerName)
Installs the callback method that handles ButtonPress events from the
display.  The callback method needs to have this prototype.

---------------------------------------------------------
  
  GLXCanvasPane instanceMethod <methodName> (Integer winX, Integer winY,
                                             Integer screenX, Integer screenY,
                                             Integer buttonState,
                                             Integer eventTime);
  
---------------------------------------------------------

The parameters winX and winY give the position of the
pointer relative to the window's origin.  The parameters screenX
and screenY give the pointer's position relative to the upper
left-hand corner of the root window.

Note this does not generally mean that the program can receive events
when a button is pressed outside of the program's window.  This
depends on how the desktop GUI interprets button presses; with many
desktop programs, the program doesn't receive events when a button is
clicked outside of the program's window.

The buttonState parameter's value records which buttons are
pressed at the time of the event.  Note that many systems interpret a
multiple button click (a ``chord'') as a unique button.  For example,
pressing the left and right buttons of a two-button mouse at the same
time results in a buttonState that indicates button 2 is pressed, not
that button 1 and button 3 are pressed simultaneously.

The time parameter is the time that the event occurred, so programs
can interpret a series of ButtonPress events as multiple mouse clicks
if necessary.

To install a buttonPress callback method, the program needs to
include an expression like this one in its initialization code.

---------------------------------------------------------
  
  myGLXPane onButtonPress "myButtonPressHandler";
  
---------------------------------------------------------

>>>GLXCanvasPane::onExpose (String exposeHandlerName)
Installs the callback method to handle Expose events received from the
display.  The callback method should have the following prototype.

---------------------------------------------------------
  
  GLXCanvasPane instanceMethod <methodName> (Integer nEvents);
  
---------------------------------------------------------

To install the callback method, the program's initialization should
contain an expression like this one.

---------------------------------------------------------
  
  myPane onExpose "myExposeHandler";
  
---------------------------------------------------------

The parameter nEvents contains the number of Expose events
that the window is waiting to receive.  This allows programs
to execute the handler's statements once per group of Expose events;
that is, when nEvents reaches 0.

This handler is important because it updates the window in
coordination with other display events.  If a callback method is not
installed, then the run method calls the swapBuffers
method.

>>>GLXCanvasPane::onIdle (String callbackMethodName)
Installs a callback method that the program executes when it is
not processing events from the display.

The callback method has the prototype:

---------------------------------------------------------
  
  GLXCanvasPane instanceMethod <idleHandler> (void);
  
---------------------------------------------------------

To install the handler, the program's initialization needs to
contain an expression like this.

---------------------------------------------------------
  
  myPane onIdle "myIdleCallback";
  
---------------------------------------------------------

>>>GLXCanvasPane::onKeyPress (String callbackMethodName)
Configures the receiver's keyPressHandler instance variable
to refer to the application's actual KeyPress handler method, which
is called when the program's window receives a KeyPress event from
the display.

The actual callback method has the prototype:

---------------------------------------------------------
  
  GLXCanvasPane instanceMethod <methodName> (Integer xKeySym,
                                             Integer keyCode,
                                             Integer shiftState);
---------------------------------------------------------

This example shows a simple KeyPress handler that closes the window and exits
the program when the @kbd{Escape} key is pressed.

---------------------------------------------------------
  
  /* This definition comes from the machine's X11/keysymdef.h file. */
  #define XK_Escape 0xff1b
  
  GLXCanvasPane instanceMethod myKeyPressMethod (Integer xKeySym,
  					       Integer keyCode,
  					       Integer shiftState) {
    if (xKeySym == XK_Escape) {
      self deleteAndClose;
      exit (0);
    }
  }
  
  
---------------------------------------------------------

The first parameter is the X Window System symbol for the key, which
is specific to the machine's keyboard configuration.  The complete
set of X key symbols is located in the machine's X11/keysymdef.h
file.

The second parameter is the ASCII value of alphanumeric keys and
punctuation keys. In the case of alphabetic characters, the value is
the same whether the keypress is shifted or unshifted.  That means
that pressing @kbd{A} and @kbd{a} both result in the keyCode
argument having the value 97.

The third parameter, shiftState, indicates whether a modifier key is
currently being pressed.  The parameter is the receiver's
shiftState instance variable.  The variable's description
describes how to interpret its value.

Then, during the program's initialization the program's code should
include an expression like the following.

---------------------------------------------------------
  
  myProgram onKeyPress "myKeyPressMethod";
  
---------------------------------------------------------

There is a more detailed description of how to configure callback
methods in section that discusses Method
class. 

>>>GLXCanvasPane::onPointerMotion (String callbackMethodName)
Installs the callback method that handles pointer motion events from
the display.  The callback method must have the prototype:

---------------------------------------------------------
  
  GLXCanvasPane instanceMethod <methodName> (Integer winX,
                                             Integer winY,
                                             Integer screenX,
                                             Integer screenY);
  
---------------------------------------------------------

The program's initialization should contain an expression like
this one:

---------------------------------------------------------
  
  myPane onPointerMotion "myPointerMotionMethod";
  
---------------------------------------------------------

>>>GLXCanvasPane::onResize (String callbackMethodName)
Installs the callback method that handles resize notifications from
the display.  The callback method needs to have the prototype:

---------------------------------------------------------
  
  GLXCanvasPane instanceMethod <methodName> (Integer width,
                                             Integer height);
  
---------------------------------------------------------

The program's initialization code should contain an expression like
this one.

---------------------------------------------------------
  
  myPane onResize "myResizeMethod";
  
---------------------------------------------------------

>>>GLXCanvasPane::onTimerTick (String callbackMethodName)
Installs the callback method to be executed when the classes' interval
timer reaches zero.  The callback method needs to have the
following prototype.

---------------------------------------------------------
  
  GLXCanvasPane instanceMethod <methodName> (void);
  
---------------------------------------------------------

The interval in milliseconds between the callback method's execution
is set in the timerMSec instance variable,

>>>GLXCanvasPane::pixelHeightFT (Integer pxHeight)
Set the pixel height of the selected font to the argument.  The default
height for rendering fonts with the Freetype libraries is 18 pixels.

>>>GLXCanvasPane::refreshRate (void)
Returns a Float with the display's refresh rate.  If the
machine's OpenGL does not support reporting the refresh rate, returns
-1.

>>>GLXCanvasPane::run (void)
Runs the event loop that receives X events from the display server,
and sends them to the callback methods that are configured for
the application.

Without any callback methods defined, the run method handles
only 'Expose' events (by calling swapBuffers), and
'ClientMessage' events, which check for the
WM_DELETE_WINDOW Atom and if present, delete the pane's window
and GLX context, and exit the program.

>>>GLXCanvasPane::swapBuffers (void)
Swaps the pane window's offscreen rendering buffer with the window's
visible buffer.

>>>GLXCanvasPane::syncSwap (Integer interval)
If interval > 0, sets the swap interval to 1/interval,
which enables swap synchronization with the display's vertical refresh
rate if the machine's OpenGL installation supports the
GLX_MESA_swap_control extension.

An interval value of 0 disables swap synchronization.

Returns 0 on sucess, or -1 if the extension is not supported.

>>>GLXCanvasPane::textWidth (String text)
Returns an Integer with the width of text in pixels
in the currently selected X font.  If no font is selected, the
method returns '-1'.

>>>GLXCanvasPane::textWidthFT (String text)
Returns a Float with the width of text in matrix
coordinates for the currently selected Freetype font.

>>>GLXCanvasPane::title (String title_string)
Set's the window's title.  This method should be called as soon
as possible after the program calls the initialize method.

>>>GLXCanvasPane::useFTFont (String fontFileName)
Load a TrueType, FreeType or Type 1 font.  Also initializes the font
and GLEW libraries if needed.

The method uses the font's file name as its argument.  To use a
system's font aliasing and lookup, refer to 

>>>GLXCanvasPane::useXFont (String fontName)
Register a X font for use with drawing text in the receiver
pane.  The argument, fontname, is th X Logical Font Descriptor
of a X font that is available on the system - refer to xlsfonts(1)
or xfontsel(1) for more information.

This method should be called during OpenGL initialization (that is,
after the GLXCanvasPane object has been created and the
GLX context established).

>>>GLXCanvasPane::xpmToTexture (Symbol xpmdata, Integer widthout, Integer heightout, Symbol texeldataout)
>>>GLXCanvasPane::xpmToTexture (Symbol xpmdata, Integer alpha Integer widthout, Integer heightout, Symbol texeldataout)

Translates a XPM pixmap into an OpenGL texture.  The argument
xpm_data is the pixmap's char *pixmap_name[] declaration.
If no alpha argument is given, then '1.0' is used to
create an opaque texture.

Alpha values can range from 0 (completely transparent) - 0xffff
(completely opaque), although in practice, the alpha channel's effect
might not be apparent, because OpenGL has its own set of functions
that perform texture blending.

The method sets the arguments width_out, height_out, and
texel_data_out with the height, width and data of the texture.

 Mesa OpenGL textures, used with Linux systems, internally have the
format GL_RGBA and the data type GL_UNSIGNED_INT_8_8_8_8, so you can
create a 2D texture from a pixmap with statements like these.

---------------------------------------------------------
  
  Integer new xpmWidth;
  Integer new xpmHeight;
  Symbol new texData;
  
  /*
   *  Note that the xpm_data argument should not normally need a
   *  translation from C.
   */
  myGLUTApp xpmToTexture xpm_data, xpmWidth, xpmHeight, texData;
  glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, xpmWidth, xpmHeight, 0,
                GL_RGBA, GL_UNSIGNED_INT_8_8_8_8, texData);
  
---------------------------------------------------------

Apple OpenGL implementations use a different internal format, so
a program would create the equivalent texture like this.

---------------------------------------------------------
  
  Integer new xpmWidth;
  Integer new xpmHeight;
  Symbol new texData;
  
  myGLUTApp xpmToTexture xpm_data, xpmWidth, xpmHeight, texData;
  glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, xpmWidth, xpmHeight, 0,
                GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, texData);
  
---------------------------------------------------------

The xpmToTexture method does not do any setup of the OpenGL texture
environment.  For basic textures, OpenGL works better with textures
that have a geometry that is an even multiple of 2; e.g., 128x128 or
256x256 pixels.  

Individual applications can add parameters for interpolation,
blending, mipmap creation, and material rendering based on the
program's requirements, though.

The Ctalk library only stores the data for one texture at a time, so
if a program uses multiple textures, it should save the texture data
to a separate Symbol, in orderq to avoid regenerating the texture each
time it's used.  Many OpenGL implementations also provide API functions
for texture caching.

For an example of how to draw with textures, refer to the
@file{glxtexture.ca} program in the Ctalk distribution's
@file{demos/glx} subdirectory.


@subheading Sample GLXCanvasPane Application

---------------------------------------------------------
  
  #include <X11/Xlib.h>
  #include <GL/glx.h>
  
  #define DEFAULT_WIDTH 500
  #define DEFAULT_HEIGHT 500
  
  float face1[3][3] = {{0.0f, 2.0f, 0.0f},
  		     {-2.0f, -2.0f, 2.0f},
  		     {2.0f, -2.0f, 2.0f}};
  float face2[3][3] = {{0.0f, 2.0f, 0.0f},
  		     {2.0f, -2.0f, 2.0f},
  		     {2.0f, -2.0f, -2.0f}};
  float face3[3][3] = {{0.0f, 2.0f, 0.0f},
  		     {2.0f, -2.0f, -2.0f},
  		     {-2.0f, -2.0f, -2.0f}};
  float face4[3][3] = {{0.0f, 2.0f, 0.0f},
  		     {-2.0f, -2.0f, -2.0f},
  		     {-2.0f, -2.0f, 2.0f}};
  
  float base[4][3] = {{2.0f, -2.0f, 2.0f},
  		    {2.0f, -2.0f, -2.0f},
  		    {-2.0f, -2.0f, -2.0f},
  		    {-2.0f, -2.0f, 2.0f}};
  
  float angle = 20.0;
  
  GLXCanvasPane instanceMethod draw (void) {
    glEnable (GL_NORMALIZE);
    glEnable(GL_DEPTH_TEST);
    glClearColor(0.0, 0.0, 0.0, 1.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    glLineWidth (1.0f);
  
    glLoadIdentity ();
    glColor4f (1.0f, 1.0f, 1.0f, 1.0f);
  
    glRotatef (angle, 0.0f, 1.0f, 0.0f);
    glRotatef (10.0f, 0.0f, 0.0f, 1.0f);
  
    glBegin (GL_TRIANGLES);
    glColor3f (1.0f, 0.0f, 0.0f);
    glVertex3fv (face1[0]);
    glColor3f (0.0f, 1.0f, 0.0f);
    glVertex3fv (face1[1]);
    glColor3f (0.0f, 0.0f, 1.0f);
    glVertex3fv (face1[2]);
  
    glColor3f (1.0f, 0.0f, 0.0f);
    glVertex3fv (face2[0]);
    glColor3f (0.0f, 1.0f, 0.0f);
    glVertex3fv (face2[1]);
    glColor3f (0.0f, 0.0f, 1.0f);
    glVertex3fv (face2[2]);
  			
    glColor3f (1.0f, 0.0f, 0.0f);
    glVertex3fv (face3[0]);
    glColor3f (0.0f, 1.0f, 0.0f);
    glVertex3fv (face3[1]);
    glColor3f (0.0f, 0.0f, 1.0f);
    glVertex3fv (face3[2]);
  			
    glColor3f (1.0f, 0.0f, 0.0f);
    glVertex3fv (face4[0]);
    glColor3f (0.0f, 1.0f, 0.0f);
    glVertex3fv (face4[1]);
    glColor3f (0.0f, 0.0f, 1.0f);
    glVertex3fv (face4[2]);
    glEnd ();
  
    glBegin (GL_QUADS);
  
    glColor3f (1.0f, 0.0f, 0.0f);
    glVertex3fv (base[0]);
    glColor3f (0.0f, 1.0f, 0.0f);
    glVertex3fv (base[1]);
    glColor3f (0.0f, 0.0f, 1.0f);
    glVertex3fv (base[2]);
    glColor3f (1.0f, 0.0f, 1.0f);
    glVertex3fv (base[3]);
  
    glEnd ();
  
    glRotatef (20.0, 0.0f, 0.0f, 1.0f);
    glRotatef (angle, 0.0f, 1.0f, 0.0f);
  
    self swapBuffers;
  }
  
  GLXCanvasPane instanceMethod initGL (void) {
    glViewport (0, 0, DEFAULT_WIDTH, DEFAULT_HEIGHT);
    glClearColor(0.0, 0.0, 0.0, 1.0);
    glLineWidth (1.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glEnable (GL_LINE_SMOOTH);
    glHint (GL_LINE_SMOOTH_HINT, GL_DONT_CARE);
    glMatrixMode (GL_PROJECTION);
    glLoadIdentity ();
    if (DEFAULT_WIDTH <= DEFAULT_HEIGHT) {
      glOrtho (-5.0, 5.0,
  	     -5.0 * ((float)DEFAULT_HEIGHT / (float)DEFAULT_WIDTH),
  	     5.0 * ((float)DEFAULT_HEIGHT / (float)DEFAULT_WIDTH),
  	     -5.0, 5.0);
    } else {
      glOrtho (-5.0, 5.0,
  	     -5.0 * ((float)DEFAULT_WIDTH / (float)DEFAULT_HEIGHT),
  	     5.0 * ((float)DEFAULT_WIDTH / (float)DEFAULT_HEIGHT),
  	     -5.0, 5.0);
    }
    glMatrixMode (GL_MODELVIEW);
    glLoadIdentity ();
  }
  
  GLXCanvasPane instanceMethod myTimerTickHandler (void) {
    angle += 1.0;
    self draw;
  }
  
  /* This definition comes from the machine's X11/keysymdef.h file. */
  #define XK_Escape 0xff1b
  
  GLXCanvasPane instanceMethod myKeyPressMethod (Integer xKeySym,
  					       Integer keyCode,
  					       Integer shiftState) {
    if (xKeySym == XK_Escape) {
      self deleteAndClose;
      exit (0);
    }
  }
  
  GLXCanvasPane instanceMethod myExposeMethod (Integer nEvents) {
    if (nEvents == 0)
      self draw;
  }
  
  GLXCanvasPane instanceMethod myResizeMethod (Integer width,
  					     Integer height) {
    float ar;
  
    glViewport (0, 0, width, height);
    glMatrixMode (GL_PROJECTION);
    glLoadIdentity ();
    if (width <= height)
      ar = (float)height / (float)width;
    else
      ar = (float)width / (float)height;
    glOrtho (-5.0, 5.0, -5.0 * ar, 5.0 * ar, -5.0, 5.0);
    glMatrixMode (GL_MODELVIEW);
    glLoadIdentity ();
  }
  
  int main () {
    GLXCanvasPane new pane;
  
    pane initialize (1, 150, 500, 500);
    pane title "GLXCanvasPane Demonstration";
    pane map;
    pane raiseWindow;
  
    pane onKeyPress "myKeyPressMethod";
    pane onExpose "myExposeMethod";
    pane onTimerTick "myTimerTickHandler";
    pane onResize "myResizeMethod";
  
    pane initGL;
    
    pane run;
  
  }
  
---------------------------------------------------------


>>>X11PaneDispatcher::attachTo (Object parentPane)
>>>X11PaneDispatcher::attachTo (Object parentPane, String geometry)
Attach the receiver to its parent pane, typically a X11Pane or
X11PaneDispatcher.  Also creates a X window, although
X11PaneDispatcher windows themselves are not normally visible.

When the subwindow is attached to the parent window, the Ctalk library
creates the pane object's window and graphics context, and clears the
window to the background color of the pane object's backgroundColor
instance variable; for example, with an expression like this:

---------------------------------------------------------
  
  myCanvasPane backgroundColor = "blue";
  
---------------------------------------------------------

Otherwise, the method clears the subpane's window to black.

The geometry argument, if present, defines the size and placement
of the subpane's window within the parent window.  A geometry specification
has the form:

---------------------------------------------------------
  
  width[%]xheight[%]+x[%]+y[%]
  
---------------------------------------------------------

The dimensions are in pixels, unless a percent sign ('%') follows
a dimension.  In that case, the dimension is a fractional percentage
of the parent pane's width or height. The String may contain a
combination of absolute and relative dimensions.

>>>X11PaneDispatcher::handleSubPaneEvent (InputEvent event)
Handle an input event from the window system. Typically the
parent pane's inputStream provides the event.


This method also checks keypresses for the @key{Tab} key, and
calls the shiftFocus method in order to shift focus between
a window's subpanes when the user presses @key{Tab}.

>>>X11PaneDispatcher::new (dispatcherName)
Create a new X11PaneDispatcher object.  Initializes the
instance variables to the default subpane event handlers and
the container mode to 'full'.  If the argument list contains
more than one label, created new X11PaneDispatcher objects
with the names of each label.

>>>X11PaneDispatcher::setMethodHandler (String handlerType, Method handlerMethod)
Set the pane's handler for handlerType to
handlerMethod.  Currently supported handler types are: 'resize'.

>>>X11PaneDispatcher::shiftFocus (void)
When the user presses @key{Tab}, handleSubPaneEvent calls this method,
which highlights a window's subpanes in succession, if the subpanes can
take the input focus.

Refer to the canFocus instance variable, and the handlers for focus
in and focus out events.  These event handlers are called by the program,
and are not the same as the handleWMFocusChange handler, which
is called when the window focus changes on the desktop.

>>>X11PaneDispatcher::clearFocus
Called before shifting the focus highlight to a new pane to insure
that only one pane indicates that it should receive focus, including
the synthetic focus that is assigned when shifting focus using the
@key{Tab} key.


>>>X11PaneDispatcher::subPaneDestroy (Object subPaneRef, InputEvent destroyEvent)
The default handler for WINDELETE events.  Like the
other method handlers, subPaneRef is typically a
Symbol object.  The X11TerminalStream section
describes these events.  

>>>X11PaneDispatcher::subPaneGeometry
A String that stores a subpane's geometry specification, if
any.  For an explanation of geometry string's format, refer to the
attachTo method, below.

>>>X11PaneDispatcher::subPaneKbdInput (Object subPaneRef, InputEvent kbdInputEvent)
The default handler for KEYPRESS and
KEYRELEASE events.  Like the other method handlers,
subPaneRef is typically a Symbol object.  The
X11TerminalStream section describes these events.


>>>X11PaneDispatcher::subPaneMove (Object subPaneRef, InputEvent moveNotifyEvent)
The default event handler for MOVENOTIFY events
from the system's GUI.  Like the other method handlers,
subPaneRef is typically a Symbol object.  The
X11TerminalStream section describes these events.


With some window managers, a subPaneMove method might
also need to handle RESIZENOTIFY events.

>>>X11PaneDispatcher::subPanePointerMotion (Object subPaneRef, InputEvent event)
>>>X11PaneDispatcher::subPanePointerInput (Object subPaneRef, InputEvent event)
The default handlers for MOTIONNOTIFY, and BUTTONPRESS
and BUTTONRELEASE events.  Like the other method handlers,
subPaneRef is typically a Symbol object.  The
X11TerminalStream section describes these events.


>>>X11PaneDispatcher::subPaneResize (Object subPaneRef, InputEvent resizeNotifyEvent)
The default resize handler for subpane windows.  Typically
subPaneRef is a Symbol object that contains a
reference to the subpane object.  The resizeEvent
argument is typically a RESIZENOTIFY event from the
system's GUI.  


>>>X11CanvasPane::attachTo (Object parent_pane)
>>>X11CanvasPane::attachTo (Object parent_pane, String geometry)
>>>X11CanvasPane::attachTo (Object parent_pane, Integer xOrg, Integer yOrg)
>>>X11CanvasPane::attachTo (Object parent_pane, Integer xOrg, Integer yOrg, Integer xSize, Integer ySize)
Attach a X11CanvasPane object to its parent pane, which is
typically a X11PaneDispatcher object.  With one argument, this
method initializes the size of the pane's window and buffers to
the parent pane's dimensions, and positions the pane at the upper left-hand
origin of the main window.

If two arguments are present, the second is a String with the
geometry specifcation for the subpane.  Subpane geometry strings have
the form:

---------------------------------------------------------
  
  width[%]xheight[%]+x[%]+y[%]
  
---------------------------------------------------------

The dimensions are in pixels, unless a percent sign ('%') follows
a dimension.  In that case, the dimension is a fractional percentage
of the parent pane's width or height.  The String may contain a
combination of absolute and relative dimensions.

With three arguments, the method positions the pane at
xOrg,yOrg within the parent pane, which usually is
relative to the upper left hand origin of the window.

With five arguments, the method positions the pane at
xOrg,yOrg within the parent pane, with the width and
height xSize,ySize.

>>>X11CanvasPane::background (String color)
Set the background of the pane to color.  You need to
update the pane using, for example, clearRectangle, for
the new background to be visible.
See the note for
X11Bitmap class's background method.


>>>X11CanvasPane::clear (void)
Clear the pane to the background color.

>>>X11CanvasPane::clearRectangle (Intger xOrg, Integer yOrg, Integer xSize, Integer ySize)
Clear the pane's image to the window background in a rectangle bounded
by the method's arguments, and update the top-level pane's window.

>>>X11CanvasPane::copy (X11Bitmap src_bitmap, Integer src_x_ort, Integer src_y_org, Integer src_width, Integer src_height, Integer dest_x_org, Integer dest_y_org)
Copies the contents of src_bitmap to the receiver's drawing surface.
The source dimensions are determined by src_x_org, src_y_org,
src_width, and src_height.  The method draws the source 
bitmap's contents with the source's upper left-hand corner at dest_x_org,
dest_y_org.

The X11Bitmap's parent drawable must be the receiver's drawable
surface, and the color depths of the source and destination must match.

The process is similar to the refresh method, below, so programs
do not need to call both copy and refresh for the same operation.

This slightly abbreviated example program is included in the Ctalk
package at test/expect/examples-x11/canvas-copy.c as well as the XPM
graphic, but almost any XPM should work as well.

---------------------------------------------------------
  #include "coffee-cup.xpm"
  
  /* 
     Set these to the width and height of your pixmap,
     and edit the pixmapFromData expression below to
     the xpm's declaration name. 
  */
  #define XPM_WIDTH 127
  #define XPM_HEIGHT 141
  
  X11CanvasPane instanceMethod drawXPMs (X11Bitmap xpmBitmap) {
    Integer new i;
  
    for (i = 0; i < 5; i++) {
      self copy xpmBitmap, 0, 0, XPM_WIDTH, XPM_HEIGHT, (i* 40), (i * 40);
    }
  
    self refresh;
  }
  
  int main () {
    X11Pane new xPane;
    InputEvent new e;
    X11PaneDispatcher new xTopLevelPane;
    X11CanvasPane new xCanvasPane;
    Application new paneApp;
    X11Bitmap new srcBitmap;
  
    paneApp enableExceptionTrace;
    paneApp installExitHandlerBasic;
  
    xPane initialize 10, 10, 300, 300;
    xTopLevelPane attachTo xPane;
    xCanvasPane attachTo xTopLevelPane;
  
    srcBitmap create xCanvasPane xWindowID, XPM_WIDTH, XPM_HEIGHT, 
      xCanvasPane depth;
  
    xPane map;
    xPane raiseWindow;
    xPane openEventStream;
  
    xCanvasPane background "white";
  
    srcBitmap pixmapFromData (0, 0, coffee_cup);
  
    xCanvasPane drawXPMs srcBitmap;
  
    while (TRUE) {
      xPane inputStream queueInput;
      if (xPane inputStream eventPending) {
        e become xPane inputStream inputQueue unshift;
        /* We don't have to use, "xPane subPaneNotify e" here, because
           the program doesn't need to handle any X events for the
           graphics classes. */
        switch (e eventClass value)
          {
          case WINDELETE:
            xPane deleteAndClose;
            exit (0);
            break;
          case EXPOSE:
          case RESIZENOTIFY:
  	  xCanvasPane drawXPMs srcBitmap;
            break;
          default:
            break;
          }
      }
      usleep (100000);
    }
  }
  
---------------------------------------------------------

Note: The copy method retrieves the paneBuffer
instance variable.  If you use an expresion like the following,
then the program calls the X11Bitmap : copy method instead.


---------------------------------------------------------
  
    myRcvrPane paneBuffer copy ...
  
---------------------------------------------------------


>>>X11CanvasPane::defineRegion (String regionName, Integer xOrg, Integer yOrg, Integer xSize, Integer ySize)
Define a rectangular region with name regionName with the upper
left-hand corner at xOrg, yOrg relative to the upper left-hand
corner of the canvas. The region has the width xSize and height 
ySize.  When handling input events, the window system clips the
region to the canvas' viewable area.

>>>X11CanvasPane::drawCircle (Circle aCircle, Integer filled, String bgColor)
>>>X11CanvasPane::drawCircle (Circle aCircle, Pen aPen, Integer filled, String bgColor)
Draw the circle defined by aCircle in the receiver's paneBuffer.
If filled is true, draws a filled circle.  If the aPen
argument is given, draws the circle with the color and the line width
defined by the Pen, and fills the interior of the circle with
bgColor.

For an example program, refer to the Circle section of this
manual. 

>>>X11CanvasPane::drawPoint (Intger x, Integer y)
Draw a dot on the pane's window at the x and y coordinates
given by the arguments.

>>>X11CanvasPane::drawLine (Line aLine)
>>>X11CanvasPane::drawLine (Line aLine, Pen aPen)
>>>X11CanvasPane::drawLine (Intger startX, Integer startY, Integer endX, Integer endY)
>>>X11CanvasPane::drawLine (Intger startX, Integer startY, Integer endX, Integer endY, pen aPen)
With one argument, a Line object, draws the line using the receiver's
Pen instance variable. With two arguments, draws the Line object
with the color and line width given by aPen.

If given the line's endpoints as arguments, the method draws a line on
the pane's window from the point given by the startX and
startY arguments to the point given by the endX and
endY arguments, with the color and the line width given
by the receiver's Pen object.

>>>X11CanvasPane::drawLine (Intger xOrg, Integer yOrg, Integer xSize, Integer ySize)
Draw a filled rectangle on the pane's window with the upper-left
hand corner at the point given by the xOrg and
yOrg arguments, with the width xSize and the
height ySize.  If a Pen argument isn't given, uses the
line width and color defined by the receiver's pen instance
variable; otherwise uses the line width and color defined by the
Pen argument.

>>>X11CanvasPane::drawRoundedRectangle (Intger xOrg, Integer yOrg, Integer xSize, Integer ySize, Integer radius)
Similar to drawFilledRectangle, but this method takes an extra
argument, the radius of the corner arcs that round the rendered rectangle's
corners.

>>>X11CanvasPane::drawRectangle (Intger xOrg, Integer yOrg, Integer xSize, Integer ySize)
Draw the borders of a rectangle on the pane's window with
the upper-left hand corner at the point given by the
xOrg and yOrg arguments, with the width
xSize and the height ySize.

>>>X11CanvasPane::drawRoundedRectangle (Intger xOrg, Integer yOrg, Integer xSize, Integer ySize, Integer radius)
This method is similar to drawRectangle, except that it takes an
extra argument, radius, which specifies the radius of the arcs
that form the rectangle's corners.

>>>X11CanvasPane::directCopy (X11Bitmap src_bitmap, Integer src_x_ort, Integer src_y_org, Integer src_width, Integer src_height, Integer dest_x_org, Integer dest_y_org)
Similar to the copy method, above, except directCopy
copies the X11Bitmap object given as its argument directly
to the window.  This might be quicker, and doesn't require that
the program call refresh (below) to update the window
contents, but this method may also cause flickering when the
window is updated. 

>>>X11CanvasPane::foreground (String color)
Set the background of the pane to color.
See the note for
X11Bitmap class's background method.


>>>X11CanvasPane::new (String pane_name)
Create a new X11CanvasPane instance and initialize
its event handlers.

If the argument list contains more than one label, create
a new X11CanvasPane object with the names given by
the arguments; for example,

---------------------------------------------------------
  
  X11CanvasPane new pane1, pane2, pane3;
  
---------------------------------------------------------

>>>X11CanvasPane::pixmapFromData (int x_org, int y_org, char *xpm_data[])
Draw the X pixmap defined by xpm_data with the upper left 
corner at x_org,y_org on the receiver's pane.

The xpm_data argument is the name of the array declared at the 
start of a xpm file's data array.

>>>X11CanvasPane::refresh (void)
Redraw the pane on the main window.

>>>X11CanvasPane::refreshReframe (void)
Redraw the pane on the main window.  If the user has moved the pane
by clicking and dragging on it, then reposition the pane within the window.

>>>X11CanvasPane::putStrXY (Integer xOrg, Integer yOrg String text)
>>>X11CanvasPane::putStrXY (Integer xOrg, Integer yOrg String text, String font_desc)
>>>X11CanvasPane::putStrXY (Integer xOrg, Integer yOrg String text, String font_desc, String color_name))
Write text on the receiver pane's drawing surface (usually a X11Bitmap)
at position xOrg,yOrg.  

If the fourth argument is font_desc, the method draws the text
using that font.  If a color_name argument is also given, draws
the text using that color.

>>>X11CanvasPane::subPaneDestroy (Object subPaneRef, InputEvent event)
Deletes the pane's window and its data when the user closes the 
pane's window.

>>>X11CanvasPane::subPaneExpose (Object subPaneRef, InputEvent event)
Redraws the pane's window whenever it is mapped or displayed after
being covered by another window.

>>>X11CanvasPane::subPanePointerInput (Object subPaneRef, InputEvent event)
Default handler for mouse ButtonPress and ButtonRelease events.  This
method is a no-op here, but it can be re-implemented if necessary by
subclasses.  The application receives pointer events, like all other
events, via the top-level window's inputStream (a
X11TerminalStream object).

>>>X11CanvasPane::subPaneResize (Object subPaneRef, InputEvent event)
The handler for Resize events from the X display.  Resizes the pane's 
X window and adjusts the pane's dimensions.



>>>X11ScrollBarPane::attachTo (Object parentPane)
Attaches the X11ScrollBarPane object to its parent pane,
which is usually a X11PaneDispatcher object.  Also sizes the
pane and its buffers to fit within the visible window, and sets the
dimensions of the scrollbar's visible frame and thumb.

>>>X11ScrollBarPane::background (String colorName)
Sets the pane's background color to colorName, and also sets
the color to use when performing scrollbar animations.

>>>X11ScrollBarPane::drawThumb (void)
>>>X11ScrollBarPane::eraseThumb (void)
These methods animate the thumb so that it tracks the pointer's
position within the scrollbar.

>>>X11ScrollBarPane::frameWidth (Integer lineWidth)
Calculates the scrollbar frame's dimensions within the pane's margins
for the line width in pixels given as the argument.

>>>X11ScrollBarPane::new (String paneName)
Creates a new X11ScrollBarPane object, initializes the pane's
event handlers, and sets the default colors of the pane's elements.

>>>X11ScrollBarPane::percent (void)
Returns a Float with the position of the thumb's top edge
in the usable trough of the scrollbar, as a percentage between 0.0
and 1.0.

The usable area of the trough is defined as the distance that the
top edge of the scrollbar thumb can travel within the scrollbar's
margins; i.e,

---------------------------------------------------------
  
  usableTrough = aScrollBar size y -
                    ((aScrollBar margin * 2) +
                     (aScrollBar frameWidthVar * 2) +
                     (aScrollBar padding * 2) +
                     (aScrollBar thumbHeight));
  
---------------------------------------------------------

>>>X11ScrollBarPane::pointIsInThumb (Integer x, Integer, y)
This method returns a Boolean value of true if the point
x,y is within the scroll bar thumb.

>>>X11ScrollBarPane::subPaneDestroy
>>>X11ScrollBarPane::subPaneExpose
>>>X11ScrollBarPane::subPanePointerInput
>>>X11ScrollBarPane::subPanePointerMotion
>>>X11ScrollBarPane::subPaneEnterNotify
>>>X11ScrollBarPane::subPaneLeaveNotify
The X11ScrollBarPane object's event handlers for DESTROY,
EXPOSE, BUTTONPRESS/BUTTONRELEASE, MOTIONNOTIFY, ENTERWINDOWNOTIFY,
and LEAVEWINDOWNOTIFY X Window System events.

>>>X11ScrollBarPane::thumbDimensions (Integer y, Integer height)
Calculates the position and size thumb's rectangle within the pane using the vertical y position and the thumb's height.

>>>X11ScrollBarPane::thumbPercent (Float pct)
Calculates the thumb's height as a percent of the trough's vertical distance.
The argument, pct, is a Float between 0.0 and 1.0.

Note that, in order to make these calculations and update the thumb height in
the pane's viewing area, the scrollbar must already be attached to its parent
pane, and the program needs to be receiving X events.  So this method should
only be used after a call to, for example, X11Pane : openEventStream.


>>>X11TextPane::addText (Object text)
Adds the argument's text to the receiver pane's text instance
variable, then word-wraps the entire text into the textList instance
variable.

>>>X11TextPane::attachTo (Object parentPane)
Attaches the X11TextPane object to its parent pane.
The parent pane should always be a X11PaneDispatcher
object.  

>>>X11TextPane::cursorPos (Integer x, Integer y)
Set the pane's cursor to the coordinates given as arguments.

>>>X11TextPane::background (String colorname)
Set the background color of the text pane.  See the note for
X11Bitmap class's background method.


>>>X11TextPane::clear (void)
Clear the pane to the background color.

>>>X11TextPane::displayText (void)
Update the pane's text.  The pane's window is updated at the 
next refresh message (see below).

>>>X11TextPane::faceRegular (void)
>>>X11TextPane::faceBold (void)
>>>X11TextPane::faceItalic (void)
>>>X11TextPane::faceBoldItalic (void)
Selects the typeface of the currently selected font.  The font
should be selected by a previous call to the font method
(below).  The font call gathers information about the
type variations if the typeface is available.

>>>X11TextPane::font (String font_descriptor)
Loads the bitmap font named by font_descriptor and the bold,
italic, and bold italic typefaces if they are available, and makes the
font named by the argument the currently selected the receiver Pane's
currently selected font.

If a program uses outline fonts, it has more freedom to decide when to
select the fonts, because the font libraries operate independently of
the program's connection to the GUI. 

Programs that use Xlib bitmap fonts, however, need to wait until the
connection to the GUI is opened, with a call to openEventStream
(class X11Pane). 

Here's a code snippet from X11TextPane class.

---------------------------------------------------------
  
    X11FreeTypeFont new ftFont;
    Integer new ftMaxCharWidth;
    
    self fontDescStr = fontDesc;
    self fontVar getFontInfo fontDesc;
    (X11Bitmap *)self paneBuffer font fontDesc;
  
    if (ftFont libIsInitialized) {
      self lineHeight = ftFont textHeight "ghyl";
      self lineHeight += self leading;
      ftMaxCharWidth = ftFont textWidth "M";
      self viewWidth = self size x / ftMaxCharWidth;
    } else {
      /* Note that we don't add the leading to the lineHeight here */
      self lineHeight = self fontVar height;
      self viewWidth = self size x / self fontVar maxWidth;
    }
    self viewHeight = self size y / self lineHeight;
  
---------------------------------------------------------

>>>X11TextPane::foreground (String colorname)
Set the forground color of the text pane.
See the note for
X11Bitmap class's foreground method.


>>>X11TextPane::gotoXY (Integer x, Integer y)
Set the pane's cursor to the coordinates given as arguments.
The coordinates are the number of horizontal and vertical
pixels from the pane's top-left corner.

This method is a synonym for cursorPos, above.

>>>X11TextPane::new (String paneName)
Creates a X11TextPane object and initializes the
pane's event handlers and other instance data.

If the argument list contains more than one name, create
X11TextPane objects with the names given by the arguments.

>>>X11TextPane::printOn (char *fmt, ...)
Print the argument, which is a printf(3) style format string
with arguments for the format conversion specifiers, in the pane's
buffer at the position given by the pane's software cursor.  To update
the visible window with the pane buffer's contents, call the
refresh method (below), after calling this function.

>>>X11TextPane::putChar (Character c)
Write a character in the pane's window at the pane's cursor
position. 

>>>X11TextPane::putStr (String s)
Write a string in the pane's window at the pane's cursor
position. 

>>>X11TextPane::refresh (void)
Update the text displayed in the pane's window.

>>>X11TextPane::subPaneDestroy (Object subPaneReference, InputEvent event)
The class's destructor method.  This method deletes only the
data associated with the pane object's window, not the pane
object itself, which is treated like any other object.  

>>>X11TextPane::subPaneExpose (Object subPaneReference, InputEvent event)
The class's EXPOSE event handler.  Refreshes the main window from 
the pane's text buffer.

>>>X11TextPane::subPaneKbdInput (Object subPaneReference, InputEvent event)
The handler for KEYPRESS and KEYRELEASE events from the
window system.

>>>X11TextPane::subPaneResize (Object subPaneReference, InputEvent event)
The handler for RESIZENOTIFY events from the window system.

>>>X11TextEditorPane::attachTo (Object parent_pane)
Attach a X11TextEditorPane object to its parent pane, which is
typically a X11PaneDispatcher object.  This method initializes
the size of the pane's window and buffers to the parent pane's
dimensions, and positions the pane at the upper left-hand origin of
the main window.

>>>X11TextEditorPane::background (String colorName)
>>>X11TextEditorPane::foreground (String colorName)
Sets the foreground and backgrounds color of the pane's window and
buffers.

>>>X11TextEditorPane::clearSelection (void)
Sets the sStart and sEnd instance variables to '0',
cancelling text selection.

>>>X11TextEditorPane::defaultFormat (void)
Sets the document-wide margins and text text colors.  If the pane is
using an X11FreeTypeFont object to render text, the font needs
to be configured before calling this method.  

>>>X11TextEditorPane::displayText (void)
Displays the text and editing cursor.  Programs should call this
method as soon as possible after the program starts the X event loop
(which it does by calling the @code{X11TerminalStream :
openEventStream} method), and after every editing operation.

>>>X11TextEditorPane::gotoChar (Integer n)
Sets the point instance variable to the n'th character in
the text.  If n is greater than the length of the text, sets
point to the end of the text.

>>>X11TextEditorPane::new (String paneName)
Initializes the X11TextEditorPane object's event handlers, and
calls constructors in the X11TextEditorPane's superclasses to
perform addition initialization.  The method attachTo, declared
in X11TextPane class, performs the actual dimensioning of the
pane and its buffers. 

>>>X11TextEditorPane::subPaneKbdInput (X11TextEditorPane subPane, InputEvent event)
Handles Keypress and KeyRelease events from the X server.  It's
possible to reconfigure the editing commands by modifying this method.

The method works in conjuction with the Ctalk library's editing
functions to translate alphanumeric and punctuation characters with
the correct shift and control state, and to transmit special keys like
arrow keys and Home/End keys untranslated.

>>>X11TextEditorPane::subPaneButtonPress (X11TextEditorPane subPane, InputEvent event)
The handler for button press and button release events.  This method
sets the value of the button instance variable, in addition
to performing other tasks.

>>>X11TextEditorPane::subPaneMotionNotify (X11TextEditorPane subPane, InputEvent event)
The handler method for pointer motion events.

>>>X11TextEditorPane::subPaneResize (X11TextEditorPane subPane, InputEvent event)
Handles resizing the X11TextEditor pane's dimensions in response
to a window resize event.  This method is a no-op in the current release.

>>>X11TextEditorPane::subPaneSelectionClear (X11TextEditorPane subPane, InputEvent event)
Updates the program's state after receiving a a SelectionClear event.
Normally this occurs when another program requests the X primary
selection.  The method updates this program's state so that it is
no longer selecting, and redraws the text.



@subsubheading Example Text Editing Program
---------------------------------------------------------
  /*
    ctedit.ca - Basic text editor using X11TextEditorPane class.
  
    Usage:
  
      ctedit [<options>] <filename>
  
    Typing, "ctedit -h" displays a list of options.
  
    Pressing Esc or selecting "Close" from the window menu
    exits the program and saves the edited text.
    
    If <filename> exists, ctedit renames the previous version
    of the file to <filename>.bak.  If <filename> doesn't
    exist, ctedit creates a new file.
  
    The editing commands are set in the X11TextEditorPane :
    handleKbdInput method.  They are:
  
       Right, Ctrl-F       Next character
       Left, Ctrl-B        Previous character
       Up, Ctrl-P          Previous line
       Down, Ctrl-N        Next line
       PgDn, Ctrl-V        Next page
       PgUp, Ctrl-T        Previous page
       Home, Ctrl-A        Start of line
       End, Ctrl-E         End of line
       Ctrl-Q              Start of text
       Ctrl-Z              End of text
       Ctrl-D              Delete character under cursor
       Backspace           Delete previous character
       Del                 At the end of the text, delete the
                           previous character.  Otherwise delete
                           the character under the cursor.
       Esc                 Close the window, save the edited text,
                           and exit the program.
   */
  
  #define WIN_WIDTH 500
  #define WIN_HEIGHT 340
  #define WIN_X 25
  #define WIN_Y 30
  #define FIXED_FONT "fixed"
  #define DEFAULT_BG "white"
  #define DEFAULT_FG "black"
  #define DEFAULT_FT_FONT "DejaVu Sans Mono"
  #define DEFAULT_FT_PTSIZE 12.0
  
  Application new ctEdit;
  String new geomString;
  String new infileName;
  String new xFontName;
  String new ftFontName;
  Float new ftFontSize;
  String new bgColor;
  String new fgColor;
  
  Boolean new createFile;
  
  Boolean new useFtFonts;
  X11FreeTypeFont new ftFont;
  Boolean new useXFont;
  
  void exit_help () {
    printf ("usage: ctedit [-h] | [-g <geom>] [-fg <color>] "
  	  "[-bg <color>] [-fn <font> ] <filename>\n");
    printf ("-bg <color>    Set the window background to <color>.\n");
    printf ("-fg <color>    Display the text using <color>.\n");
    printf ("-fn <font>     Use the X <font> to display the text. See xfontsel(1).\n");
    printf ("-ft <font>     Use the FreeType <font> to display the text. See\n");
    printf ("               X11FreeTypeFont class.\n");
    printf ("-g  <geom>     Set the window geometry to <geom>. See XParseGeometry (3).\n");
    printf ("-h             Print this message and exit.\n");
    printf ("-xfonts        Use X bitmap fonts, even if outline fonts are available.\n");
    exit (1);
  }
  
  /* UNIX-compatible line ending. */
  #define LF 10
  
  X11TextEditorPane instanceMethod writeOutput (String infileName) {
    "Create a backup of the previous version of the file, if any,
     and check that the text ends with a UNIX-standard newline
     (ASCII 10) character."
    WriteFileStream new writeFile;
    Character new c;
  
    c = self text at (self text length - 1);
    if (c != LF) {
      self text += "\n";
    }
    
    if (!createFile)
      writeFile renameFile infileName, infileName + ".bak";
    writeFile openOn infileName;
    writeFile writeStream (self text);
    writeFile closeStream;
  
  }
  
  Application instanceMethod commandLineOptions (void) {
    Integer new i, nParams;
    String new param;
  
  
    nParams = self cmdLineArgs size;
    for (i = 1; i < nParams; i++) {
  
      param = self cmdLineArgs at i;
  
      if (param  == "-g") {
        ++i;
        geomString = self cmdLineArgs at i;
        continue;
      }
      if (param == "-fn") {
        ++i;
        xFontName = self cmdLineArgs at i;
        continue;
      }
      if (param == "-bg") {
        ++i;
        bgColor = self cmdLineArgs at i;
        continue;
      }
      if (param == "-fg") {
        ++i;
        fgColor = self cmdLineArgs at i;
        continue;
      }
      if (param == "-ft") {
        ++i;
        ftFontName = self cmdLineArgs at i;
        continue;
      }
      if (param == "-xfonts") {
        useXFont = True;
        continue;
      }
      if (param == "-pt") {
        ++i;
        ftFontSize = (self cmdLineArgs at i) asFloat;
        continue;
      }
      if (param == "-h" || param == "--help" || param == "--h" ||
  	param at 0 == '-') {
        exit_help ();
      }
      
      infileName = param;
  
    }
  
  }
  
  Application instanceMethod winDimensions (void) {
    if (geomString length > 0) {
      self parseX11Geometry geomString;
      if (self winWidth == 0) {
        self winWidth = WIN_WIDTH;
      }
      if (self winHeight == 0) {
        self winHeight = WIN_HEIGHT;
      }
      if (self winXOrg == 0) {
        self winXOrg = WIN_X;
      }
      if (self winYOrg == 0) {
        self winYOrg = WIN_Y;
      }
    } else {
      self winWidth = WIN_WIDTH;
      self winHeight = WIN_HEIGHT;
      self winXOrg = WIN_X;
      self winYOrg = WIN_Y;
    }
  }
  
  Application instanceMethod findFtFonts (void) {
  
    if (useFtFonts && !useXFont) {
      ftFont initFontLib;
      ftFont selectFont ftFontName, 0, 80, 72, ftFontSize;
      ftFont namedX11Color fgColor;
    }
    
  }
  
  int main (int argc, char **argv) {
    X11Pane new xPane;
    X11PaneDispatcher new xTopLevelPane;
    X11TextEditorPane new xEditorPane;
    InputEvent new e;
    Exception new ex;
    X11Cursor new watchCursor;
    ReadFileStream new readFile;
    String new winTitle;
  
    geomString = "";
    xFontName = FIXED_FONT;
    bgColor = DEFAULT_BG;
    fgColor = DEFAULT_FG;
    infileName = "";
    useFtFonts = True;
    useXFont = False;
    ftFontSize = DEFAULT_FT_PTSIZE;
    ftFontName = DEFAULT_FT_FONT;
  
    ctEdit parseArgs argc, argv;
    ctEdit commandLineOptions;
    ctEdit winDimensions;
  
    if (ftFont version < 10) {
      useFtFonts = false;
    } else {
      ctEdit findFtFonts;
    }
    
  
    if (infileName length == 0) {
      exit_help ();
    }
  
    if (!readFile exists infileName) {
      createFile = true;
      winTitle = infileName + "   (New file)";
    } else {
      readFile openOn infileName;
      xEditorPane text = readFile readAll;
      readFile closeStream;
      winTitle = infileName;
      createFile = false;
    }
  
    xPane initialize ctEdit winXOrg, ctEdit winYOrg,
      ctEdit winWidth, ctEdit winHeight, ctEdit geomFlags, winTitle;
  
    xTopLevelPane attachTo xPane;
    xEditorPane attachTo xTopLevelPane;
    xPane map;
    xPane raiseWindow;
    watchCursor watch;
  
    xPane openEventStream;
  
    /* This sets the maximum line width to the width of the window. */
    xEditorPane lineWidth = 0;
  
    if (!useFtFonts || useXFont) {
      xEditorPane foreground fgColor;
      xEditorPane font xFontName;
      xEditorPane defaultFormat;
    } else {
      xEditorPane defaultFormatFT ftFont;
    }
  
    xEditorPane background bgColor;
    xEditorPane clear;
  
    xPane defaultCursor;
  
    while (TRUE) {
      xPane inputStream queueInput;
      if (xPane inputStream eventPending) {
        e become xPane inputStream inputQueue unshift;
        xPane subPaneNotify e;
        if (ex pending)
   	ex handle;
        switch (e eventClass value) 
  	{
  	  /*
  	   *  Handle both types of events in case the window
  	   *  manager doesn't distinguish between them.
  	   */
  	case MOVENOTIFY:
  	  break;
  	case RESIZENOTIFY:
  	  break;
  	case EXPOSE:
  	  xEditorPane displayText;
  	  break;
  	case WINDELETE:
  	  xEditorPane writeOutput infileName;
   	  xPane deleteAndClose;
  	  exit (0);
  	  break;
  	default:
  	  break;
  	}
      } else {
        if (xEditorPane requestClose) {
  	xEditorPane writeOutput infileName;
  	xPane deleteAndClose;
  	exit (0);
        }
      }
    }
  }
---------------------------------------------------------





>>>Symbol::* (void)
The *. A shortcut for the getValue method, below.

>>>Symbol::= (void *v)
Assign a reference to the argument as the value of the
receiver.  If v is also a Symbol object, simply
copy the reference.  This method is a synonym for
symbolReference, below.  If you want to use multiple
levels of object references and dereferences, see the
addressOf method in Object class 
and the deref method, below.

>>>Symbol::asAddrString (void)
Returns a String object with the formatted hexadecimal
address of the object pointed to by the receiver.

>>>Symbol::asString (void)
Returns the receiver's value as a String object with the value
of the char string that the Symbol receiver object
points to.  The result object has the same name as the receiver and
the class of String.

>>>Symbol::basicObject (char *name, char *classname, char *superclassname, char *value_expr)
Create a basic object and make the receiver's value point to it.  The
new object has the scope 'LOCAL_VAR|VAR_REF_OBJECT' and a
reference count of 1.

Referencing the object with a Symbol makes it easy to create
objects and then assign them to C variables in the calling method
or function. For example,

---------------------------------------------------------
  
    Symbol new s;
    OBJECT *int_object;
  
    s basicObject "new_int", "Integer", "Magnitude", "10";
  
    int_object = s getValue;
  
    printf ("%d\n", int_object value);
  
---------------------------------------------------------

>>>Symbol::deref (void)
Return the object referred to by the receiver. This method
is functionally equivalent to the C '*' operator.

>>>Symbol::getValue (void)
Return the object that the receiver's value (previously set by =
or symbolReference) refers to.  If the address doesn't refer to
an object, returns the receiver and generates an exception, which the
program can handle in whatever manner is necessary.  In some cases,
the internals of Ctalk's object-to-C routines can also generate an
warning message.

Note that when assigning a non-object data address to a C variable
like a void *, Ctalk allows both of these expressions:

---------------------------------------------------------
  
   void *myVoidPtr;
  
   myVoidPtr = mySymbol;
  
   myVoidPtr = *mySymbol;   /* Generates an exception. */
  
---------------------------------------------------------

>>>Symbol::name (void)
Return a new String object containing the receiver's name.

>>>Symbol::removeValue (void)
Remove the reference to the target object from the receiver. Delete
the target object if there are no further references to it.

>>>Symbol::symbolReference (void *v)
Return a new String object containing the receiver's name.




>>>Key::+ (Integer n)
Increments the receiver by n.  For a Key object, this
sets the receiver to the nth successive element in a collection.
The increments are numbered with '1' pointing to the first member
of the collection, and so on.  If there are no more elements, the
receiver's value is NULL.  For an example, refer to -, below.

>>>Key::++
Increments the receiver to point to the next Key in a
collection.  If the receiver is already the last item item in the
collection, the value of the receiver after it is incremented is NULL.
This method works as both a prefix and postfix method, and increments
the receiver either before or after it is referenced, respectively.

Here is an example of how to iterate over an AssociativeArray using
++.

---------------------------------------------------------
  
    AssociativeArray new a;
    Key new k;
  
    a atPut "key1", "value1";
    a atPut "key2", "value2";
    a atPut "key3", "value3";
    a atPut "key4", "value4";
  
    k = *a;
  
    while (++k)
      printf ("%s --> %s\n", k name, *k);
  
---------------------------------------------------------

>>>Key::- (Integer n)
Decrements the receiver by n.  For a Key object,
this sets the receiver to the nth previous element of
the collection that the receiver is a member of.  Here is
a brief example

---------------------------------------------------------
  
  int main () {
  
    AssociativeArray new a;
    Key new k;
  
    a atPut "1", "value1";
    a atPut "2", "value2";
    a atPut "3", "value3";
    a atPut "4", "value4";
  
    k = *a;
    printf ("%s --> %s\n", k name, *k);
    k = k + 3;
    printf ("%s --> %s\n", k name, *k);
    k = k - 1;
    printf ("%s --> %s\n", k name, *k);
  }
  
---------------------------------------------------------

Running this program produces the following output.

---------------------------------------------------------
  
  1 --> value1
  4 --> value4
  3 --> value3
  
---------------------------------------------------------

>>>Key::--
Decrements the receiver to point to the previous Key in a
collection. If the receiver is the first item in the collection, the
value of the receiver after it is decremented is NULL.  Like ++,
this method works as both a prefix and postfix method, and decrements
the receiver either before or after it is referenced, respectively.

>>>Key::=
If the receiver refers to an object reference (that is, preceded by a
'*' operator), sets the value of the receiver to the address of
the argument.  Otherwise, sets the receiver to refer to the argument.

>>>Key::getKeyObject (void)
Return the receiver.

>>>Key::setName (char *key_name)
Set the receiver's name to the argument, a String object.

Note: In some cases, the object's name is the only way that
Ctalk can refer to it.  In that case, the program needs to maintain an
alias to the object, like an OBJECT *, so that it can refer to
the object later.  In the following example, the program can refer to
keyObject by using key_alias_ptr, regardless of the
object's name.
---------------------------------------------------------
  Key new keyObject;
  OBJECT *key_alias_ptr;
  ...
  key_alias_ptr = KeyObject setName keyNameString;
---------------------------------------------------------

>>>Key::ulink (void)
Detach the receiver object from its parent collection.  The
method also removes the OBJECT_IS_MEMBER_OF_PARENT_COLLECTION
attribute from the receiver.




>>>Vector::+ (Vector v)
Return a Vector object that is the concatenation
of the receiver and the argument.

>>>Vector::+= (Vector v)
Concatenate the receiver with the vector given as the argument.

>>>Vector::asString (void)
Returns the value of the receiver as a String object terminated
with a NUL byte to the value of the receiver's length instance
variable.  Does not check for NULs or non-printing characters in the
value, so the returned String may still be truncated to less
than the receiver's length.

>>>Vector::basicNew
>>>Vector::basicNew (char *name, char *classname, char *superclassname, char *value, int value_length)
Create a new Vector object with the name, contents, length,
and, optionally, class name and superclass name given as the
arguments.  

For the five-argument form of basicNew, the class should be
Vector and the superclassname should be Symbol, unless
the program has subclassed Vector.  

In the three-argument form, the receiver must be a member of
Vector class or its subclasses, in which case the method takes
the class and superclass from the receiver, as in this example.

---------------------------------------------------------
  
  myBuf = Vector basicNew "memorybuf", memory_buf_ptr, memory_buf_length;
  
---------------------------------------------------------

The value argument may be any memory address that points to data
of arbitrary size, and may contain any data, including NULL bytes.

The value_length argument supplies the length of the memory
segment in bytes, which the returned Vector object stores in
its length instance variable.

Most of the internal work of setting the values and attributes of the
returned object, and registering the memory area, is performed by
__ctalkSetObjectValueAddr, which each of these methods call.


It's also necessary that these methods take care of other initialization
tasks which are necessary for all classes of objects.  They're described
in general in the description of basicNew (Object class).


>>>Vector::contains (String pattern)
>>>Vector::contains (String pattern, Integer start_offset)
With one argument, returns an Integer with the byte offset of
the first occurence of pattern in the receiver, starting from
the beginning of the receiver's value, or -1 if the pattern is not
found.

If a second argument is given, it contains the Integer offset
into the buffer where the method begins its search.  That allows
programs to find multiple matches of the same pattern in the
receiver's value.


