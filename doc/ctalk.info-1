This is ctalk.info, produced by makeinfo version 6.5 from ctalk.texi.

INFO-DIR-SECTION Ctalk
START-INFO-DIR-ENTRY
* ctalk: (ctalk).	The Ctalk language reference manual.
END-INFO-DIR-ENTRY

This file documents Ctalk version 0.0.66.

Copyright (C) 2007-2015 Robert Kiesling

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled, "GNU
Free Documentation License."


File: ctalk.info,  Node: Top,  Prev: (dir),  Up: (dir)

Ctalk Language Reference
************************

This document describes the Ctalk programming language, version 0.0.66.

* Menu:

* Invoking::                          Command line options.
* Classes::                           The Ctalk class library.
* Methods::                           How to use and implement methods.
* C::                                 C language implementation.
* Copying::                           Ctalk is free software.
* GNU Free Documentation License::    Copying and distributing this manual.
* Index::


File: ctalk.info,  Node: Invoking,  Next: Classes,  Prev: Top,  Up: Top

Invoking Ctalk
==============

Ctalk has two parts: a preprocessor and interpreter that translates
Ctalk code into C, which a compiler can use to create an executable
program, and a run-time library, which the compiler links with the
executable.

Ctalk has its own C99 compatible preprocessor, 'ctpp,' which is
described in its Texinfo manual, 'ctpp.info'.

To use 'ctalk,' you must provide at least the name of the input file.
Normally, you also provide the name of the output file with the '-o'
option.  If you use the conventions followed by GNU C, the output file
is normally the base name of the input file with the extension '.i', as
in this example.

     $ ctalk myprog.c -o myprog.i

The 'ctalk' program preprocesses 'myprog.c' and translates it into
standard C. After 'ctalk' has finished, you can compile and link the
output of 'ctalk' to produce an executable program.

     $ gcc myprog.i -o myprog -lctalk

More conveniently, the 'ctcc' command combines these operations, with
the appropriate command line options, to build an executable program.
     $ ctcc myprog.c -o myprog

If you need to build a program for debugging, the 'ctdb' command builds
executables that you can debug with 'gdb'.  *Note Debugging::.

For more information, refer to the 'ctalk(1),' 'ctcc(1),' 'ctdb(1),'
'gcc(1),' and 'gdb(1)' manual pages.

Command Line Options
====================

'--clearpreload'
     Clear preloaded methods so they can be rewritten.

'-E'
     Preprocess the input and exit.

'-h, --help'
     Print a help message and exit.

'-I DIR'
     Add DIR to the 'ctalk' include search path.

'--keeppragmas'
     Write pragmas untranslated to the output.

'--nolibinc'
     Do not include Ctalk's system headers in the output.

'--nopreload'
     Do not use preloaded methods.

'-o FILE'
     Write the 'ctalk' output to FILE.

'--printlibdirs'
     Print the library directories and exit.

'--printtemplates'
     Print the templates that Ctalk loads and caches (but does not
     necessarily send to the output).

'--progress'
     Print dots to indicate Ctalk's progress.

'-P'
     Do not output line number information.

'-s DIR'
     Add DIR to the compiler system include search path.

'-V'
     Print the Ctalk version number and exit.

'-v'
'--verbose'
     Print verbose warnings.  This option also sets the
     '--warnextension', '--warnduplicatenames' and
     '--warnunresolvedselexpr' options.

'--warnclasslibs'
     Print the names of class libraries as they are loaded.

'--warnduplicatenames'
     Print a warning when an object duplicates a C variable name.
     Because of the way Ctalk's just-in-time interpreter works, the
     front end prints warnings of any duplicate names.  The variables
     and objects need not be in the same scope.  Usually, though, Ctalk
     can make an intelligent decision about how to process objects and
     variables with duplicate names.  This option does not affect errors
     caused by duplicate symbols or shadowing.

'--warnextension'
     Print warnings for some compiler extensions.

'--warnunresolvedselfexpr'
     Prints warnings if 'self' appears in an argument block with either
     an instance variable label or an unresolvable method label
     following it.  In expressions like these, the class of each element
     of a collection, when represented by 'self' within the argument
     block, often can't be determined until run time.

     You can specify a class for 'self' by placing a class cast
     expression (described in the section 'Class casting') before the
     'self' keyword.  *Note Class casting::.

     For example, if a program contains an expression like this:


          List new textLines;

             _...The program adds items to textLines..._

          textLines map {

            if (self length > 0) {

              _...do something..._

            }

          }


     Then the expression, 'self length' would generate a warning due to
     the label, 'length,' because the class membership of, 'self,' which
     represents each successive element of the, 'textLines,' list,
     normally isn't determined until run time, and so the receiver class
     of 'length' is also undetermined.

     However, if you know that 'textLines' contains only 'String'
     objects, then you can add a class cast expression in the argument
     block.


          textLines map {

            if ((String *)self length > 0) {

              _...do something..._

            }

          }


     This tells the program to treat 'length's' receiver, 'self,' as a
     String object, so it's possible to determine, before the program is
     actually executed, whether, 'self length,' is a valid expression.


File: ctalk.info,  Node: Classes,  Next: Methods,  Prev: Invoking,  Up: Top

Classes
=======

Class library files contain class and method definitions and are located
in the 'classes' subdirectory.  After installation, the libraries are in
a 'ctalk' include subdirectory defined by the macro CLASSLIBDIR when the
program is built.

* Menu:

* Object::
*  Bitmap::
*   DisplayFont::
*    X11Font::
*      X11Cursor::
*    X11FreeTypeFont::
*   X11Bitmap::
*  Boolean::
*  Collection::
*   Array::
*   List::
*    AssociativeArray::
*    SortedList::
*   Stream::
*    FileStream::
*     DirectoryStream::
*     ReadFileStream::
*     WriteFileStream::
*    TerminalStream::
*     ANSITerminalStream::
*     Win32TerminalStream::
*     X11TerminalStream::
*    NetworkStream::
*     TCPIPNetworkStream::
*      TCPIPNetworkStreamReader::
*      TCPIPNetworkStreamWriter::
*     TCPIPV6NetworkStream::
*      TCPIPV6NetworkStreamReader::
*      TCPIPV6NetworkStreamWriter::
*     UNIXNetworkStream::
*      UNIXNetworkStreamReader::
*      UNIXNetworkStreamWriter::
*  TreeNode::
*  Event::
*   Application::
*    ClassLibraryTree::
*    GLUTApplication::
*    ObjectInspector::
*    LibrarySearch::
*   Exception::
*    SystemErrnoException::
*   InputEvent::
*   SignalEvent::
*    SignalHandler::
*  Expr::
*   CFunction::
*  Magnitude::
*   Character::
*    String::
*   Float::
*   Integer::
*    CTime::
*      CalendarTime::
*   LongInteger::
*   Pen::
*   Point::
*    Line::
*     Rectangle::
*    Circle::
*  Method::
*  Pane::
*   ANSITerminalPane::
*    ANSIWidgetPane::
*     ANSIButtonPane::
*     ANSILabelPane::
*     ANSIListBoxPane::
*     ANSIMessageBoxPane::
*     ANSIProgressBarPane::
*     ANSIScrollingListBoxPane::
*     ANSIScrollPane::
*     ANSITextBoxPane::
*     ANSITextEntryPane::
*     ANSIYesNoBoxPane::
*   X11Pane::
*    GLXCanvasPane::
*    X11PaneDispatcher::
*     X11CanvasPane::
*      X11ButtonPane::
*      X11LabelPane::
*      X11MessageBoxPane::
*      X11ScrollBarPane::
*     X11TextPane::
*      X11TextEditorPane::
*  Symbol::
*   Key::
*   Vector::


File: ctalk.info,  Node: Object,  Next: Bitmap,  Up: Classes

'Object' Class
--------------

Ctalk defines the 'Object' class by default at run time.  All other
classes are subclasses of 'Object'.

Instance Variables
..................

'value'
     The value of the object.  For classes that correspond to the C data
     types: 'Character', 'Float', 'Integer', 'LongInteger', and
     'String', ctalk formats the value as it would appear as if output
     by the C 'printf' function.

     When you use one of these classes in a C expression, ctalk
     translates the object's value to its C data type.

     Other classes may define 'value' to return class specific data.

     Null Objects
     ............

     To help make Ctalk compatible with C, Ctalk defines the macro
     STR_IS_NULL, which checks whether the object's value evaluates to
     false in C. That means that objects that have the value '(null)',
     are an empty string, or if the object's value is a NULL pointer,
     all evaluate similarly.  The STR_IS_NULL macro is defined in the
     include file 'ctalkdefs.h', so to use it, add the following line at
     the start of a class library.


          #include <ctalk/ctalkdefs.h>


     Ctalk also assigns an object the value of '(null)' when an object
     is created or when Ctalk encounters a C NULL in an expression
     (which is a macro that expands to '((void *)0)').

Instance Methods
................

'! (void)'
     Overloads the '!' prefix operator.

'!= (Object ARG)'
     Returns a 'Boolean' value of False if the receiver and the argument
     are the same object, True otherwise.  Also returns False if the
     receiver and argument's values both evaluate to False.

'& (void)'
     When used to overload C's "address of" ('&') operator, is
     synonymous with the 'addressOf' method, below.

'-> (String MEMBER_NAME)'
     Given the name of an a C 'OBJECT *' member name, like '__o_name',
     '__o_classname', '__o_class' and so on, return a 'String,'
     'Integer,' or 'Symbol' with the value of that member.  *Note OBJECT
     typedef::.

     The class of the returned object depends on which OBJECT * is
     selected.  Some of the results are returned as references contained
     in Symbol objects, which avoids unexpectedly changing the target
     object.

          OBJECT Member        Expression                  Class of Result Object
          -------------        ----------                  ----------------------
          __o_name             obj -> __o_name             String
          __o_classname        obj -> __o_classname        String
          __o_superclassname   obj -> __o_superclassname   String
          __o_value            obj -> __o_value            String
          __o_class            obj -> __o_class            <obj's> class
          __o_superclass       obj -> __o_superclass       <obj's> superclass
          instancevars         obj -> instancevars         Symbol
          classvars            obj -> classvars            <obj's> class
          __o_p_obj            obj -> __o_p_obj            <obj's> parent's class
          scope                obj -> scope                Integer
          attrs                obj -> attrs                Integer
          nrefs                obj -> nrefs                Integer

     The method sets the OBJECT_IS_DEREF_RESULT attribute on objects
     that the method creates.

     The result of retrieving an object's instance or class variables
     depends on the object.  If the object is not a class object, then
     the 'classvars' member will be NULL. The class of an instance
     variable is the parent object, so the Ctalk library returns the
     address of the first instance variable.  If you want to check each
     variable, it is much easier to use the methods
     'mapInstanceVariables' or 'mapClassVariables', below.

     Examples


          /* Set a Symbol object and an Object instance to
             another object's class, and display the classes'
             name. */
          int main () {

            String new myObject;
            Symbol new optr;
            Object new classObj;

            myObject = "String"; /*Needed by classObject, below.*/

            printf ("%p\n", myObject -> __o_class);
            printf ("%s\n", myObject -> __o_class -> __o_name);

            *optr = myObject -> __o_class;
            printf ("%p\n", (*optr) -> __o_class);
            printf ("%s\n", (*optr) -> __o_class -> __o_name);

            classObj = (*optr) classObject;
            printf ("%p\n", classObj);
            printf ("%s\n", classObj -> __o_name);

            classObj = myObject classObject;
            printf ("%p\n", classObj);
            printf ("%s\n", classObj -> __o_name);

          }

          /* To print an object's value. */
          int main () {

            String new s;

            s = "StringValue";

            printf ("%s\n", s -> __o_value);

          }

          /* To save an object's scope to an Integer object, and
             print them. */
          int main () {

            String new s;
            Integer new scopeInt;


            scopeInt = s -> scope;

            printf ("%d == %d\n", s -> scope, scopeInt);

          }


          /* To save an object's attributes to an Integer and
             print them. */

          int main () {

            Integer new attrsInt;
            List new l;
            String new member1;
            String new member2;


            l = member1, member2;

            /* Check for an OBJECT_IS_MEMBER_OF_PARENT_COLLECTION attribute
               (currently its definition is (1 << 7), or 128), which is set
               in each of the list's Key objects. (The '->' operator in the
               expressions has a higher precedence than '*', so parentheses
               are necessary.) */
            attrsInt = (*l) -> attrs;

            printf ("%d == %d\n", (*l) -> attrs, attrsInt);
          }



     _Note:_ The use of '__o_classname' and '__o_superclassname' as
     separate object member is being superceded by the 'CLASSNAME' and
     'SUPERCLASSNAME' definitions.  The '->' method recognizes both the
     old and new names, but if '->' is used with an 'OBJECT *' as a C
     operator, then the program must use the 'CLASSNAME' or
     'SUPERCLASSNAME' macros.  *Note CLASSNAMEMacro::.

'= (Object NEW_OBJECT)'
     A basic assignment method.  Assigns NEW_OBJECT so that the receiver
     label can refer to it.

'== (Object ARG)'
     Returns a 'Boolean' value of True if the receiver and the argument
     are the same object, False otherwise.

     As a special case, the method returns True if the receiver and
     argument's values evaluate to a C NULL. Refer to the description of
     null objects above.  *Note NullObjects::.

'addInstanceVariable (char *NAME, OBJECT *VALUE)'
     Add instance variable NAME with VALUE to the receiver.

'addressOf (void)'
     Return a 'Symbol' that contains the address of the receiver.  This
     method is functionally equivalent to the C language '&' operator.

'asFloat (void)'
     Return a 'Float' object with the value of the receiver.

'asString (void)'
     Return a 'String' object of the receiver.

'asSymbol (void)'
     If the value of the receiver is an object reference, return a
     Symbol object with that reference.  Otherwise, return a Symbol
     object with a reference to the receiver.

'backgroundMethodObjectMessage (Method METHOD_OBJECT)'
     Send the message defined in METHOD_OBJECT to the receiver as a new
     process, which runs concurrently until METHOD_OBJECT returns.

     The argument, METHOD_OBJECT, is a previously defined method which
     takes no arguments.  The return value, if any is not saved when the
     background process exits.

     Here is a brief example that opens an 'ObjectInspector' on a
     process.


          Object instanceMethod bgMethod (void) {
            self inspect "bgMethod> ";
            printf ("bgMethod printed this.\n");
          }

          int main () {
            Integer new i;
            Method new bgMethodObject;
            int status;

            bgMethodObject definedInstanceMethod "Object", "bgMethod";
            i backgroundMethodObjectMessage bgMethodObject;

            wait (&status);  /* Returns when the background */
                             /* process exits.              */

          }


'basicNew (char *NAME)'
'basicNew (char *NAME, char *VALUE_EXPR)'
'basicNew (char *NAME, char *CLASSNAME, char *SUPERCLASSNAME, char *VALUE_EXPR)'
     If given with one argument, the receiver must be a class object,
     and the method creates a new object with the name given as the
     argument and a value of '(null)'.

     With two arguments, create a new object with the name and value
     given in the arguments, and with the class and superclass of the
     receiver, which needs to be a class object in this case also.

     If the method is used with four arguments, create a new object with
     the name, class, superclass and value given by the arguments - in
     this case, 'basicNew' doesn't use the class and superclass of the
     receiver.

     In each case, the newly created object contains all of the instance
     variables defined by the class object and has a scope of
     LOCAL_VAR|METHOD_USER_OBJECT and a reference count of 1.

     _Note:_ The addition of the receiver's instance variables means you
     need to be careful when the receiver is not a class object.  The
     'basicNew' method does not check for cascading or circular instance
     variables.  So if you're creating and then pushing a lot of items,
     make sure the method's receiver is a class object, and assigning
     the new object using a 'Symbol' is more robust that assigning other
     types of objects.

     That is, a set of statements like


          *tokSym = String basicNew "token", valuebuf;
          myList push *tokSym;


     is much more reliable than, say


          myTok = myString basicNew "token", valuebuf;
          myList push myTok;


'become (OBJECT *ORIGINAL_OBJECT)'
     Make the receiver a duplicate of the argument object.

'callStackTrace (void)'
     Print a call stack trace.

'class (char *CLASSNAME)'
     Declare a new class 'classname'.  The class declaration consists of
     a superclass name, the 'class' keyword, the name of the new class,
     and an optional documentation string.  For example;


          FileStream new WriteFileStream;

          _... or, with a docstring between the class name and semicolon ..._

          FileStream new WriteFileStream
          "Defines the methods and instance variables that write data to files. Also
          defines the class variables stdoutStream and stderrStream, which are the
          object representation of the standard output and standard error streams.";


'className (void)'
     Return a 'String' object containing the class name of the receiver.

'classObject (void)'
     Return the class object named by the receiver's value.  Normally
     the receiver should be a 'String' object - the method uses the C
     value of the receiver to retrieve the class object by its name.  If
     the receiver is a class object, the method returns the receiver
     itself.

'copy (Object SOURCE_OBJECT)'
     Copy SOURCE_OBJECT to the receiver.  This method replaces the
     receiver, which received the message, with a completely new copy of
     the SOURCE_OBJECT argument.  The original receiver object no longer
     exists.

'decReferenceCount (void)'
     Decrease the receiver object's reference count by one.

'delete (void)'
     Delete the receiver object and its instance variables.

     For some of the details of how Ctalk deletes objects, refer to the
     '__ctalkDeleteObject ()' API function.  *Note
     __ctalkDeleteObject::.

'disableExceptionTrace (void)'
     Disable method walkback displays when handling exceptions.

'docDir (void)'
     Returns a 'String' that contains the path where the Ctalk-specific
     documentation is installed on the system (i.e., documentation other
     than man pages and Texinfo manuals).

'dump (void)'
     Create an 'ObjectInspector' object and print the object's contents
     on the terminal.  This is a convenience method for the
     ObjectInspector : formatObject method.

'enableExceptionTrace (void)'
     Enable method walkback displays when handling exceptions.

'getReferenceCount (void)'
     Return an Integer with the receiver's reference count.

'hasPointerContext (void)'
     Returns a 'Boolean' value of True if the receiver appears in a
     pointer context; i.e., on the left-hand side of an assignment
     operator in an expression with some dereferencing method (usually a
     "'*'"), as in this example.


          Symbol new myNewObjectPtr;
          Symbol new myOldObjectPtr;


          *myNewObjectPtr = myOldObjectPtr;


'incReferenceCount (void)'
     Increase the receiver object's reference count by one.

'inspect (void)'
'inspect (String PROMPTSTR)'
     Open an inspector on the receiver object.  At the prompt, typing
     '?' or 'help' displays a list of the inspector's commands.  If
     given a String object as its argument, displays the string as the
     inspector's command prompt.  This method is a shortcut for
     'inspect' in 'ObjectInspector' class.  *Note
     ObjectInspector_inspect::.

'is (char *CLASSNAME)'
     Return 'TRUE' if the receiver is a member of the class given in the
     argument, 'FALSE' otherwise.  _Note:_ Don't use an expression like,
     'obj is Class'.  The argument must be a valid, defined class, which
     simplifies the method considerably.

     To determine if an object is a class object, use 'isClassObject',
     which is mentioned below.  This example illustrates the difference.


          if (myObject is String) {   /* OK - String is a defined class. */
           ...
          }

          if (myObject is Class) {    /* Not OK - 'Class' is not a defined class. */
           ...
          }

          if (myObject isClassObject) {  /* OK - Just check whether the object is
           ...                              its own class object. */
          }


'isClassMethod (char *CLASSMETHODNAME)'
     Return 'TRUE' if the receiver's class defines an instance method
     named CLASSMETHODNAME, 'FALSE' otherwise.  If the receiver is an
     instance or class variable, look for the method in the class of the
     receiver's value.

'isClassObject (void)'
     Returns a Boolean value of True if the receiver is a class object,
     False otherwise.

'isInstanceMethod (char *INSTANCEMETHODNAME)'
     Return 'TRUE' if the receiver's class defines an instance method
     named INSTANCEMETHODNAME, 'FALSE' otherwise.  If the receiver is an
     instance or class variable, look for the method in the class of the
     receiver's value.

'isInstanceVariable (char *INSTANCEVARIABLENAME)'
     Return 'TRUE' if the receiver has an instance variable named
     INSTANCEVARIABLENAME, 'FALSE' otherwise.

'instanceMethod (char *ALIAS, char *NAME, (ARGS)'
     Declare a method of the receiver's class with the name NAME, with
     the arguments ARGS, and, optionally, with the alias ALIAS.  *Note
     Methods::.

'isNull (void)'
     Return 'TRUE' if the receiver is a null result object, 'FALSE'
     otherwise.

'isNullValue (void)'
     Return 'TRUE' if the receiver's value is 'NULL', '(null)', or '0',
     'FALSE' otherwise.  Note that this method is here for compatibility
     with older programs.  New programs should not need it.

'isSubClassOf (String CLASSNAME)'
     Returns True if the reciever's is a member of CLASSNAME or one of
     its subclasses, False otherwise.

'libraryPath (void)'
     Return the file path name of the receiver's class library.

'mapClassVariables (OBJECT *(*FN)())'
     Apply the argument, FN to each of the class variables in the
     receiver's class object.  The argument may be either a method or a
     code block.  Refer to the 'Ctalk Tutorial' for examples of inline
     method messages using methods like 'map' and
     'mapInstanceVariables'.

'mapInstanceVariables (OBJECT *(*FN)())'
     Apply the argument, FN, to each of an object's instance variables.
     The argument may be either a method or a code block.  Refer to the
     'Ctalk Tutorial' for examples of inline method messages using
     methods like 'map' and 'mapInstanceVariables'.

'methodObjectMessage (Method METHOD_OBJECT)'
'methodObjectMessage (Method METHOD_OBJECT, Object ARG1, Object ARG2)'
     Perform a method call with a 'Method' class object.  The
     METHOD_OBJECT argument and its own arguments must have been
     previously defined.  *Note Method::.

     With three arguments, the method uses the second and third
     arguments as the method instance's arguments, without previous
     calls to the 'withArg' method (defined in 'Method' class).

     Method instances with two arguments are commonly used in graphical
     event dispatchers.  They're found mostly in 'X11PaneDispatcher'
     class, and the three-parameter form of 'methodObjectMessage' allows
     the method instance calls to be more efficient.

     The following examples of method calls shows how to call method
     instances with and without using the 'withArg' method first.

     This example is from 'X11PaneDispatcher' class.


            /* This example pushes the arguments separately. */
          __subPane handleKbdInput withArg __subPane;
          __subPane handleKbdInput withArg __event;
          __subPane methodObjectMessage __subPane handleKbdInput;

            /* The three-argument form of methodObjectMessage allows
               passing two arguments to a method instance with only
               a single expression. */
          __subPane methodObjectMessage __subPane handleKbdInput,
            __subPane, __event;


     This example is the 'demos/ipc/sockproc.c' demonstration program,
     which shows how to define and start a method instance as a separate
     process.


          #define SOCK_BASENAME "testsocket.$$"

          String new gSocketPath; /* The socket path is common to both
          			   processes. */

          Object instanceMethod startTimeServer (void) {
            UNIXNetworkStreamReader new reader;
            String new utcTimeString;
            CalendarTime new timeNow;
            SystemErrnoException new ex;

            reader openOn gSocketPath;
            if (ex pending) {
              ex handle;
              return ERROR;
            }

            while (1) {
              utcTimeString = reader sockRead;
              if (ex pending) {
                ex handle;
                return ERROR;
              }
              if (utcTimeString length > 0) {
                timeNow = utcTimeString asInteger;
                timeNow localTime;
                printf ("%s\n", timeNow cTimeString);
              }
            }
          }

          int main (int argc, char **argv) {

            CTime new thisTime;
            CTime new prevTime;
            UNIXNetworkStream new strObject;
            UNIXNetworkStreamWriter new client;
            Method new timeServerInit;
            Integer new childPID;
            SystemErrnoException new ex;
            Object new procRcvr;

            gSocketPath = strObject makeSocketPath SOCK_BASENAME;

            timeServerInit definedInstanceMethod "Object",
              "startTimeServer";
            childPID =
              procRcvr backgroundMethodObjectMessage timeServerInit;

            client openOn gSocketPath;
            if (ex pending) {
              ex handle;
              return ERROR;
            }

            prevTime utcTime;

            while (1) {

              thisTime utcTime;

              if (thisTime != prevTime) {

                client sockWrite (thisTime asString);

                if (ex pending) {
          	ex handle;
          	return ERROR;
                }

                prevTime = thisTime;

              }
              usleep (1000);
            }
            exit (0);
          }


'methods (Boolean FINDCLASSMETHODS)'
     Return a string containing the methods defined by the receiver's
     class, one method per line.  If FINDCLASSMETHODS is True, return a
     list of class methods in the class.  If the argument is False,
     return a list of the class's instance methods.

'name (void)'
     Return the name of the receiver as a 'String' object.

'new (NEWOBJECT1, NEWOBJECT2, NEWOBJECT3...)'
     Create an object or object's of the receiver's class with the names
     NEWOBJECT1, etc.  For example:


          String new myString1, myString2, myString3;


'printSelfBasic (void)'
     Print the contents of the receiver to the program's standard error
     output.

'setReferenceCount (Integer REFCNT)'
     Set the receiver's reference count to the value given as the
     argument.  Note, however, that the reference count given as the
     argument does not include any changes in the reference count as
     this method is executed.  If you're unsure about how to adjust the
     reference count it's safer to use 'incReferenceCount' and
     'decReferenceCount' instead, or use the '__objRefCntSet ()' library
     function directly.  *Note objRefCntSet::.

'sizeof (OBJECT)'
     Overloads the C 'sizeof' operator when the argument is an object.
     If the argument is a C variable or a type expression, then Ctalk
     uses the compiler's 'sizeof' operator.

'superclassName (void)'
     Return a 'String' that contains the name of the object's
     superclass, or '(null)' if the receiver is an instance of 'Object'
     class, which has no superclass.

'traceEnabled (void)'
     Return 'TRUE' if exception walkback displays are enabled, 'FALSE'
     otherwise.

'value (void)'
     Returns the value of the receiver object.  When you use an object
     without a method, ctalk uses the 'value' message to return the
     object's value.  For example,

            printf ("%s", stringObject);

     is the same as,

            printf ("%s", stringObject value);


File: ctalk.info,  Node: Bitmap,  Next: DisplayFont,  Prev: Object,  Up: Classes

'Bitmap' Class
--------------


File: ctalk.info,  Node: DisplayFont,  Next: X11Font,  Prev: Bitmap,  Up: Classes

'DisplayFont' Class
-------------------


File: ctalk.info,  Node: X11Font,  Next: X11Cursor,  Prev: DisplayFont,  Up: Classes

'X11Font' Class
---------------

A 'X11Font' object provides information about a X Window System font,
like its resource ID, width, height, and X Logical Font Descriptor
(XLFD) string.  Normally, a pane or X window does not use font glyphs
directly but uses Pane methods to display text using the font resource.
*Note X11Pane::.

For variable width fonts, the 'maxWidth' instance variable provides the
width of the widest character in the set.

For more information about X's font naming scheme, the 'xfontsel(1)'
manual page is a good place to begin.

Instance Variables
------------------

'ascent'
'descent'
     'Integer' objects that contain the number of pixels the character
     set extends above and below the baseline.  These dimensions are
     typically used to determine interline spacing.

'fontDesc'
     A 'String' containing the X Logical Font Descriptor of the
     receiver's font.  After a call to 'getFontInfo' (below), contains
     the XLFD of the actual font.

'fontId'
     An 'Integer' that contains the X Window System's resource ID of the
     font.

'height'
     An 'Integer' that contains the sum of the maximum descent and
     ascent; that is, the height of the font's tallest character.

'maxLBearing'
     An 'Integer' that contains the maximum distance in pixels from a
     character's drawing origin to its glyph.

'maxRBearing'
     An 'Integer' that contains the maximum distance in pixels between
     the right side of a font's character glyphs to the right-hand edge
     of the character space.

'maxWidth'
     An 'Integer' that contains the width of the font's widest character
     glyph.  Note that these metrics' uses differ for different fonts,
     and can vary a lot, especially in foreign language character sets.
     Generally, though, for Western, monospaced fonts, the width in
     pixels of a character plus its horizontal spacing is:


          myFont maxLBearing + myFont maxWidth;


Instance Methods
................

'getFontInfo (String FONTDESC)'
     Fills in the font metrics (height, maxWidth, ascent, descent, X
     font ID) for the font named by FONTDESC.  Also fills in the
     receiver's 'fontDesc' instance variable with the string given as
     the argument.

'textWidth (String TEXT)'
     Returns an 'Integer' with the width of TEXT in pixels when rendered
     in the reciever's font.  The program should call the 'getFontInfo'
     method before calling this method.


File: ctalk.info,  Node: X11Cursor,  Next: X11FreeTypeFont,  Prev: X11Font,  Up: Classes

'X11Cursor' Class
-----------------

The 'X11Cursor' class represents cursor objects and provides wrapper
methods that create X11 cursor resources.  A 'X11Cursor' object's value
is the ID of the newly created cursor resource.

To display the cursor in a 'X11Pane' object's window, see the
'useCursor' method in 'X11Pane' class.  This example shows the sequence
of expressions.  *Note X11Pane::.


     X11Pane new xPane;        /* Create our objects. */
     X11Cursor new waitCursor;

     _..._

     waitCursor watch;         /* Get the resource ID of a wait cursor
                                  (normally, a watch or a spinner). */
     _..._

     xPane useCursor waitCursor;  /* Display the wait cursor on the xPane's
                                     window. */

The 'defaultCursor' method (class 'X11Pane') restores the window's
cursor to its parent window's cursor, which is the default cursor for
new windows.  *Note X11Pane::.


     xPane defaultCursor;


Instance Methods
................

'arrow (void)'
     Sets the cursor to the upward-left pointing arrow that is the
     default for most new windows.

'grabMove (void)'
     Creates a grab cursor.

'scrollArrow (void)'
     Creates a scrollbar vertical double arrow cursor.

'watch (void)'
     Creates a cursor that displays a small watch.


File: ctalk.info,  Node: X11FreeTypeFont,  Next: X11Bitmap,  Prev: X11Cursor,  Up: Classes

'X11FreeTypeFont' Class
-----------------------

This class contains the methods that handle FreeType fonts using the Xft
and Fontconfig libraries.  In classes and methods that use fonts,
FreeType fonts take priority if they are available and the program has
initialized the library with the 'initFontLib' method, which is
described in further detail below.  Otherwise, applications use the X
Window System's builtin bitmap fonts.

Internally Ctalk uses the Fontconfig library to locate the system's
'fonts.conf' file.  The 'fonts.conf' file's default location is
configured when the library is built.  Generally, the 'font.conf' file's
path is '/etc/fonts/fonts.conf' or '/usr/local/etc/fonts/fonts.conf.'

However, an alternate 'fonts.conf' pathname may be set in the
environment with the 'FONTCONFIG_FILE' environment variable.  If its
value begins with a '~', the path is relative to the user's 'HOME'
directory.  If the name doesn't start with a '/', then the pathname is
relative to the fontconfig libraries' default installation directory.
This directory can be changed by setting the 'FONTCONFIG_PATH'
environment variable to an alternate directory.

Classes that use X Window System graphics (that is, 'X11Pane' and its
subclasses) can use either the X libraries' built-in bitmap fonts (via
the pane's 'fontVar' instance variable), or the scalable Freetype fonts
(via the pane's 'ftFontVar' instance variable).

The default is to use X's built in bitmap fonts.  These fonts are
initialized when the program connects to the display server.

However, to enable drawing with scalable fonts, programs need to call
the 'initFontLib' method during program initialization, with a line
similar to this one.


     myMainWindow ftFontVar initFontLib;


Fontconfig Font Descritions
...........................

Fontconfig has its own syntax for selecting fonts.  Here are a few
examples.


     DejaVu Sans Mono
     Nimbus Sans L-12
     FreeMono-10:slant=italic:weight=bold


These font descriptors work with the 'selectFontFromFontConfig' method.
The receiver, of course, must be a 'X11FreetypeFont' object, or the pane
object's 'ftFontVar' instance variable.  Here is an example


     myWindow ftFontVar selectFontFromFontConfig "DejaVu Sans Mono-12"


A full description of the Fontconfig's descriptor syntax is available in
the Fontconfig user guide, which is included with Fontconfig
documentation packages, and also available on the web at
<http://freedesktop.org/fontconfig>.

Further Information Qbout Fontconfig and libXft
...............................................

For further information about the the Fontconfig libraries, refer to:
<https://freedesktop.org/fontconfig>.  Information about Xft is
available at <http://freedesktop.org/wiki/Software/Xft>.

Instance Variables
..................

'family'
     A 'String' that contains the family of the currently selected font.
     *Note String::.
'fgRed'
'fgGreen'
'fgBlue'
'fgAlpha'
     The parameters of the font's RGBA color.  The variables are
     'Integers' and can have a range of 0 - 0xffff.  *Note Integer::.
'rotation'
'scaleX'
'scaleY'
     'Float' instance variables that control the scaling and rotation of
     the rendered fonts.
'slant'
'weight'
'dpi'
     'Integers' that contain the slant, weight, and dpi resolution of
     the receiver font.  For a description of the Xft library's
     constants, refer to the 'selectFont' method entry, below.  *Note
     Integer::.
'pointSize'
     A 'Float' that contains the font's point size.  *Note Float::.
'ascent'
     An 'Integer' that contains the font's height in pixels above the
     baseline.
'descent'
     An 'Integer' that contains the font's height in pixels below the
     baseline.
'height'
     An 'Integer' that contains the dimensions in pixels of the font's
     total height, both above and below the baseline, and any extra
     vertical spacing.
'maxAdvance'
     An 'Integer' that contains the maximum width in pixels of a font's
     characters horizontal dimensions.

Instance Methods
................

'alpha (Integer VALUE)'
     Set the current Xft font's foreground alpha channel.  The argument
     VALUE must be an unsigned short int; i.e., in the range 0 - 65535
     (0xffff hex).

'blue (Integer VALUE)'
     Set the current Xft font's foreground blue channel.  The argument
     VALUE must be an unsigned short int; i.e., in the range 0 - 65535
     (0xffff hex).

'green (Integer VALUE)'
     Set the current Xft font's foreground green channel.  The argument
     VALUE must be an unsigned short int; i.e., in the range 0 - 65535
     (0xffff hex).

'initFontLib (void)'
     Initializes the font library and sets the reciever's instance
     variables to the default selected font.  Apps need to use this
     method before most of the other other methods in this class.

     If the system is not configured to use outline fonts then the
     library prints a message and exits the program with a non-zero
     value.  *Note ctalkXftInitLib::.

'libIsInitialized (void)'
     Returns a non-zero 'Integer' value if the Xft libraries are
     initialized and a font is selected.

'listFonts (String PATTERN)'
     List the font descriptors in the FreeType library that contain
     PATTERN.  If PATTERN is an empty string '""' or a '*', match every
     font descriptor.

'namedX11Color (String COLORNAME)'
     Sets the selected font's red, green, and blue values from the X11
     color name given as the argument.

     _Note:_ For a list of the colors that the X Window System
     recognizes, consult the file 'rgb.txt', which is often stored with
     the server's configuration files when the GUI is installed.

'qualifyName (String XFTPATTERN)'
     Returns a fully qualified 'String' containing a fully qualified Xft
     font descriptor that matches XFTPATTERN.

'red (Integer VALUE)'
     Set the current Xft font's foreground red channel.  The argument
     VALUE must be an unsigned short int; i.e., in the range 0 - 65535
     (0xffff hex).

'saveSelectedFont (void)'
     This method does the work of setting the receiver's instance
     variables to the values of the selected font.

'selectedFont (void)'
     Returns the 'String' with the descriptor of the selected font.
     Because a complete font descriptor contains a lot of information,
     this method can generate a lot of output.

'RGBAColor (void)'
'RGBAColor (int RED, int GREEN, int BLUE, int ALPHA)'
     If given with no arguments, sets the current font's color to the
     values of the receiver's 'ftRed, fgGreen, fgBlue,' and 'fgAlpha'
     values.  If the method is used with arguments, set's the current
     font's color to their values.  The values are 'Integers' and can
     have a range of 0-0xffff.

'selectFont (void)'
'selectFont (String FAMILY, Integer SLANT, Integer WEIGHT, Integer DPI, Float POINTSIZE)'
     If used without arguments, selects the font named by the receiver's
     instance variables.  If the statement provides arguments, only the
     FAMILY argument needs to describe an actual font family; that is,
     it has no default value.  Defaults for the other arguments are
     described below.  In this case, the method sets the receiver's
     instance variables to the selected font.

     For the 'slant' and 'weight' arguments, the Xft library defines the
     constants and their meanings as the following.

                SLANT
           0    Roman
           100  Italic
           110  Oblique

                WEIGHT
           0    Light
           100  Medium
           180  Demibold
           200  Bold
           210  Black

     The DPI parameter should be set to the resolution of the display.

     An easier way to describe a font may be to use the
     'selectFontFromFontConfig' method, which takes a FontConfig format
     font specification as its argument.  *Note
     selectFontFromFontConfig::.

'selectFontFromXLFD (String XLFD)'
     Similar to 'selectFont', above, except that its argument is a
     string in XLFD format.  That is, the method translates the XLFD
     argument into the Xft library's font metrics.  This makes possible
     font descriptions like the following.


          -*-DejaVu Sans-medium-r-*-*-12-72-72-*-*-*-*-*


'selectFontFromFontConfig (String FONT_CONFIG_STRING)'
     Selects a font using the FontConfig specification given as its
     argument.

'textHeight (String TEXT)'
     Return an 'Integer' with the height in pixels of TEXT in the
     currently selected FreeType font.  If the Xft library is not
     available or not initialized, the method returns 0.

'textWidth (String TEXT)'
     Return an 'Integer' with the width in pixels of TEXT in the
     currently selected FreeType font.  If the Xft library is not
     available or not initialized, the method returns 0.


File: ctalk.info,  Node: X11Bitmap,  Next: Boolean,  Prev: X11FreeTypeFont,  Up: Classes

'X11Bitmap' Class
-----------------

A 'X11Bitmap' object is similar to a Bitmap object - it contains the
address of a bitmap in memory.  In addition, a 'X11Bitmap' object has
its own X11 graphics context for graphics operations.

Instance Variables
..................

'backgroundColor'
     A 'String' that contains the name of a X color.  Setting this
     variable does not affect the color of a displayed bitmap - programs
     should call the 'X11Bitmap : background' method, which also sets
     this variable.

'depth'
     An 'Integer' that contains the depth of the bitmap.

'displayPtr'
     A 'Symbol' that contains the address of the connection to the X
     server that was returned by a call to 'XOpenDisplay'.  This is
     generally the address of the main window pane's 'displayPtr'
     instance variable, and in this class, it is expressly set in the
     'create' method.

'height'
     An 'Integer' that contains the height of the bitmap.

'modal'
     A 'Boolean' that helps determine how Ctalk draws graphics on the
     X11Bitmap.  True for X11Bitmap objects that are displayed in popup
     windows, false otherwise.

'parentDrawable'
     An 'Integer' that contains the window ID of the bitmap's parent
     drawable.  Normally this is set by the 'create' method, below.

'width'
     An 'Integer' that contains the width of the bitmap.

'xGC'
     A 'Symbol' object that contains the address of the X11 graphics
     context.

'xID'
     The X resource ID of the Pixmap associated with this object.

Instance Methods
................

'background (String COLOR)'
     Set the background color of the receiver to COLOR.  _Note:_ When
     changing foreground and background color, make sure that an
     application has is receiving and processing events, using the
     'openEventStream' method in class 'X11Pane'.

     Clear the receiver to the background color.

'clearRectangle (Integer X, Integer Y, Integer WIDTH, Integer HEIGHT)'
     Clear the specified area to the background color.

     Copies the contents of SRCBITMAP to the receiver's drawing surface.
     The source dimensions are determined by SRCX, SRCY, SRCWIDTH, and
     SRCHEIGHT.  The method draws the source bitmap's contents with the
     source's upper left-hand corner at DESTX, DESTY.

'initialize (void *displayPtr, int PARENTWINDOW, int WIDTH, int HEIGHT, int DEPTH)'
     Create a X11Bitmap object and its graphics data.

'delete (void)'
     Delete a pixmap and its graphics data.

'drawCircle (Circle ACIRCLE, Integer FILLED, String BGCOLOR)'
'drawCircle (Circle ACIRCLE, Pen APEN, Integer FILLED, String BGCOLOR)'
     Draw the circle defined by ACIRCLE in the receiver's paneBuffer.
     If FILLED is true, draws a filled circle.  If the APEN argument is
     given, draws the circle with the color and the line width defined
     by the 'aPen', and fills the interior of the circle with BGCOLOR.

'drawLine (Integer XSTART, Integer YSTART, Integer XEND, Integer YEND, Pen APEN)'
'drawLine (Line ALINE, Pen APEN)'
     Draw a point on the receiver's drawing surface between the points
     XSTART,YSTART and XEND,YEND using the color, width, and
     transparency defined by the argument APEN.  *Note Pen::.

     If a program uses the two-argument form of the method, ALINE is a
     member of class LINE.  *Note Line::.

'drawPoint (Integer X, Integer Y, Pen APEN)'
     Draw a point on the receiver's drawing surface at X,Y using the
     color, width, and transparency defined by the argument APEN.  *Note
     Pen::.

'faceRegular (void)'
'faceBold (void)'
'faceItalic (void)'
'faceBoldItalic (void)'
     Selects the typeface of the currently selected font.  The font
     should have been selected by a previous call to 'font', below,
     which loads the regular, bold, italic (or oblique), and bold italic
     flavors of the selected font if they are available.

'font (String FONT_DESC)'
     Set the font of the receiver.

'foreground (String COLOR)'
     Set the foreground color of the receiver.  _Note:_ When changing
     foreground and background color, make sure that an application has
     is receiving and processing events, using the 'openEventStream'
     method in class 'X11Pane'.

'icon (int ICONID)'
'iconStop (void)'
'iconCaution (void)'
'iconInfo (void)'
     These methods draw a 64x64 dialog icon on the receiver's drawing
     surface.  In the case of the 'icon' method, the ICONID argument can
     be one of the following.


          ICON_NONE
          ICON_STOP
          ICON_CAUTION
          ICON_INFO


     Before calling any of these methods, a program must have created
     the pane's drawing surface with the 'create' method.  It is also
     generally necessary to set the pane's background color to that of
     the surrounding window.  Here is an example.


          myIcon create aPane displayPtr, aPane paneBuffer xID,
            ICON_WIDTH_PX, ICON_HEIGHT_PX, pPane paneBuffer depth;
          myIcon background "blue";


     Because icons are generally rendered off-screen, the program should
     use the parent pane's display connection, 'paneBuffer xID,' and
     depth.  Then the program can use the 'X11Bitmap : copy' method to
     draw the bitmap on the surround pane's buffer.  Here's another
     example.

          aPane paneBuffer copy myIcon, 0, 0, ICON_WIDTH_PX, ICON_HEIGHT_PX,
                iconLeftOrigin, iconTopOrigin;


     The constants 'ICON_WIDTH_PX' and 'ICON_HEIGHT_PX' are defined in
     'ctalkdefs.h', so programs and classes that use icons should add
     this line near the top of the source module.


          #include <ctalk/ctalkdefs.h>


'putStr (Integer X, Integer Y, String TEXT)'
'putStr (Integer X, Integer Y, String TEXT, String FONT_DESC)'
'putStr (Integer X, Integer Y, String TEXT, String FONT_DESC, String COLORNAME)'
     Print TEXT on the receiver's drawable X resource, at X,Y.  If
     FONT_DESC, a, X logical font descriptor, is given, use that font to
     display the text.  If COLORNAME is also given, render the text
     using that color.

'pixmapFromData (int X_ORG, int Y_ORG, char *XPM_DATA[])'
     Draw the X pixmap defined by XPM_DATA with the upper left corner at
     X_ORG,Y_ORG on the receiver's pane buffer.

     The XPM_DATA argument is the name of the array declared at the
     start of a 'xpm' file's data array.

     In Ctalk's standard libraries, the image will appear on a
     'X11CanvasPane' object, and programs can use the 'pixmapFromData'
     method in 'X11CanvasPane' instead of calling this method directly.
     *Note X11CanvasPane_pixmapFromData::.

'resize (Integer PARENTVISUAL, Integer NEW_WIDTH, Integer NEW_HEIGHT)'
     Resize the receiver Pixmap.  This method is normally called by an
     event handler in a parent class (typically, that's a
     'X11CanvasPane').  If you need to resize a graphics pane's buffers,
     then the program should also call 'subPaneNotify' (class
     'X11Pane'), which invokes the handler for a 'RESIZENOTIFY' event.

     Here is the 'X11CanvasPane' classes' 'RESIZENOTIFY' event handler.


          X11CanvasPane instanceMethod subPaneResize (Object __subPane,
          					  InputEvent __event) {
            "Resize the receiver pane.  This is the resize event
            handler called by the parent window's pane
            dispatcher."

            if (__ctalkX11ResizeWindow (__subPane, __event xEventData3,
          			      __event xEventData4,
          			      __subPane depth) > 0) {
              /* refreshReframe uses viewWidth and viewHeight, refresh uses size x
                 and size y */
              __subPane viewWidth = __event xEventData3;
              __subPane viewHeight = __event xEventData4;
              __subPane size x = __event xEventData3;
              __subPane size y = __event xEventData4;
              (X11Bitmap *)self paneBuffer resize self xWindowID,
                __event xEventData3, __event xEventData4;
              (X11Bitmap *)self paneBackingStore resize self xWindowID,
                __event xEventData3, __event xEventData4;
            }

            return NULL;
          }


     For an example of how a program can handle 'RESIZENOTIFY' events,
     refer to the examples in the 'X11CanvasPane' section.  *Note
     X11CanvasPane::.

'xpmInfoFromData (char **XPM_DATA, Array DATARETURN)'
     Fills in the 'Array' DATARETURN with the information from the X
     pixmap data referred to by XPM_DATA: [width, height, colors,
     characters_per_color];

'xpmCharsPerColorFromData (char **XPM_DATA)'
     Returns an 'Integer' with the number characters per color in the X
     pixmap referred to by XPM_DATA.

'xpmColorsFromData (char **XPM_DATA)'
     Returns an 'Integer' with the number of colors in the X pixmap
     referred to by XPM_DATA.

'xpmHeightFromData (char **XPM_DATA)'
     Returns an 'Integer' with the height of the X pixmap referred to by
     XPM_DATA.

'xpmWidthFromData (char **XPM_DATA)'
     Returns an 'Integer' with the width of the X pixmap referred to by
     XPM_DATA.


File: ctalk.info,  Node: Boolean,  Next: Collection,  Prev: X11Bitmap,  Up: Classes

'Boolean' Class
---------------

'Boolean' class objects are used mainly as the return values of methods
of various classes that test equality, like '<,' '>,' '==,' '!=,' '&&,'
and '||.'

An expression can treat 'Boolean' methods differently than methods that
perform numerical calculations, which usually return objects of
'Magnitude' class and its subclasses.

Methods can return one of the 'Boolean' class variables, 'boolTrue' or
'boolFalse'.  In addition, methods can also define their own 'Boolean'
objects to return.  The API function '__ctalkRegisterBoolReturn ()' does
this automatically when it encounters a return statement in a method
that has declared a 'Boolean' return value.

Class Variables
...............

'boolFalse'
'boolTrue'
     Objects that represent the logical values true and false.  The
     objects can be used as return values in methods that return boolean
     values and in API functions like '__ctalkRegisterBoolReturn ()'.
     *Note ctalkRegisterBoolReturn::.

Instance Methods
................

'!= (Integer I)'
     Return a 'Boolean' value of 'True' if the values of the receiver
     and the argument are different, 'False' otherwise.

'&& (Boolean B)'
     Returns a 'Boolean' value of 'True' if both the receiver and the
     method's operand evaluate to true.

'= (Integer I)'
     Sets the value of the receiver to True or False.  The method uses
     the Ctalk library to perform the numeric conversion of the argument
     to a C 'int', then casts the result to True or False.

'== (Integer I)'
     Return a 'Boolean' value of 'True' if the values of the receiver
     and the argument are the same, 'False' otherwise.

'|| (Boolean B)'
     Returns a 'Boolean' value of 'True' if either the receiver or the
     method's operand evaluate to true.


File: ctalk.info,  Node: Collection,  Next: Array,  Prev: Boolean,  Up: Classes

'Collection' Class
------------------

The 'Collection' class is the superclass of all objects that contain
groups of objects.

Internally, a 'Collection' is made up of a series of 'Key' objects.
*Note Key::.  The only function of 'Key' has is to maintain a reference
to one of the collection's items.  The 'Key' objects have no other
references, while the contents that they refer to may be used elsewhere.

But programs can also refer to 'Key' objects individually.  Most of the
math operators that are overloaded to work with 'Collections' actually
work on 'Key' objects.

If you write a method that adds objects to collections, it's important
to add the attribute OBJECT_IS_MEMBER_OF_PARENT_COLLECTION to each 'Key'
object, which tells Ctalk that the 'Key' object can be referred to
individually, and not just by its parent object.  *Note Attributes::.

Instance Methods
................

'* (void)'
     When used as a unary operator to overload C's dereference ('*')
     prefix operator, returns the first element of the array or
     'Collection'.  This method is actually a shortcut for the method
     'head', below.

'+ (Integer N)'
     Returns the NTH member of the receiver 'Collection'.  This method
     is actually a shortcut for the following expressions.


          Collection new myCollection;

          .....  /* Add members to the collection. */

          if (*(myCollection + 1)) {
          ...
          }

          Collection instanceMethod + nth (Integer new n) {
            Key new k;

            k = *self;
            k += n;
            return k;
          }


'at (char *KEYSTRING)'
     Retrieve the element of the receiver Collection at KEYSTRING.

'atPut (char * KEYSTRING, OBJECT *ELEMOBJECT)'
     Add ELEMOBJECT to the receiver with the key KEYSTRING.

'delete (void)'
     Remove all of the items in the receiver collection, leaving an
     empty collection.  If any of the items are temporary (for example,
     a C variable alias), delete the item also.

'getValue (void)'
     Return the value of the receiver, a 'Key' object.

'isEmtpy (void)'
     Return 'TRUE' if the receiver collection is emtpy, 'FALSE'
     otherwise.

'head (void)'
     Return the first 'Key' in the receiver collection, or NULL if the
     collection is empty.

'keyExists (String KEYNAME)'
     Return an 'Integer' value of True if the key given as the argument
     is present in the receiver collection, False otherwise.

'map (OBJECT *(*METHOD)())'
     Execute METHOD, an instance method of class 'AssociativeArray,' for
     each key/value pair of the receiver array.  The receiver of METHOD
     is a 'Key' object with the parent class of 'AssociativeArray'.  The
     return value of 'mapKeys' is NULL.

'removeAt (String KEY_NAME)'
     Remove the object stored at KEY_NAME from the receiver collection
     and return it.  Returns NULL if the entry isn't present in the
     receiver collection.  In that case, the method does not create a
     new entry, so programs should then call the 'atPut' method.

'replaceAt (String KEY_NAME, Object NEW_VALUE)'
     Replace the value at KEY_NAME in the receiver collection.  Returns
     the old value object, or NULL if the key doesn't exist.  In that
     case, the method does not create a new entry, so in that case it's
     necessary to add the key/value entry to the receiver collection
     using 'atPut'.

'size (void)'
     Return an 'Integer' with the number of items in the receiver
     collection.

'tail (void)'
     Return the last 'Key' object that was added to the receiver
     collection.


File: ctalk.info,  Node: Array,  Next: List,  Prev: Collection,  Up: Classes

'Array' Class
-------------

The 'Array' class contains objects ordered by index from 0...  n.

Instances of 'Array' objects store unique copies of objects, so they can
be added and deleted without worrying too much if an 'Array' member is
referred to by another object (unless the program later refers to the
'Array' member; i.e., after it's been stored with a method like
'atPut').

So most statements on 'Array' members are safe, but you should be
careful when using multiple 'Array' operations in the same expression.
For example, the following expression is not safe.


       myArray atPut 0, ((myArray at 0) - 3);


That's because the 'atPut' method replaces the element at 0 while the
original element is still being used as an argument.  It's safer to use
another object to work on an 'Array' element.


       tmpInt = ((myArray at 0) - 3);
       myArray atPut 0, tmpInt;


Instance Variables
..................

'value'
     The value is the name of the array.

'0... n'
     These instance variables refer to the elements of the array.

Instance Methods
................

'= (Array A)'
     Set the receiver array's elements equal to the argument array's
     elements.

'asString (void)'
     Returns the contents of the receiver 'Array' as a 'String' object.
     If any member of the receiver is a 'Character' object, unquotes the
     'Character' object's value and concatenates the character to the
     result string.  Otherwise the method concatenates each of the
     receiver 'Array''s values into the result string.

'at (int N)'
     Retrieve the Nth element of the receiver array.

'atPut (int INDEX, OBJECT *ITEM)'
     Add ITEM to the receiver at INDEX.

'map (METHOD)'
     Executes METHOD with each element of the receiver.

     The argument, METHOD, is a method that should belong to the same
     class as the receiver.  When METHOD is executed, its receiver is
     each successive array element, and METHOD can refer to it with
     'self.'

'size (void)'
     Return the number of elements in the receiver.


File: ctalk.info,  Node: List,  Next: AssociativeArray,  Prev: Array,  Up: Classes

'List' Class
------------

Objects of class 'List' allow sets of objects to be sequentially added,
removed, and used as method receivers.

Instance Methods
................

'+= (Object OBJ1, ...)'
     Add the items given in the argument to the receiver List.  For
     example:

          int main () {
            List new l;

            l = "first", "second", "third", "fourth";
            l += "fifth", "sixth", "seventh", "eighth";

            l map {
              printf ("%s\n", self);
          v  }
          }

'= (Object OBJ1, ...)'
     Push the arguments on to the receiver List.  The arguments are a
     comma separated list of objects.  For example:

          int main () {
            List new l;

            l = "first", "second", "third", "fourth";

            l map {
              printf ("%s\n", self);
            }
          }

     The '=' method initializes a list with only the objects that are
     given as arguments.  The memthod deletes any previous list
     contents.

'append (Object OBJ1, ...)'
     Add the objects given in the argument to the receiver List.  This
     is a synonym for the '+=' method, above.

'init (Object OBJ1, ...)'
     This is a synonym for the '=' method, above.

'map (OBJECT *(*METHOD)())'
'map (OBJECT *(*METHOD)(), Object ARGUMENT)'
'map (OBJECT *(*METHOD)(), Object ARGUMENT1, Object ARGUMENT2)'
     Execute METHOD, an instance method of class 'List,' for each member
     of the receiver List.  Within METHOD, 'self' refers to each
     successive list element.  Here is an example.


          List instanceMethod printElement (void) {
            printf ("%s\n", self);  /* Here, for each call to the printElement
                                       method, "self" is each of myList's
                                       successive members, which are String
                                       objects. */
          }

          int main () {

            List new myList;

            myList = "item1", "item2", "item3";  /* Initialize the List with
                                                    three String objects. */
            myList map printElement;

          }


     The 'map' method can also use a code block as its argument.  The
     example above, written with a code block, would look like this.


          int main () {

            List new myList;

            myList = "item1", "item2", "item3";  /* Initialize the List with
                                                    three String objects. */
            myList map {
              printf ("%s\n", self);
            }

          }


     If given with two arguments, METHOD'S parameter list must have one
     parameter.  The parameter's class is significant within METHOD;
     that is, 'map' can use any class of object for ARGUMENT.  Here is
     the example above with one argument for the printElement method;


          List instanceMethod printElement (String leftMargin) {
            printf ("%s%s\n", leftMargin, self);

          }

          int main () {

            List new myList;
            String new leftMargin;

            myList = "item1", "item2", "item3";  /* Initialize the List with
                                                    three String objects. */
            leftMargin = "- ";

            myList map printElement, leftMargin;

          }


     Calling 'map' with three arguments works similarly.  The 'map'
     methods in 'List' class all return NULL.

'mapRev (OBJECT *(*METHOD)())'
     Like 'map', except that it executes METHOD for the last member that
     was added to the receiver List, then the previous member, and so on
     until the 'mapRev' executes METHOD for the first member of the list
     before returning.

'new (LIST1, LIST2, LIST3, ...;)'
     Create the 'List' objects LIST1, etc.  For example:


          List new list1, list2, list3;


'pop (void)'
     Remove the object from the end of the receiver's list and return
     the object.

'popItemRef (void)'
     Here for backward compatibility; it is now the same as 'pop.'

'push (OBJECT *(*OBJECT)(int))'
     Add OBJECT to the end of the receiver's list contents.

'pushItemRef (OBJECT *(*OBJECT)(int))'
     Also here for backward compatibility, this method is now the same
     as 'push.'

'shift (OBJECT *(*OBJECT)(int))'
     Add OBJECT as the first element of the receiver's list contents.

'sortAscending (void)'
'sortDescending (void)'
'sortAscendingByName (void)'
'sortDescendingByName (void)'
     Sorts the receiver list based on either the members' values or
     names, in ascending or descending order.  The sort algorithm is
     very simple minded, but due to the mechanics of determining
     earlier/later 'List' members, the methods are as fast for small and
     medium 'Lists' as more complex sort algorithms.

     If possible, you should try to add members in order rather than try
     to re-arrange a 'List' later.  For this, refer to the methods in
     'SortedList' class *Note SortedList::.

'unshift (void)'
     Remove the first object from the receiver's list and return the
     object.

'value (void)'
     Class 'List' objects have no 'value' instance variable.  Instead,
     return the 'List' object's contents, or 'NULL' if the list is
     empty.


File: ctalk.info,  Node: AssociativeArray,  Next: SortedList,  Prev: List,  Up: Classes

'AssociativeArray' Class
------------------------

Objects of class 'AssociativeArray' contain members that are stored and
retrieved using 'Key' objects.  *Note Key::.

'AssociativeArray' objects use the 'atPut' and 'at' methods in
'Collection' class to store and retrieve objects.  *Note Collection::.

The 'keyAt' method returns the key/value pair of the array element named
as its argument.

The 'map' method maps over each object stored in an 'AssociativeArray',
and provides that element as the receiver to the method or code block
given as the argument.

If you want to work with the object stored in the array and the key it
is stored with, the 'mapKeys' method iterates over each key/value pair
of the 'AssociativeArray'

The following example shows how to retreive the keys and values stored
in an 'AssociativeArray'.  Each value that is stored in the array is a
'String' object, so the program does not need to check for different
classes of objects that are stored in the array.


     AssociativeArray instanceMethod printValue (void) {

       printf ("%s\t", self name);
       printf ("%s\n", self value);
       return NULL;
     }

     AssociativeArray instanceMethod printKeyValue (void) {

       String new valueObject;
       printf ("%s =>\t", self name);
       valueObject = self getValue;
       printf ("%s\n", valueObject);
       return NULL;
     }

     int main () {
       AssociativeArray new assocArray;
       String new s1;
       String new s2;
       String new s3;

       WriteFileStream classInit;

       s1 = "string1 value";
       s2 = "string2 value";
       s3 = "string3 value";

       assocArray atPut "string1", s1;
       assocArray atPut "string2", s2;
       assocArray atPut "string3", s3;

       stdoutStream printOn ("%s\n%s\n%s\n\n", (assocArray at "string1"),
     			(assocArray at "string2"),
     			(assocArray at "string3"));
       stdoutStream printOn "%s\n%s\n%s\n\n", (assocArray at "string1"),
         (assocArray at "string2"),
         (assocArray at "string3");
       stdoutStream printOn "%s\n%s\n%s\n\n", assocArray at "string1",
         assocArray at "string2",
         assocArray at "string3";

       assocArray map printValue;

       assocArray mapKeys printKeyValue;

       return 0;
     }


Instance Methods
................

'at (char *KEY)'
     Retrieve the element of the receiver array stored at KEY.

'atPut (char *KEY, OBJECT *ITEM)'
     Add ITEM to the receiver at KEY.

'keyAt (String KEYNAME)'
     Returns the 'Key' object named by KEYNAME.

'map (OBJECT *(*METHOD)())'
     Execute METHOD, an instance method of class 'AssociativeArray,' for
     each member of the receiver array.  Each time METHOD is executed,
     'self' refers to the object stored in the associativeArray.  This
     method returns NULL.

'setValue (void)'
     A wrapper method for 'getValue' in class 'Key.' If received by an
     instance of 'Collection' or its subclasses instead of a 'Key'
     object, this method generates an exception.


File: ctalk.info,  Node: SortedList,  Next: Stream,  Prev: AssociativeArray,  Up: Classes

'SortedList' Class
------------------

Instance Methods
................

'+= (Object OBJ1, ...)'
     Add the items given in the argument to the receiver list.  For
     example:

          int main () {
            SortedList new l;

            l = "first", "second", "third", "fourth";
            l += "fifth", "sixth", "seventh", "eighth";

            l map {
              printf ("%s\n", self);
            }
          }

'= (Object OBJ1, ...)'
     Push the arguments on to the receiver list.  The arguments are a
     comma separated list of objects.  For example:

          int main () {
            SortedList new l;

            l = "first", "second", "third", "fourth";

            l map {
              printf ("%s\n", self);
            }
          }

     The '=' method initializes a list with only the objects that are
     given as arguments.  The memthod deletes any previous list
     contents.

'append (Object OBJ1, ...)'
     Add the objects given in the argument to the receiver list.  This
     is a synonym for the '+=' method, above.

'init (Object OBJ1, ...)'
     This is a synonym for the '=' method, above.

'pushAscending (Object NEW_ITEM)'
'pushDescending (Object NEW_ITEM)'
     Adds NEW_ITEM to the receiver list at the point where its value
     maintains the receiver list items' ascending or descending sort
     order.


File: ctalk.info,  Node: Stream,  Next: FileStream,  Prev: SortedList,  Up: Classes

'Stream' Class
--------------

'Stream' class is the superclass of classes that provide sequential read
and write access to objects and I/O devices.

The subclasses of 'Stream' class are listed here.  This manual describes
each class in its own section.


       Stream
        FileStream
         DirectoryStream
         ReadFileStream
         WriteFileStream
        TerminalStream
         ANSITerminalStream
         Win32TerminalStream
         X11TerminalStream
        NetworkStream
         UNIXNetworkStream
          UNIXNetworkStreamReader
          UNIXNetworkStreamWriter
         TCPIPV6NetworkStream
          TCPIPV6NetworkStreamReader
          TCPIPV6NetworkStreamWriter
         TCPIPNetworkStream
          TCPIPNetworkStreamReader
          TCPIPNetworkStreamWriter



File: ctalk.info,  Node: FileStream,  Prev: Stream,  Up: Classes

'FileStream' Class
------------------

'FileStream' and its subclasses contain methods and variables that read
and write to files and other I/O devices.

Instance Variables
------------------

'streamMode (Class Integer)'
     File permissions mode.
'streamDev (Class Integer)'
     Device ID of a file.
'streamRdev (Class Integer)'
     Device ID if a special file.
'streamSize (Class LongInteger)'
     File size in bytes.
'streamAtime (Class LongInteger)'
     Time of last file access.
'streamMtime (Class LongInteger)'
     Time of last file modification.
'streamCtime (Class LongInteger)'
     Time of last file status change.
'streamPos (Class LongInteger)'
     Offset of read or write operation in the file, if a regular file.
'streamErrno'
     System error number of the last file operation, EOF at the end of
     the file, or 0 on success.
'streamPath'
     A 'String' object, containing the path name of a regular file.

Class Variables
---------------

None.

Instance Methods
................

'= (ARG)'
     Assign the value of the file stream in the argument to the
     receiver.  This method does not duplicate the file handle.

'closeStream (void)'
     Close the receiver's input file stream.  Note that 'closeStream'
     does _not_ delete the receiver object.  You must call 'delete'
     (Class Object) to delete the object explicitly.  Deleting global
     and local objects is still not complete - you must check the
     receiver and argument stacks, and the local variables of the
     function or method, to make sure that the object is removed from
     its dictionary.

'deleteFile (String FILE_PATH)'
     Deletes the file given as the argument.  If the deletion is not
     successful, the method raises a 'SystemErrnoException' which an
     application can check for.

'exists (char *__PATH_NAME)'
     Return 'TRUE' if the file exists, 'FALSE' otherwise.

'isDir (void)'
     Return an 'Integer' object that evaluates to 'TRUE' if the receiver
     is a directory, 'FALSE' otherwise.

'renameFile (String OLDNAME, String NEWNAME)'
     Renames the file named by OLDNAME to NEWNAME.  Raises a
     'SystemErrnoException' if renaming the file causes an error.

'seekTo (Integer FILE_POS)'
     Reposition the file's reading and writing position indicator at
     FILE_POS.  If the request is unsuccessful, the method raises a
     'SystemErrnoException' that a program can check for.

'seekToBeginning (void)'
     Reposition the file's reading and writing position indicator at the
     beginning of a file.  If the request is unsuccessful, the method
     raises a 'SystemErrnoException' that a program can check for.

'seekToEnd (void)'
     Reposition the file's reading and writing position indicator at the
     end of a file.  If unsuccessful, the method raises a
     'SystemErrnoException' that programs can check for.

'size (void)'
     Returns the size of the receiver's file as a 'LongInteger'.

'statFile (String FILE_PATH)'
     A wrapper method for the C 'stat(2)' function.  This method fills
     in the receiver stream's 'streamMode', 'streamDev', 'StreamRdev',
     'streamSize', 'streamAtime', 'streamMtime', and 'streamCtime'
     instance variables.  The stream does not need to be opened on the
     file given by FILE_PATH.

     The method returns an 'Integer' with a value of '0' on success, or
     if an error occurs, returns '-1' and raises a
     'SystemErrnoException'.

'statStream (void)'
     Another wrapper method for the C 'stat(2)' function.  The method
     fills in the 'streamMode', 'streamDev', 'StreamRdev', 'streamSize',
     'streamAtime', 'streamMtime', and 'streamCtime' instance variables
     of the receiver, an open file stream.

     The method returns an 'Integer' with a value of '0' on success, or
     if an error occurs, returns '-1' and raises a
     'SystemErrnoException'.

'streamEof (void)'
     Returns a non-zero 'Integer' object if at the end of the receiver's
     file stream, a zero-value 'Integer' otherwise.

Class Methods
-------------

None.


File: ctalk.info,  Node: DirectoryStream,  Next: ReadFileStream,  Up: Classes

'DirectoryStream' Class
-----------------------

The 'DirectoryStream' class contains methods for creating and deleting
directories, and for reading files in directories.

On machines which have library support for file globbing,
'DirectoryStream' provides methods that read directories and files that
match patterns which contain metacharacters like '*', '?', and '['.
This is in addition to whatever file pattern expansion the shell
performs on file patterns provided on the command line.  See below for
more details.

Metacharacter Expansion.
........................

If a command provides a file specification that contains a
metacharacter, often the shell expands the pattern into a list of files
that the program receives in the function 'main's' 'argv' array.

If the command line provides a quoted metacharacter as one of the
program's arguments, however, the program can use the 'DirectoryStream'
methods 'globPattern' and 'globCwd' to expand the pattern into a list of
filenames.


     $ myfileprog some_arg *    # The shell expands '*' into a list of files.

     $ myfileprog some_arg '*'  # The shell adds a literal '*' to the app's
                                # arguments.

Not all shells provide metacharacter expansion before the program
executes 'main', however, and so the app should check for metacharacters
as arguments also.  The following example shows one way to do this.


     List new fileNames;

     String instanceMethod globFile (void) {

       DirectoryStream new d;
       List new globFiles;

       if (d hasMeta self) {  /* The argv entry contains a wildcard character. */
         d globPattern self, globFiles;
         globFiles map {
           fileNames push self;
         }
       } else {             /* The argv entry is an unambiguous file name. */
         fileNames push self;
       }

     }

     int main (int argc, char *argv[]) {

       int i;

       for (i = 1; i < argc; ++i) {
         argv[i] globFile;
       }

       fileNames map {
         printf ("%s\n", self);
       }
     }


Directory Modes
...............

The default mode for new directories is '0755' ('drwxr-xr-x') modified
by the user's 'UMASK'.  Programs can change the default directory
permissions by redefining the macro 'CTALK_DIRECTORY_MODE'.

Error Handling
..............

The methods 'chDir', 'mkDir', and 'rmDir' raise a 'SystemErrnoException'
on error and return an 'Integer' with the value '-1'.

Instance Methods
................

'chDir (char *DIR)'
     Change to the directory DIR.

'directoryList (char *DIRNAME, List DIRLIST)'
     List directory DIRNAME, and store it in the 'List' DIRLIST.  The
     order of the elements in the list depends on the operating system.
     To expressly create a sorted directory listing, see the
     'sortedDirectoryList' method.

'getCwd (void)'
     Return the current directory as a 'String' object.

'globPattern (String FILE_NAME_PATTERN, List MATCHING_FILE_NAMES)'
     Adds the file names that match FILE_NAME_PATTERN to
     MATCHING_FILE_NAMES.  This method uses the machine's 'glob' library
     call, if it is available, to do the pattern matching.  If the
     system doesn't support filename pattern matching in its C library,
     the method prints a warning message and returns.  For more
     information about how the machine expands file globbing patterns
     into file names, refer to the 'glob(3)' and 'glob(7)' manual pages.

'hasMeta (String FILE_NAME_PATTERN)'
     Returns a 'Boolean' value of True if FILE_NAME_PATTERN contains one
     of the opening metacharacters '*', '?', or '[', False otherwise.

'mkDir (char *DIRECTORYNAME)'
     Create the directory DIRECTORYNAME.

'rmDir (char *DIRECTORYNAME)'
     Delete the directory DIRECTORYNAME.

'sortedDirectoryList (char *DIRNAME, SortedList DIRLIST)'
     List directory DIRNAME, and store it in the 'SortedList' DIRLIST.
     The members of the directory listing are stored in ascending order.


File: ctalk.info,  Node: ReadFileStream,  Next: WriteFileStream,  Prev: DirectoryStream,  Up: Classes

'ReadFileStream' Class
----------------------

The 'ReadFileStream' class contains methods and objects for reading
files.

Instance Variables
------------------

None

Class Variables
---------------

'stdinStream'
     The 'stdinStream' object contains the value of the application's
     standard input channel.

Instance Methods
................

'new (STREAM1, STREAM2, STREAM3,...)'
     Creates one or more new 'ReadFileStream' objects with the names
     given in the argument list; e.g.,


          ReadFileStream new stream1, stream2, stream3;


'openOn (String PATH)'
     Open file PATH with mode 'r' and set the receiver's value to the
     file input stream.

'readAll (void)'
     Returns a String with the contents of the receiver's file stream.

'readChar (void)'
     Returns a Character from the stream defined by the receiver, or
     'EOF' at the end of the input.

'readFormat (char *FMT, ...)'
     Read formatted input from the receiver and store in the objects
     given as arguments.

'readLine (void)'
     Returns a String of characters up to and including the next newline
     of the stream defined by the receiver, or a String containing 'EOF'
     at the end of the input.

'readRec (Integer RECORD_LENGTH)'
     Return a 'String' that contains RECORD_LENGTH characters from the
     receiver's input stream.

'readVec (LongInteger DATA_LENGTH)'
     Reads DATA_LENGTH bytes from the receiver stream and returns a new
     'Vector' object that points to the data.  This is useful for
     reading binary data which may have embedded NULLs and other
     non-human readable characters.  *Note Vector::.

'value'
     Returns the receiver's 'value' instance variable.

Class Methods
-------------

'classInit'
     Called automatically by 'new' when the first 'ReadFileStream'
     object is created.  Initializes 'stdinStream'.


File: ctalk.info,  Node: WriteFileStream,  Prev: ReadFileStream,  Up: Classes

'WriteFileStream' Class
-----------------------

Class 'WriteFileStream' provides objects and methods for writing to
files, including the application's 'stdout' and 'stderr' output
channels.

Because the way UNIX and Linux file stream modes work, a WriteFileStream
opens file non-destructively; that is, for reading and writing, which
means that programs can actually perform both reads and writes from a
WriteFileStream.

All of the methods for reading files are defined in ReadFileStream
class, however.  *Note ReadFileStream::.  It's safer to handle existing
files when they are opened for reading; i.e., as a 'ReadFileStream'
object.

That means 'openOn' won't truncate an existing file.  To start with a
new file, use 'deleteFile' (class 'FileStream').  *Note FileStream::.

In that case, and also any time that 'openOn' doesn't find a file with
that path name, it creates the file first.


       writeFile deleteFile "my/file/path";
       writeFile openOn "my/file/path";


To append to an existing file, use 'seekToEnd' (also in 'FileStream'
class).  *Note FileStream::.


       writeFile openOn "my/file/path";
       writeFile seekToEnd;
       writeFile writeStream appendLine;
       writeFile closeStream;


Instance Variables
------------------

None

Class Variables
---------------

'stdoutStream'
     The 'stdoutStream' object contains the application's standard
     output channel.

'stderrStream'
     The 'stderrStream' object contains the application's standard error
     channel.

Instance Methods
................

'new (STREAM1, STREAM2, STREAM3, ...;)'
     Creates one or more new 'WriteFileStream' objects with the names
     given in the argument list; e.g.,


          WriteFileStream new stream1, stream2, stream3;


'openOn (String PATH_NAME)'
     Open file PATH and set the receiver's value to the file output
     stream.  The file is created if it does not exist.  Raises a
     'systemErrnoException' if an error occurs.

'printOn (char *FMT, ...)'
     Format and print the method's arguments to the receiver, which must
     be a 'WriteFileStream' object that has been opened with 'openOn.'

'value'
     Returns the receiver's 'value' instance variable.

'writeChar CHAR'
     Writes CHAR to the receiver's output file stream.

'writeFormat (char *FMT, ...)'
     Writes its arguments to the receiver using format FMT.

'writeStream STRING'
     Write STRING to the receiver's output file stream.

'writeVec (Vector VECTOR_OBJECT)'
     Write the contents of VECTOR_OBJECT to the receiver stream.  The
     length of the data written is determined by VECTOR_OBJECT'S
     'length' instance variable.  This allows the method to write binary
     data that may contain NULLs and other non-human readable
     characters.  *Note Vector::.


File: ctalk.info,  Node: TerminalStream,  Up: Classes

'TerminalStream' Class
----------------------

'TerminalStream' is the superclass of terminal classes that provide
terminal and console input and output capabilities.

This class implements the input queue for its subclasses.  The queue is
a 'List' object whose members are 'InputEvent' objects.  *Note
InputEvent::.

Instance Variables
..................

'inputQueue'
     A 'List' contains that contains 'InputEvent' objects.
'inputQueueMax'
     The maximum number of 'InputEvent' objects in the 'inputQueue'
'nInputEvents;'
     The actual number of 'InputEvent' objects in the 'inputQueue'

Instance Methods
................

'inputPending (void)'
     Returns 'TRUE' if a terminal stream has pending input objects.

'isATty (void)'
     Return 'TRUE' if the receiver's stream is a tty device, 'FALSE'
     otherwise.

'nextInputEvent (void)'
     Return the next 'InputEvent' object from the stream's input queue.

'queueInput (void)'
     Turn on queueing of input events.

'queueInputEvent (void)'
     Queue this input event.


File: ctalk.info,  Node: ANSITerminalStream,  Up: Classes

'ANSITerminalStream' Class
--------------------------

'ANSITerminalStream' objects and their methods provides basic I/O
capabilities for consoles that use standard input and output input, as
well as serial terminals.

'ANSITerminalStream' also provides basic input translation and output
formatting for ANSI, VT100, XTerm, and similar terminal types.

'ANSITerminalStream' does not provide curses-like screen buffering
methods.  The class's output methods output characters correctly whether
the terminal is in canonical or raw mode.

If a program sets the terminal to raw mode (either with the 'rawMode' or
'getCh' methods), it should also output characters with 'printOn', and
restore the terminal before exiting, as this example illustrates.
     int main () {
       ANSITerminalStream new term;
       Character new c;

       term rawMode;
       term clear;
       term gotoXY 1, 1;

       while ((c = term getCh) != EOF)
         term printOn "%c", c;

       term restoreTerm;
     }

If a program needs to handle cursor and other non-alphanumeric keys,
then it must open the 'TerminalStream' input queue (with the
'openInputQueue' method) and read input events.  *Note TerminalStream::.

At present, Ctalk recognizes the following input event classes.
     KBDCHAR        # ASCII Characters
     KBDCUR         # Cursor Keys.

When reading an 'InputEvent' (with 'nextInputEvent' in 'TerminalStream'
class), the event class is stored in the 'eventClass' instance variable
of the 'InputEvent' object.

Here is an example of a program that opens a terminal input queue and
reads characters by retrieving input event objects from the queue.
     int main () {
       ANSITerminalStream new term;
       Character new c;
       InputEvent new iEvent;

       term rawMode;
       term clear;
       term cursorPos 1, 1;
       term openInputQueue;

       while ((c = term getCh) != EOF) {
         iEvent become (term nextInputEvent);
         if (iEvent eventClass == KBDCHAR) {
           term printOn "<KEY>%c", iEvent eventData;
         }
         if (iEvent eventClass == KBDCUR) {
           term printOn "<CURSOR>%c", iEvent eventData;
         }
       }
     }
Because 'ANSITerminalStream' objects wait until the user has typed a
key, programs can read input events synchronously, but programs that use
other input stream classes may read the input queue asynchronously.

Newly created ANSITerminalStream objects use standard input and standard
output as their file streams.  Programs that read and write to serial
terminals can open the terminal's serial line with 'openOn', and set the
communication parameters with 'setTty', as in this example.
     int main () {
       ANSITerminalStream new term;
       SystemErrnoException new s;

       term openOn "/dev/ttyS1";
       if (s pending)
         s handle;

       term setTty 9600, 8, N, 1;
       term printOn "Hello, world!\r\nHello, world!\r\n";
       term closeStream;
     }

However, programs also need to take note of the differences between
xterms, console displays, and serial terminals.  For example, some
serial terminals won't send an 'ESC' ('0x1b' hex) character until
another character is typed at the terminal to flush the terminal's
output.  Also, programs should not depend on a particular terminal's
newline translation protocol, and some terminals echo tab characters
without special configuration.  Some terminal parameters are tunable in
the 'ANSITerminalStrea' class, but if a program needs special character
handling, you may need to write a subclass of 'ANSITerminalStream' for a
particular terminal.

Instance Variables
..................

'inputHandle'
     A 'ReadFileStream' object that contains the terminal's input
     stream.  The handle is initialized to standard input when the
     'ANSITerminalStream' object is created.  Also refer to the
     information for 'outputHandle', below.

'outputHandle'
     A 'WriteFileStream' object that contains the terminal's output
     stream.  The handle is initialized to standard output when the
     'ANSITerminalStream' object is created.  Programs can use the
     methods 'openOn' and 'setTty' (below), to open and configure
     handles for serial terminals.

     In practice, objects that are instances of 'ANSITerminalPane' and
     its subclasses use the 'inputHandle' stream for both input and
     output with serial terminals, but programs can configure
     'ouputHandle' independenly if necessary.

'queueInput'
     True if queueing input events.

'rawModeFlag'
     True if the terminal stream parameters are set to raw mode.

'termioCIFlag'
'termioCOFlag'
'termioCLFlag'
'termioCCFlag'
     Terminal settings.  These variables are set with the current
     terminal parameters when creating an 'ANSITerminalStream' object
     with 'new', and restored by the 'restoreTerm' method.
'ttyDevice'
     A 'String' containing the path terminal's device file, if different
     than 'stdinStream' and 'stdoutStream'.  This variable is currently
     unused.

Instance Methods
................

'clear (void)'
     Clear the terminal stream.

'closeStream (void)'
     Close a terminal stream that was previously opened with 'openOn',
     below.

'cursorPos (int ROW, int COLUMN)'
     Set the cursor position to ROW, COLUMN.  The upper left-hand corner
     of screen is '1,1'.

'getCh (void)'
     Get a character from the terminal without echoing it.  This method
     handles 'C-c', 'C-d', and 'C-z' control characters by exiting.
     This method calls 'rawMode', so the application must call
     'restoreTerm' before exiting.

'gotoXY (int ROW, int COLUMN)'
     Set the cursor position to ROW, COLUMN.  The upper left-hand corner
     of screen is '1,1'.  This method is a synonym for 'cursorPos',
     above.

'new (STREAM1, STREAM2, ... STREAMN; )'
     Create one or more new 'ANSITerminalStream' objects and initialize
     their input and output handles to 'stdinStream'.  *Note
     ReadFileStream::, and 'stdoutStream'.  *Note WriteFileStream::.
     For example,


          ANSITerminalStream new stream1, stream2;


'openInputQueue (void)'
     Begin queueing input events.  *Note InputEvent::.

'openOn (char *TTY_DEVICE_NAME)'
     Open a tty device for the receiver.

'printOn (char *FMT, ...)'
     Print the formatted output to the receiver's output stream.

'rawMode (void)'
     Set the terminal input and output streams to raw mode.

'readChar (void)'
     Read a character from the receiver's input stream.

'readLine (void)'
     Read a line of text from the receiver's input stream and return a
     'String' object with the text.

'restoreTerm (void)'
     Restore the terminal parameters to the values when the
     'ANSITerminalStream' object was created.  Applications must call
     this method after using the 'getCh' and 'rawMode' methods, or the
     terminal may be unusable after the the application exits.

'setGraphics (char ATTRIBUTE)'
     Set the graphics attribute for the following characters.  The
     ATTRIBUTE argument can be one of the following characters.
          0       Attributes Off
          1       Bold
          4       Underscore
          5       Blink
          7       Reverse

'setTty (int SPEED, int DATA_BITS, char PARITY, int STOP_BITS)'
     Set the communication parameters of a terminal device opened with
     'openOn', above.


File: ctalk.info,  Node: Win32TerminalStream,  Up: Classes

'Win32TerminalStream' Class
---------------------------

The 'Win32TerminalStream' class provides keyboard input capabilities for
Win32 'cmd.exe' consoles.  It also provides basic output formatting
capabilities using DJGPP's 'conio.h' functions.  This class does not
provide curses-style output buffering.

This class is not strictly a stream, and is likely to remain limited to
displays in the 'cmd.exe' window until Ctalk can implement a genuine
'fork(3)' system call for non-POSIX systems.

'Win32TerminalStream' simulates raw terminal I/O using BDOS and C
library function calls.  If the program needs to handle extended keys
like cursor and keypad keys, it should open the 'TerminalStream' input
queue (with the 'openInputQueue' method) and read input events.  *Note
TerminalStream::.

At present, Ctalk recognizes the following input event classes.  In
'Win32TerminalStream' class, the 'getCh' method generates a 'KBDCUR'
input events for all extended keys.
     KBDCHAR        # ASCII Characters
     KBDCUR         # Extended keys (first character read returns 0).

For examples of how to read characters from the keyboard, see the
program listings in the 'ANSITerminalStream' class section of the
manual.  *Note ANSITerminalStream::.

Instance Variables
..................

'queueInput'
     True if queueing input events.  The current state of the keyboard's
     modifier keys.  Set by the 'biosKey' and 'getShiftState' methods,
     below.

Instance Methods
................

     Waits for a key and returns the scan code of a BIOS Int 16h,
     function 0 call.  Also sets the shift state in the receiver's
     'shiftState' instance variable.  See the 'getShiftState' method,
     below.

'cGetStr (void)'
     Returns a 'String' object that contains input typed by the user.
     The input is echoed to the console.

'clear (void)'
     Clears the terminal window and moves the cursor to the upper
     left-hand corner.

'cPutStr (char *STR'
     Prints STR to the console at the current cursor position.

'cusorPos (int X, intY)'
     Positions the cursor at character position X, Y.  The upper
     left-hand corner of the screen is row 1, column 1.  This is a
     synonym for 'gotoXY,' below.

'getCh (void)'
     Essentially a wrapper for the BDOS character input without echo
     function.  This method handles 'C-c', 'C-d', and 'C-z' by exiting
     the application.

'getShiftState (void)'
     Get the state of the keyboard's modifier keys with by calling BIOS
     Int 0x16, function 12h.  Stores the result in the receiver's
     'shiftState' instance variable.

'gotoXY (int X, intY)'
     Positions the cursor at character position X, Y.  The upper
     left-hand corner of the screen is row 1, column 1.

'openInputQueue (void)'
     Begin queueing input events.  *Note InputEvent::.

'printOn (char *FMT, ...)'
     Print the formatted output to the receiver's output stream.

'screenColor (char *FGCOLOR, char*BGCOLOR)'
     Sets the window's foreground and background colors for following
     writes using 'cPutStr,' above.  The arguments are class 'String,'
     and may have the following values.
          black
          blue
          green
          cyan
          red
          magenta
          brown
          lightgray
          darkgray
          lightblue
          lightgreen
          lightcyan
          lightred
          yellow
          white


File: ctalk.info,  Node: X11TerminalStream,  Next: NetworkStream,  Up: Classes

'X11TerminalStream' Class
-------------------------

'X11TerminalStream' objects and methods handle input events from X
Window System displays.  Ctalk's X11 support focuses on the windows
themselves, so this class should almost always be used with a 'X11Pane'
object.  *Note X11Pane::.

Here is an example program that uses 'InputEvent' objects created by the
window's input stream, 'xPane', to configure the dimensions of the
pane's window.  The 'X11TerminalStream' object is contained in the
'X11Pane''s 'inputStream' instance variable.
     int main () {

       X11Pane new xPane;
       InputEvent new e;

       xPane initialize 25, 30, 100, 100;
       xPane map;
       xPane raiseWindow;
       xPane openEventStream;

       WriteFileStream classInit;

       while (TRUE) {
         xPane inputStream queueInput;
         if (xPane inputStream eventPending) {
           e become xPane inputStream inputQueue unshift;
           switch (e eventClass value)
     	{
     	case CONFIGURENOTIFY:
     	  stdoutStream printOn "ConfigureNotify\t%d\t%d\t%d\t%d\n",
     	    e xEventData1,
     	    e xEventData2,
     	    e xEventData3,
     	    e xEventData4;
     	  stdoutStream printOn "Window\t\t%d\t%d\t%d\t%d\n",
     	    xPane origin x,
     	    xPane origin y,
     	    xPane size x,
     	    xPane size y;
     	  break;
     	case WINDELETE:
     	  xPane deleteAndClose;
     	  exit (0);
     	  break;
     	default:
     	  break;
     	}
         }
       }
     }

When compiling this program, you might also need to add the directory
that contains the X include files to the include search path.  For
example:
     $ ctcc -I /usr/include/X11 windemo.c -o windemo       # Recent Linux
Ctalk's libraries are linked with the system's X libraries during
installation if they are present, but applications may also need to link
with X libraries directly in some cases.

Event Classes
.............

A 'X11TerminalStream' object recognizes the following input event
classes, and returns the following information in the 'xEventData'
instance variables, which are defined in 'InputEvent' class.  *Note
InputEvent::.
     Event Class     xEventData1 xEventData2 xEventData3 xEventData4 xEventData5
     BUTTONPRESS     x           y           state       button      -
     BUTTONRELEASE   x           y           state       button      -
     KEYPRESS        x           y           state       keycode     x_keycode[1]
     KEYRELEASE      x           y           state       keycode     x_keycode[1]
     CONFIGURENOTIFY x           y           height      width       border
     MOVENOTIFY      x           y           height      width       border
     RESIZENOTIFY    x           y           height      width       border
     MOTIONNOTIFY    x           y           state       is_hint     -
     MAPNOTIFY       event       window      -           -           -
     EXPOSE          x           y           width       height      count
     SELECTIONREQUEST -          -           -           -           -
     SELECTIONCLEAR  -           -           -           -           -
     WINDELETE       -           -           -           -           -
[1] The values of X keycodes are defined in X11/keysymdefs.h.

The 'x' and 'y' coordinates of the key and button events are relative to
the window's origin.  The 'x' and 'y' coordinates of a 'CONFIGURENOTIFY'
event are relative to the origin of the root window, normally the upper
left-hand corner of the display.

The 'MOVENOTIFY' and 'RESIZENOTIFY' events are both derived from
'CONFIGURENOTIFY' events, depending on whether the receiver's window was
moved or resized.

Instance Variables
..................

'inputPID'
     The process ID of the 'X11TerminalStream' event handler.
'clientFD'
     The file descriptor that the 'X11TerminalStream' event handler uses
     when communicating with the main window's process.
'eventMask'
     An 'Integer' that contains the OR'd values of the window system
     events that the program wants to be notified of.  The window system
     events are listed in the table above.  If 'eventMask's' value is
     zero, then the event handler assumes that the program wants to
     receiver all window system events.  Any non-zero value, however,
     causes the program to receive only those events; for example:


          myMainWindow inputStream eventMask = WINDELETE|KEYPRESS;


     In this case the program only receives notice of key presses
     ('KEYPRESS' events) and requests from the GUI desktop to close the
     window ('WINDELETE' events) and exit the program.

Instance Methods
................

'openInputClient (void)'
     Open the X input handler.  This method is normally used by
     'X11Pane' class's 'openEventStream' method.  *Note X11Pane::.

'parentPane (void)'
     Return the receiver's 'X11Pane' parent object if present.

'queueInput (void)'
     Queue window system events as 'InputEvent' objects in the
     receiver's 'inputQueue' instance variable.  The 'inputQueue'
     instance variable is inherited from 'TerminalStream' class.  *Note
     TerminalStream::.


File: ctalk.info,  Node: NetworkStream,  Next: TCPIPNetworkStream,  Prev: X11TerminalStream,  Up: Classes

'NetworkStream' Class
---------------------

'NetworkStream' is the superclass of objects that use socket connections
to send and receive data.  The subclasses of 'NetworkStream' provide
support for connections between processes within a program, between
programs on the same machine or a local network, or between Internet
sites.

Each of 'NetworkStream's' subclasses, listed here, has its own section.


       TCPIPNetworkStream
         TCPIPNetworkStreamReader
         TCPIPNetworkStreamWriter
       TCPIPV6NetworkStream
         TCPIPV6NetworkStreamReader
         TCPIPV6NetworkStreamWriter
       UNIXNetworkStream
         UNIXNetworkStreamReader
         UNIXNetworkStreamWriter



File: ctalk.info,  Node: TCPIPNetworkStream,  Next: TCPIPNetworkStreamReader,  Prev: NetworkStream,  Up: Classes

'TCPIPNetworkStream' Class
--------------------------

'TCPIPNetworkStream' class contains methods for sockets that are used
for both writing and reading.

Methods that are specific to programs that read from sockets are defined
in 'TCPIPNetworkStreamReader' class, *Note TCPIPNetworkStreamReader::,
and methods that work with programs that write to network connections
are defined in 'TCPIPNetworkStreamWriter' class *Note
TCPIPNetworkStreamWriter::.

Here is a program that writes data to a network connection.


     static char *msg = "First connect.\n";

     int main (int argc, char **argv) {
       SystemErrnoException new ex;
       TCPIPNetworkStreamWriter new client;

       if (argc != 2) {
         printf ("Usage: ip6writer <server_hostname>\n");
       }
       client openOn argv[1];
       client writeText msg;
       if (ex pending) {
         ex handle;
       }

       client closeSock;
     }


And here is the corresponding program that reads the data from the
network connection and displays it.


     int main () {
       TCPIPNetworkStreamReader new server;
       Exception new ex;
       String new output;
       int newsocket;

       server openOn;

       newsocket = server acceptSock;

       if (newsocket > 0) {
         output = server readText newsocket;
         if (ex pending) {
           ex handle;
         }
         printf ("%s\n", output);
         server closeSock newsocket;
       } else if (ex pending) {
         ex handle;
       } else {
         printf ("Connection timed out.\n");
       }

       server closeSock;
     }


Instance Variables
..................

'sock'
     An 'Integer' that contains the file handle number of the socket
     created when a network connection is opened.

Instance Methods
................

'addrInfo (String HOSTNAME, String CANONICALNAMEOUT, List ADDRSOUT'
     Performs a lookup of HOSTNAME'S IP addresses.  If the lookup is
     successful, returns the host's canonical name in CANONNAMEOUT and
     each of the host's addresses as a string in ADDRSOUT.  The method's
     return value is an 'Integer' with the number of addresses found.

     If the lookup causes an error, the method raises an 'Exception'
     (_not_ a 'SystemErrnoException') and returns 0.

'closeSock (void)'
'closeSock (Integer SOCK_FH)'
     With no arguments, closes the receiver's socket.  With one
     argument, closes the socket given as the argument.  If closing a
     socket causes an error, the method raises a 'SystemErrnoException'.

'createSocketBasic (void)'
     Creates a socket with the domain AF_INET and the protocol
     SOCK_STREAM, and sets the receiver's sock instance variable to the
     new socket's file handle number, an Integer, and then returns the
     socket's file handle number.  If not successful, the method raises
     a SystemErrnoException and returns 0.

'hostToAddress (String HOSTNAME)'
     Given the name of a network host as the argument, the method
     returns a 'String' containing the host's dotted quad Internet
     address.

     If the hostname lookup doesn't return any results, the method
     raises an 'Exception' (_not_ a 'SystemErrnoException') and returns
     an empty 'String'.


          #include <stdio.h>   /* contains printf prototype */

          int main () {
            TCPIPNetworkStream new net;
            String new address;

            address = net hostToAddress "MyHostName"; /* Substitute your host's name. */

            printf ("%s\n", address);
          }


'readText (void)'
'readText (Integer SOCK_FH)'
     Reads a socket's input and returns the input as a 'String' object.
     With no arguments, the method uses the receiver's socket file
     handle, which is normally assigned by 'createSocketBasic', above.

     If a socket file handle is given as the argument, then the method
     performs the read on that handle.  This is useful when performing
     reads after a call to 'acceptSock' or a similar method.  *Note
     TCPIPNetworkStreamReader::.

     If an error occurs while reading, the methods raise a
     'SystemErrnoException'.

'readVec (Integer SOCK_FH, Vector DATA_VEC_OUT)'
     Reads binary data from the socket given as the first argument and
     returns the data in the 'Vector' object give as the second
     argument.

     The method raise a 'SystemErrnoException' if an error occurs while
     reading.

     This example is a simple server that receives image data and writes
     it to a file.


          int main () {
            TCPIPNetworkStreamReader new server;
            SystemErrnoException new ex;
            Vector new output;
            WriteFileStream new writeF;
            int newsocket;
            char *socket_out;

            server openOn;

            newsocket = server acceptSock;  /* INADDR_ANY */

            if (newsocket > 0) {
              server readVec newsocket, output;
              if (ex pending) {
                ex handle;
              }
              server closeSock newsocket;
            } else if (ex pending) {
              ex handle;
            } else {
              printf ("Connection timed out.\n");
            }

            server closeSock;

            writeF openOn "image-copy.jpeg";
            writeF writeVec output;
            writeF closeStream;
          }


     Here is the corresponding client program that transmits the image
     data.


          int main () {
            SystemErrnoException new ex;
            TCPIPNetworkStreamWriter new client;
            ReadFileStream new readF;
            Vector new photo;
            LongInteger new imageSize;

            readF openOn "image.jpeg";

            readF statStream;
            imageSize = readF streamSize;

            photo = readF readVec imageSize;

            readF closeStream;

            client openOn "127.0.0.1"; /* Edit with the reciever's actual network
                                          address. */

            client writeVec photo;
            if (ex pending) {
              ex handle;
            }

            client closeSock;
          }

'readText (String TEXT)'
     Writes the TEXT given as the argument to the reciever's socket.  If
     the number of bytes actually written isn't equal to the length of
     TEXT, then the method raises a 'SystemErrnoException'.

'readText (Vector DATA)'
     Writes the data contained in the argument to the receiver's socket.
     The method raises an Exception if the argument is not a 'Vector',
     or a 'SystemErrnoException' if an error occurs while writing.

     Examples of client and server programs which handle binary data are
     given in the entry for 'readVec', above.


File: ctalk.info,  Node: TCPIPNetworkStreamReader,  Next: TCPIPNetworkStreamWriter,  Prev: TCPIPNetworkStream,  Up: Classes

'TCPIPNetworkStreamReader' Class
--------------------------------

'TCPIPNetworkStreamReader' class defines methods and instance variables
that are used specifically for reading data from network connections.

For example programs, refer to the 'TCPIPNetworkStream' class *Note
TCPIPNetworkStream::.

Instance Variables
..................

'timeout'
     An 'Integer' that contains the number of seconds to wait for
     incoming connections.

Instance Methods
................

'acceptSock (void)'
     Waits for an incoming connection on the receiver's socket, and if a
     connection is pending, returns the number of the socket that
     communications will take place on.

     If the connection times out, then the method returns 0.  The length
     of time the method should wait for incoming connections is given by
     the receiver's 'timeout' instance variable.

     If an error occurs, the method returns 0 and also raises a
     'SystemErrnoException'.

     Note: The method can handle peer connections if the operating
     system supports it - binding listening sockets to specific
     addresses is not uniformly supported among operating systems.  In
     these cases, the method can also wait for connections using the
     constant INADDR_ANY.

     This is done by using the 'openOn' method (below) with no network
     address.


            mySock openOn "127.0.0.1";   /* bind the socket to the
                                            local network connection. */

            mySock openOn;               /* bind a socket to listen for
                                            connections from any network
                                            address. */


     In the second case, the 'acceptSock' method can also function as
     the core of a more conventional network server.

'openOn (void)'
'openOn (String ADDRESS)'
'openOn (String ADDRESS, Integer PORT)'
     Creates the receiver's socket and binds it to receive messages from
     the network ADDRESS given as the argument.  If no network address
     is given, the receiver's socket is bound to the constant
     INADDR_ANY.

     If no PORT argument is given, the socket is bound to
     DEFAULT_TCPIP_PORT, which is defined in 'classes/ctalkdefs.h', and
     which you can set depending on the the systems' needs.

     These methods raise an 'Exception' if any of the networking
     functions return an error.


File: ctalk.info,  Node: TCPIPNetworkStreamWriter,  Next: TCPIPV6NetworkStream,  Prev: TCPIPNetworkStreamReader,  Up: Classes

'TCPIPNetworkStreamWriter' Class
--------------------------------

The 'TCPIPNetworkStreamWriter' class defines supporting methods for
programs that write to network connections.

For example programs, refer to the 'TCPIPNetworkStream' class; *Note
TCPIPNetworkStream::.

Instance Methods
................

'openOn (String ADDRESS)'
'openOn (String ADDRESS, Integer PORT)'
     Creates a socket and connects it to the network ADDRESS given as
     the argument.

     If a PORT argument is given, the socket connects over that port;
     otherwise, the socket connects via DEFAULT_TCPIP_PORT, which is
     defined in 'classes/ctalkdefs.h', which you can adjust to suit the
     network's needs.

     These methods raise a 'SystemErrnoException' if any of the
     networking functions return an error.


File: ctalk.info,  Node: TCPIPV6NetworkStream,  Next: TCPIPV6NetworkStreamReader,  Prev: TCPIPNetworkStreamWriter,  Up: Classes

'TCPIPV6UNIXNetworkStream' Class
--------------------------------

The 'TCPIPV6NetworkStream' class manages TCPIP version 6 stream objects.
The class is a superclass of the 'TCPIPV6NetworkStreamReader' and
'TCPIPV6NetworkStreamWriter' classes, and the methods and instance
variables that are defined by this class are common to both client and
server programs.

Here is an example of simple IPv6 reader program.


     int main () {
       SystemErrnoException new ex;
       TCPIPV6NetworkStreamReader new server, connection;
       String new data;

       server openOn;
       if (ex pending) {
         ex handle;
       }

       connection = server acceptSock;
       if (ex pending) {
         ex handle;
       }
       data = server readText connection;
       printf ("%s\n", data);

       server closeSock;
     }


And here is a simple program that writes a message to a TCPIP v6
connection.


     static char *msg = "First connect.\n";

     #include <ctalk/ctalkdefs.h>

     int main (int argc, char **argv) {
       SystemErrnoException new ex;
       TCPIPV6NetworkStreamWriter new client;

       if (argc != 2) {
         printf ("Usage: ip6writer <server_hostname>\n");
       }

       client openOn argv[1];
       if (ex pending) {
         ex handle;
       }

       client writeText msg;

       client closeSock;
     }


Instance Variables
..................

'sock'
     An 'Integer' that contains the system-assigned file handle number
     of 'TCPIPV6NetworkStreamReader' and 'TCPIPV6NetworkStreamWriter'
     objects.

Instance Methods
................

'addrInfo (String HOSTNAME, String CANONNAMEOUT, List ADDRSOUT)'
     Performs a lookup of HOSTNAME'S IPv6 addresses.  If the lookup is
     successful, returns the host's canonical name in CANONNAMEOUT and
     each of the host's addresses as a string in ADDRSOUT.  The method's
     return value is an 'Integer' with the number of addresses found.

     If the lookup causes an error, the method raises an 'Exception'
     (_not_ a 'SystemErrnoException') and returns 0.

'closeSock (void)'
'closeSock (Integer SOCKNUM)'
     With no arguments, closes the receiver's socket.  If a socket file
     handle number is given as the argument, closes that socket.  If
     closing the socket causes an error, the method raises a
     'SystemErrnoException'.

'createSocketBasic'
     Creates a new IPv6 socket and sets the receiver's 'sock' instance
     variable, an 'Integer', to the system-assigned file number, and
     returns the 'sock' instance variable.  If an error occurs while
     creating a socket, the method raises a 'SystemErrnoException' and
     returns 0.

'readText (void)'
'readText (Integer SOCK_FN)'
     Read text from a network connection.  With no arguments, the value
     of the receiver's 'sock' instance variable provides the socket file
     handle.  If one argument is given, the argument, an 'Integer',
     provides the file handle number.

     These methods return a 'String' with the contents of the received
     message.  If an error occurs while reading, the methods raise a
     'SystemErrnoException' and return 'NULL'.

'readVec (Integer SOCK_FN, Vector RESULTVEC)'
     Reads binary data from the socket handle SOCK_FN into RESULTVEC,
     and returns RESULTVEC.  The method raises a 'SystemErrnoException'
     if an error occurs.

'writeText (String TEXTARG)'
     Writes the 'String' given as the argument to the receiver's socket.
     If the number of bytes written does not match the length of
     TEXTARG, the method raises a 'SystemErrnoException'.

'writeVec (Vector DATAVEC)'
     Writes the contents of DATAVEC to the receiver's socket.  If the
     number of bytes written does not match the length of the data, the
     method raises a 'SystemErrnoException'.


File: ctalk.info,  Node: TCPIPV6NetworkStreamReader,  Next: TCPIPV6NetworkStreamWriter,  Prev: TCPIPV6NetworkStream,  Up: Classes

'TCPIPV6UNIXNetworkStreamReader' Class
--------------------------------------

Instance Variables
..................

'timeout'
     An 'Integer' that contains the number of seconds that the
     'acceptSock' method (below) should wait for a connection.  The
     default is 10 seconds.

Instance Methods
................

'acceptSock (void)'
     Listens for incoming connections on the socket that is bound to a
     network address and port by a previous call to 'openOn'.

     If the program receives an incoming connection, 'acceptSock'
     creates a new socket to read data from the connection and returns
     the socket number, an 'Integer', to the calling program.

     If the method times out, it returns 0 to the calling program.  The
     'timeout' instance variable determines the number of seconds the
     method should wait for incoming connections.  The default is 10
     seconds.

     If an error occurs, the method returns -1 and raises a
     'SystemErrnoException'.

'openOn (void)'
'openOn (Integer PORT)'
'openOn (String HOSTNAME, Integer PORT)'
     Binds a 'TCPIPV6NetworkStreamReader' object to the hostname and
     port given as the arguments, if any.  The return value is the
     socket handle number of the receiver, an 'Integer'.

     If no hostname or port is given, the method binds the socket to the
     system constant 'in6addr_any', and the port defined by
     DEFAULT_TCPIP_PORT, defined by the Ctalk library in the ctalkdefs.h
     header file.

     If an error occurs, these methods raise an 'Exception' and return
     0.


File: ctalk.info,  Node: TCPIPV6NetworkStreamWriter,  Next: UNIXNetworkStream,  Prev: TCPIPV6NetworkStreamReader,  Up: Classes

'TCPIPV6UNIXNetworkStreamWriter' Class
--------------------------------------

Instance methods
................

'openOn (String HOSTNAME)'
'openOn (String HOSTNAME, Integer PORT)'
     Open a socket connection to HOSTNAME for writing, optionally using
     PORT as the network port for the connection.  If successful, the
     method returns the filehandle number of the socket object that made
     the connection as an 'Integer'

     If no PORT is given, the method uses the definition of
     'DEFAULT_TCPIP_PORT', which is defined in 'ctalkdefs.h', as the
     port number.  To include these definitions, you can add the
     following line to a program.


          #include <ctalk/ctalkdefs.h>


     The argument HOSTNAME must be the name of an IPv6 capable host, or
     the method raises an 'Exception' and returns 0.  The method also
     raises an 'Exception' and returns 0 if an error occurs while trying
     to connect the socket.


File: ctalk.info,  Node: UNIXNetworkStream,  Next: UNIXNetworkStreamReader,  Prev: TCPIPV6NetworkStreamWriter,  Up: Classes

'UNIXNetworkStream' Class
-------------------------

'UNIXNetworkStream' and its subclasses define instance and class
variables and methods to communicate over UNIX domain sockets between
processes and programs operating on the same machine.

As a type of interprocess communication, UNIX domain sockets are more
flexible than named pipes - programs create and manage one or more sets
of reader and writer objects independently of each other.

The section 'UNIXNetworkStreamReader' describes the methods and instance
data for creating and managing reader objects *Note
UNIXNetworkStreamReader::, and the section 'UNIXNetworkStreamWriter'
describes the details of writer objects *Note UNIXNetworkStreamWriter::.

Class Variables
...............

'socketPrefix'
     A 'String' that defaults to the machine-specific directory name
     where the system stores its temporary files (e.g., '/tmp',
     '/var/tmp', etc.).

Instance Variables
..................

'sock'
     An 'Integer' that contains the file handle number the receiver's
     socket.
'socketBaseName'
     A 'String' that contains the base name of the socket's path name.
     The string may contain escape characters.  Refer to the
     'makeSocketPath' method, below.
'socketPath'
     A 'String' that contains the fully qualified path name of a
     program's UNIX domain socket.

Instance Methods
................

'closeSocket (void)'
     Shuts down the receiver's socket (defined in the 'sock' instance
     variable) and deletes the socket's file entry (which is defined in
     the 'socketPath' instance variable), if present.

'makeSocketPath (String BASENAME)'
     Constructs a fully qualified socket path from BASENAME and the
     prefix given by 'socketPrefix' (described above).  If BASENAME
     contains the characters '$$', the method replaces the character
     with the program's process ID.

     After constructing the fully qualified name, the method fills in
     the receiver's 'socketBaseName' and 'socketPath' instance
     variables, and returns the value of the 'socketPath' instance
     variable.

     The small program here constructs and prints the file pathname of a
     program's UNIX socket, which includes the process ID of the
     program.


          int main () {
            UNIXNetworkStream new un;
            String new sockName;

            sockName = "myprogsocket.$$";

            un makeSocketPath sockName;
            printf ("%s\n", un socketPath);
          }


'removeSocket (void)'
     Deletes the socket's file entry by its name, which is defined by
     'makeSocketPath', above.


File: ctalk.info,  Node: UNIXNetworkStreamReader,  Next: UNIXNetworkStreamWriter,  Prev: UNIXNetworkStream,  Up: Classes

'UNIXNetworkStreamReader' Class
-------------------------------

'UNIXNetworkStreamReader' objects receive data using UNIX domain sockets
on a single machine.  The class defines methods to create a connection
and check the connection for incoming data, and read any data for the
application.

Here are slightly abreviated versions of the 'sockread.c' and
'sockwrite.c' example programs.  This is the source code of
'sockread.c'.


     int main () {
       UNIXNetworkStreamReader new reader;
       SystemErrnoException new ex;
       FileStream new f;
       String new sockName;
       String new data;

       sockName = "testsocket";

       reader makeSocketPath sockName;
       printf ("reader socket:  %s\n", reader socketPath);

       /* Delete a socket from a previous connection if necessary. */
       if (f exists reader socketPath) {
         f deleteFile reader socketPath;
       }

       reader open;
       if (ex pending) {
         ex handle;
         unlink (reader socketPath);
         return -1;
       }

       while (1) {
         data = reader sockRead;

         if (data length > 0) {
           printf ("%s\n", data);
         }
         if (ex pending) {
           ex handle;
           break;
         }
         usleep (1000);
       }

       return 0;
     }


And here is 'sockwrite.c'.  For details about its operation, refer to
the 'UNIXNetworkStreamWriter' section.  *Note UNIXNetworkStreamWriter::.


     int main (int argc, char **argv) {
       UNIXNetworkStreamWriter new writer;
       SystemErrnoException new ex;
       String new sockName;
       String new data;

       sockName = "testsocket";

       writer makeSocketPath sockName;
       printf ("writer socket:  %s\n", writer socketPath);

       writer open;
       if (ex pending) {
         ex handle;
       }

       writer sockWrite argv[1];

       if (ex pending) {
         ex handle;
       }

       exit (0);
     }


The programs communicate if started from different shells used by
different virtual terminals or different windows on a graphical desktop,
or if the reader program is started in the background and the writer
started in the foreground.

Instance Variables
..................

'charsRead'
     An 'Integer' that contains the number of characters read by the
     last reception of data from a connection, or zero if there is no
     data waiting.  Refer to the method 'sockRead', below.

Instance Methods
................

'open (void)'
     Creates a socket to read data from the socket name by the
     receiver's 'socketPath' instance variable, which is defined in
     'UNIXNetworkStream' class.  *Note UNIXNetworkStream::.

     The method returns the file number of the socket, or -1 if there is
     an error, and raises a 'SystemErrnoException' if an error occurred
     in the network library routines.

'openOn (String SOCKETPATH)'
     Creates a new reader socket and binds it to SOCKETPATH.  Sets the
     receiver's 'socketPath' instance variable to the argument.  Returns
     an 'Integer' with the file number of the newly created socket.

'sockRead (void)'
     Returns a 'String' containing data received from the socket
     previously created by the 'open' method, above, and sets the
     'charsRead' instance variable to the number of characters read.

     If no data is waiting, the method returns an empty string and sets
     the receiver's 'charsRead' instance variable to 0.

     If an error occurs during one of the system calls, the method
     raises a 'SystemErrnoException'.


File: ctalk.info,  Node: UNIXNetworkStreamWriter,  Next: TreeNode,  Prev: UNIXNetworkStreamReader,  Up: Classes

'UNIXNetworkStreamWriter' Class
-------------------------------

'UNIXNetworkStreamWriter' objects send data over machine- local UNIX
domain sockets.  The class contains methods to open sockets and send
data over the network connection.

For an example of how to use 'UNIXNetworkStreamWriter' objects, refer to
the programs in the 'UNIXNetworkStreamReader' section.  *Note
UNIXNetworkStreamReader::.

Instance Variables
..................

'charsWritten'
     An 'Integer' that contains the number of bytes written by the
     previous call to the 'sockWrite' method, which is described below.

Instance Methods
................

'open (void)'
     Creates a machine-local UNIX socket connection with the socket name
     given by the 'socketPath' instance variable, which is defined in
     'UNIXNetworkStream' class.  *Note UNIXNetworkStream::.

     If successful, the method returns the file handle number of the new
     socket.  If an error occurs, the method returns -1 and raises a
     'SystemErrnoException' if the error occured in a library call.

'openOn (String SOCKETPATH)'
     Creates a new writer socket and binds it to SOCKETPATH.  Sets the
     receiver's 'socketPath' instance variable to the argument.  Returns
     an 'Integer' with the file number of the newly created socket.

'sockWrite (String DATA)'
     Writes DATA to the socket created by a previous call to the 'open'
     method, above.  Sets the receiver's 'charsWritten' instance
     variable to the number of characters written.  If successful,
     returns 0, or if an error occured, returns -1 and raises a
     'SystemErrnoException'.


File: ctalk.info,  Node: TreeNode,  Next: Event,  Prev: UNIXNetworkStreamWriter,  Up: Classes

'TreeNode' Class
----------------

'TreeNode' objects and methods maintain links to other 'TreeNode'
objects (_siblings_), and to sets of objects (_children_).  The methods
can add sibling and child 'TreeNodes', traverse the tree, and set the
content of each 'TreeNode'.

The class provides basic methods for adding sibling and child nodes,
adding content to each node (which is a 'String' object), and to
traverse the tree.  The methods that visit each node in a tree- 'print,
format,' and 'search'-are fairly generic.  They perform a depth-first
traversal which should work equally well with balanced and non-balanced
trees.

Instance Variables
..................

'children'
     A 'List' of 'TreeNode' objects, which are accessible only through
     the parent node.  *Note List::.
'content'
     A 'String' that contains the node's displayable text.
'levelMargin'
     A 'String,' normally consisting of all spaces, that is the
     additional left margin for each level of the tree.  *Note String::.
'levelMarginLength'
     An 'Integer' that is the length of the 'levelMargin' string.
'siblings'
     Another 'List' of 'TreeNode' objects that occur at the same level.
     *Note List::.

Instance Methods
................

'addChild (TreeNode CHILD)'
     Add CHILD to the end of the receiver's 'children' list.

'format (void)'
     Print the receiver tree to a 'String' object.  This method uses two
     other methods, '__formatChildren' and '__formatSiblings' to
     traverse each 'TreeNode' object in the receiver tree.  Returns a
     'String' object.

'makeSibling (TreeNode SIB)'
     Add SIB to the end of the receiver's 'sibling' list.

'map (OBJECT *(METHOD)())'
     Execute METHOD over each member of the receiver tree.  As with
     'map' methods in other classes, METHOD must also belong to
     'TreeNode' class and takes no arguments.

'print (void)'
     Print the receiver tree to the terminal.  This method uses two
     other methods, '__printChildren' and '__printSiblings' to traverse
     each 'TreeNode' object in the receiver tree.

'search (String SEARCHSTRING)'
     Return the first node in the receiver tree whose content matches
     SEARCHSTRING.  Returns only the first node that contains
     SEARCHSTRING.  Does not look for multiple matches.

'setContent (String STR)'
     Sets the receiver 'TreeNode's' 'content' instance variable to STR,
     a 'String' object.  *Note String::.


File: ctalk.info,  Node: Event,  Next: Expr,  Prev: TreeNode,  Up: Classes

'Event' Class
-------------

'Event' and its subclasses represent system and language events like
applications, errors, input, and signals, and these classes provide the
methods that receive and handle the events.


File: ctalk.info,  Node: Application,  Up: Classes

'Application' Class
-------------------

Objects of 'Application' class represent programs.  This class provides
basic methods for initializing and exiting programs, handling window
size and placement for graphical programs, and starting subprograms, as
well as other tasks.

Instance Variables
..................

'cmdLineArgc'
     An 'Integer' that contains the value of the 'argc' argument to
     'main ()'.  The value is normally set by the 'parseArgs' method,
     below.

'cmdLineArgs'
     An 'Array' of 'Strings' that contains each element of the 'argv'
     parameter to 'main ()'.  This is normally filled in by the
     'parseArgs' method, below.

'exitHandler'
     A 'SignalHandler' object that contains a user-installable signal
     handler.  *Note SignalHandler::.

'geomFlags'
'winXOrg'
'winYOrg'
'winWidth'
'winHeight'
     Variables that specify the appication window's dimensions, if any.
     These can be set by the 'parseX11Geometry' method, below.

Instance Methods
................

'__handleAppExit (__c_arg__ int SIGNO)'
     A standard, user installable SIGINT ('Ctrl-C') signal handler.  If
     the application has enabled exception traces, print a stack trace
     and then call the default SIGINT handler.  The SIGNO argument
     contains the number of the signal that calls the method.

     The application must first call the 'installExitHandler' method
     (below) to define this method as a signal handler - then this
     method is called when the application receives a SIGINT, which is
     normally generated when the user presses Control-C.

     This method does not return.

'__handleSigAbrt (__c_arg__ int SIGNO)'
     A standard, user installable SIGABRT handler.  The application must
     first call 'installAbortHandler', below.  If the application has
     enabled exception traces, print a stack trace before exiting.  This
     method does not return.

'classSearchPath (void)'
     Returns a 'String' that contains Ctalk's class library search path,
     with each directory separated by a colon (':').  The default is
     usually '/usr/local/include/ctalk.'

     If there are any directories given as arguments to the '-I' command
     line option, and any directories named in the 'CLASSLIBDIRS'
     environment variable, Ctalk includes those directories as well, and
     searches them first.

'execC (String COMMANDLINE)'
'execC (String COMMANDLINE, String COMMANDOUTPUT)'
     Execute the command and arguments given by COMMANDLINE and wait for
     the program to finish.  The method displays the standard output of
     the subprocess.

     If a second argument is given, the program's standard output is
     saved in the COMMANDOUTPUT object, which should normally be a
     'String' object.  Here is a simple example program.


          int main () {
            Application new myApp;
            String new str, output;

            str = "/bin/ls -l";
            myApp execC str, output;
            printf ("%s\n", output);
          }


     For any number of arguments, if the command redirects the standard
     outut, then the output is sent to the file that is the operand of a
     '>' or '>>' redirection operator.

     If COMMANDLINE is the name of a shell script, the shell script is
     executed by a sub-shell using the 'system(3)' library call.

'getPID (void)'
     Returns an 'Integer' with the program's process ID.

'installAbortHandlerBasic (void)'
     Installs a C handler for 'SIGABRT' signals.  The C handlers are
     more reliable, though less flexible, than handlers that use
     'SignalHandler' class.

     This method catches a SIGABRT, and prints a walkback trace if
     tracing is enabled, before the application exits.

'installExitHandler (void)'
     Install a 'SIGINT' ('C-c') handler in a Ctalk program that performs
     cleanup before exiting the application.

'installExitHandlerBasic (void)'
     Installs a C handler for 'SIGINT' signals ('C-c' or 'C-break' for
     DJGPP) that is slightly more robust and reliable, though less
     flexible, than the 'SignalHandler' classes.

     This method causes the application to exit when receiving a signal,
     and prints a walkback trace if tracing is enabled.

'installPrefix (void)'
     Returns a 'String' with the name of the top-level directory where
     Ctalk's various component subdirectories are located.  For example,
     in relative terms, this is where Ctalk's various components get
     installed.


          Executables:            _prefixdir_/bin
          Libraries:              _prefixdir_/lib
          Class Libraries:        _prefixdir_/include/ctalk
          Texinfo Manuals:        _prefixdir_share/info
          Manual Pages:           _prefixdir_/share/man
          Searchable Docs:        _prefixdir_/share/ctalk


'membervars (void)'
     Returns a 'String' with the member variable declarations of the
     class named by the receiver.  If the receiver is a 'String' object,
     'membervars' returns the variables for the class given by the
     'String's' value.  If the receiver is a class object, 'membervars'
     returns the member variables for that class.  For nany other type
     of object, 'membervars' returns the variables declared in the
     object's class.  *Note ClassVariableKeyword::.

     'Membervars' returns the complete documentation of the instance or
     class variable, if the declaration also contains a documentation
     string.  *Note VariableDocStrings::.

'methodDocString (String METHOD-SOURCE)'
     Returns the documentation string from the source of the method
     given as the argument.  *Note MethodDocStrings::.

'methodPrototypes (String INPUT)'
     If INPUT is a method's source or a class library, returns a
     'String' containing the prototypes of the methods; that is, the
     declaration and the argument list.

'methodSource (String CLASSNAME, String METHODNAME)'
     Returns a 'String' object with the source code of the method(s)
     that match the declarations, The 'methodSource' method does not
     distinguish methods by the number of arguments, so it returns the
     code of any method in a class that matches the METHODNAME
     arguement.


          CLASSNAME instanceMethod METHODNAME
          CLASSNAME classMethod METHODNAME


     The method generates a 'SystemErrnoException' if it can't find the
     class file.

     The 'methodSource' method is built to be as fast as possible and
     has a rather simple minded view of what constitutes a method
     declaration.

     The method only recognizes declarations that appear on a single
     line, in order to keep the regular expressions that do the matching
     as simple as possible, and it only matches spaces between tokens,
     and not tabs, at least at the moment.  It can also be fooled by
     things that even _look_ like a method declaration within the method
     body.  For example, a phrase like,


          CLASSNAME instanceMethod <some-method-name>


     in the method's documentation, causes 'methodSource' to signal the
     start of the next method.

'parseArgs (Integer ARGC, Array ARGV)'
     Takes the ARGV and ARGC parameters to 'main ()' and sets each
     element of the 'cmdLineArgs' instance variable (above) to a
     'String' that contains each element of the system's 'argv' array.

'parseX11Geometry (String GEOMETRYSTRING)'
     Parses a X Window System geometry string.  If the string specifies
     any of the x, y, width, or height values for a window, the method
     sets the 'winXOrg', 'winYOrg', 'winWidth', or 'winHeight' instance
     variables.  If the geometry string omits any of the values, the
     method sets the corresponding instance variable to zero.  The
     method sets the 'geomFlags' instance variable to the geometry flags
     provided by the window system.

     This method only parses the geometry string.  It does not make any
     adjustments for the display dimensions, or the window dimensions or
     placement.

     For information about the format of a X geometry string, refer to
     the 'XParseGeometry(3)' manual page.

'spawnC (String COMMAND, Integer RESTRICT)'
     Starts the program given by the argument COMMAND, and resumes
     execution of the main program.  The method returns an 'Integer'
     with the process ID of the child process.

     The child process becomes a daemon process, which means it has no
     interaction with the parent process.  If you want the parent
     process to handle the child processes' output, refer to the 'execC'
     method, above.  Otherwise, communication between the parent and
     child process should be handled by UNIX's interprocess
     communication facilities.

     If the RESTRICT argument is non-zero, the method also changes the
     child processes' working directory to '/' and its umask to '0'.

     The 'spawnC' method does not use a shell when executing the child
     process, which means that the method doesn't handle shell
     facilities like IO redirection or file globbing.  It's also
     necessary to provide the full path name of the program to be
     launched in the background.

     The process that handles the session management when the daemon
     process is launched remains executing until the parent process
     exits.  This means there can be _three_ entries in the system's
     process table, but it helps minimize creating zombie processes in
     case any part of the program quits unexpectedly.

'uSleep (long long int USECS)'
     Sleep for USECS microseconds.

'useXRender (Boolean B)'
     If B is true, draw graphics using the X Render extension if it is
     available.  If B is false, use Xlib for graphics drawing.  The
     default is to draw using the X Render extension if it is available.

'usingXRender (void)'
     Returns a 'Boolean' value of True if the program is using the X
     Render extension for drawing, False otherwise.


File: ctalk.info,  Node: ClassLibraryTree,  Up: Classes

'ClassLibraryTree' Class
------------------------

A 'ClassLibraryTree' application is a utility program that formats a
tree of the available Ctalk class hierarchy.

The class lists the libraries in Ctalk's default installation directory,
and in any directories named by the 'CLASSLIBDIRS' environment variable.

The class contains one method, 'init', which collects the class and
superclass information into a set 'TreeNode' objects.  The prototype of
init is:


     TreeNode instanceMethod init (TreeNode classTree, Boolean verbose);


After the method finishes the 'classTree' object contains the classes
and subclasses.  You can then print or format the with the 'TreeNode'
methods 'format' and 'print'.

The 'verbose' argument, if True, tells the method to print dots to
indicate its progress.

Here is an example program that displays the class hierarchy on a
terminal.


     Boolean new verbose;

     int main (int argc, char **argv) {

       TreeNode new tree;
       ClassLibraryTree new classTree;
       Integer new nParams;
       Integer new i;
       String new param;

       verbose = True;

       classTree parseArgs argc, argv;
       nParams = classTree cmdLineArgs size;

       for (i = 1; i < nParams; i++) {

         param = classTree cmdLineArgs at i;

         if (param == "-q") {
           verbose = False;
           continue;
         }

         if (param == "-h" || param == "--help") {
           printf ("Usage: classes [-q] [-h]\n");
           exit (0);
         }

       }

       classTree init tree, verbose;
       tree print;

       exit (0);
     }


Instance Methods
................

'init instance method (TreeNode TREE, Boolean PRINTDOTS)'
     Creates a a tree of the class library with TREE as the root node of
     the tree.  If PRINTDOTS is true, prints the method's progress on
     the terminal.


File: ctalk.info,  Node: GLUTApplication,  Up: Classes

'GLUTApplication' Class
-----------------------

The 'GLUTApplication' class provides a class library interface to the
GLUT application programming interface, which is a platform-independent
window API for OpenGL programs.

The GLUT API uses C functions to handle window system events.  This is
the simplest approach to adding event handlers.  Ctalk does not, itself,
use any GLUT or OpenGL functions, so it is normally safe to use Ctalk
methods within a window callback, as in this example.

     #include <ctalk/ctalkGLUTdefs.h>

     GLUTApplication new teapotApp;

     float angle = 0.0f;

     void mydisplay (void) {       /* This callback updates the display. */
       glEnable (GL_NORMALIZE);
       glEnable(GL_DEPTH_TEST);
       glClearColor(0.0, 0.0, 0.0, 1.0);
       glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
       glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
       glLineWidth (1.0f);

       glLoadIdentity ();
       glColor4f (0.0f, 0.0f, 1.0f, 1.0f);

       glRotatef (angle, 0.0f, 1.0f, 0.0f);
       glRotatef (10.0f, 1.0f, 0.0f, 0.0f);

       teapotApp teapot 3.0, 0;    /* Method call within the callback. */

       glutSwapBuffers ();
     }

     void animation (void) {  /* Callback to update the animation state. */
       angle += 0.2f;
       if (angle >= 360.0f)
         angle = 0.0f;
       glutPostRedisplay();
     }

     int main (int argc, char **argv) {

       teapotApp initGLUT(argc, argv);
       teapotApp initWindow (640, 480);
       teapotApp createMainWindow ("teapotApp -- GLUTApplication Class");
       teapotApp defineDisplayFn mydisplay;
       teapotApp defineIdleFn animation;
       teapotApp installCallbackFns;
       teapotApp run;

     }


If you save the example in a file called teapotApp.ca, you can build
this program with the following command on Linux/UNIX systems.


       $ ctcc -x teapotApp.ca -o teapotApp


To build the example on Apple OS X machines, you need to link it with
the GLUT application framework.  Refer to the discussion below for more
information.

You can also use the OpenGL API within methods.  This lets programs use
C functions, methods, and the GLUT and OpenGL APIs together with few
restrictions.  The 'GLUTApplication' class does not, at least at this
time, support all of the functions that the GLUT API provides, but the
API is flexible enough that you can extend it if necessary

Apple OS X Machines
...................

OS X machines include GLUT as an application framework, which Ctalk does
not support directly.  Ctalk provides the platform independent
'ctalkGLUTdefs.h' include file, which you can use to add the GLUT
definitions to programs, by adding a statement like this one to the
program.


     #include <ctalk/ctalkGLUTdefs.h>


Then you need to link the program with the framework to produce an
executable.  Normally you would use a series of commands like these.


       $ ctalk -I /usr/X11R6/include teapotApp.ca -o teapotApp.i
       $ gcc -framework GLUT teapotApp.i -o teapotApp -lctalk -lreadline \
             -L/usr/X11R6/lib -lGL -lGLU


This example isn't meant to be definitive.  You might need to experiment
to find the right build configuration for a particular OS X machine.

There is more platform specific information in the example programs and
'README' file in the 'demos/glut' subdirectory.

The 'GLUTApplication' class doesn't provide a guide to the very involved
subject of programming with the GLUT and OpenGL APIs.  There are many
references and tutorials available on the Internet and in bookstores
that teach OpenGL programming.

Instance Methods
................

'createMainWindow (String TITLE)'
     Create the main window.  The argument, a 'String' contains the
     window's title.

'cone (Float BASE, Float HEIGHT, Integer SLICES, Integer STACKS, Integer FILL)'
     Draw a cone with a base of size BASE, height HEIGHT, with SLICES
     longitudinal slices and STACKS lateral slices.  If FILL is True,
     draw a filled cone; otherwise, draw a wireframe cone.

'cube (Float SIZE, Integer FILL)'
     Draw a cube with sides of SIZE length.  If FILL is True, draw a
     filled cube; otherwise draw a wirefame cube.

'defineAnimationFn (Symbol FN)'
'defineButtonBoxFn (Symbol FN)'
'defineDialsFn (Symbol FN)'
'defineDisplayFn (Symbol FN)'
'defineEntryFn (Symbol FN)'
'defineIdleFn (Symbol FN)'
'defineKeyboardFn (Symbol FN)'
'defineMenuStateFn (Symbol FN)'
'defineMenuStatusFn (Symbol FN)'
'defineMotionFn (Symbol FN)'
'defineMouseFn (Symbol FN)'
'defineOverlayDisplayFn (Symbol FN)'
'definePassiveMotionFn (Symbol FN)'
'defineSpaceballMotionFn (Symbol FN)'
'defineSpaceballRotateFn (Symbol FN)'
'defineSpecialFn (Symbol FN)'
'defineTabletButtonFn (Symbol FN)'
'defineTabletMotionFn (Symbol FN)'
'defineVisibilityFn (Symbol FN)'
'defineTimerFn (Integer MSEC, Symbol FN, Integer ARGVALUE)'
     Define callback functions for window system events.  The argument
     is the name of the C function that handles the event.  Refer to the
     method's documentation and the GLUT API's documentation for
     information about each callback function's parameters.

     _Note:_ 'defineAnimationFn' and 'defineTimerFn' both use the
     'glutTimerFunc ()' callback, so the actual callback is the last
     function defined (before calling 'installCallBackFns').

     The difference is that 'defineAnimationFn' executes its callback 24
     times per second, while 'defineTimerFn' uses an application defined
     interval, and takes three arguments: the timer interval in
     milliseconds, the name of the callback function, and an integer
     that is passed to the callback function as an argument.

'defineReshapeFn (Symbol FN)'
     Defines the function used to reshape the window's 3D viewing space.
     The default is an orthographic projection, 5 grid units wide on
     each axis.  If you need to duplicate the default viewing area in a
     program, here is the code that defines it.  The variables 'width'
     and 'height' are provided by the GLUT application as arguments to
     the reshape function.


          void defualt_reshape_fn (int width, int height) {
            float ar = (float)width / (float)height;
            glViewport(0, 0, w, h);
            glMatrixMode(GL_PROJECTION);
            glLoadIdentity();
            glOrtho (-5.0 * ar, 5.0 * ar, -5.0, 5.0, 5.0, -5.0);
            glMatrixMode(GL_MODELVIEW);
            glLoadIdentity();
          }


'dodecahedron (Integer FILL)'
     Draw a dodecahedron.  If 'fill' is True, draw a solid dodecahedron;
     otherwise draw a wireframe dodecahedron.

'fullScreen (void)'
     Resize the main window so that it occupies the entire screen.  A
     call to 'reshape' (the method, not the callback) or 'position'
     returns the window to its normal state.

'icosahedron (Integer FILL)'
     Draw a icosahedron.  If 'fill' is True, draw a solid icosahedron;
     otherwise draw a wireframe icosahedron.

'initGlut (Integer ARGC, Array ARGV)'
     Initialize the GLUT window system.  If there are any GLUT specific
     command line arguments, this method parses them and uses then uses
     the options to configure the window system.  This method also calls
     'Application' method 'parseArgs', so the command line arguments are
     available in the 'cmdLineArg' instance variable (an 'Array').
     *Note Application::.

'initWindow (Integer WIDTH, Integer HEIGHT)'
'initWindow (Integer XORG, Integer YORG, Integer WIDTH, Integer HEIGHT)'
     Initialize the main window's size or, with four arguments, its size
     and position.

'installCallBackFns (void)'
     Install the callback functions defined by previous calls to
     'define*Fn' methods.

'octahedron (Integer FILL)'
     Draw a octahedron.  If 'fill' is True, draw a solid octahedron;
     otherwise draw a wireframe octahedron.

'tetrahedron (Integer FILL)'
     Draw a tetrahedron.  If 'fill' is True, draw a solid tetrahedron;
     otherwise draw a wireframe tetrahedron.

'run (void)'
     Enter the GLUT API's main event loop.  When this method returns,
     the program typically exits.  _Note:_ GLUT does not provide any
     events to terminate program.  To exit a program normally, use C's
     'exit (3)' function and 'on_exit(3)' (or 'onexit(3)') to handle any
     program specific exit processing.

'sphere (Float RADIUS, Integer SLICES, Integer STACKS, INTEGER FILL)'
     Draw a sphere with RADIUS with SLICES longitudinal sections and
     STACKS lateral sections.  If FILL is True, draw a filled sphere;
     otherwise draw a wireframe sphere.

'teapot (Integer FILL)'
     Draw the classic teapot demonstration.  If FILL is True, draw a
     solid teapot; otherwise draw a wireframe teapot.

'torus (Float INNER_RADIUS, Float OUTER_RADIUS, Integer SIZE, Integer RINGS, INTEGER FILL)'
     Draw a torus with the inner and outer radii given by the arguments,
     with a section SIZE and rendered in RINGS sections.  If FILL is
     True, draw a solid torus; otherwise draw a wireframe torus.

'windowID (String WINDOW_TITLE)'
     Return an 'Integer' with the X window ID of the window with the
     title WINDOW_TITLE.  _Note:_ Some OS's, like OSX/Darwin, don't use
     Xlib to draw windows; in that case, this method won't be able to
     provide a lower level window ID.

'xpmToTexture (char **XPM_DATA, Integer WIDTH_OUT, Integer HEIGHT_OUT, Symbol TEXTURE_DATA_OUT)'
'xpmToTexture (char **XPM_DATA, Integer ALPHA, Integer WIDTH_OUT, Integer HEIGHT_OUT, Symbol TEXTURE_DATA_OUT)'
     Translates a XPM pixmap into an OpenGL texture.  The argument
     XPM_DATA is the pixmap's 'char *pixmap_name[]' declaration.  If no
     ALPHA argument is given, then '1.0' is used to create an opaque
     texture.  Alpha values can range from 0.0 (completely transparent)
     - 1.0 (completely opaque).

     The method sets the arguments WIDTH_OUT, HEIGHT_OUT, and
     TEXEL_DATA_OUT with the height, width and data of the texture.

     The resulting texture has the format GL_RGBA and the data type
     GL_UNSIGNED_INT_8_8_8_8, so you can create a 2D texture from a
     pixmap with statements like these.


          Integer new xpmWidth;
          Integer new xpmHeight;
          Symbol new texData;

          /*
           *  Note that the xpm_data argument should not normally need a
           *  translation from C.
           */
          myGLUTApp xpmToTexture xpm_data, xpmWidth, xpmHeight, texData;
          glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, xpmWidth, xpmHeight, 0,
                        GL_RGBA, GL_UNSIGNED_INT_8_8_8_8, texData);


     The 'xpmToTexture' method does not do any setup of the OpenGL
     texture environment.  For basic textures, OpenGL works better with
     textures that have a geometry that is an even multiple of 2; e.g.,
     128x128 or 256x256 pixels.

     Individual applications can add parameters for interpolation,
     blending, mipmap creation, and material rendering based on the
     program's requirements, though.

     The Ctalk library only stores the data for one texture at a time,
     so if a program uses multiple textures, it should save the texture
     data to a separate 'Symbol', in orderq to avoid regenerating the
     texture each time it's used.

     For an example of how to draw with textures, refer to the
     'texture.ca' and 'texblend.ca' programs in the Ctalk distribution's
     'demos/glut' subdirectory.


File: ctalk.info,  Node: ObjectInspector,  Up: Classes

'ObjectInspector' Class
-----------------------

The 'ObjectInspector' class provides basic methods for examining the
contents of objects.

The central method of this class is 'formatObject,' which returns the
contents of an object and its instance variables as a 'String' object.
However, applications can also use the 'formatInstanceVariable' and
'formatClassVariable' methods.

These methods use the 'mapInstanceVariables' and 'mapClassVariables'
methods, defined in 'Object' class.  *Note Object::.

Other classes provide convenience methods that call 'formatObject;' for
example, 'dump' in 'Object' class.

Instance Variables
..................

'promptString'
     A 'String' object that contains the text of the inspector's command
     prompt.  *Note String::.
'verbose'
     A 'Boolean' value that causes the inspector to print a verbose
     listing of objects when set to True.  *Note Boolean::.

Instance Methods
................

'formatClassVariable (Symbol OBJECTREF)'
     Return a 'String' containing the contents of an object and its
     instance variables.  The argument is a reference to the object to
     be formatted.  Both 'formatClassVariable' and
     'formatInstanceVariable' are used by 'formatObject,' below.

'formatInstanceVariable (Symbol OBJECTREF)'
     Return a 'String' containing the contents of an object and its
     instance variables.  The argument is a reference to the object to
     be formatted.

'formatObject (Symbol OBJECTREF)'
     Return a 'String' containing the contents of an object and its
     instance variables.  The argument is a reference to the object to
     be formatted.

'inspect (Symbol OBJECTREF)'
'inspect (Symbol OBJECTREF, String PROMPTSTR)'
     Suspends execution of the program and enters the Object inspector.
     This allows you to examine the object pointed to by OBJREF,
     continue execution, or exit the program.  Typing '?' or 'help' at
     the prompt prints a list of the inspector's commands.  With a
     'String' object as the second argument, the inspector displays the
     string as its command prompt.

     The manual page, 'inspect(3ctalk)', contains a description the
     inspector's commands and a brief tutorial.


File: ctalk.info,  Node: LibrarySearch,  Up: Classes

'LibrarySearch' Class
---------------------

The methods in 'LibrarySearch' class perform searches on the Ctalk
reference documentation.  The documentation is derived from this
reference and is formatted to be easily searchable.  Ctalk installs the
documentation files during the installation process.

These methods are also used in the 'searchlib' program to search the
documentation.

Note that these methods raise an exception if they can't open the
documentation file, in which case they return an empty string and leave
it up to the calling function or method to handle the exception.

The 'searchlib' program is described in the 'searchlib(1)' man page and
the 'ctalktools' Texinfo documentation.

Instance Methods
................

'cAPIFunctionSearch (String DOCPATH, String SEARCH_PATTERN)'
     Returns a 'String' that contains the results of a search for the C
     API function or functions that match SEARCH_PATTERN.

'methodSearch (String DOCPATH, String SEARCH_PATTERN)'
     Search the class library's method prototypes for SEARCH_PATTERN.
     Returns a 'String' object with the results.  Note that this
     function is designed to be rather inclusive; it searches the
     _entire_ method prototype for a pattern, which may include the
     receiver class's name or any parameter name(s).  So including the
     receiver class name is a search is perfectly valid - the syntax of
     a method prototype in the documentation is:


          _<receiver_class>_::_<method_selector>_ (_param_list_)



File: ctalk.info,  Node: Exception,  Up: Classes

'Exception' Class
-----------------

'Exception' and its subclasses handle system and language errors.  These
classes provide default and user-defined handlers to respond to the
Exceptions;

If a program calls 'enableExceptionTrace' (class 'Object'), then the
'handle' method, below, and other exception handlers print a walkback of
the program's method stack.  *Note Object::.

Here is an example of how to handle an exception when trying to open a
file.
     Exception new e;
     ...
     e enableExceptionTrace;
     ...
     inputStream openOn fileArg;
     if (e pending) {
       e handle;
       exit (1);
     }
The 'pending' method returns 'TRUE' or 'FALSE' depending on whether an
exception is waiting to be processed.  The 'handle' method processes the
exception.

The class's default method handlers format and print the text provided
when a program calls 'raiseException'.  Here is the code from 'openOn'
(class 'ReadFileStream') that creates the exception.
     SystemErrnoException new e;
     ...
     if ((f = fopen (__streamPath, "r")) != NULL) {
       __ctalkObjValPtr (selfval, f);
       self streamPath = __streamPath;
       self statStream;
     } else {
       e raiseCriticalException __streamPath;
       strcpy (selfval -> __o_value, "");
     }
The object 'e' is a 'SystemErrnoException'.  The 'SystemErrnoException'
class translates the operating system's errors into Ctalk exceptions.
In the example above, the type of the exception is provided by the
operating system.

The 'Exception' class also provides the 'installHandler' method to allow
programs to use their own handlers.  Here is an example.
     Exception instanceMethod myHandler (void) {
       printf ("My exception handler: %s.\n",
     	  __ctalkGetRunTimeException ());
       return NULL;
     }

     int main () {
       Exception new e;
       e installHandler "myHandler";
       e raiseException USER_EXCEPTION_X, "my program's exception";
       e handle;
     }

Some notes about exceptions:
............................

1.  The receiver class of an exception handler is the the same as the
exception object; e.g., 'myHandler' in the example above is the same as
the class of 'e'; that is, 'Exception'.  In addition, exception handlers
take no arguments and rely on information at the time the exception is
raised.

2.  Programs must take care that they handle any exceptions that they
raise as soon as possible.  If not handled by the application, the
run-time library API might then handle the exception, which could lead
to confusing results.

3.  Ctalk uses _critical exceptions_ internally.  At the application
level, however, all exceptions are treated with the same priority.  The
application needs to take the appropriate action, depending on the type
of exception.

4.  Exception classes should not, as much as possible, depend on other
classes being evaluated.  This is because even basic classes use
exceptions, and if the exceptions in turn use the basic classes, it can
lead to circular reference.  In fact, 'Symbol' is one of the few classes
that 'Exception' can use without generating circular method and class
references.  That is why the 'handlerMethod' instance variable (see
below) is implmented as a 'Symbol'.

5.  When writing exception handlers, you should use as much as possible
the following library API functions: __ctalkGetRunTimeException,
__ctalkHandleRunTimeException, __ctalkPeekRunTimeException,
__ctalkPeekExceptionTrace, and __ctalkPendingException.  They are
located in 'lib/except.c' and described in a later section.  *Note Ctalk
library::.

6.  The only way to distinguish between different exceptions within a
handler is to compare the text returned by a function like
__ctalkGetRunTimeException.  The exception information is generated at
the time the exception is raised, which is the information that the
program should be interested in.  Handling exceptions as soon as
possible also helps avoid confusion if one exception then causes other
exceptions.  Also, different operating systems map errors codes
differently, so Ctalk uses the operating systems' interpretations of the
errors.

7.  Exception handlers in calling methods take priority over handlers in
the methods they call.  You need to be careful that exception handlers
within the scope of a caller do not supercede each other.  This is
especially true if an application tries to use a global Exception
object.  You should try to keep Exception objects as local as possible.

Exception Codes
...............

Exceptions have a corresponding integer code.  The following macros
correspond to the actual exceptions.

     SUCCESS_X
     CPLUSPLUS_HEADER_X
     MISMATCHED_PAREN_X
     FALSE_ASSERTION_X
     FILE_IS_DIRECTORY_X
     FILE_ALREADY_OPEN_X
     UNDEFINED_PARAM_CLASS_X
     PARSE_ERROR_X
     INVALID_OPERAND_X
     PTR_CONVERSION_X
     UNDEFINED_CLASS_X
     UNDEFINED_METHOD_X
     METHOD_USED_BEFORE_DEFINE_X
     SELF_WITHOUT_RECEIVER_X
     UNDEFINED_LABEL_X
     UNDEFINED_TYPE_X
     UNDEFINED_RECEIVER_X
     UNKNOWN_FILE_MODE_X
     INVALID_VARIABLE_DECLARATION_X
     WRONG_NUMBER_OF_ARGUMENTS_X
     SIGNAL_EVENT_X
     INVALID_RECEIVER_X
     NOT_A_TTY_X
     USER_EXCEPTION_X

Instance Variables
..................

'handlerMethod'
     A 'Symbol' object that contains the address of a user defined
     method to handle exceptions.

Instance Methods
................

'deleteLastException (void)'
     Delete the last generated exception from Ctalk's internal exception
     list.

'handle (void)'
     Execute the exception handler for the next pending method.  If a
     program calls 'enableExceptionTrace' (class 'Object'), then
     'handle' also displays a walkback of the exception's copy of the
     program call stack.  *Note Object::.

'exceptionHandler (void)'
     Handle an exception either with Ctalk's default exception handler
     or a user defined handler.  If the program has called the
     'traceEnabled' method (class 'Object'), print a stack trace also.

'installHandler (char *HANDLER_METHOD_NAME)'
     Install a user-defined method to handle exceptions.  The method's
     receiver class must be of the same class as the exception; i.e.,
     either 'Exception' or 'SystemErrnoException'.

'peek (void)'
     Returns a 'String' containing the text of the first pending
     exception, if any.

'pending (void)'
     Return 'TRUE' if any exceptions are pending, 'FALSE' otherwise.

'raiseCriticalException (EXCEPTION EX, char *TEXT)'
     Raise a critical exception.  A critical exception is similar to a
     normal exception, below, except that it is not caught internally.
     The application must catch the exception with 'pending' and
     'handle.'

     You should use one of the 'EXCEPTION' macros defined above as the
     argument EX.

     Print a trace of the methods in the current exception's copy of the
     program's call stack.

'raiseException (EXCEPTION EX, char *TEXT)'
     Raise an exception.  You should use one of the 'EXCEPTION' macros
     defined above as the argument EX.


File: ctalk.info,  Node: SystemErrnoException,  Up: Classes

'SystemErrnoException' Class
----------------------------

The 'SystemErrnoException' class translates operating system errors into
Ctalk exceptions.  The exceptions, which are specific to each operating
system, correspond to the interpretation of the system's 'errno' global
variable and allows Ctalk to work with system errors even if the system
implements its error codes via a built-in variable, a macro, or
function.

There is an example of a system error handler in the 'Exception' class
section.  *Note Exception::.

Class Variables
...............

'sysErrno'
     The 'sysErrno' object contains the value of the C library's 'errno'
     variable or macro.

Instance Methods
................

'raiseException (char *DATA)'
     Sets the value of the 'sysErrno' class variable and raises an
     exception if the C library's 'errno' variable or macro returns a
     nonzero value.


File: ctalk.info,  Node: InputEvent,  Up: Classes

'InputEvent' Class
------------------

Instance Variables
..................

'eventClass'
     An 'Integer' that defines the class of the input event.  Ctalk
     defines the following input event classes.
          KBDCHAR        # ASCII Characters
          KBDCUR         # Cursor Keys.
'eventData'
     An 'Integer' that contains the data specific to an input event.

     For example, when used with subclasses of 'ANSITerminalPane,'
     'eventData' holds the ASCII value of a keypress.

     When used with subclasses of X11Pane (actually, any subclass or
     program that uses X11TerminalStream : queueInput), 'eventData'
     generally holds the ID of the window that received the event.

'xEventData1'
'xEventData2'
'xEventData3'
'xEventData4'
'xEventData5'
     Data provided by the 'X11TerminalStream' input handler.  *Note
     X11TerminalStream::.


File: ctalk.info,  Node: SignalEvent,  Up: Classes

'SignalEvent' Class
-------------------

The 'SignalEvent' class provides methods and variable definitions for
Ctalk programs to handle signal events.

Signal handler (*note SignalHandler::) methods act like C functions when
a program installs them to handle signals.  The signal handler methods
cannot, in most cases, create objects.  Ctalk provides the C function
'__ctalkNewSignalEventInternal' to create and queue 'SignalEvent'
objects from the handler.

Here is an example of a signal handler method that creates 'SignalEvent'
objects.
     #include <time.h>

     SignalHandler instanceMethod handleSignal (__c_arg__ int signo) {
       time_t t;
       char buf[MAXLABEL];
       noMethodInit;
       t = time (NULL);
       /* Format the system time, then create a new SignalEvent object,
          and add the time data to the new object's text instance variable. */
       __ctalkDecimalIntegerToASCII (t, buf);
       __ctalkNewSignalEventInternal (signo, getpid (), buf);
       return NULL;
     }

For more information, *note Method functions::, and *note
__ctalkNewSignalEventInternal::.

Class Variables
...............

'pendingEvents'
     A 'List' of pending signal events.

Instance Variables
..................

'processID'
     An 'Integer' that contains the process ID of the program that
     received the signal.

'sigNo'
     An 'Integer' that contains the signal number of the handler.

'data'
     A 'String' object that contains data from the signal handler.

Instance Methods
................

'getPID (void)'
     Set the 'SignalEvent' object's 'pid' instance variable to the
     program's process ID.

'new (EVENT1, EVENT2, ... EVENT3;)'
     Create one or more new 'SignalEvent' objects with the names given
     in the argument lists.


          SignalEvent new event1;
          SignalEvent new event1, event2;


'nextEvent (void)'
     Return the next 'signalEvent' object from the class'
     'pendingEvents' queue.

'pending (void)'
     Return 'TRUE' if the class' 'pendingEvents' queue contains
     'SignalEvent' event objects, 'FALSE' otherwise.

'queueEvent (void)'
     Add the receiver to the class' 'pendingEvents' queue.


File: ctalk.info,  Node: SignalHandler,  Up: Classes

'SignalHandler' Class
---------------------

Class 'SignalHandler' provides the methods that install handlers for
signals from the operating system.

Applications can also define signal handlers with this class.  Signal
handler methods need to use the calling conventions of C functions.
*Note Method functions::.

For POSIX signals, you can use a method to set the signal number.
     Signal    Method       Signal
     ------    ------       ------
     SIGHUP    setSigHup    Termination of terminal process.
     SIGINT    setSigInt    Interrupt from keyboard.
     SIGQUIT   setSigQuit   Quit from keyboard.
     SIGILL    setSigIll    Illegal instruction.
     SIGABRT   setSigAbrt   Abort from C library abort(3).
     SIGFPE    setSigFpe    Floating point exception.
     SIGKILL   -            Kill process - non-catchable.
     SIGSEGV   setSigSegv   Invalid memory address.
     SIGPIPE   setSigPipe   Broken pipe or write to pipe with no reader.
     SIGALRM   setSigAlrm   Timer signal from C library alarm(2).
     SIGTERM   setSigTerm   Process termination.
     SIGUSR1   setSigUsr1   User defined.
     SIGUSR2   setSigUsr2   User defined.
     SIGCHLD   setSigChld   Child process stopped or terminated.
     SIGCONT   setSigCont   Continue stopped process.
     SIGSTOP   -            Stop process - non-catchable.
     SIGTSTP   setSigTstp   Stop from tty.
     SIGTTIN   setSigTtin   Terminal input for background process.
     SIGTTOU   setSigTtou   Terminal output from background process.

You can also set system-specific signals by number with 'setSigNo.'

'SignalHandler' methods can also send 'SignalEvent' objects to Ctalk
programs.  Refer to *note Method functions::, *note SignalEvent::, and
*note __ctalkNewSignalEventInternal::.

Internally, methods in 'SignalHandler' class use the library functions
'__ctalkIgnoreSignal ()', '__ctalkDefaultSignalHandler ()',
'__ctalkInstallHandler ()', and '__ctalkSystemSignalNumber.' Signal
handlers need to be reset after each usage.  Refer to the 'timeclient.c'
example program.

Instance Variables
..................

'attributes'
     The value of 'attributes' can be one of the following.
     'SIG_DEFAULT'
          The application uses the operating system's default signal
          handler for the signal.  The operating system's documentation
          describes how it handles signals.
     'SIG_IGNORE'
          The application ignores the signal.
     'SIG_METHOD'
          The application provides a method to handle the signal.

'handler'
     The value is an instance method of class 'SignalHandler' that is
     provided by the application.

Instance Methods
................

'defaultHandler (void)'
     Install the operating system's default handler for the receiver's
     signal number 'sigNo.' The operating system's documentation
     describes how it handles signals.

'ignoreSignal (void)'
     Set the receiver signal handler to ignore a signal.

'installHandler (OBJECT *(*METHOD)(int))'
     Install METHOD as the receiver's signal handler.  The method must
     be callable as a C function.  *Note Method functions::.

'new (char *NAME)'
     Create new 'SignalHandler' objects with the name(s) given in the
     argument list.

'raiseSignal (void)'
     Send the signal of the receiver's 'sigNo' variable to the current
     program.

'setSigAbrt (void)'
     Set the signal of the receiver's handler to 'SIGABRT.'

'setSigAlrm (void)'
     Set the signal of the receiver's handler to 'SIGALRM.'

'setSigChld (void)'
     Set the signal of the receiver's handler to 'SIGCHLD.'

'setSigCont (void)'
     Set the signal of the receiver's handler to 'SIGCONT.'

'setSigFpe (void)'
     Set the signal of the receiver's handler to 'SIGFPE.'

'setSigHup (void)'
     Set the signal of the receiver's handler to 'SIGHUP.'

'setSigIll (void)'
     Set the signal of the receiver's handler to 'SIGILL.'

'setSigInt (void)'
     Set the signal of the receiver's handler to 'SIGINT.'

'setSigNo (int SIGNUM)'
     Set the signal number of the receiver to SIGNUM.

'setSigPipe (void)'
     Set the signal of the receiver's handler to 'SIGPIPE.'

'setSigQuit (void)'
     Set the signal of the receiver's handler to 'SIGQUIT.'

'setSigSegv (void)'
     Set the signal of the receiver's handler to 'SIGSEGV.'

'setSigTerm (void)'
     Set the signal of the receiver's handler to 'SIGTERM.'

'setSigTstp (void)'
     Set the signal of the receiver's handler to 'SIGTSTP.'

'setSigTtin (void)'
     Set the signal of the receiver's handler to 'SIGTTIN.'

'setSigTtou (void)'
     Set the signal of the receiver's handler to 'SIGTTOU.'

'setSigUsr1 (void)'
     Set the signal of the receiver's handler to 'SIGUSR1.'

'setSigUsr2 (void)'
     Set the signal of the receiver's handler to 'SIGUSR2.'

'signalProcessID (int PROCESSID)'
     Send the signal 'sigNo' of the receiver to process PROCESSID.

'sigName (Integer SIGNAL_NUMBER)'
     Return a 'String' with the name of the signal whose number is given
     as the argument.

'sigNum (String SIGNAL_NAME)'
     Return an 'Integer' with the value of the signal whose name is
     given as the argument.

'waitStatus (Integer CHILD_PID, IntegerCHILD_RETURN_VAL, Integer CHILD_SIGNAL, Integer ERRNO)'
     Checks for a change in the status of the child process given by
     CHILD_PID.

     The return value is an 'Integer' with the value 0, which indicates
     that the child process has not changed status, an 'Integer' equal
     to CHILD_PID, or -1.

     If the return value is equal to CHILD_PID, then the processes'
     return code is returned in CHILD_RETURN_VAL if the process exited
     normally.  If the child process was terminated by an uncaught
     signal, the signal's number is returned in CHILD_SIGNAL.

     If the return value is -1, the system ERRNO is returned in ERRNO,
     which indicates an error when the parent process called
     'waitStatus'.

     Here is an example.


          SignalHandler new s;
          Integer new r, childProcessID, child_retval, child_sig,
                  child_errno;

           _... do stuff ..._

           r = s waitStatus childProcessID,
          	child_retval, child_sig, child_errno;

           if (r == childProcessID) {
              if (child_sig) {
                 printf ("Child received signal %s - exiting.\n",
          		  s sigName child_sig);
          	  exit (1);
              }
           }

           _... do more stuff ..._

           exit (0);



File: ctalk.info,  Node: Expr,  Next: Magnitude,  Prev: Event,  Up: Classes

'Expr' Class
------------

Ctalk uses objects of class 'Expr' and its subclasses internally to
represent C expressions, functions, and variables.


File: ctalk.info,  Node: CFunction,  Up: Classes

'CFunction' Class
-----------------

Ctalk uses the 'CFunction' class internally to represent C function
calls.  Ctalk installs the 'CFunction' methods library templates in
'CLASSLIBDIR/libc' and 'CLASSLIBDIR/libctalk'.

Note that this class does not, at this time, provide methods for all C99
library function calls.  If you want to add C library templates, look at
the templates in 'classes/libc' and at the API documentation.  *Note
Templates::.  Refer to the 'README' file in the Ctalk distribution for
instructions on submitting source code contributions.

Class Methods
.............

'cAbs (int I)'
     Return the result object of an 'abs(3)' library call.

'cAcos (double D)'
     Return the result object of an 'acos(3)' library call.

'cAcosh (double D)'
     Return the result object of an 'acosh(3)' library call.

'cAscTime (struct tm *TM)'
     Return the result object of an 'asctime(3)' library call.  The
     value of TM is the result of a 'gmtime(3)' or 'localtime(3)' call.

'cAsin (double D)'
     Return the result object of an 'asin(3)' library call.

'cAsinh (double D)'
     Return the result object of an 'asinh(3)' library call.

'cAtof (char *S)'
     Return the result object of an 'atof(3)' library call.

'cAtoi (char *S)'
     Return the result object of an 'atoi(3)' library call.

'cAtol (char *S)'
     Return the result object of an 'atol(3)' library call.

'cAtoll (char *S)'
     Return the result object of an 'atoll(3)' library call.

'cCbrt (double D)'
     Return the result object of a 'cbrt(3)' library call.

'cCeil (double D)'
     Return the result object of a 'ceil(3)' library call.

'cChdir (char *S)'
     Change the working directory to S.  Returns '0' on success, '-1' on
     error, and sets the system error number.

'cClearErr (OBJECT * FILECLASSOBJECT)'
     Perform a 'clearerr(3)' library call on the file stream of the
     argument.

'cClock (void)'
     Return the result object of a 'clock(3)' library call.

'cCopySign (double D, double S)'
     Return the result object of a 'copysign(3)' library call.

'cCos (double D)'
     Return the result object of a 'cos(3)' library call.

'cCosh (double D)'
     Return the result object of a 'cosh(3)' library call.

'cCTime (int *T)'
     Return the result object of a 'ctime(3)' library call.

     _Note:_ Because 'ctime(3)' uses a pointer to 'int' as its argument,
     arguments to 'cCTime' should be of class 'Symbol.' *Note Objects in
     Function Arguments::.

'cDiffTime (int TIME1, int TIME2)'
     Return the result object of a 'difftime(3)' library call.

'cErf (double D)'
     Return the result object of an 'erf(3)' library call.

'cErfc (double D)'
     Return the result object of an 'erfc(3)' library call.

'cExp (double D)'
     Return the result object of an 'exp(3)' library call.

'cExpm1 (double D)'
     Return the result object of an 'expm1(3)' library call.

'cFabs (double D)'
     Return the result object of a 'fabs(3)' library call.

     _Note:_ The functions 'fabsf(3)' and 'fabsl(3)' functions are not
     supported on Solaris systems that don't have 'math_c99.h'.  Use
     'fabs(3)' or 'cFabs' instead.

'cGetchar (void)'
     Return an object of class 'Integer' from the standard input.

'cGetCwd (void)'
     Return the current directory as a 'String' object.

     Return a 'String' object with the result of a 'getenv(3)' C library
     function call.

'cGetPID (void)'
     Return an 'Integer' object with the result of a 'getpid(3)' C
     library function call.

'cLrint (DOUBLE)'
'cLrintf (FLOAT)'
'cLrintl (LONG DOUBLE)'
'cLlrint (DOUBLE)'
'cLlrint (FLOAT)'
'cLlrint (LONG DOUBLE)'
     Return an 'Integer' or 'LongInteger' object that is the result of a
     'lrint(3)', 'lrintf(3)', 'lrintl(3)', 'llrint(3)', 'llrintf(3)', or
     'llrintf(3)' library call.

'cStrcat (char *S1, char *S2)'
     Return the result of a 'strcat(3)' library function call.
'cStrcasecmp (char *S1, char *S2)'
     Return the result of a 'strcasecmp(3)' library call.

'cStrcmp (char *S1, char *S2)'
     Return the result of a 'strcmp(3)' library call.

'cStrlen (char *S)'
     Return the result of a 'strlen(3)' library call.

'cStrncat (char *S1, char *S2, int N)'
     Return the result of a 'strncat(3)' library call.

'cStrncasecmp (char *S1, char *S2, int N)'
     Return the result of a 'strncasecmp(3)' library call.

'cStrncmp (char *S1, char *S2, int N)'
     Return the result of a 'strncmp(3)' library call.

'cStrncpy (char *S1, char *S2, int N)'
     Return the result of a 'strncpy(3)' library call.

'cRand (void)'
     Return the result of a 'rand(3)' library call.

This class is not complete.  The use of C library functions is described
later in this manual.  *Note C library functions::.


File: ctalk.info,  Node: Magnitude,  Next: Method,  Prev: Expr,  Up: Classes

'Magnitude' Class
-----------------

'Magnitude' is the superclass of all object classes that contain
quantities.

Instance Methods
................

'! (void)'
     When used as a prefix operator, overloads C's '!' operator in
     expressions that contain objects.

'* (void)'
     When used as a prefix operator, overloads C's '*' dereference
     operator and returns the first element of an 'int', 'long int,'
     'long long int,' or 'double' array as an 'Integer,' 'LongInteger,'
     or 'Float' object.

'- (void)'
     Overloads the unary '-' prefix operator.  Returns the negated value
     of an 'Integer,' 'LongInteger,' or 'Float,' receivers.

'asCharacter (void)'
     Return an object with the receiver's value as a 'Character' object.

'asFloat (void)'
     Return the value of an 'Integer' or 'LongInteger' receiver as a
     'Float' object.  If the receiver is a 'Float' object, returns the
     receiver.  For all other classes, prints a warning and returns
     '0.0f'.

'asInteger (void)'
     Return an object with the receiver's value as an 'Integer' object.

'asLongInteger (void)'
     Return an object with the receiver's value as a 'LongInteger'
     object.


File: ctalk.info,  Node: Character,  Next: Float,  Up: Classes

'Character' Class
-----------------

The value of 'Character' class objects is (on most hardware platforms)
an 8-bit integer corresponding to the ISO-8859-1 character set.

Character Constants
...................

Ctalk recognizes the following escape sequences as character constants.


     \a      Alert
     \b      Bell
     \e      Escape
     \f      Form Feed
     \n      New line
     \r      Carraige return
     \t      Horizontal tab
     \v      Vertical tab
     \0      NUL
     \"      Literal double quote.
     \'      Literal single quote.


The '\e' escape sequence is an extension to the C language standard.

Ctalk itself doesn't interpret the character constants, though - it
simply recognizes that the character or escaped character can be part of
a literal string or character.  However, if a method encounters a
constant, it should interpret the character constant based on the
method's function.

Very often a character constant's value is enclosed in single quotes if
they are part of the token's name.  Again it's up to the method to
interpret the character's value.  The Ctalk library includes the macros
'TRIM_CHAR()' and 'TRIM_CHAR_BUF()' that can remove the quotes from the
character sequences if necessary.

_Note:_ Ctalk does not support negative 'Characters' (i.e., 'ch' < 0)
universally, even though C 'char' types are "signed" by default.  This
is due to the uneven support in the Ctalk and C libraries for negative
characters.  So if you need negative values, it's generally safer to use
'Integers'.

Additionally, if an expression doesn't need a separate buffer for
function arguments, it can also use the 'CHAR_CONSTANT_VALUE' macro,
which returns a string with the first character pointing to the
Character constant's actual value.  The argument to the macro is a C
'char *'.  Here is an example of how to store the value of a Character
object in a C 'char'.


     char c;
     OBJECT *self_value;

     self_value = self value;

     sscanf (CHAR_CONSTANT_VALUE(self_value -> __o_value), "%c", &c);


Instance Variables
------------------

'value'
     The value of an 8-bit character in the ISO-8859-1 character set.

Instance Methods
................

'! (void)'
     Return a character value of true if the receiver evaluates to zero,
     false otherwise.

'!= (char CHARACTER)'
     Returns true if the receiver is not equal to CHARACTER.

'& (char CHARACTER)'
     Returns a bitwise AND of the receiver and the argument.

'&& (char CHARACTER)'
     Returns 'TRUE' if both operands are 'TRUE,' 'FALSE' otherwise.

'* (char C)'
     Multiply the receiver and the operand.  The result is a 'Character'
     object.

'*= (char C)'
     Multiply the receiver by the operand, and return the receiver.

'+ (char C)'
     Add the receiver and the operand.  The result is a 'Character'
     object.

'++ (void)'
     The prefix and postfix increment operators for 'Character' objects.

'+= (char C)'
     Add the operand to the receiver and the operand and return the
     receiver.

'- (char C)'
     Subtract the receiver and the operand.  The result is a 'Character'
     object.

'-- (void)'
     The prefix and postfix decrement operators for 'Character' objects.

'-= (char C)'
     Subtract the operand from the receiver and return the receiver.

'/ (char C)'
     Divide the receiver and the operand.  The result is a 'Character'
     object.

'/= (char C)'
     Divide the receiver by the operand and return the receiver.

'< (char CHARACTER)'
     Returns 'TRUE' if the receiver is less than the operand, 'FALSE'
     otherwise.

'<< (int I)'
     Shift the receiver left by the number of bits in the operand, which
     must be an 'Integer'.

'<= (char CHARACTER)'
     Returns 'TRUE' if the receiver is less than or equal to the
     operand, FALSE otherwise.

'= (char CHARACTER)'
     Set the value of the receiver object to CHARACTER.

'> (char CHARACTER)'
     Returns 'TRUE' if the receiver is greater than the operand, 'FALSE'
     otherwise.

'>> (int I)'
     Shift the receiver right by the number of bits in the operand,
     which must be an 'Integer'.

'>= (char CHARACTER)'
     Returns 'TRUE' if the receiver is greater than or equal to the
     operand, FALSE otherwise.

'== (char CHARACTER)'
     Returns true if the receiver is equal to CHARACTER.

'^ (char CHARACTER)'
     Returns a bitwise XOR of the receiver and the argument.

     Returns a 'Character' object that is the bitwise complement of the
     receiver.  This method simply calls 'bitComp', below.

'bitComp (void)'
     Perform a bitwise complement of the receiver.

'invert (void)'
     Returns 'TRUE' if the receiver evaluates to 'FALSE,' 'FALSE' if the
     receiver evaluates to 'TRUE.'

'isASCII (void)'
     Returns 'TRUE' if the receiver is a 7-bit ASCII character '0-127',
     FALSE otherwise.

'isAlNum (void)'
     Returns 'TRUE' if the receiver is an alphanumeric character '0-9',
     'A-Z', 'a-z', 'FALSE' otherwise.

'isAlpha (void)'
     Returns 'TRUE' if the receiver is an alphabetic character 'A-Z',
     'a-z', 'FALSE' otherwise.

'isBlank (void)'
     Returns 'TRUE' if the receiver is a space ' ' or horizontal tab
     '\t' character, 'FALSE' otherwise.

'isCntrl (void)'
     Returns 'TRUE' if the receiver is a control character, 'FALSE'
     otherwise.

'isDigit (void)'
     Returns 'TRUE' if the receiver is a character '0-9', 'FALSE'
     otherwise.

'isGraph(void)'
     Returns 'TRUE' if the receiver is any character except a space,
     'FALSE' otherwise.

'isLower (void)'
     Returns 'TRUE' if the receiver is a lower case character, 'FALSE'
     otherwise.

'isPrint (void)'
     Returns 'TRUE' if the receiver is a printable character, 'FALSE'
     otherwise.

'isPunct (void)'
     Returns 'TRUE' if the receiver is a printable non-alphanumeric
     character, 'FALSE' otherwise.

'isSpace (void)'
     Returns 'TRUE' if the receiver is a space, horizontal tab ('\t'),
     newline ('\n'), vertical tab ('\v'), form feed ('\f'), or carriage
     return ('\r') character, 'FALSE' otherwise.

'isUpper (void)'
     Returns 'TRUE' if the receiver is an upper case letter, 'FALSE'
     otherwise.

'isXDigit (void)'
     Returns 'TRUE' if the receiver is a character '0-9', 'a-f', or
     'A-F', 'FALSE' otherwise.

'toLower (void)'
     If the receiver is an upper case letter, returns the lower case
     version.

'toUpper (void)'
     If the receiver is a lower case letter, returns the upper case
     version.

'| (char CHARACTER)'
     Returns a bitwise OR of the receiver and the argument.

'|| (char CHARACTER)'
     Returns 'TRUE' if either operand is 'TRUE,' 'FALSE' otherwise.


File: ctalk.info,  Node: String,  Up: Classes

'String' Class
--------------

Objects of 'String' class contain arrays of ASCII characters.  The value
of a 'String' object is similar to the C language organization of
strings as a NUL terminated array of 'char' values.

In most cases, 'String' objects can be used like a collection of
'Character' objects.  The overloaded operators '++', '--', '+', and '-',
all work similarly to the operators in 'List' or 'AssociativeArray'
objects.

Some of 'String' classes' methods add semantics to operators, like the
'+=' method, which behaves differently depending on whether its argument
is another 'String' object, or an 'Integer' object.


     myString = "Hello, ";    /* The resulting value is, */
     myString += "world!";    /* "Hello, world!"         */

     myString = "Hello, ";    /* The resulting value is, */
     myString += 3;           /* "lo, "                  */


The main exception to this is the 'map' method, which doesn't allow
incrementing 'self' within an argument block.  This is because 'String'
objects don't use 'Key' objects internally to order a 'String' object's
individual 'Character' objects.  If it's necessary to treat a 'String'
object as a collection, the 'asList' method will organize the receiver
'String' into a 'List' of 'Character' objects.

Conversely, 'Array' and 'List' classes contain the 'asString' method,
which translates an 'Array' or 'List' into a String object.

In addition, methods like 'matchRegex', '=~', and '!~' can accept as
arguments strings that contain regular expression metacharacters and use
them to perform regular expression matches on the receiver 'String'.
*Note Pattern Matching::.

Instance Variables
..................

'value'
     The value is a pointer to the character string.

Instance Methods
................

'* (void)'
     When used as a prefix operator, overloads C's '*' dereference
     operator and returns the first element of the receiver, a
     'Character' object.

'= (char *S)'
     Set the value of the receiver object to S.

'== (char *S)'
     Return 'TRUE' if S and the receiver are identical, 'FALSE'
     otherwise.

'=~ (char *PATTERN)'
     Returns a 'Boolean' value of 'true' if the receiver contains the
     regular expression PATTERN, false otherwise.  *Note Pattern
     Matching::.

'!~ (char *PATTERN)'
     Returns a 'Boolean' value of 'false' if the receiver does not
     contain the argument, PATTERN, which may contain regular expression
     metacharacters.  *Note Pattern Matching::.

'!= (char *S)'
     Return 'FALSE' if S and the receiver are not identical, 'TRUE'
     otherwise.

'!= (char *S)'
     Return 'FALSE' if S and the receiver are not identical, 'TRUE'
     otherwise.

'+ (String S)'
'+ (Integer I)'
     If the argument is a 'String', concatenate the receiver and S and
     return the new 'String.' If the argument is an 'Integer', return a
     reference to the receiver plus I.

'++ (void)'
     Increment the value of the receiver as a 'char *'.  This method
     uses '__ctalkIncStringRef ()' to handle the pointer math.

     In other words, this method effectively sets the receiver
     'String's' value from, for example, 'Hello, world!' to 'ello,
     world!'.  If the receiver is incremented to the end of its
     contents, then its value is 'NULL'.

'+= (String S)'
'+= (Integer I)'
     If the argument is an 'Integer', increment the reference to the
     receiver by that amount.  If the argument is a 'String' or any
     other class, concatenate the argument to the receiver and return
     the receiver, formatting it as a string first if necessary.

'- (Integer I)'
     Return a reference to the receiver 'String' minus I.  If the
     reference is before the start of the string, return NULL. That
     means the method is only effective after a call to '++' or a
     similar method.


          String new str;

          str = "Hello, world!";

          str += 1;

          printf ("%s\n", str);    /* Prints, "ello, world!" */

          --str;

          printf ("%s\n", str);    /* Prints, "Hello, world!" */


'-- (void)'
     Decrement the value of the receiver as a 'char *'.  The effect is
     the converse of '++', above.  The method doesn't decrement the
     reference so that it points before the beginning of the 'String'
     object's contents.  That means, like '-' above, the method only
     returns a pointer to somewhere in the receiver's value after a
     previous call to '++' or a similar method.  For example,


          String new str;

          str = "Hello, world!";

          ++str;

          printf ("%s\n", str);    /* Prints, "ello, world!" */

          --str;

          printf ("%s\n", str);    /* Prints, "Hello, world!" */



'-= (Integer I)'
     If the argument is an 'Integer', decrement the reference to the
     receiver's value by the amount given as the argument, an 'Integer'.
     Like the other methods that decrement the reference to the
     receiver's value, the program must first have incremented it
     further than the start of the string.

'asInteger (void)'
     Return an 'Integer' object with the value of the receiver.

'asList (List NEWLIST)'
     Store each character of the receiver 'String' as 'Character' object
     members of NEWLIST.

'at (int INDEX)'
     Return the character at INDEX.  The first character of the string
     is at index 0.  If INDEX is greater than the length of the string,
     return 'NULL'.

'atPut (int N, char c)'
     Replace the N'th character of the receiver with C.  Has no effect
     and returns 'NULL' if n is greater than the length of the receiver.

     The 'atPut' method interprets the following character sequences
     (with their ASCII values)


          Sequence   ASCII Value
          \0         0
          \a         7
          \b         7
          \n         10
          \e         27
          \f         10
          \r         13
          \t         9
          \v         11


     The '\e' escape sequence is an extension to the C language
     standard.

     The method returns the receiver (with the new value) if successful.

     You should note that the method does not do any conversion of the
     argument; that is, if C isn't a 'Character' object, then the
     results are probably not going to be what you want.  For example,
     if you try to store an 'Integer' in a 'String', like this:


          myInt = 1;

          myString atPut 0, myInt + '0';


     The results aren't going to be what you want; adding ASCII ''0''
     _doesn't_ convert 'myInt' to a 'Character' object.  You still need
     to use the 'asCharacter' method from 'Magnitude' class to create a
     'Character' object, as in this example.


          myInt = 1;

          myString atPut 0, (myInt + '0') asCharacter;


     The parentheses in the second argument are necessary; otherwise,
     'asCharacter' would use ''0'' as its receiver because
     'asCharacter', which is a method message, has a higher precedence
     than '+'.  Instead, 'asCharacter's' receiver should be the value of
     'myInt + '0'', so we enclose the first part expression in
     parentheses so it gets evaluated first.

'callStackTrace (void)'
     Print a call stack trace.

'charPos (char C)'
     Return an 'Integer' with the position of C in the receiver.
     Returns an 'Integer' between 0 (the first character) and the
     receiver's length, minus one (the last character).  If the receiver
     does not contain C, returns -1.

'charPosR (char C)'
     Return an 'Integer' with the position of the last occurence of C in
     the receiver.  Returns an 'Integer' between 0 (the first character)
     and the receiver's length, minus one (the last character).  If the
     receiver does not contain C, returns -1.

'chomp (void)'
     Removes a trailing newline character ('\n') if the receiver
     contains one.  Named after Perl's very useful string trimming
     function.

'consoleReadLine (String PROMPTSTR)'
     Print the PROMPTSTR on the terminal and wait for the user to enter
     a line of text.  If Ctalk is built with the GNU readline libraries,
     adds readline's standard line editing and command history
     facilities.  In that case, Ctalk also defines the
     'HAVE_GNU_READLINE' preprocessor definition to '1'.  You can build
     Ctalk with or without readline; see the options to './configure'
     for further information.

     Here is a sample program that shows how to use 'consoleReadLine'.
          int main (int argc, char **argv)    String new s;
            String new promptStr;

            if (argc > 1)
              promptStr = argv[1];
            else
              promptStr = "Prompt ";

            printf ("Readline test.  Type ^C or, \"quit,\" to exit.\n");
          #if HAVE_GNU_READLINE
            printf ("Ctalk built with GNU Readline Support.\n");
          #else
            printf ("Ctalk built without GNU Readline Support.\n");
          #endif
            while (1)      s consoleReadLine promptStr;
              printf ("You typed (or recalled), \"%s.\"\n", s);
              /*
               *  Matches both, "quit," and, "quit\n."
               */
              if (s match "quit")
                break;
            }
          }

'contains (String PATTERN)'
'contains (String PATTERN, Integer STARTING_OFFSET)'
     Returns a 'Boolean' value of True if the receiver string contains
     an exact match of the text in PATTERN, False otherwise.

     With a second argument N, an 'Integer', the method begins its
     search from the N'th character in the receiver string.

'envVarExists (char *ENVVARNAME)'
     Test for the presence of an environment variable.  Return 'TRUE' if
     the variable exists, 'FALSE' otherwise.

'getEnv (char *ENVVARNAME)'
     Return the value of environment variable ENVVARNAME as the value of
     the receiver, or '(null).' Note that this method generates an
     internal exception of the environment variable does not exist.  To
     test for the presence of an environment variable without generation
     an exception, see 'envVarExists', above.

'getRS (void)'
     Returns a 'Character' with the current record separator.

     The record separator determines whether the regular expression
     metacharacters '^' and '$' recognize line endings.  The default
     value of the record separator is a newline '\n' character, which
     means that a '^' character will match an expression at the start of
     a string, or starting at the beginning of a text line.  Likewise, a
     '$' metacharacter matches both the end of a line and the end of the
     string.

     To match only at the beginning and end of the string, set the
     record separator to a NUL character ('\0').  *Note Pattern
     Matching::.

'isXLFD (void)'
     Returns a Boolean value of True if the receiver is a XLFD font
     descriptor, False otherwise.  For more information about font
     selection, refer to the 'X11Font' class *Note X11Font::, and the
     'X11FreeTypeFont' class *Note X11FreeTypeFont::.

'length (void)'
     Return an object of class 'Integer' with the length of the receiver
     in characters.

'map (OBJECT *(*METHOD)())'
     Execute METHOD, an instance method of class 'String,' for each
     character of the receiver object.  For example,

          String instanceMethod printSpaceChar (void) {
            printf (" %c", self);  /* Here, for each call to the printSpaceChar
                                       method, "self" is each of myString's
                                       successive characters. */
          }

          int main () {

            String new myString;

            myString = "Hello, world!";

            myString map printSpaceChar;

            printf ("\n");
          }


     The argument to 'map' can also be a code block:


          int main () {

            String new myString;

            myString = "Hello, world!";

            myString map {
              printf (" %c", self);
            }

            printf ("\n");
          }


'match (char *PATTERN)'
     Returns 'TRUE' if PATTERN matches the receiver 'String' regardless
     of case, false otherwise.  Both 'match' and 'matchCase', below, are
     being superceded by 'matchRegex' and 'quickSearch', also below.

'matchAt (Integer IDX)'
     Returns the text of the IDX'TH parenthesized match resulting from a
     previous call to 'matchRegex', '=~', or '!~'.  *Note Pattern
     Matching::.

'matchCase (char *PATTERN)'
     Returns 'TRUE' if PATTERN matches the receiver case- sensitively,
     false otherwise.  Like 'match', above, 'matchCase' is being
     superceded by 'matchRegex' and 'quickSearch', below.

'matchIndexAt (Integer IDX)'
     Returns the character position in the receiver 'String' of the
     IDX'TH parenthesized match resulting from a previous call to
     'matchRegex', '=~', or '!~'.  *Note Pattern Matching::.

'matchLength (void)'
     Returns the length of a regular expression match from the previous
     call to the 'matchRegex' method, below.

'matchRegex (String PATTERN, Array OFFSETS)'
     Searches the receiver, a 'String' object, for all occurrences of
     PATTERN.  The 'matchRegex' method places the positions of the
     matches in the OFFSETS array, and returns an 'Integer' that
     contains the number of matches.  *Note Pattern Matching::.

     The 'quickSearch' method, below, matches exact text only, but it
     uses a much faster search algorithm.

'nMatches (void)'
     Returns an 'Integer' with the number matches from the last call to
     the 'matchRegex' method.

'printMatchToks (Integer YESNO)'
     If the argument is non-zero, print the tokens of regular expression
     patterns and the matching text after each regular expression match.
     This can be useful when debugging regular expressions.  *Note
     DebugPattern::.

'printOn (char *FMT, ...)'
     Format and print the method's arguments to the receiver.

'quickSearch (String PATTERN, Array OFFSETS)'
     Searches the receiver, a 'String' object, for all occurrences of
     PATTERN.  The 'quickSearch' method places the positions of the
     matches in the OFFSETS array, and returns an 'Integer' that
     contains the number of matches.

     Unlike 'matchRegex', above, 'quickSearch' matches exact text only,
     but it uses a much faster search algorithm.

'readFormat (char *FMT, ...)'
     Scan the receiver into the arguments, using FMT.

'search (String PATTERN, Array OFFSETS)'
     This method is a synonym for 'matchRegex', above, and is here for
     backward compatibility.

'setRS (char record_separator_char)'
     Sets the current application's record separator character, which
     determines how regular expression metacharacters match line
     endings, among other uses.  *Note RecordSeparator::.  *Note Pattern
     Matching::.

'split (char DELIMITER, char ** RESULTARRAY)'
     Split the receiver at each occurrence of DELIMITER, and save the
     result in RESULTARRAY.  The DELIMITER argument can be either a
     'Character' object or a STRING object.  If DELIMITER is a 'String,'
     it uses Ctalk's pattern matching library to match the delimiter
     string.  *Note Pattern Matching::.

     However, the pattern matching library only records the length of
     the last match, so if you use a pattern like '" *"' then the
     results may be inaccurate if all of the delimiters are not the same
     length.

'subString (int INDEX, int LENGTH)'
     Return the substring of the receiver of LENGTH characters beginning
     at INDEX.  String indexes start at 0.  If INDEX + LENGTH is greater
     than the length of the receiver, return the substring from INDEX to
     the end of the receiver.

'sysErrnoStr (void)'
     Sets the receiver's value to the text message of the last system
     error (the value of 'errno(3)').

'tokenize (List TOKENS)'
     Splits the receiver 'String' at each whitespace character or
     characters (spaces, horizontal and vertical tabs, or newlines) and
     pushes each non-whitespace set of characters (words, numbers, and
     miscellaneous punctuation) onto the 'List' given as the argument.
     The method uses 'ispunct(3)' to separate punctuation, except for
     '_' characters, which are used in labels.

     Note that this method can generate lists with hundreds or even
     thousands of tokens, so you need to take care with large (or even
     medium sized) input 'Strings' as receivers.

'tokenizeLine (List TOKENS)'
     Similar to tokenize, above.  This method also treats newline
     characters as tokens, which makes it easier to parse input that
     relies on newlines (for example, C++ style comments, preprocessor
     directives, and some types of text files).

'vPrintOn (StringCALLING_METHODS_FMT_ARG)'
     This function formats the variable arguments of its calling method
     on the receiver 'String' object.

     The argument is the format argument of the calling method.  When
     'vPrintOn' is called, it uses the argument as the start of the
     caller's variable argument list.

     Here is an example of 'vPrintOn's' use.


          Object instanceMethod myPrint (String fmt, ...) {
            String new s;
            s vPrintOn fmt;
            return s;
          }

          int main () {
            Object new obj;
            Integer new i;
            String new str;

            i = 5;

            str = obj myPrint "Hello, world no. %d", i;

            printf ("%s\n", str);
          }


'writeFormat (char *FMT,...)'
     Write the formatted arguments using FMT to the receiver.  Note that
     Ctalk stores scalar types as formatted strings.  *Note Variable
     arguments::.

String Searching and Pattern Matching
.....................................

'String' class defines a number of methods for searching and matching
'String' objects.  The 'matchRegex' method recognizes some basic
metacharacters to provide regular expression search capabilities.  The
'quickSearch' method searches 'String' objects for exact text patterns,
but it uses a much faster search algorithm.

The operators, '=~' and '!~' return true or false depending on whether
the receiver contains the pattern given as the argument.  If the
argument contains metacharacters, then Ctalk conducts a regular
expression search; otherwise, it tries to match (or not match, in the
case of '!~') the receiver and the pattern exactly.

If you want more thorough information about the search, the 'matchRegex'
and 'quickSearch' methods allow an additional argument after the text
pattern: an 'Array' object that the methods use to return the character
positions of the matches within the receiver.  After the method is
finished searching, the second argument contains the position of the
first character wherever the text pattern matched text in the receiver.
The last offset is '-1', indicating that there are no further matches.
The methods also return an 'Integer' object that contains the number of
matches.

Here is an example from 'LibrarySearch' class that contains the
additional 'offsets' argument.


     if ((inputLine match KEYPAT) &&
            (inputLine matchRegex (pattern, offsets) != 0)) {

     ...

     }


Searches can provide even more information than this, however.  Pattern
strings may contain 'backreferences', which save the text and position
of any of the receiver string's matched text that the program needs.
The sections just below describe backreferences in detail.

All of these methods (except 'quickSearch') recognize a few regular
expression metacharacters.  They are:

'.'
     Matches any single character.
'^'
     Matches text at the beginning of the receiver 'String's' text.
'$'
     Matches text at the end of the receiver 'String's' text, or the end
     of a line (that is, the character before a '\n' or '\r' newline
     character).
'*'
     Matches zero or more occurrences of the character or expression it
     follows.
'+'
     Matches one or more occurences of the character or expression it
     follows.

'?'
     Matches zero or one occurrence of the character or expression it
     follows.

'\'
     Escapes the next character so it is interpreted literally; e.g.,
     the sequence '\*' is interpreted as a literal asterisk.  Because
     Ctalk's lexical analysis also performs the same task, so if you
     want a backslash to appear in a pattern, you need to type, '\\',
     for example,


          myPat = "\\*";   /* The '\\' tells Ctalk's lexer that we really
                              want a '\' to appear in the pattern string,
                              so it will still be there when we use myPat
                              as a regular expression. */


     However, Ctalk also recognizes patterns, which only need to be
     evaluated by the regular expression parser.  Patterns do not get
     checked immediately for things like for balanced quotes and ASCII
     escape sequences; instead, they get evaluated by the regular
     expression parser when the program actually tries to perform some
     pattern matching.  Otherwise, patterns are identical to 'Strings'.
     Expressed as a pattern, 'myPat' in the example above would look
     like this.


          myPat = /\*/;


     Pattern strings are described in their own section, below.  *Note
     Pattern Strings::.

'('
')'
     Begin and end a match reference (i.e., a 'backreference').  Matched
     text between '(' and ')' is saved, along with its position in the
     receiver 'String', and can be retrieved with subsequent calls to
     the 'matchAt' and 'matchIndexAt' methods.  The match information is
     saved until the program performs another pattern match.

'\W'
'\d'
'\p'
'\w'
'\l'
     In patterns, these escape sequences match characters of different
     types.  The escape sequences have the following meanings.


          Character Class      Matches
          ---------------      ------
          \W                   'Word' Characters (A-Z, a-z)
          \d                   Decimal Digits (0-9)
          \w                   White Space (space, \t, \n, \f, \v)
          \p                   Punctuation (Any other character.)
          \l                   'Label' Characters (A-Z, a-z, 0-9, and _)
          \x                   Hexadecimal Digits (0-9, a-f, A-F, x, and X)


     The following program contains a pattern that looks for alphabetic
     characters, punctuation, and whitespace.


          int main (int argc, char **argv) {
            String new str;

            str = "Hello, world!";

            if (str =~ /e(\W*\p\w*\W)/) {
              printf ("match - %s\n", str matchAt 0);
            }
          }


     When run, the expression,


          str =~ /e(\W*\p\w*\W)/


     Produces the following output.


          match - llo, w


'|'
     Matches either of the expressions on each side of the '|'.  The
     expressions may be either a character expression, or a set of
     characters enclosed in parentheses.  Here are some examples of
     alternate patterns.

          a|b
          a*|b*
          a+|b+
          \W+|\d+
          (ab)|(cd)


     When matching alternate expressions, using '*' in the expressions
     can produce unexpected results because a '*' can provide a
     zero-length match, and the '|' metacharacter is most useful when
     there is some text to be matched.

     If one or both expressions are enclosed in parentheses, then the
     expression that matches is treated as a backreference, and the
     program can retrieve the match information with the 'matchAt' and
     'matchIndexAt' methods.

The following example shows how to use some of the matching featues in
an actual program.  This program saves the first non-label character
(either a space or parenthesis) of a function declaration, and its
position, so we can retrieve the function name and display it
separately.


     int main (argc, argv) {
       String new text, pattern, fn_name;
       List new fn_list;

       fn_list = "strlen ()", "strcat(char *)", "strncpy (char *)",
         "stat (char *, struct stat *)";

       /* Match the first non-label character: either a space or a
          parenthesis.  The double backslashes cause the content of
          'pattern' (after the normal lexical analysis for the string) to
          be,

            "( *)\("

          So the regular expression parser can check for a backslashed
          opening parenthesis (i.e., a literal '(', not another
          backreference delimiter).
       */

       pattern = "( *)\\(";

       fn_list map {
         if (self =~ pattern) {
           printf ("Matched text: \"%s\" at index: %d\n",
     	      self matchAt 0, self matchIndexAt 0);
           fn_name = self subString 0, self matchIndexAt 0;
           printf ("Function name: %s\n", fn_name);
         }
       }

       return 0;
     }


When run, the program should produce results like this.


     Matched text: " " at index: 6
     Function name: strlen
     Matched text: "" at index: 6
     Function name: strcat
     Matched text: " " at index: 7
     Function name: strncpy
     Matched text: " " at index: 4
     Function name: stat


Note that the first backreference is numbered '0', in the expression
'self matchAt 0'.  If there were another set of (unescaped) parentheses
in 'pattern', then its text would be refered to as 'self matchAt 1'.

You should also note that the second function match saved an empty
string.  That's because the text that the backreferenced pattern
referred to resulted in a zero-length match.  That's because '*'
metacharacters can refer to _zero_ or more occurrences of the character
that precedes it.

The program could also use the 'charPos' method to look for the ' '
and/or '(' characters, but using a regular expression gives us
information about which non-label character appears first more
efficiently.

Here's another example.  The pattern contains only one set of
parentheses, but Ctalk saves a match reference every time the pattern
matches characters in the target string.


     int main () {
       String new string, pattern;
       Array new offsets;
       Integer new nMatches, i;

       pattern = "(l*o)";
       string = "Hello, world! Hello, world, Hello, world!";

       nMatches = string matchRegex pattern, offsets;

       printf ("nMatches: %d\n", nMatches);
       offsets map {
         printf ("%d\n", self);
       }
       for (i = 0; i < nMatches; ++i) {
         printf ("%s\n", string matchAt i);
       }
     }


When run, the program produces output like this.


     nMatches: 6
     2
     8
     16
     22
     30
     36
     -1
     llo
     o
     llo
     o
     llo
     o


The character classes match anywhere they find text in a target string,
including control characters like '\n' and '\f', regardless of the
record separator character.  For a brief example, refer to the section,
'The Record Separator Character,' below.

This example matches one of two patterns joined by a '|' metacharacter.


     int main () {
       String new s, pat;
       Array new matches;
       Integer new n_matches, n_th_match;

       pat = "-(mo)|(ho)use";

       s = "-mouse-house-";

       n_matches = s matchRegex pat, matches;

       for (n_th_match = 0; n_th_match < n_matches; ++n_th_match) {
         printf ("Match %d. Matched %s at character index %ld.\n",
     	    n_th_match, s matchAt n_th_match, s matchIndexAt n_th_match);
       }

       matches delete;

     }


When run, the program should produce output like this.


     Match 0. Matched mo at character index 0.
     Match 1. Matched ho at character index 6.


You should note that if a pattern in a backreference results in a zero
length match, then that backreference contains a zero length string.
While not incorrect, it can produce confusing results when examining
matched text.  The following program shows one way to indicate a
zero-length backreference.  It prints the string '(null)' whenever a
backreference contains a zero-length string.


     int main () {
       String new s;
       String new pat;
       Integer new n_matches;
       Array new offsets;
       Integer new i;

       s = "1.mobile 2mobile mobile";
       pat = "(\\d\\p)?m";

       n_matches = s matchRegex pat, offsets;

       for (i = 0; i < n_matches; ++i) {
         printf ("%Ld\n", offsets at i);
       }

       for (i = 0; i < n_matches; ++i) {
         if ((s matchAt i) length == 0) {
           printf ("%d: %s\n", s matchIndexAt i, "(null)");
         } else {
           printf ("%d: %s\n", s matchIndexAt i, s matchAt i);
         }
       }
     }


When run, the program should produce output that looks like this.


     0
     10
     17
     0: 1.
     17: (null)
     22: (null)


Pattern Strings
...............

When writing a regular expression, it's necessary to take into account
all of the processing that String objects encounter when they are
evaluated, before they reach the Ctalk library's regular expression
parser.  To help facilitate lexical analysis and parsing, Ctalk also
provides 'pattern strings', which allow Ctalk to defer the evaluation of
a pattern until the regular expression parser actually performs the text
matching.

Ctalk also provides operators that provide shorthand methods to match
patterns with text, the =~ and !~ operators.

Pattern constants at this time may only follow the =~ and !~ operators,
but you can use the 'matchAt' and 'matchIndexAt', and 'nMatches' methods
to retrieve the match information.  You must, as with 'Strings' that are
used as patterns, enclose the pattern in '(' and ')' metacharacters in
order to create a backreference.

Here is a simple string matching program that matches text against a
pattern constant.


     int main () {

       String new s;
       Integer new n_offsets;
       Integer new i;

       s = "Hello?";

       if (s =~ /(o\?)/) {
         printf ("match\n");
         i = 0;
         n_offsets = s nMatches;
         while (i < n_offsets) {
           printf ("%d: %s\n", s matchIndexAt i, s matchAt i);
           ++i;
         }
       }
     }


The most obvious example of how a pattern provides an advantage for text
matching is when writing backslash escapes.  To make a backslash appear
in a pattern string, you need to write at least two backslashes in order
for a backslash to appear when it's needed to escape the following
character.  If you want to match an escaped backslash, then you need to
write at least _four_ backslashes.


     String         Pattern
     "\\*"          /\*/        # Matches a literal '*'.
     "\\\\*"        /\\*/       # Matches the expression '\*'.


To create a pattern, you delimit the characters of the pattern with
slashes ('//') instead of double quotes.  Other delimiters can signify
patterns also if the pattern starts with a 'm' character, followed by
the delimiter character, which must be non-alphanumeric.


     String         Pattern     Alternate Pattern
     "\\*"          /\*/        m|\*|
     "\\\\*"        /\\*/       m|\\*|


There is no single rule that governs how often 'String' objects are
evaluated when a program runs.  So writing patterns helps take some of
the work out of testing an application's pattern matching routines.

Debugging Pattern Matches
.........................

Ctalk allows you to view the parsed pattern tokens, and the text that
each token matches.  Token printing is enabled using the
'printMatchToks' method, like this.


     myString printMatchToks TRUE;


When token printing is enabled, then Ctalk's pattern matching routines
print the tokens of the pattern and the text that each token matches
after every pattern match attempt.

If we have a program like the following:


     int main () {

       String new s;

       s printMatchToks TRUE;

       s = "192.168.0.1";

       if (s =~ /\d+\.(\d+)\.\d+\.\d+/) {
         printf ("match!\n");
       }

     }


Then, when this program is run with token printing enabled, the output
should look similar to this.


     joeuser@myhost:~$ ./mypatprogram
     PATTERN: /\d+\.(\d+)\.\d+\.\d+/         TEXT: "192.168.0.1"
     TOK: d+         (character class)               MATCH: "192"
     TOK: .          (literal character)             MATCH: "."
     TOK: (          (backreference start)           MATCH: ""
     TOK: d+         (character class)               MATCH: "168"
     TOK: )          (backreference end)             MATCH: ""
     TOK: .          (literal character)             MATCH: "."
     TOK: d+         (character class)               MATCH: "0"
     TOK: .          (literal character)             MATCH: "."
     TOK: d+         (character class)               MATCH: "1"
     match!
     joeuser@myhost:~$


The processed token text is followed by any attributes that the regular
expression parser finds (for example, then a pattern like '\d+' becomes
the token 'd+' with the attribute of a character class identifier, or
the '(' and ')' characters' backreference attributes).  Then, finally,
the library prints the text that matches each token.

Successful matches have text matched by each token in the pattern
(except for zero-length metacharacters like '(', ')', '^', or '$').

Unsuccessful matches, however, may display text that matches where you
don't expect it.  That's because the regular expression parser scans
along the entire length of the text, trying to match the first pattern
token, then the second pattern token, and so on.

Although this doesn't always pinpoint the exact place that a match first
failed, it can provide a roadmap to help build a complex pattern from
simpler, perhaps single-metachar patterns, which shows what the regular
expression parser is doing internally.

The Record Separator Character
..............................

Ctalk uses a record separator character to determine how the
metacharacters '^' and '$' match line endings, among other uses.

The default record separator character is a newline ('\n').  In this
case a '^' metacharacter in an expression matches the beginning of a
string as well as the character(s) immediately following a newline.
Similarly, a '$' metacharacter anchors a match to the characters at the
end of a line and at the end of a string.

Setting the record separator character to NUL ('\0') causes '^' and '$'
to match only the beginning and the end of a string.

Here is an example that prints the string indexes of matches with the
default newline record separator and with a NUL record separator
character.

When the record separator is ''\n'', the '$' metacharacter in our
pattern matches the text immediately before a '\n' character, as well as
the text at the end of the string.


     int main () {

       String new s;
       Integer new n_indexes;
       Array new match_indexes;
       String new pattern;

       printf ("\tMatch Indexes\n");

       /* Begin with the default record separator ('\n'). */

       s = "Hello, world!\nHello, wo\nHello, wo";
       pattern = "wo$";
       n_indexes = s matchRegex pattern, match_indexes;

       printf ("With newline record separator:\n");
       match_indexes map {
         printf ("%d\n", self);
       }

       s setRS '\0';   /* Set the record separator to NUL ('\0'). */

       match_indexes delete; /* Remember to start with an empty Array again. */

       n_indexes = s matchRegex pattern, match_indexes;

       printf ("With NUL record separator:\n");
       match_indexes map {
         printf ("%d\n", self);
       }
     }


When run, the program should produce output like this.


             Match Indexes
     With newline record separator:
     21
     31
     -1
     With NUL record separator:
     31
     -1


Likewise, a '^' metacharacter matches text immediately after the '\n'
record separator, or at the beginning of a string.

It's also possible, though, to match newlines (and other ASCII escape
characters) in patterns, either with a character class match, or by
adding the escape sequence to the pattern.  To do that, the program
should use a double backslash with the ASCII escape sequence, as with
the newline escape sequence in this example.


     int main () {
       String new s;

       s = "Hello,\nworld!";

       if (s =~ /(\W\p\\n)/)
         printf ("%s\n", s matchAt 0);

     }



File: ctalk.info,  Node: Float,  Next: Integer,  Prev: Character,  Up: Classes

'Float' Class
-------------

Objects of 'Float' class represent double precision, floating point
numbers.

Instance Variables
------------------

'value'
     The value is the formatted representation of a double precision
     floating point number.

Instance Methods
................

'&& (double D)'
     Return an 'Integer' that evaluates to 'TRUE' if both operands are
     'TRUE,' 'FALSE' otherwise.

'= (double D)'
     Set the value of the receiver object to D.

'+ (double D)'
     Add D to the receiver.

'+= (double D)'
     Add D to the receiver's value.  Set the receiver to the new value,
     and return the receiver.

'- (void)'
'- (double D)'
     Subtract D from the receiver.  When used as a prefix operator,
     negate the receiver.

'-= (double D)'
     Subtract D from the receiver's value.  Set the receiver to the new
     value, and return the receiver.

'* (double D)'
     Multiply the receiver by D.

'*= (double D)'
     Multiply D by the receiver's value.  Set the receiver to the new
     value, and return the receiver.

'* (double D)'
     Divide the receiver by D.

'/= (double D)'
     Divide D by the receiver's value.  Set the receiver to the new
     value, and return the receiver.

'< (double D)'
     Return an 'Integer' that evaluates to 'TRUE' if the receiver is
     less than the argument, 'FALSE' otherwise.

'<= (double D)'
     Return an 'Integer' that evaluates to 'TRUE' if the receiver is
     less than or equal to the argument, 'FALSE' otherwise.

'> (double D)'
     Return an 'Integer' that evaluates to 'TRUE' if the receiver is
     greater than the argument, 'FALSE' otherwise.

'>= (double D)'
     Return an 'Integer' that evaluates to 'TRUE' if the receiver is
     greater than or equal to the argument, 'FALSE' otherwise.

'asInteger (void)'
     Return the integer portion of the receiver.

'|| (double D)'
     Return an 'Integer' that evaluates to 'TRUE' if either operand is
     'TRUE,' 'FALSE' otherwise.


File: ctalk.info,  Node: Integer,  Next: CTime,  Prev: Float,  Up: Classes

'Integer' Class
---------------

Objects of 'Integer' class represent signed and unsigned integers of the
C types 'int' and 'long int'.

Instance Variables
------------------

'value'
     The value is the formatted representation of the receiver.

Instance Methods
................

'!= (int I)'
     Return 'TRUE' if the receiver and the argument are not equal,
     'FALSE' otherwise.

'& (int I)'
     As a binary operator, perform a bitwise and of the receiver and the
     argument.  The 'Object' class's '&' method overloads C's unary
     "address of" prefix operator.  *Note Object::.

'% (int I)'
     Return an 'Integer' that is the modulus of the receiver and the
     argument.

'%= (int I)'
     Perform a modulus of the receiver and its argument, and store the
     result in the receiver.  Returns the receiver.

'&& (int I)'
     Return 'TRUE' if the receiver and the argument evaluate to 'TRUE.'

'&= (Integer I)'
     Perform a bitwise and of the receiver and the argument, and assign
     the result to the receiver.

'+ (int I)'
     Add I and the receiver, as in this example.

'++ (void)'
     Postfix and prefix increment operators for 'Integer' objects.

'+= (int ARG)'
     Add the value of ARG to the receiver.

'- (int I)'
     Subtract I from the receiver.

'- (void)'
     When used as a unary minus prefix operator, negate the expression.

'-- (void)'
     Postfix and prefix decrement operators for 'Integer' objects.

'-= (Integer ARG)'
     Subtract the value of ARG from the receiver.

'* (int I)'
     Multiply the receiver by I.

'*= (int ARG)'
     Multiply the receiver by ARG.

'/ (int I)'
     Divide the receiver by I.

'/= (int ARG)'
     Divide the receiver by ARG.

'< (int I)'
     Return 'TRUE' if the receiver is less than the argument, 'FALSE'
     otherwise.

'<< (int I)'
     Perform an arithmetic left shift on the receiver by the number of
     bits in the argument.

'<= (int I)'
     Return 'TRUE' if the receiver is less than or equal to the
     argument, 'FALSE' otherwise.

'= (int I)'
     Set the value of the receiver object to I.  Also checks for
     'Symbol' pointer contexts and other aliases.

          intObject = 2;

          resultInt = intObject + intObject;

'== (int I)'
     Return 'TRUE' if the receiver and the argument are equal, 'FALSE'
     otherwise.

'> (int I)'
     Return 'TRUE' if the receiver is greater than the argument, 'FALSE'
     otherwise.

'>= (int I)'
     Return 'TRUE' if the receiver is greater than or equal to the
     argument, 'FALSE' otherwise.

'>> (int I)'
     Perform an arithmetic right shift on the receiver by the number of
     bits in the argument.

'^ (int I)'
     Return the result of a bitwise xor of the receiver and its
     argument.

'^= (int I)'
     Preform a bitwise xor of the receiver with its argument, and assign
     the value to the receiver.  Returns the receiver.

'bitComp (int I)'
     Return the bitwise complement of the receiver.

'invert (void)'
     Return 'TRUE' if the receiver evaluates to 'FALSE,' 'FALSE' if the
     receiver evaluates to 'TRUE.'

'| (int I)'
     Perform a bitwise or of the receiver and the argument.

'|= (Integer I)'
     Perform a bitwise or of the receiver and the argument, and assign
     the result to the receiver.

'|| (int I)'
     Return 'TRUE' if either the receiver or the argument, or both,
     evaluate to 'TRUE.'

'^ (int I)'
     Perform a bitwise exclusive or of the receiver and the argument.

     Returns a 'String' formatted as a decimal or hexadecimal integer.
     The 'asString' method is a synonym for 'asDecimalString'.

'~ (void)'
     When used to overload C's '~' operator, is synonymous with the
     'bitComp' method, above.


File: ctalk.info,  Node: CTime,  Next: CalendarTime,  Prev: Integer,  Up: Classes

'CTime' Class
-------------

Objects of 'CTime' class represent the system's UTC clock which measures
time in seconds since 1900.  This class also implements the methods that
convert UTC time into calendar time.

The return value of the methods 'gmTime' and 'localTime' is an 'Array'
that contains the following values.
     returnArray at 0    Seconds (0... 59)
     returnArray at 1    Minutes (0... 59)
     returnArray at 2    Hours (0... 23)
     returnArray at 3    Day of the Month (1... 31)
     returnArray at 4    Month (0... 11)
     returnArray at 5    Year (Number of years since 1900.)
     returnArray at 6    Day of the Week (0 = Sunday ... 6 = Saturday)
     returnArray at 7    Day of the Year (1... 365)
     returnArray at 8    > 0 = Daylight Savings Time; 0 = Standard Time;
                         < 0 = Not Available

Instance Methods
................

'cTime (void)'
     Returns a formatted 'String' with the date and time of the
     receiver.

     The return 'String' of a 'cTime' call is formatted as in this
     example.
          "Sun Jan 6 13:04:00 2008\n"

'gmTime (void)'
     Returns an 'Array' with the values described above for the current
     Greenwich Mean Time.

'haveDST (void)'
     Return an 'Integer' that evaluates to True if the system provides
     daylight savings time information, False otherwise.

'isAM (void)'
     Returns an 'Integer' that evaluates to True or False depending on
     whether the local time is a.m.  or p.m.

'localTime (void)'
     Returns an 'Array' with the values described above for the current
     local time.

'timeZoneName (void)'
     Return a 'String' with the name of the time zone provided by the
     system.

'timeZoneOffset (void)'
     Return an 'Integer' with the time zone offset in seconds from GMT.
     Not all systems provide this information.

'utcTime (void)'
     Return an 'Integer' object containing the current UTC time.


File: ctalk.info,  Node: CalendarTime,  Next: LongInteger,  Prev: CTime,  Up: Classes

'CalendarTime' Class
--------------------

'CalendarTime' class provides instance variables for elements of a
broken-down clock and calendar UTC time: seconds, minutes, hours, day of
the month, and so on.  The methods in this class might be more
convenient in many cases than their functional equivalents in 'CTime'
class.

All of the methods in this class expect that the receiver has made a
previous call to 'getUTCTime' (which is defined in 'CTime' class).  The
'getUTCTime' method fills in the receiver's value with the UTC seconds
since the epoch.  *Note CTime::.

The 'localTime' and 'gmTime' methods contain calls to the system's
'localtime(3)' and 'gmtime(3)' library functions (or localtime_r and
gmtime_r).  These manual pages provide more information about how the
system translates seconds since 1900 into a local time zone's calendar
time, or UTC calendar time.

This brief example prints an ISO-format date and time string.


     int main () {
       CalendarTime new ct;

       ct utcTime;
       ct localTime;
       printf ("%s\n", ct isoTimeString);
     }


Instance Variables
..................

'seconds'
'minutes'
'hours'
'dom'
'month'
'year'
'dow'
'doy'
     'Integers' that contain the clock time and calendar date
     represented by the receiver's UTC time.  The values are translated
     using the local time zone information if necessary.


          Instance Variable                   Range
          -----------------                   -----
          seconds                             0 - 59
          minutes                             0 - 59
          hours                               0 - 23
          dom  (day of the month)             1 - 31
          month                               0 - 11 (0 = January)
          year                                Years since 1900.
          dow  (day of the week)              0 - 6  (0 = Sunday)
          doy  (day of the year)              0 - 365
          isdst                               > 0 : true
                                                0 : false
                                              < 0 : not available


'isdst'
     An 'Integer' value that indicates whether Daylight Savings Time is
     in effect on systems that support it.  If the value is positive,
     Daylight Savings Time is in effect, zero indicates that DST is not
     in effect, and a value less than zero indicates that the
     information is not available.

'timeZone'
     An 'Integer' that contains the seconds west of GMT of the local
     time zone.
'tzStd'
'tzDst'
'gmtOff'
     'String' objects that contain the abbreviation of the standard
     local time zone, the local daylight savings time zone, and the
     hours from GMT, usually expressed as a four digit number; e.g.,
     '-0700' for the MST time zone.  The value of 'gmtOff' is the result
     of dividing the value of the 'timeZone' instance variable by -3600,
     them multiplying the result by 100.  The 'haveDst' instance
     variable is 'true' if the timezone supports daylight savings time,
     but not all systems support this.  To find out whether daylight
     savings time is in effect, the 'isdst' instance variable above, can
     provide that information if the machine supports it.

     Calling the 'localTime' and 'zoneInfo' methods fill in the time
     zone information.

Instance Methods
................

'cTimeString (void)'
     Returns a formatted string with the date and time given by the
     receiver.

     The returned String is formatted similarly to the output of the
     'ctime(3)' C function, except that the string does not include a
     trailing newline.

     Programs should call the 'utcTime' method to get the current UTC
     time, and then either the 'localTime' or 'gmTime' method to convert
     the UTC time into calendar day and date information, before calling
     this method.

'dayName (void)'
     Returns a 'String' with the three-letter abbreviation of the
     current day: 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', and 'Sat'.

'gmTime (void)'
     Fills in the receiver's instance variables with the elements of the
     UTC calendar time.

     Programs should call the 'utcTime' method to get the current UTC
     time before calling this method.

'isoTimeString (void)'
     Returns a formatted string with the date and time given by the
     receiver.  The returned String has the format of an ISO date and
     time string.

     Programs should call the 'utcTime' method to get the current UTC
     time, and then either the 'localTime' or 'gmTime' methods to
     convert the UTC time into calendar day and date information, before
     calling this method.

'localTime (void)'
     Fills in the receiver's instance variables with the elements of the
     local calendar time, as determined by the system's time zone
     setting.

     Programs should call the 'utcTime' method to get the current UTC
     time before calling this method.

'monName (void)'
     Returns a 'String' with the three-letter abbreviation of the
     current time's month: 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
     'Jul', 'Aug', 'Sep', 'Oct', 'Nov', and 'Dec'.

'zoneInfo (void)'
     Fills in the receiver's 'timeZone', 'tzStd', 'tzDst', 'gmtOff', and
     'haveDst' with information about the machine's current time zone.


File: ctalk.info,  Node: LongInteger,  Next: Pen,  Prev: CalendarTime,  Up: Classes

'LongInteger' Class
-------------------

Objects of 'LongInteger' class represent signed and unsigned integers of
the C type 'long long int'.

Instance Variables
------------------

'value'
     The value is the formatted representation of a signed 'long long
     int'.

Instance Methods
................

'!= (long long int L)'
     Return 'TRUE' if the receiver is not equal to L.

'= (long long int L)'
     Set the value of the receiver to L.

'== (long long int L)'
     Return 'TRUE' if the receiver is equal to L.

'+ (long long int L)'
     Add L to the the receiver.

'++ (void)'
     Implements both the C prefix and postfix increment operators for
     'LongInteger' objects.

'- (long long int L)'
     Subtract L from the receiver.

'- (void)'
     When used as a prefix operator, negate the argument.

'-- (void)'
     The C decrement operator, both prefix and postfix, for
     'LongInteger' objects.

'% (long long int L)'
     Return a 'LongInteger' that is the modulus of the receiver and the
     argument.

'%= (int I)'
     Perform a modulus of the receiver and its argument, and store the
     result in the receiver.  Returns the receiver.

'& (long long int L)'
     Perform a bitwise AND of the receiver and the operand.  The
     'Object' class's '&' operator overloads C's unary "address of"
     prefix operator.  *Note Object::.

'&& (long long int L)'
     Return 'TRUE' if both the receiver and the operand evaluate to
     'TRUE.'

'& ( int I)'
     Perform a bitwise AND of the receiver and the operand, and store
     the result in the receiver.  Returns the receiver.

'* (long long int L)'
     Multiply the receiver by L.

'/ (long long int L)'
     Divide the receiver by L.

'< (long long int L)'
     Return 'TRUE' if the receiver is less than the operand, 'FALSE'
     otherwise.

'<= (long long int L)'
     Return 'TRUE' if the receiver is less than or equal to the operand,
     'FALSE' otherwise.

'<< (int I)'
     Shift the receiver left by the number of bits in the operand, an
     'Integer.'

'> (long long int L)'
     Return 'TRUE' if the receiver is greater than the operand, 'FALSE'
     otherwise.

'>= (long long int L)'
     Return 'TRUE' if the receiver is greater than or equal to the
     operand, 'FALSE' otherwise.

'>> (int L)'
     Shift the receiver right by the number of bits in the operand, an
     'Integer.'

'^ (long long int L)'
     Perform a bitwise XOR of the receiver and the operand.

'^= (int I)'
     Perform a bitwise XOR of the receiver and the operand, and store
     the result in the receiver.  Returns the receiver.

'bitComp (void)'
     Return a bitwise complement of the receiver.

'invert (void)'
     Return 'TRUE' if the receiver evaluates to 'FALSE,' 'FALSE' if the
     receiver evaluates to 'TRUE.'

'| (long long int L)'
     Perform a bitwise OR of the receiver and the operand.

'|= (int I)'
     Perform a bitwise OR of the receiver and the operand, and store the
     result in the receiver.  Returns the receiver.

'| (long long int L)'
     Return 'TRUE' if either the receiver or the operand evaluate to
     'TRUE.'

'~ (void)'
     When overloading C's unary '~' operator, is synonymous with the
     'bitComp' method, above.


File: ctalk.info,  Node: Pen,  Next: Point,  Prev: LongInteger,  Up: Classes

'Pen' Class
-----------

'Pen' class objects define drawing parameters for graphics primitives
when drawing points or lines.  Currently the only parameter that 'Pen'
implements with the 'width' instance variable, which controls the width
of graphics shapes like points and lines.

The 'Point' class section contains an example of how to use 'Pen'
objects when drawing graphics.  *Note Point::.

Instance Variables
------------------

'alpha'
     Defines an object's opacity when using drawing libraries that
     support alpha channel blending (presently that is only the 'Line'
     class drawing library, which uses the X Render extension).  The
     value is an Integer in the range, 0..65535 (0..0xffff hexadecimal).
     For graphics library functions that do not support alpha blending,
     this value is not used.
'colorName'
     A 'String' containing the name of the 'Pen' object's color.  The X
     Window System's libraries use color names defined in the server's
     'rgb.txt' file, which is normally located a directory that contains
     the server's configuration files (e.g., _<prefix>_'/etc/X11' or
     similar).
'width'
     The width in pixels of a line when drawing non-filled shapes.  The
     default is 1.


File: ctalk.info,  Node: Point,  Next: Line,  Prev: Pen,  Up: Classes

'Point' Class
-------------

Objects of 'Point' class describe a location with X- and Y-axis
coordinates.  These objects are commonly used to describe locations on a
display.

The 'draw' and 'drawWithPen' methods allow you to draw 'Point' objects
on a 'X11CanvasPane' object at the coordinates given by the point's 'x'
and 'y' instance variables.  There is an example program at the end of
this section.  *Note point-example::.

If you use the 'draw' method and don't provide a 'Pen' object, Ctalk
draws the point with the default diameter of one pixel, and the default
color is black.

Instance Variables
------------------

'x'
     The x coordinate of the receiver object.
'y'
     The y coordinate of the receiver object.

Instance Methods
................

'draw (X11Pane PANE_OBJECT)'
     Draw the receiver on PANE_OBJECT at the coordinates given by the
     receiver's 'x' and 'y' instance variables.

     This method draws to the 'X11Pane' objects buffer.  To draw
     offscreen to a separate 'X11Bitmap', object refer to the method
     'drawPoint' in class 'X11Bitmap'.  *Note X11Bitmap::.

'drawWithPein (X11Pane PANE_OBJECT, Pen PEN_OBJECT)'
     Draw the receiver on PANE_OBJECT at the coordinates given by the
     receiver's 'x' and 'y' instance variables, with the diameter and
     color supplied by the PEN_OBJECT argument.  *Note Pen::.

     This method also draws to the 'X11Pane' object's buffer.  To draw
     offscreen to a separate 'X11Bitmap' object, refer to the method
     'drawPoint' in class 'X11Bitmap'.  *Note X11Bitmap::.


     int main () {
       X11Pane new xPane;
       InputEvent new e;
       X11PaneDispatcher new xTopLevelPane;
       X11CanvasPane new xCanvasPane;
       Application new paneApp;

       paneApp enableExceptionTrace;
       paneApp installExitHandlerBasic;

       xPane initialize 10, 10, 250, 250;
       xPane inputStream eventMask =        /* Tell the main window's event */
         WINDELETE|EXPOSE;                  /* object, a X11InputStream,    */
                                            /* which types of events we     */
                                            /* plan to use.                 */

       xTopLevelPane attachTo xPane;        /* The attachTo methods also */
       xCanvasPane attachTo xTopLevelPane;  /* set the dimensions of the */
                                            /* subpanes before they are  */
                                            /* mapped and raised along   */
                                            /* with the top-level pane.  */

       xPane map;
       xPane raiseWindow;
       xPane openEventStream;               /* Before we can do any      */
                                            /* drawing on the window, we */
                                            /* need to start sending and */
                                            /* receiving events from the */
                                            /* X server.  That is what   */
                                            /* openEventStream does.     */

       xPane background "yellow";           /* Setting the background of */
       xPane clearWindow;                   /* an X11Pane object sets the*/
                                            /* background of the actual  */
                                            /* window.                   */

       xCanvasPane background "yellow";     /* Setting the background of */
                                            /* a buffered pane like a    */
                                            /* X11CanvasPane sets the    */
                                            /* background color of its   */
                                            /* buffer.                   */

       xCanvasPane clearRectangle 0, 0, 250, 250; /* In both cases, we   */
                                                  /* need to update the  */
                                                  /* pane before the new */
                                                  /* color is visible,   */
                                                  /* with either,        */
                                                  /* "clearWindow," or,  */
                                                  /* "clearRectangle."   */
       xCanvasPane pen width = 100;
       xCanvasPane pen colorName = "red";
       xCanvasPane drawPoint 40, 40;
       xCanvasPane pen colorName = "green";
       xCanvasPane drawPoint 120, 40;
       xCanvasPane pen colorName = "blue";
       xCanvasPane drawPoint 80, 90;

       while (TRUE) {
         xPane inputStream queueInput;
         if (xPane inputStream eventPending) {
           e become xPane inputStream inputQueue unshift;
           xPane subPaneNotify e;          /* We need to notify subPanes */
                                           /* e.g., xCanvasPane of the   */
                                           /* input events from the GUI. */
           switch (e eventClass value)
             {
             case WINDELETE:
               xPane deleteAndClose;
               exit (0);
               break;
             case EXPOSE:
             case RESIZENOTIFY:
     	  xCanvasPane pen width = 100;
     	  xCanvasPane pen colorName = "red";
     	  xCanvasPane drawPoint 40, 40;
     	  xCanvasPane pen colorName = "green";
     	  xCanvasPane drawPoint 120, 40;
     	  xCanvasPane pen colorName = "blue";
     	  xCanvasPane drawPoint 80, 90;
               break;
             default:
               break;
             }
         }
       }
     }



File: ctalk.info,  Node: Line,  Next: Rectangle,  Prev: Point,  Up: Classes

'Line' Class
------------

A 'Line' object contains the coordinates for a line graphics shape.
'Line' objects use 'Pen' objects to specify the width and color of the
line.  If an application doesn't specify a 'Pen' object, the default
width is one pixel and the default color is black.  *Note Pen::.

Here is an example of how to draw a line on a 'X11Pane' window.
     int main () {
       X11Pane new xPane;
       InputEvent new e;
       Pen new bluePen;
       Line new basicLine;

       xPane initialize 10, 10, 100, 100;
       xPane map;
       xPane raiseWindow;
       xPane openEventStream;
       bluePen width = 10;
       bluePen colorName = "blue";
       while (TRUE) {
         xPane inputStream queueInput;
         if (xPane inputStream eventPending) {
           e become xPane inputStream inputQueue unshift;
           switch (e eventClass value)
     	{
     	case WINDELETE:
     	  xPane deleteAndClose;
     	  exit (0);
     	  break;
     	case EXPOSE:
     	case RESIZENOTIFY:
     	  basicLine start x = 90;
     	  basicLine start y = 10;
     	  basicLine end x = 10;
     	  basicLine end y = 90;
      	  basicLine drawWithPen xPane, bluePen;
     	  break;
     	default:
     	  break;
     	}
         }
       }
     }

Instance Variables
------------------

'start'
     A 'Point' object that contains the receiver's starting 'x' and 'y'
     coordinates.
'end'
     A 'Point' object that contains the receiver's ending 'x' and 'y'
     coordinates.

Instance Methods
................

'draw (X11Pane PANEOBJECT)'
     Draw a line on the PANEOBJECT's visible area at the receiver's
     'start' and 'end' coordinates, using a default pen width of one
     pixel and default color of black.

     This method is mainly used for drawing on a buffer already attached
     to a 'X11Pane' object.  To draw offscreen to a separate 'X11Bitmap'
     object, use 'drawLine' in class 'X11Bitmap'.  *Note X11Bitmap::.

'drawWithPen (X11Pane PANEOBJECT, Pen PENOBJECT)'
     Draw a line on the PANEOBJECT's visible area at the receiver's
     'start' and 'end' coordinates.  The PENOBJECT argument contains the
     width and color of the line.  *Note Pen::.

     This method is also used mainly for drawing on a buffer already
     attached to a 'X11Pane' object.  To draw offscreen to a separate
     'X11Bitmap' object, use 'drawLine' in class 'X11Bitmap'.  *Note
     X11Bitmap::.


File: ctalk.info,  Node: Rectangle,  Next: Circle,  Prev: Line,  Up: Classes

'Rectangle' Class
-----------------

Programs can use 'Rectangle' objects to describe and draw four-sided
square and rectangular shapes.

Although the 'Rectangle' objects are meant to be displayed on X11Pane
displays that require only the origin and extent of a rectangle to
display it, the class defines each side's line separately, in case a
program needs to work with all of the object's dimensions.

The methods 'drawWithPen' and 'fillWithPen' draw either the sides of a
rectangle or a filled rectangle, using the line width and color defined
by a 'Pen' object.  The methods 'draw' and 'fill' use a default line
width of one pixel and the color black.

Here is a simple example program.
     int main () {
       X11Pane new xPane;
       InputEvent new e;
       Pen new bluePen;
       Rectangle new rectangle;

       xPane initialize 10, 10, 100, 100;
       xPane map;
       xPane raiseWindow;
       xPane openEventStream;

       /*
        *  The rectangle's sides are four Line objects:
        *  top, bottom, left, and right.  There is also
        *  a "dimensions" method that fills in all of
        *  the sides' dimensions.
        */
       rectangle top start x = 10;
       rectangle top start y = 10;
       rectangle right end x = 80;
       rectangle right end y = 80;

       bluePen width = 3;
       bluePen colorName = "blue";

       while (TRUE) {
         xPane inputStream queueInput;
         if (xPane inputStream eventPending) {
           e become xPane inputStream inputQueue unshift;
           switch (e eventClass value)
             {
             case WINDELETE:
               xPane deleteAndClose;
               exit (0);
               break;
             case EXPOSE:
             case RESIZENOTIFY:
     	  /*
     	   *  To draw only the outline of the rectangle,
     	   *  use the "draw" method instead.
     	   */
     	  rectangle fillWithPen xPane, bluePen;
               break;
             default:
               break;
             }
         }
       }
     }

Instance Variables
------------------

'top'
'right'
'bottom'
'left'
     'Line' objects that contain the dimensions of each of the
     rectangle's sides.  Each 'Line' instance variable in turn contains
     'Point' objects that contain the endpoints of each side.

     _Note:_ Unlike 'Line' objects, which specify endpoints as absolute
     window coordinates, 'Rectangle' objects specify the endpoints of
     each side as relative to the origin of the 'Rectangle' object; that
     is, as height and width dimensions.  *Note Line::.

Instance Methods
................

'clear (X11Pane PANEOBJECT)'
     Clear the rectangle defined by the receiver to the background color
     of PANEOBJECT.  This method requires that the dimensions of the
     rectangle be completely defined.  The easiest way to do this is
     with the 'dimensions' method, below.

'draw (X11Pane PANEOBJECT)'
     Draw an outline of the receiver's rectangle dimensions on
     PANEOBJECT's display area, using a line width of one pixel and the
     color black.

'drawWithPen (X11Pane PANEOBJECT, Pen PENOBJECT)'
     pDraw an outline of the receiver's rectangle dimensions on
     PANEOBJECT's display area, using the line width and color given by
     PENOBJECT.

'dimensions (Integer XORIGIN, Integer YORIGIN, Integer XSIZE, Integer YSIZE)'
     A convenience method that fills in the dimensions of each of the
     receiver's sides from the arguments, which specify the origin,
     height, and width of the receiver.

'fill (X11Pane PANEOBJECT)'
     Draw a solid rectangle on PANEOBJECT's display area, using a
     default line width of one pixel and the default color, black.

'fillWithPen (X11Pane PANEOBJECT, Pen PENOBJECT)'
     Draw a solid rectangle on PANEOBJECT's display area, using the
     color given by PENOBJECT.


File: ctalk.info,  Node: Circle,  Prev: Rectangle,  Up: Classes

'Circle' Class
--------------

Objects of 'Circle' class contain instance variables that define the
center and radius of a circle.  The class also defines methods for
drawing circles on X displays.

The methods defined in this class can render circles on any GUI drawable
surface.  To work with the pane buffering mechanism, however,
'X11CanvasPane' class also defines drawing methods.  *Note
X11CanvasPane::.

Circle drawing methods also require an interior color argument.  This is
the name of the color within the circle.  To give the appearance of
drawing just the circle's rim, a program can set the interior color to
the window's background color.  If the fill argument is TRUE, then the
circle is filled with the rim color.  If the fill argument is FALSE, the
width and color of the rim are determined by the pen object used to draw
the circle, and the color inside the circle is determined by the
interior color argument.


     int main () {
       X11Pane new xPane;
       InputEvent new e;
       X11PaneDispatcher new xTopLevelPane;
       X11CanvasPane new xCanvasPane;
       Application new paneApp;
       Circle new inner;
       Circle new outer;
       Circle new middle;
       Pen new innerPen;
       Pen new middlePen;
       Pen new outerPen;
       String new bgColor;

       paneApp enableExceptionTrace;
       paneApp installExitHandlerBasic;

       bgColor = "white";

       xPane initialize 10, 10, 300, 300;
       xTopLevelPane attachTo xPane;
       xCanvasPane attachTo xTopLevelPane;
       xPane map;
       xPane raiseWindow;
       xPane openEventStream;
       xPane clearWindow;
       xCanvasPane background bgColor;

       inner center x = 150;
       inner center y = 150;
       inner radius = 30;

       innerPen colorName = "navy";
       innerPen width = 10;

       middle center x = 150;
       middle center y = 150;
       middle radius = 40;

       middlePen colorName = "blue";
       middlePen width = 10;

       outer center x = 150;
       outer center y = 150;
       outer radius = 50;

       outerPen colorName = "sky blue";
       outerPen width = 10;

       xCanvasPane pen width = 1;
       xCanvasPane pen colorName = "black";

       xCanvasPane drawCircle outer, outerPen, FALSE, bgColor;
       xCanvasPane drawCircle middle, middlePen, FALSE, bgColor;
       xCanvasPane drawCircle inner, innerPen, FALSE, bgColor;
       xCanvasPane drawLine 50, 150, 250, 150;
       xCanvasPane drawLine 150, 50, 150, 250;
       xCanvasPane refresh;

       while (TRUE) {
         xPane inputStream queueInput;
         if (xPane inputStream eventPending) {
           e become xPane inputStream inputQueue unshift;
           xPane subPaneNotify e;
           switch (e eventClass value)
             {
             case WINDELETE:
               xPane deleteAndClose;
               exit (0);
               break;
             case EXPOSE:
             case RESIZENOTIFY:
     	  xCanvasPane drawCircle outer, outerPen, TRUE, bgColor;
     	  xCanvasPane drawCircle middle, middlePen, TRUE, bgColor;
     	  xCanvasPane drawCircle inner, innerPen, TRUE, bgColor;
     	  xCanvasPane drawLine 50, 150, 250, 150;
     	  xCanvasPane drawLine 150, 50, 150, 250;
     	  xCanvasPane refresh;
               break;
             default:
               break;
             }
         }
       }
     }


Instance Variables
..................

'center'
     A 'Point' object that defines the 'x,y' coordinates of the circle's
     center.  If drawn on a X display the units represent pixels on the
     display.  *Note Point::.
'radius'
     An 'Integer' that defines the 'Circle' object's radius.

Instance Methods
................

'draw (Pane PANEOBJECT, Integer FILLED, String BGCOLOR)'
'draw (Pane PANEOBJECT, Pen PENOBJECT, Integer FILLED, String BGCOLOR)'
     Draw the receiver circle on the display.  If a 'Pen' argument is
     given, use the 'Pen' object's color and line width to draw the
     circle.  If a 'Pen' argument is not given use a default 'Pen', and
     fill the interior of the circle with BGCOLOR if FILLED is false.


File: ctalk.info,  Node: Method,  Next: Pane,  Prev: Magnitude,  Up: Classes

'Method' Class
--------------

The 'Method' class provides a virtual mechanism for objects to maintain
references to methods and also to call the methods.

A 'Method' instance variables can contain all of the data of an actual
method.  Much of the method's instance data is used only by the Ctalk
front end, and the instance data may or may not be needed at run time
when a 'Method' object is created or used.  This class defines the
instance variables anyway in case a program needs them.

Note that defining a 'Method' object does not include the method
receiver's class library.  The program must already have included a
method's receiver class, either by constructing an object of that class,
or by including the class with the 'require' keyword.

Note also that, in this version, 'Method' object calls are only tested
with a receiver, so you may want to use a virtual method as part of an
expression, you might want to write a wrapper method for it, as in this
example.  The 'methodObjectMessage' method is defined in class 'Object'.
*Note Object::.
     String instanceMethod selfConcat (String __arg) {
       self = self + __arg;
       return NULL;
     }

     int main () {
       Method new m;
       String new s;
       Exception new e;

       s = "Hello,";

       m definedInstanceMethod "String", "selfConcat";
       m withArg " world!";
       s methodObjectMessage m; /* methodObjectMessage is defined */
                                /* in Object class.               */
       if (e pending) {
         e handle;
       } else {
         printf ("%s\n", s);
       }
     }

Instance Variables
------------------

'methodName'
     A 'String' object that contains the method's name.
'methodSelector'
     A 'String' object that contains the name of the method's selector.
'returnClass'
     A 'String' object that contains the name of the method's return
     class.
'rcvrClassObject'
     A 'Symbol' that refers to the method's receiver class object.
'methodFn'
     A 'Symbol' that contains the address of the method's function call.
'methodSource'
     A 'String' that contains the method's source code.
'methodParameters'
     A 'List' that contains the method's paramter definitions.
'nParams'
     An 'Integer' that contains the number of parameters the method
     requires.
'varargs'
     An 'Integer' that is either 'TRUE' or 'FALSE' depending on whether
     the method takes a variable number of arguments.
'nArgs'
     An 'Integer' that contains the number of arguments the method is
     called with.
'errorLine'
     An 'Integer' that contains the first line of the method in a class
     library or program input.
'errorColumn'
     An 'Integer' that contains the first column of the method in a
     class library or program input.
'argFrameTop'
     An 'Integer' that contains the stack index of the method's first
     argument.
'rcvrFrameTop'
     An 'Integer' that contains the stack index of the method's
     receiver.
'imported'
     An 'Integer' that is either 'TRUE' or 'FALSE' depending on whether
     the method is imported from a class library.
'queued'
     An 'Integer' that is either 'TRUE' or 'FALSE' depending on whether
     a method is queued for output.
'methodArgs'
     A 'List' of references to the method's arguments.
'localObjects'
     A 'List' of references to the method's local objects.
'userObjects'
     A 'List' of references to objects created during the method's
     execution.
'localCVARs'
     A 'List' of references to the method's local C variables.
'isInitialized'
     A 'Boolean' that is True only if the 'Method' object has been
     initialized to refer to an actual method.  This variable should
     only be set by the methods 'definedInstanceMethod' and
     'definedClassMethod' (in 'Object' class).

Instance Methods
................

'definedClassMethod (String CLASSNAME, String NAME)'
     Initialize the receiver with the class method named by the
     arguments.
'definedInstanceMethod (String CLASSNAME, String NAME)'
     Initialize the receiver with the instance method named by the
     arguments.
'withArg (Object METHOD_ARGUMENT)'
     Define an argument for the receiver method.

     This method normally precedes a 'methodObjectMessage' call.  For
     examples of its use, refer to the 'methodObjectMessage' section.
     *Note methodObjectMessage::.

'setCallbackName (String NAME)'
     Sets the receiver object's name to the name of the callback, which
     is generally set when the program is compiled.  This does not
     change the name of the actual method, only the name by which the
     Method object that represents it is referred to.

     Here is a slightly hypothetical example of the steps that use
     'setCallbackName' to set up a callback method.


          /*
           * 1. In MyClass, the callback here is defined as an instance
           * variable.
           */
          MyClass instanceVariable myCallback Method NULL;

          ...

          /*
           * 2. Also in MyClass, define a method to configure the callback.
           */
          MyClass instanceMethod onEvent (String methodClassName,
                                          String methodName) {
            Method new callbackMethod;

            callbackMethod definedInstanceMethod methodClassName, methodName;

            /* This sets the class and name of callbackMethod to the name
                of the callback instance variable defined above, at the
                start of the class. */
            callbackMethod setCallbackName "myCallback";

            self addInstanceVariable "myCallback", callbackMethod;
          }

          /*
           * 3. In the program's source file, define the callback method
           * itself.
           */
          MyClass instanceMethod callbackMethod (void) {
            _... do something ..._
          }

          _..._

          /*
           * 4. Also in the program's source file, set up the callback
           * method during program initialization.
           */
          int main () {
            MyClass new myProgram;

            _..._

            myProgram onEvent "MyClass", "callbackMethod";

            _..._
          }


     For a working example, refer to the class 'GLXCanvasPane', which
     uses this process to assign callbacks.


File: ctalk.info,  Node: Pane,  Next: ANSITerminalPane,  Prev: Method,  Up: Classes

'Pane' Class
------------

'Pane' is the superclass of all classes that handle graphical displays.

Subclasses need to provide their own constructor and destructor methods
for extra object construction and cleanup.  'Pane' subclasses need to
provide at least a 'paneBuffer' (below) allocated during object creation
and freed during object deletion, unless the subclass is very simple.

Instance Variables
------------------

'children'
     A 'List' of child panes.

'cursor'
     A 'Point' object that contains the X and Y coordinates within the
     pane where text writes will occur.

'mapped'
     An 'Integer.' If 'TRUE,' display the pane when it, or its parent
     pane, receives a 'refresh' message.

'origin'
     A 'Point' object that contains the X and Y coordinates of the upper
     left-hand corner of the pane within the parent pane, or the
     terminal window or display if the pane is the parent pane.

'paneBackingStore'
     A 'Symbol' object that contains the memory address of the pane's
     backing store buffer.  Subclasses should provide constructors that
     allocate this memory, using the '__ctalkCreateWinBuffer' library
     function.  The methods 'map' or 'unmap' handle the task of saving
     and restoring window contents, by calling functions like
     '__ctalkANSITerminalPaneMapWindow' and
     '__ctalkANSITerminalPaneUnMapWindow.' Classes that re-implement
     'map' and 'unmap' need to handle these tasks also.

'paneBuffer'
     A 'Symbol' object that contains the memory address of the pane's
     display buffer.  Subclasses should provide constructors that
     allocate this memory, using the '__ctalkCreateWinBuffer' library
     function.

'size'
     A 'Point' object that contains the width and height of the pane.

Instance Methods
................

'attach (Pane CHILDPANE)'
     Attach CHILDPANE to the receiver.  If mapped, then the child pane
     is displayed the next time the parent pane and its children are
     updated.  If CHILDPANE is an 'ANSITerminalPane' object, the child
     pane inherits the parent's input and output stream handles.

'deletePaneBuffer'
     Deletes the 'paneBuffer' backing store memory that constructors
     should allocate when creating subclass objects.  Subclasses should
     also use this message in destructor or cleanup methods.


File: ctalk.info,  Node: ANSITerminalPane,  Next: ANSIWidgetPane,  Prev: Pane,  Up: Classes

'ANSITerminalPane' Class
------------------------

The 'ANSITerminalPane' class allows applications to write output to
multiple panes or windows on ANSI terminals, consoles and 'xterm's.

Printing output to a pane does not immediately update the display;
instead, the pane's contents are updated, and the pane is displayed with
the 'refresh' message.

The 'ANSITerminalPane' class supports the display multiple panes.  Each
pane is a child of the initial, or parent, pane.  Child panes attached
to the parent pane (with the 'Pane' : 'attach' method) inherit the input
and output streams of the parent pane.

The 'map' configures a child pane for display on top of its parent pane,
and the child pane is displayed on top of the parent pane at the next
'refresh' message.

Coordinates and dimensions are numbered from 1,1, which is the upper
left-hand corner of a terminal or a content region.

'ANSITerminalPanes' support bold, blinking, reverse, and underline text
attributes for its contents.  Some attributes, like blinking and
underlined text, or foreground and background colors, are not
universally supported.

The program listing shows how to display parent and child
'ANSITerminalPane' objects.
     int main () {
       ANSITerminalPane new parentPane;
       ANSITerminalPane new childPane;

       /*
        *  Use openOn with the terminal device
        *  to open a remote serial terminal.
        */
     /*   parentPane paneStream openOn "/dev/ttya"; */
       parentPane initialize 1, 1, 79, 24;
       parentPane withShadow;
       parentPane withBorder;
       parentPane refresh;

       parentPane gotoXY 29, 10;
       parentPane printOn "Parent Pane";
       parentPane gotoXY 25, 11;
       parentPane printOn "Please press [Enter].";
       parentPane refresh;

       getchar ();  /* Actual apps should use getCh, etc. */

       childPane initialize 10, 10, 40, 10;
       childPane withShadow;
       childPane withBorder;
       childPane boldOnOff;
       parentPane map childPane;
       parentPane attach childPane;

       childPane gotoXY 13, 2;
       childPane printOn "Child Pane";
       childPane gotoXY 10, 3;
       childPane printOn "Please press [Enter].";

       parentPane refresh;

       getchar ();

       parentPane unmap childPane;

       parentPane refresh;

       parentPane paneStream closeStream;

       childPane delete;
       parentPane delete;
     }

Instance Variables
------------------

'paneStream'
     An 'ANSITerminalStream' object containing the input and output
     channels and parameters for the pane and its child panes.  When
     created with 'new', initializes input and output to the terminal's
     standard input and standard output file handles.  Communication
     settings, including TTY settings, can be set with methods from the
     'ANSITerminalStream' class.  *Note ANSITerminalStream::.

'shadow'
     If 'TRUE,' draw a shadow beneath the pane.  The shadow is drawn
     over the background window and is not part of the pane's content
     region.

'border'
     If 'TRUE,' draw a border around the edges of the pane.  The border
     is within the pane's content region, and it can objscure text
     beneath it.

'parentOrigin'
     A 'Point' object containing the X and Y coordinates of the parent
     pane's origin.

'parentClip'
     A 'Point' object containing the X and Y dimensions of the parent
     pane's content area.

Instance Methods
................

'blinkOnOff (void)'
     Toggle the pane's blinking graphics attribute; if enabled, display
     blinking text; if disabled, display normal text.  Blinking text is
     not supported on all terminals.

'boldOnOff (void)'
     Toggle the pane's bold graphics attribute; if enabled, display bold
     text; if disabled, display normal text.

'childRefresh (void)'
     Refresh the receiver, a child pane.  This method is called by
     'refresh' for each of a parent pane's children.

'cursorPos (int X, intY)'
     Position the software cursor at coordinates X, Y within the pane's
     content area.  This method is a synonym for 'gotoXY,' below.

'delete'
     The class destructor.  This method performs the extra cleanup that
     the 'ANSITerminalPane' class requires.

'gotoXY (int X, intY)'
     Position the software cursor at coordinates X, Y within the pane's
     content area.

'initialize (int X_ORG, int Y_ORG, int X_SIZE, int Y_SIZE)'
     Initialize the receiver pane's coordinate instance variables, and
     screen buffers.

'map (ANSITerminalPane __CHILD)'
     Enable the display of a child pane, and buffer any screen contents.
     The receiver should be a pane that completely encloses the child
     pane's content region and shadow if any.  The pane is displayed
     when the parent pane receives a 'refresh' message.

'new (char *__PANENAME)'
     Create a new 'ANSITerminalPane' object.  If more than one label is
     given in the argument list, create new 'ANSITerminalPane' objects
     with those names.  This method also creates and initializes the
     'paneStream' (class 'ANSITerminalStream') instance variable.  *Note
     ANSITerminalStream::.

'printOn (char *__FMT, ...)'
     Print the arguments to the pane's content area at the software
     cursor position.  The output is displayed after the receiver pane
     receives a 'refresh' message.

'putCharXY (intX, intY, charC)'
     Put character C at coordinates X,Y of the pane's content area.  The
     character is displayed immediately using the pane's current
     graphics mode.

'refresh (void)'
     Display the receiver pane content and decorations like borders and
     shadows on the screen.  This method also calls 'childRefresh' for
     each child pane that is attached (with 'attach', class 'Pane') to
     the receiver pane.  *Note Pane::.

'resetGraphics (void)'
     Reset the pane's graphics attributes to normal text; i.e., bold,
     underline, reverse, and blink attributes are turned off.

'reverseOnOff (void)'
     Toggle the pane's reverse graphics attribute; if enabled, display
     text in inverse video; if disabled, display normal text.

'terminalHeight'
     Returns an 'Integer' with the terminal's height in character rows.

     _Note:_ If an operating system has a terminal interface that Ctalk
     doesn't know about, then the method returns 0.

'terminalWidth'
     Returns an 'Integer' with the terminal's width in character
     columns.

     See the note about terminal compatibility in the 'terminalHeight'
     entry, above.

'underlineOnOff (void)'
     Toggle the pane's underline graphics attribute; if enabled, display
     text underlined; if disabled, display normal text.  Underlined text
     is not supported on all terminals.

'unmap (ANSITerminalPane __CHILD)'
     Hide a child pane, and restore any screen contents that were
     obscured when the child pane was displayed.  The child pane is
     withdrawn when the parent pane receives the next 'refresh' message.

'withBorder (void)'
     Enable the display of a border around the edges of the pane's
     content area, using ANSI line drawing characters.  The border is
     within the pane's content area and can obscure text at the edges of
     the pane.

'withShadow (void)'
     Enable the display of a shadow underneath the pane.  The shadow is
     outside of the pane's content area, and should be within the
     clipping area of the parent pane.


File: ctalk.info,  Node: ANSIWidgetPane,  Next: ANSIButtonPane,  Prev: ANSITerminalPane,  Up: Classes

'ANSIWidgetPane' Class
----------------------

'ANSIWidgetPane' contains methods and instance variables that are useful
when creating widgets, which are made up of one or more pane objects for
display on ANSI terminals.

Widgets should be designed so they can be displayed either independently
or above a main pane object.  That means a widget class needs to provide
its own methods for rendering the widget, handling input, returning the
input to the application program, and cleaning up if necessary.

The 'ANSIWidgetPane' class provides basic methods for these tasks, but
subclasses probably will need to implement their own versions of these
methods.  For example, the 'ANSITextEntryPane' class contains its own
'handleInput' method.

Or, for example, a subclass can provide a 'withdraw' method, as in this
method from 'ANSITextEntryPane', which unmaps the widget pane if it was
popped up over another pane.  *Note ANSITextEntryPane::.
     ANSIWidgetPane instanceMethod withdraw (void) {
       if (self parentPane) {
         self unmap;
       } else {
         self paneStream clear;
       }
       return NULL;
     }

A Note About Using Widgets with Serial Terminals.
.................................................

The 'ANSIWidgetPane' classes do not, at this time, provide any methods
for setting terminal parameters for a widget and all subpanes.  That
means applications must see the terminal parameters of each subwidget,
and there does not yet exist a general mechanism for handling the input
and output of entire sets of widgets.  However, classes can always
implement convenience methods if necessary.  For an example, see the
'ANSIMessageBoxPane' section.  *Note ANSIMessageBoxPane::.

Instance Variables
------------------

'hasFocus'
     An 'Integer' that is either 'TRUE' or 'FALSE' depending on whether
     the subwidget has the input focus.  Methods should set and check
     the 'isInputPane' instance variable, below, to make sure that a
     subwidget's class accepts user input.

'isInputPane'
     An 'Integer' that is either 'TRUE' or 'FALSE' depending on whether
     the pane can take the input focus.

'paneID'
     An 'Integer' that contains an identifier of a widget pane or
     subpane.

'parentPane'
     A 'Key' object that contains the address of a parent pane, if the
     widget is displayed over a normal pane.  If this variable is set,
     then the widget needs to map and unmap itself from the parent pane
     as with a normal child pane.

'titleString'
     An optional 'String' object that can be displayed as the widget's
     title.

'withdraw'
     Delete the receiver from the display, by clearing the display if
     the widget is displayed independently, or by unmapping it from a
     parent widget.

Instance Methods
................

'addBuffer (Integer WIDTH, Integer HEIGHT,'
     'Integer' CELLSIZE) A convenience method that creates the receiver
     pane's buffers with the width, height and character cell size given
     as the arguments.  The CELLSIZE argument should almost always be
     '1'.  If the pane has buffers created previously by another method,
     'addBuffer' deletes the old buffers first.

'handleInput'
     Process 'InputEvent' objects from the receiver's 'paneStream' input
     handle.  This 'handleInput' definition provides only basic
     functionality.  Subclasses should re-implement this method with the
     additional functions that the widget needs.

'map (void)'
     Maps the receiver widget pane over another pane that was defined by
     a previous 'parent' message (below).

'mapSubWidget (ANSIWidgetPane SUBPANE)'
     Maps the receiver widget pane over another pane that was defined by
     a previous 'parent' message (below), and sets the SUBPANE's
     'mapped' instance variable to 'TRUE', and adds SUBWIDGETPANE, to
     the parent pane's 'children' list.  SUBPANE may be any subclass of
     'ANSIWidgetPane'.

'new (PANENAME1, PANENAME2, ... PANENAMEN;)'
     Create one or more new 'ANSIWidgetPane' objects.  The object is
     similar to an 'ANSITerminalPane' object, but it contains the
     additional instance variables listed in the previous section.  This
     method also relies on the 'ANSITerminalPane' methods 'withShadow'
     and 'withBorder', and the 'ANSITerminalStream' method
     'openInputQueue'.

'parent (ANSITerminalPane PARENTPANEOBJECT)'
     Sets the receiver's 'parentPane' instance variable to the main
     'ANSITerminalPane' (or subclass) object that the receiver is to be
     mapped over.  This method also provides the subWidget with copies
     of the parent's input and output stream handles.

'title (String TITLESTRING)'
     Set the receiver's title string to the argument.

'unmap (void)'
     Unmaps the receiver from its parent pane.  Used after previous
     'parent' and 'map' messages (above).


File: ctalk.info,  Node: ANSIButtonPane,  Next: ANSILabelPane,  Prev: ANSIWidgetPane,  Up: Classes

'ANSIButtonPane' Class
----------------------

'ANSIButtonPane' objects represent pushbutton widgets.  Generally, they
are sub-panes of other widget classes.  For program examples, see *Note
ANSIMessageBoxPane::, and the methods in the 'ANSIButtonPane' and
'ANSIMessageBoxPane' class libraries.

Instance Variables
------------------

'buttonText'
     The text that will appear within the button.

'outputBuffer'
     The buffer that contains the ANSIButtonPane's return text.
     Normally, the ANSIButtonPane object is drawn by a parent widget,
     which uses its 'handleInput' and 'show' methods to retrieve the
     button's result.

     In cases where the ANSIButtonPane object is displayed on its own
     and uses the ANSIButtonPane 'handleInput' and 'show' methods listed
     in the next section, this variable contains an empty string if the
     user presses 'Escape', or the button text if the user presses
     'Return', which is returned by the 'show' method, below.

Instance Methods
................

'focusHighlightOnOff'
     Toggle the button's highlight.

'handleInput (void)'
     Wait for input from the receiver's 'paneStream' object.  Withdraws
     the receiver if the the user types an escape ('0x1b') or carraige
     return ('0x0d') character, or the 'paneStream' object receives
     these characters from another input source.

     The 'paneStream' instance variable (which is declared in
     'ANSITerminalPane' class), contains a reference to an
     'ANSITerminalStream' object.  *Note ANSITerminalStream::.

     This method sets the value of the 'outputBuffer' instance variable,
     as described above.

'new (BUTTON1_NAME, BUTTON2_NAME, ...;)'
     Create one or more new 'ANSIButtonPane' object, with border and
     shadow decorations, for each name given in the argument list.  The
     buttons' exact sizes are determined by the 'withText' method,
     below.

'show (Integer X_ORIGIN, Integer Y_ORIGIN)'
     Display the button or map it to a parent widget.  The X_ORIGIN and
     Y_ORIGIN are relative to the upper left of the display if the
     button is displayed independently, or relative to the upper
     left-hand corner of a parent pane.

     This method returns the 'outputBuffer' instance variable, which
     contains the result of input from the user or another source, as
     described above.

'withText (String BUTTON_TEXT)'
     Set the text that will appear inside the button.  The method
     adjusts the button dimensions to fit the text.


File: ctalk.info,  Node: ANSILabelPane,  Next: ANSIListBoxPane,  Prev: ANSIButtonPane,  Up: Classes

'ANSILabelPane' Class
---------------------

The 'ANSILabelPane' class draws text labels on a terminal, with or
without border and shadow decorations, and with the graphics attributes
provided by 'ANSITerminalPane' class.  *Note ANSITerminalPane::.

The default is to draw a single-line or multi-line label in a pane with
a border and drop shadow.  When drawing multi-line labels, it is
necessary to give the pane's dimensions to the 'appendLine' method,
below.

To draw a single-line label in reverse video, without any decorations
and large enough to contain only the text, use a routine like the
following.


       ANSILabelPane new labelBox;

       labelBox borderLess = TRUE;   /* The decorations are specified with */
       labelBox border = FALSE;      /* instance variables.                */
       labelBox shadow = FALSE;
       labelBox reverseOnOff;        /* Defined in ANSITerminalPane class. */

       labelBox appendLine "LabelBox Text", 20, 0;


Note that when creating pane buffers, Ctalk numbers the lines from zero,
so it is safe to specify a pane's height as '0'.

When drawing a label alone, pressing Escape or Enter withdraws the label
from the display.

Instance Variables
------------------

'borderLess'
     Specify that the label not contain extra space around the edges for
     a border.

'text'
     nA 'List' containing the label text, one item per line of text.

'viewHeight'
     An 'Integer' that contains the height of the label's viewable area
     in character rows.

'viewWidth'
     An 'Integer' that contains the width of the label's viewable area
     in character columns.

Instance Methods
................

'appendLine (String TEXT)'
'appendLine (String TEXT, Integer WIDTH, Integer HEIGHT)'
     Add a line of text to the label's contents.  If given with a width
     and height, specify the size of the label.  Otherwise, the label is
     drawn large enough to display the contents.

     If the label contains multiple lines of text, then the dimensions
     given (or calculated) for the last line determine the size of the
     label.

'cleanup (void)'
     Delete the buffers associated with the pane object.

'display (Integer X, Integer Y)'
     Display the pane at X,Y on the display or parent pane.  Unlike
     'show', below, does not wait for user input.

'handleInput (void)'
     Process input for the pane.  This method is normally called by the
     'Show' method, below.  When the pane is displayed by itself,
     pressing Escape or Enter returns from the method, and the 'Show'
     method withdraws the pane from the display.

'new (LABEL1, LABEL2, LABEL3,...;)'
     Create new 'ANSILabelPane' objects for each member of the argument
     list.  The arguments specify the names of the new object.

'refresh (void)'
     Draw the pane's contents on the terminal.

'show (Integer X, Integer Y)'
     Display the pane at the position X, Y on the terminal.  This method
     also calls the 'handleInput' method, above, and waits for the
     user's input before returning.

'sizePane (Integer WIDTH, Integer HEIGHT)'
     Set the size of the pane object and its buffers.  This method is
     normally called by the 'appendLine' method, above.


File: ctalk.info,  Node: ANSIListBoxPane,  Next: ANSIMessageBoxPane,  Prev: ANSILabelPane,  Up: Classes

'ANSIListBoxPane' Class
-----------------------

An 'ANSIListBoxPane' object displays a list of items, and allows the
user to select one of the items in the list by using the cursor motion
keys.

Each item in the list is an 'ANSILabelPane'.  To modify the appearance
of the items, refer to the 'ANSILabelPane' class.  *Note
ANSILabelPane::.

After exiting by pressing Escape or Enter, a program can retrieve the
text of the selected item.

Here is a simple program that displays a list of items, then prints the
selected item's text before exiting.


     int main () {
       ANSIListBoxPane new listBox;

       listBox appendLine "Item 1";
       listBox appendLine "Item 2";
       listBox appendLine "Item 3";
       listBox appendLine "Item 4";
       listBox appendLine "Item 5";

       listBox show 2, 2;   // Waits for the user to press Escape or Enter
                            // before returning.

       printf ("\nYou selected %s.\n", listBox selectedText);

       listBox cleanup;
     }


Instance Variables
------------------

'items'
     A 'List' of 'ANSILabelPane' items that contain the text of the list
     selections.

'oldSelectedContent'
     An 'ANSILabelPane' object that contains the content of the previous
     selection.  Used for erasing the previous selection before drawing
     the new selection.

'prevSelectedLine'
     An 'Integer' that contains the index of the previously selected
     item.  The 'ANSIListBoxPane' indexes items starting with 1 for the
     first item.

'selectedContent'
     An 'ANSILabelPane' object that contains the contents of the
     currently selected item.

'selectedLine'
     An 'Integer' that contains the index, counting from 1, of the
     currently selected item.

'totalLines'
     An 'Integer' that contains the number of items to be displayed.

Instance Methods
................

'appendLine (String TEXT)'
     Creates a new 'ANSILabelBox' object with the contents TEXT, then
     adds the 'ANSILabelBox' to the 'items' list.

'cleanup (void)'
     Deletes the buffers associated with the 'ANSIListBoxPane' object
     and its items.

'handleInput (void)'
     Waits for input from the user and processes it.  Pressing a cursor
     key or an Emacs or vi next/previous line key shifts the selection.
     Pressing Escape or Enter causes the method to return.

'new (LISTPANE1, LISTPANE2, ...;)'
     The 'ANSIListBoxPane' constructor.  The argument contains the names
     of one or more new 'ANSIListBoxPane' objects.

'refresh (void)'
     Draw the list pane and items on the terminal.

'refreshSelectionFirst (void)'
     Highlight the initially selected item.  Should only be called after
     a call to 'refresh'.

'refreshSelection (void)'
     Redraw the highlightd selected item, and un-highlight the
     previously selected item.  Should only be called after a call to
     'selectNext' or 'selectPrev'

'selectedText (void)'
     Returns the text of the selected item as a 'String' object.

'selectNext (void)'
'selectPrev (void)'
     Select the next or previous item of the list box's contents.  Also
     saves the index and contents of the previously selected item.


File: ctalk.info,  Node: ANSIMessageBoxPane,  Next: ANSIProgressBarPane,  Prev: ANSIListBoxPane,  Up: Classes

'ANSIMessageBoxPane' Class
--------------------------

'ANSIMessageBox' objects present users with a pop-up dialog that
contains a messages, and an 'ANSIButtonPane' 'Ok' button to close the
widget.

Here is a simple example.
     int main () {
       ANSIMessageBoxPane new messageBox;
       messageBox withText "Hello, world!";
       messageBox show 10, 10;
       messageBox cleanup;
     }

Subclasses can always implement convenience methods to set input and
output stream parameters if necessary.

You should also take care of the differences between xterms, consoles,
and serial terminals.  In particular, even though the 'parent' method
(class 'ANSIWidgetPane') *Note ANSITerminalStream::.

Instance Variables
------------------

'okButton'
     An 'ANSIButtonPane' object that contains the pane's 'Ok' button.
'messageText'
     A 'String' object that contains the text that appears in the
     message box.

Instance Methods
................

'cleanup (void)'
     Delete the receiver's extra data before deletion.  The receiver
     objects themselves are deleted normally.

'new (String MESSAGE_BOX_NAME)'
     Create one or more new 'ANSIMessageBox' objects.

'withText (String TEXT)'
     The argument is the text that will appear in the message box.  The
     method adjusts the pane's dimensions to fit the text.

'show (int X_ORIGIN, int Y_ORIGIN)'
     Display the receiver at X_ORIGIN, Y_ORIGIN.  If the receiver is
     displayed independently, the origin is relative to the upper
     left-hand corner of the display, or if the receiver is to be
     displayed over a parent pane, it is mapped to the parent pane with
     the origin relative the the parent pane's upper left-hand corner.


File: ctalk.info,  Node: ANSIProgressBarPane,  Next: ANSIScrollingListBoxPane,  Prev: ANSIMessageBoxPane,  Up: Classes

'ANSIProgressBarPane' Class
---------------------------

An 'ANSIProgressBarPane' object displays a horizontal progress bar on a
serial terminal or xterm.  If you display a progress bar pane
independently (using the 'show' method), you can close the pane by
pressing 'Enter' or 'Esc'.

The 'progress' instance variable specifies how much of the progress bar
is highlighted.  It's better to use the 'percent' method, though, which
calculates the progress bar's hightlighted area and sets the percent
legend.

As with all other ANSI pane widgets, you either display or omit the
border and shadow decorations.  Progress bars can also display a title
string, which you can set using the 'title' method, implemented in
'ANSIWidgetPane' class.  *Note ANSIWidgetPane::.

Here is an example program that displays an 'ANSIProgressBarPane'
object.


     int main () {
       ANSIProgressBarPane new progressBar;


       progressBar shadow = 1;
       progressBar border = 1;

       progressBar title "Progress";

       progressBar percent 65.0;

       progressBar show 2, 2;

       progressBar cleanup;
     }


You can set the size of a progres bar using the 'dimension' method.  In
that case, setting the progress bar using the 'percent' method adjusts
for the pane's width.  The widget's display area is always drawn as one
character row tall, however.

If you display the progress bar as a widget in an application, then you
can update the progress bar on the screen using the 'display' method
instead of 'show', because 'display' does not wait for user input before
returning.

Instance Variables
------------------

'pctLabelMargin'
     An 'Integer' that specifies where to draw the percent legend in the
     progress bar's content area.

'percentInt'
     An 'Integer' that specifies percent of the progress bar's internal
     area that is highlighted.  Setting this using the 'percent' method,
     below, also adjusts the hightlight's dimensions for the progress
     bar's width.  This variable is also used to display the text of the
     percent logo in the widget's content area.

'progress'
     An 'Integer' that specifies the number of character columns to
     highlight in the progress bar's viewable area.

'viewHeight'
     An 'Integer' that specifies the height in character rows of the
     widget's viewable area.  The progress bar highlight is always drawn
     as one character row in height.

'viewWidth'
     An 'Integer' that specifies the width in character rows of the
     widget's viewable area.

Instance Methods
................

'dimension (Integer WIDTH, Integer HEIGHT)'
     Set the width and height of the pane in character columns.

'show (Integer X, Integer Y)'
     Display the pane at row and column X,Y, and return immediately.

'handleInput (void)'
     Wait for the user's input.  Pressing 'Esc' or 'Enter' closes the
     pane.  and returns.

'new (String PANENAME)'
     Create new 'ANSIProgressBarPane' objects, one for each label given
     in the method's argument list.

'percent (Float PERCENT)'
     Set the percent of the progress bar's highlighted area.  This
     method adjusts for the width of the progress bar and sets the text
     for the percent logo.

'refresh (void)'
     Redraw the progress bar on the terminal.

'show (Integer X, Integer Y)'
     Display the pane at row and column X,Y, and wait for the user's
     input.


File: ctalk.info,  Node: ANSIScrollingListBoxPane,  Next: ANSIScrollPane,  Prev: ANSIProgressBarPane,  Up: Classes

'ANSIScrollingListBoxPane' Class
--------------------------------

An 'ANSIScrollingListBoxPane' object is similar to an 'ANSIListBoxPane';
it displays a list of items in a text mode terminal or 'xterm' and
allows the user to use the terminal's 'Cursor-Up'/'Cursor-Down' keys,
Emacs compatible 'C-n'/'C-p' keys, or vi compatible 'j'/'k' keys to
select an item in the list.

Pressing 'Enter' or 'Escape' closes the widget.  An application can
retrieve the selected item's text with the 'selectedText' method, which
is described below.

In addition, an 'ANSIScrollingListBoxPane' object can scroll the list if
the number of items is greater than the height of the widget's viewable
area, in order to keep the selected item visible.  The widget also
displays a read-only scroll bar that indicates which portion of the list
is visible.


     int main () {
       ANSIScrollingListBoxPane new sListBox;

       sListBox enableExceptionTrace;

       sListBox withShadow;
       sListBox noBorder;    /* Not all terminals support line
                                drawing characters.            */

       sListBox appendLine "Item 1";
       sListBox appendLine "Item 2";
       sListBox appendLine "Item 3";
       sListBox appendLine "Item 4";
       sListBox appendLine "Item 5";
       sListBox appendLine "Item 6";
       sListBox appendLine "Item 7";
       sListBox appendLine "Item 8";
       sListBox appendLine "Item 9";
       sListBox appendLine "Item 10";
       sListBox appendLine "Item 11";
       sListBox appendLine "Item 12";
       sListBox appendLine "Item 13";
       sListBox appendLine "Item 14";
       sListBox appendLine "Item 15";
       sListBox appendLine "Item 16";
       sListBox appendLine "Item 17";
       sListBox appendLine "Item 18";
       sListBox appendLine "Item 19";
       sListBox appendLine "Item 20";
       sListBox appendLine "Item 21";
       sListBox appendLine "Item 22";
       sListBox appendLine "Item 23";
       sListBox appendLine "Item 24";
       sListBox appendLine "Item 25";
       sListBox appendLine "Item 26";
       sListBox appendLine "Item 27";
       sListBox appendLine "Item 28";
       sListBox appendLine "Item 29";
       sListBox appendLine "Item 30";
       sListBox appendLine "Item 31";
       sListBox appendLine "Item 32";

       sListBox show 5, 6;

       printf ("%s\n", sListBox selectedText);

       sListBox cleanup;
     }


Instance Variables
------------------

'items'
     A 'List' of the items that the receiver displays.  *Note List::.

'oldSelectedContent'
     An 'ANSILabelPane' object that contains previously selected item.
     *Note ANSILabelPane::.

'prevSelectedLine'
     An 'Integer' that contains the index of the previously selected
     item.  *Note Integer::.

'selectedContent'
     An 'ANSIScrollPane' object that draws the widget's scroll bar.
     *Note ANSIScrollPane::.

'selectedContent'
     An 'ANSILabelPane' object that contains selected item.  *Note
     ANSILabelPane::.

'selectedLine'
     An 'Integer' that contains the index of the selected item.  *Note
     Integer::.

'totalLines'
     An 'Integer' that contains total number of list items.  *Note
     Integer::.

'viewStartLine'
     An 'Integer' that specifies which item begins the list's viewable
     portion.  *Note Integer::.

'viewHeight'
     An 'Integer' that contains the height in text lines of the widget's
     visible area.  *Note Integer::.

'viewWidth'
     An 'Integer' that contains the height in character columns of the
     widget's visible area.  *Note Integer::.

Instance Methods
................

'appendLine (String ITEM_TEXT)'
     Adds ITEM_TEXT to the list's contents.

'cleanup (void)'
     Deletes the display buffers associated with the list box and scroll
     bar.

'handleInput (void)'
     Waits for the user's input.  Changes the selected item when the
     user cursors through the list using the terminal's cursor keys,
     Emacs compatible 'C-n'/'C-p', or vi compatible 'j'/'k'.  Restores
     the terminal and returns when the user presses 'Enter' or 'Escape'.

'noBorder (void)'
'withBorder (void)'
     Set or unset the border for the main scroll pane and the scroll
     bar.  These methods are equivalent to the following expressions.


            /* To display borders. */
            listPane border = 1;
            listPane scrollBar border = 1;

            /* To hide the borders. */
            listPane border = 0;
            listPane scrollBar border = 0;


     Note that not all terninals support line drawing characters.

'noBorder (void)'
'withBorder (void)'
     Set or unset the shadow for the main scroll pane and the scroll
     bar.  The methods are a shortcut for these statements.


            /* To display shadows. */
            listPane shadow = 1;
            listPane scrollBar shadow = 1;

            /* To hide the shadows. */
            listPane shadow = 0;
            listPane scrollBar shadow = 0;


'new (String OBJECT_NAME)'
     Constructs a new 'ANSIScrollingListBoxPane' for each label given in
     the argument list.  Sets the dimensions for the viewable areas,
     decorations, and creates the display buffers for the list box and
     the scroll bar.

'refresh (void)'
     Redraws the list box.

'refreshSelection (void)'
     Un-highlights the previously selected item and highlights the
     currently selected item.

'refreshSelectionFirst (void)'
     Highlights the currently selected item, which is normally the first
     item in the list when first drawing the widget-i.e., when there is
     no previously selected item.

'scrollThumbSize (void)'
     Sets the 'scrollBar' instance variable's 'thumbHeight' instance
     variable based on which portion of the list is visible.  *Note
     ANSIScrollPane::.

'scrollThumbStart (void)'
     Sets the 'scrollBar' instance variable's 'thumbStartLine' instance
     variable based on which portion of the list is visible.  *Note
     ANSIScrollPane::.

'selectedText (void)'
     Returns a 'String' containing the text of the selected item.  *Note
     String::.

'selectNext (void)'
     Sets the next 'selectedLine' and 'selectedContent' instance
     variables to the next item in the list.  If the selected item is
     already the last item in the list, the method does nothing.

'selectPrev (void)'
     Sets the next 'selectedLine' and 'selectedContent' instance
     variables to the previous item in the list.  If the selected item
     is already the first item in the list, the method does nothing.

'show (Integer X, Integer Y)'
     Displays the widget an character row and column X,Y on the terminal
     display, then calls the 'handleInput' method to process user input.

