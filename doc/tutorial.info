This is tutorial.info, produced by makeinfo version 6.5 from
tutorial.texi.

INFO-DIR-SECTION Ctalk
START-INFO-DIR-ENTRY
* tutorial: (tutorial).	 Object oriented programming tutorial with Ctalk.
END-INFO-DIR-ENTRY

This file documents Ctalk version 0.0.56.

Copyright (C) 2007-2015, Robert Kiesling

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled, "GNU
Free Documentation License."


File: tutorial.info,  Node: Top,  Prev: (dir),  Up: (dir)

Ctalk Tutorial
**************

This document is an introduction and tutorial to the Ctalk programming
language.  The tutorial assumes that you have at least a basic knowledge
of the C programming language and discusses topics in object oriented
programming in the second section, and when the principles apply to a
specific example program or language feature.  This manual is organized
approximately into increasing levels of difficulty, and does not
describe all of the Ctalk language's features.  Refer to the 'Ctalk
Language Reference' for a complete guide to the Ctalk language.

* Menu:

* Preface::                 What Ctalk is good at.
* Objects::                 A gentle introduction to objects.
* Hello::                   Hello, world! and other simple programs.
* Basic classes::           How to use objects instead of C variables.
* File input and output::   How to open, close, read, and write files.
* Self and super::          Receivers and classes at run time.
* Collections::             Working with groups of objects.
* Classes::                 Defining and initializing class objects.
* Methods::                 Everything you wanted to know about methods.
* Graphics::                How to write programs that use Panes and windows.
* Debugging::               How to handle errors and debug programs.
* GNU Free Documentation License::    Copying and distributing this manual.
* Index::


File: tutorial.info,  Node: Preface,  Next: Objects,  Prev: Top,  Up: Top

Preface
=======

Ctalk helps you create programs.  The language is object orientated, and
highly extendable and scalable.  With Ctalk, you can include a linked
list in your C program, or perform regular expression searches, or get
user information from a serial terminal, simply by using the language's
class libraries.

You can also use plain old C statements within Ctalk, which allows the
language to perform any task that C can accomplish, while still saving
many hours of design and coding of tasks that programs need to perform
often.

Ctalk shares C's strengths, like the ability to write programs with a
minimal set of keywords and still access C's versatile programming
libraries, and Ctalk adds a set of object oriented rules that help you
modify and extend your code, while leveraging the system's programming
environment at any phase in the program's design.

Then, at some point, if you find that you need to write a list that you
can sort and scan, or a utility that communicates with a USB device, or
a display routine that draws complex text and graphics in a Web browser
or X window, you'll find that Ctalk can handle those tasks, too.

The next chapter describes some of the essentials of object oriented
programming.  Ctalk's syntax is similar to C and includes a few
additions.  The chapter provides a brief description of how Ctalk adds
object oriented language rules to a basic language design and shows how
Ctalk can help extend and adapt the programming environment to your
needs.

If you're already familiar with an object oriented language, the next
section might be familiar to you.  In that case, you can go ahead and
skip to the, "Hello, world!"  program and the following example programs
to get you started.


File: tutorial.info,  Node: Objects,  Next: Hello,  Prev: Preface,  Up: Top

A Brief Introduction to Objects
===============================

In Ctalk, as in all object oriented languages, _objects_ are the pieces
of information that define and implement both code and data.  Look at
the following examples.  They implement the same operations in BASIC, C,
and Ctalk.


     10 let a = 2
     20 let b = a + a
     30 print b


     int a, b;

     a = 2;
     b = a + a;
     printf ("%d\n", b);


     Integer new a;
     Integer new b;

     a = 2;
     b = a + a;
     stdoutStream writeStream b;


The examples look similar, but there is a difference in the object
oriented example.  When a program declares new objects, in this case 'a'
and 'b', Ctalk creates them as members of a _class_.  In this example,
'a' and 'b' are members of the class 'Integer'.

If this were as far a object oriented programming went, these statements
would function exactly the same as their C counterpart, 'int a, b;'

However, classes belong to a library called a _class library._  Class
libraries contain all of the routines of the language, and declarations
of different types of objects.  A class library is organized so that the
most general classes are at the top of the hierarchy, and proceed to
more specialized _subclasses._  Each class may have more than one
subclass.  Ctalk classes each have one _superclass,_ except for the
class 'Object', the topmost class in the class hierarchy.  More on class
hierarchies in a moment.

Methods, Messages, and Receivers
--------------------------------

As the previous section mentioned, classes contain both the
specification of objects and the source code of the routines or
functions that operate with each class.  These routines are called
_methods._

Look at this statement from the example above.


     a = 2;


In this statement, the object 'a' is called the _receiver_ of the
method.  The method is the assignment operator, '='.  The number '2' is
the _argument_ to the method.  When the program tells 'a' to use the
method '=', The '=' character is not simply an operator, it is the name,
or _message_ of a method that the language provides to the receiver,
'a'.  In simple examples, the operation is very similar to using a math
operator or function call.  But the language treats the message as
separate from the operation it describes, which means the message is
extendable to any class that you might want to implement.  We'll
describe this in more detail in a moment.

Polymorphism and Overloading
----------------------------

Each class can have its own implementation of '='.  The class 'String',
for example, can have its own '=' method, which would do exactly what
you'd expect.


     String new myString;

     myString = "Hello, world!";


The next line from the example above,


     b = a + a;


contains two methods, '=' and '+'.  The receiver of '=' is 'b', and the
receiver of '+' is 'a'.  The argument of '=' is the complete expression,
'a + a'.

Programs can do the same with character strings.


     String new myString;

     myString = "Hello, " + "world!";


This is a simple example of a characteristic of computer languages:
_polymorphism._  That means different types of data have a common
interface and are treated the same by the language.  When the '=' and
'+' methods work with different classes of objects, we say that the
methods _overload_ the operators.

Class and Instance Data
-----------------------

In the next line from the example above,


     stdoutStream writeStream b;


the receiver, 'stdoutStream', receives the message 'writeStream' with
the argument 'b'.

The receiver 'stdoutStream' is a _class variable._  There is one
'stdoutStream' for its class, 'WriteFileStream.'  'stdoutStream'
represents the program's standard output.  The argument 'b', however, is
an _instance_ of class 'String', and it contains an _instance variable,_
'value,' which contains the character string itself.  A program can
create as many _instances of a class_ as it needs.

Each instance of a class contains its own data.  For 'Integer' and
'String' objects, the data is simply the 'value' of the object, either
'2' or 'Hello, world!'

Class 'WriteFileStream' objects, however, need to keep track of more
data than a basic type like an 'Integer', data like the permissions of
the file stream, the position in the stream, the type of I/O device, and
the memory address of the stream itself.  This information is contained
in _instance variables._  Each class defines its own set of instance
variables, and each instance of a class has its own copy of them.

Inheritance and Constructors
----------------------------

The methods that create objects, which are generally called 'new,' have
a special status.  They are called _constructors._  It's important to
remember that they're methods, not keywords or operators.

The following two statements look similar, but internally they function
differently.


     String new myString;
     WriteFileStream new myOutput;


Recall from the previous sections that the class hierarchy proceeds from
the more general objects at the top of the hierarchy, to the more
specific subclasses.  Also, instances of class 'WriteFileStream' contain
more instance data than many other classes of objects.

What actually occurs in the above statements is that 'myString' is
created like any other object, with its own 'value' instance variable.
'myOutput', however, uses the 'new' method of its class, which first
creates the basic 'myOutput' object and then adds the additional
instance variables and data that we mentioned above.

So in addition to the 'value' instance variable, which the method 'new'
obtains from the 'Object' class, the object 'myOutput' also contains the
instance variables it needs to manage writing to a file.  This is called
_inheritance._  We say that instances of class 'WriteFileStream' inherit
the 'value' instance variable from the 'Object' class.  Instances of
class 'WriteFileStream' also inherit other instance variables, as
described below.

Here is another example, which shows how classes inherit methods.
Suppose you wanted to create a class that represented positive integers.
You would accomplish this, most likely, by creating a subclass of
'Integer.'


     Integer class PositiveInteger;


Objects of your new class could use the '+' method of the 'Integer'
class.  So you could write:


     PositiveInteger new a;
     PositiveInteger new b;

     a = 2;
     b = a + 2;


Ctalk, if it doesn't find a method for '+' in the 'PositiveInteger'
class, then uses the '+' method of class 'Integer'.

If you wanted to subtract two 'PositiveInteger' objects, however, you
would need to implement the method '-' to insure that the result is also
positive.  The code within that method might look something like the
following.


     if ((b = (a - a)) < 0)
        warning ("Negative result for PositiveInteger.");


The later chapters describe the details of creating your own classes and
methods.

The Class Hierarchy
-------------------

Let's return to the constructor example above.  You should note that the
'WriteFileStream' class does not actually _define_ its instance
variables.


     WriteFileStream new myOutput;


This is because the instance variables necessary for reading from files
(with class 'ReadFileStream' objects) and writing to files (with class
'WriteFileStream' objects) are similar.  Instead, Ctalk defines them in
a _superclass,_ 'FileStream'.

A section of the class hierarchy, showing the instance variables that
each class defines, should help explain this organization.


     Class                  Instance Variables Defined
     -----                  --------------------------
     Object                 <------  value
      Stream
       FileStream           <------  streamMode
                            <------  streamDev
                            <------  streamRdev
                            <------  streamSize
                            <------  streamAtime
                            <------  streamMtime
                            <------  streamCtime
                            <------  streamPos
                            <------  streamErrno
                            <------  streamPath
        ReadFileStream
        WriteFileStream


Self and Super
--------------

Ctalk does have a few keywords.  Two of them are _self_ and _super._
They're mentioned here because they are essential to the creation of new
objects, as well as other tasks.

Both _self_ and _super_ can occur only in methods.  The keyword 'self'
refers to the receiver of the method that 'self' occurs in.  It's
functionally equivalent to the keyword 'this' in C++.

The keyword 'super' refers to the superclass of the method's receiver.
In some cases, it can also refer to the receiver of an enclosing scope.
This tutorial discusses the uses of 'super' later on.

So when a new 'WriteFileStream' object gets its instance variables from
its class definition and the definitions of each of its superclasses,
its 'new' method can use 'super' to refer to a superclass's 'new'
method.  Very often, much of the initialization has already been defined
in the superclass methods, with only a few tasks remaining to be done by
the receiver class's constructor.

It might not be apparent from these simple examples, but the methods and
instance data are closely tied together, and they're independent of the
methods and instance data of other classes.  A simple operation might
turn out to be more complex that it appears at first.  But class
inheritance helps separate and define more general tasks from the tasks
that are specific to a single object.

Classes do not need to be completely separate, however.  A method can
reference some other class's methods or object's instance data if a
program or method needs it.

The 'Ctalk Reference Manual' describes the Ctalk class library, and the
methods and variables, that each class defines.

Ctalk shares the strengths of the C programming language.  Ctalk, like
C, has very few keywords - nearly everything is an object or a method.
The the rules for defining classes are very simple and general.  You can
write any code you like, no matter how system specific, and Ctalk can
integrate the code into its class library.

As a historical note, Ctalk's language syntax and class library
organization are based very closely on the Smalltalk language, one of
the earliest truly object oriented languages.  You can find much
information about Smalltalk and its design in on-line and printed
documents.

But Ctalk is unique in that it lets you program in C when that is more
suitable to a particular chore.  The tutorial assumes that you're fairly
proficient in C. However, if you want to read further about the C
language and object oriented programming, there are many books and
tutorials, on line and in print, that describe these subjects in detail.


File: tutorial.info,  Node: Hello,  Next: Basic classes,  Prev: Objects,  Up: Top

'Hello, world!' and Other Simple Programs
=========================================

Ctalk assumes that you are familiar with the C language, and that you
have an understanding of basic object oriented programming concepts,
which we described in the previous chapter.

This chapter presents a few simple programs that demonstrate how the
Ctalk language works.  Later chapters will describe the more advanced
features of the language in greater detail.

Printing '"Hello, world!"'
==========================

To learn how to write and compile a Ctalk application, this chapter
starts with the usual 'Hello, world!' program.

Here is the 'Hello, world!' program listing.


     int main () {

       String new helloObject;

       helloObject = "\"Hello, world!\"";

       printf ("%s\n", helloObject value);

       exit (0);
     }


Save this listing in a file called 'hello.c.' (It's also in the 'demos'
subdirectory if you have the source code archive.)  Then you can build
'hello.c' with the 'ctcc' command.


     $ ctcc hello.c -o hello


Then, you can run the program with this command, and the program prints
the output.


     $ ./hello
     "Hello, world!"


1 Splitting a Directory Path
============================

Here is another simple program, 'ctpath.c.' You can find the source file
in the 'demos' subdirectory of the Ctalk source code distribution.

This program prints the directory path that you supply as an argument,
one directory to a line.


     int main (int argc, char **argv) {

       String new path;
       Array new paths;
       Integer new nItems, i;
       Character new separator;

       if (argc != 2) {
         printf ("Usage: ctpath <path>\n");
         exit (1);
       }

       path = argv[1];

       separator = '/';

       nItems = path split separator, paths;

       for (i = 0; i < nItems; i = i + 1)
         printf ("%s\n", paths at i);

       exit (0);
     }


Although there is a lot of code for initializing variables and checking
the command line arguments, 'ctpath' does the actual work in three lines
of code.


     nItems = path split separator, paths;

     for (i = 0; i < nItems; i = i + 1)
       printf ("%s\n", paths at i);


The method split (class 'String') splits the string 'path' at each
occurrence of 'separator' and places the result in the array, 'paths.'
The next two lines print each element of the array 'paths' with the
statement, 'paths at i.'

As with the previous example, you can compile the program using the
following commands.


     $ ctcc ctpath.c -o ctpath


When you run the program, the output should look like this, depending on
the directory path you provide on the command line.


     $ ./ctpath /home/users/joe
     home
     users
     joe


If you're not certain of how the arguments to 'main,' 'argc' and 'argv,'
function (they contain the command line, split into individual strings,
and the number of command line strings), then you should go back and
study the C language until you are comfortable with the language.

You might note also the constructor statement in the example above,


     Integer new nItems, i;


This is a shorthand that is specific to constructor methods (i.e., the
methods that are named 'new'): A 'new' method can construct as many
objects of the receiver's class (that is, the class object before
'new'), as there are labels given in the argument list.

The expression above is exactly equivalent to this set of expressions:


     Integer new nItems;
     Integer new i;


So anywhere in this manual that you see one or more expressions that
contain 'new' with the same receiver class, you can use either of the
two forms and achieve the same result.

2 Printing the Time
===================

Here is a program that uses a method to get the local time and store it
in an array.


     Array instanceMethod getTime (void) {

       CTime new timeNow;
       Array new currentLocalTime;

       timeNow utcTime;

       currentLocalTime = timeNow localTime;

       self atPut 0, (currentLocalTime at 2);
       self atPut 1, (currentLocalTime at 1);
       self atPut 2, (currentLocalTime at 0);

       return NULL;
     }

     int main () {

       Array new clockTime;

       clockTime getTime;

       printf ("%02d:%02d:%02d\n", (clockTime at 0), (clockTime at 1), (clockTime at 2));
     }


In the method 'getTime,' 'self' refers to the method's receiver,
'clockTime,' which is declared in 'main.'

The 'localTime' method ('CTime' class), returns an 'Array' that is
filled in by the C library's call to 'localtime(3).' The 'Ctalk Language
Reference' describes how 'localTime' returns time and date information.

Note that in 'main,' the arguments to 'printf' are enclosed in
parentheses, so there is no ambiguity in evaluating the expressions in
each argument.

3 Printing the Time, at a Higher Level
======================================

The 'CalendarTime' class achieves the much the same result as the
'CTime' class, except that it uses named instance variables to store
elements of the current time:


     int main () {
       CalendarTime new ct;

       ct utcTime;
       ct localTime;
       printf ("%02d:%02d:%02d %04d-%02d-%02d\n", ct hours, ct minutes, ct seconds,
     	  (ct year + 1900), ct month, ct dom);
     }


Depending on the needs of the program, you might find this to be more
efficient than dealing with individual 'Array' elements.

4 Opening a X Window
====================

The program 'xhello.c' in the 'demos' subdirectory is too lengthy to
include here, but if you open it in a text editor, it should look at
least a little familiar if you've written programs with the X Window
System.

'xhello.c' performs the basic steps of creating and displaying a window,
and then waiting for input from the keyboard or mouse.

Building the program is similar to the other examples in this chapter.
You need to include the '-x' option when building 'xhello.c', so that
Ctalk links the program with the X Window System libraries, however.


     $ ctcc -x xhello.c -o xhello


And then you can run the program directly.


     $ ./xhello


In brief, whenever you move or resize the window, or another window
uncovers the 'xhello' window, the program redisplays the "Hello, world!"
text in the center of the window.

If you click on the "Close" icon or menu item in the Window's frame
(depending on the type of desktop your system has), the program closes
the window and exits.

With some desktops, you might notice that the message flickers as the
program handles events from the display system.  That's because 'xhello'
responds to a generic set of events so that it works with many different
desktops and window system features and is simple for beginners to
build.

In addition to displaying simple text, Ctalk's classes provide flexible
support of many drawing and user interface capabilities.  That lets
programs handle complex interactions with the window system.  The later
chapters of the tutorial discuss these features and how to write
programs with them.  *Note Graphics::.


File: tutorial.info,  Node: Basic classes,  Next: File input and output,  Prev: Hello,  Up: Top

Basic Classes and Ctalk Statements
==================================

Ctalk is designed to work with C. There are a number of classes that
correspond directly to the basic C data types.

In Ctalk, you can use instances of the classes that are shown in the
table below interchangeably with their C equivalents.
     Ctalk Class         C Type
     -----------         ------
     Array               char **, int **, ...
     Character           char
     Float               float, double
     Integer             int, long int
     LongInteger         long long int
     String              char *

There are a few places that you cannot use objects, like function
parameter declarations or 'struct' members.  You'll also see a lot of
examples that translate data between objects and C variables.  The
manner in which Ctalk translates between the two is a powerful feature
of the language.

'Integer,' 'Character,' 'LongInteger,' and 'Float' Classes
----------------------------------------------------------

Like most object oriented languages, when you declare an object, you're
actually sending a message to a constructor method.  As we mentioned
earlier, the methods that create objects are called _constructors._  And
as with many object oriented languages, you create an object with the
message 'new.'
     Integer new myInt;

Objects of class 'Integer' work exactly the same as C variables of type
'int.' You can use expressions like the following, as though you were
programming in C.
     Integer new myInt;

     myInt = 2;
     printf ("%d\n", myInt + myInt);
With several exceptions, you can use all of the operators that C
integers recognize.  Prefix and postfix operators, like '+,' '-,' '*,'
'&,' and so on, also work as methods.

'Integer' class also defines some methods as the equivalent of these
operators, like 'invert' for '!' and 'bitComp' for '~'.

This example shows how you would use the methods in C statements.
     int i;               /* C variable.   */
     Integer new myInt;   /* Ctalk Object. */

     i = 2;
     myInt = 2;

     /* These two statements are equivalent. */
     printf ("%d\n", !i);
     printf ("%d\n", myInt invert);

     /* These two statements are also equivalent. */
     printf ("%d\n", ~i);
     printf ("%d\n", myInt bitComp);

The same is also true for instances of the 'Character,' 'LongInteger,'
and 'Float' classes.

For instance, you can add and subtract two characters.  This is
sometimes useful for conversions, as in the following examples.
     Character new receiver;
     Character new operand;

     receiver = 'A';
     operand = ' ';

     printf ("%c\n", receiver + operand);
The result is the lower case 'a'.  This has the same effect as:
     Character new receiver;
     receiver = 'A';
     printf ("%c\n", receiver toLower);
Or even:
     printf ("%c\n", 'A' toLower);

To convert a character to uppercase, you can use either '-' or
'toUpper.' Both are implemented by the 'Character' class.
     Character new receiver;
     Character new operand;

     receiver = 'a';
     operand = ' ';

     /* These two statements produce the same result. */
     printf ("%c\n", receiver - operand);
     printf ("%c\n", receiver toUpper);

For completeness, we should note that you can also achieve the same
effect with the bit operators '&', '|', and '^,' although their
application can be a bit more involved.  If you're not certain how the
operators would work, enter the ASCII value of a character in a
programmer's calculator and convert it to base 2.  Then notice the
effect of changing different bits.

For now, we'll just show an example of changing a letter's case - from
lower to upper case, or vice versa.

We do this by XOR'ing the fifth bit of the character value.  (Note that
'2^5' is '32,' the ASCII value of a space (' ') character.)

Here is a simple example of the operation.
     Character new upperCase;
     Character new lowerCase;
     Integer new toggleBit;

     upperCase = 'Z';
     lowerCase = 'z';
     toggleBit = 100000b;


     printf ("%c\n", upperCase ^ toggleBit);
     printf ("%c\n", lowerCase ^ toggleBit);

'String' Class
--------------

As the introduction mentioned, Ctalk overloads many operators.  This is
especially obvious of class 'String.'

This code shows how 'String' class overloads some math operators.
     String new s1;
     String new s2;
     String new helloString;

     /* C's strcpy () would also work here. */
     s1 = "Hello, ";
     s2 = "world!";

     /* And strcat () could perform the same task here. */
     helloString = s1 + s2;

     printf ("The value of \"helloString\" is \"%s\".\n", helloString);

     s1 = "s1";
     s2 = "s2";

     /* Test whether String objects are equal without strcmp (). */
     if (s1 == s2) {
       printf ("The strings s1 and s2 are equal.\n");
     } else {
       printf ("The strings s1 and s2 are not equal.\n");
     }
Briefly, the 'String' instance methods '=,' '==,' and '+' function
similarly to the C library functions 'strcpy(3),' 'strcmp(3),' and
'strcat(3),' respectively.

But these operators can also be overloaded.  For example, the '+' method
behaves like C's 'strcat()' function when the argument is also a
'String' object.  If the argument is a 'Integer', then the '+' method
increments the reference to the receiver 'String' object.  This is
discussed further below.  *Note String_pointer_math::.

Like C, however, instances of 'String' and 'Character' are not
interchangeable.  If you want to use an instance of class 'Character' as
a string, you must use the method 'asString' (class 'Magnitude') to
return a 'String' version of the 'Character' object.

Here is a brief example.  The two 'printf' statements produce the same
output.
     Character new myChar;

     myChar = 'a';

     printf ("%c\n", myChar);
     printf ("%s\n", myChar asString);

'String' class implements several convenience methods.  The 'split'
method, which we described in the previous chapter, splits a string
along a separator character and puts each substring token in an array.

Here is the statement from the example in the previous chapter.  *Note
ctpath.c::.
     nItems = path split separator, paths;
If the receiver, 'path,' contains a string like '/home/users/joe', and
separator, a 'Character' contains '/', then 'split' places the
individual names in the 'Array,' 'paths.'

The operation looks something like this.
     path    --->       "/home/users/joe"
                          /     |     \
                         /      |      \
     split              /       |       \
                       v        v        v
                   --------------------------------
     paths   ---> |paths at 0|paths at 1|paths at 2|
                  | "home"   | "users"  | "joe"    |
                   --------------------------------
The expression, 'paths at 0,' is equivalent to the 'paths[0]' element of
a C array, and so on, for the other elements of the array.

Another convenience method, 'subString,' returns the part of the
receiver string beginning at the first argument.  The second argument is
the length of the substring.  Here is an example.
     myString = "This is a string.";
     mySubString = myString subString 5, 2;

Ctalk has two methods that allow you to search strings: 'search' and
'quickSearch'.

The 'search' method allows you to search for text patterns within
strings.  It recognizes a few metacharacters: '.', '^', '$', and '*'.
The 'quickSearch' searches for exact text only, but it uses a much
faster search algorithm.

Both methods take as their arguments the text pattern you want to search
for, and an 'Array' object, where the methods return the positions in
the receiver where the first character of the pattern occurs.  The first
character of the receiver is offset '0'.  The last element of the
offsets array is '-1', which indicates that 'search' found no further
matches.  The methods return an 'Integer' that contains the number of
matches.  This example shows how a program might search a 'String'
object with 'quickSearch'.

     int main () {
       String new string;
       String new pattern;
       Array new offsets;
       Integer new nMatches;

       pattern = "He";
       string = "Hello, world! Hello, world, Hello, world!";

       nMatches = string quickSearch pattern, offsets;

       printf ("nMatches: %d\n", nMatches);
       offsets map {
         printf ("%d\n", self);
       }
     }

When run, the program should produce output similar to this.
     nMatches: 3
     0
     14
     28
     -1

Here is an example of using 'search' to find a pattern in a 'String'
object.
     int main () {
       String new string;
       String new pattern;
       Array new offsets;
       Integer new nMatches;

       pattern = "l*o";
       string = "Hello, world! Hello, world, Hello, world!";

       nMatches = string search pattern, offsets;

       printf ("nMatches: %d\n", nMatches);
       offsets map {
         printf ("%d\n", self);
       }
     }

When run, the program should produce results like this.
     nMatches: 6
     2
     8
     16
     22
     30
     36
     -1
The 'search' method matches as much of a pattern as possible.  It's also
important to remember that a '*' metacharacter matches zero or more
occurrences of the character it follows.  So the pattern, '"l*o,"'
matches both '"llo,"' and, '"o."'

However, Ctalk's pattern matching does not allow the text that matches a
pattern to overlap.  So a pattern like '.:' matches the character
_before_ each pair of colons in the string 'item1::item2::item3::item4',
while the pattern ':.' matches only the first colon of each pair of
colons.

Using Math Operators with 'Strings'
...................................

As the the section above mentioned, Ctalk overloads math operators for
'String' and its subclasses.  These operators are '+', '-', '++', '--',
'+=', '-=', and '*'.  For 'String' objects (and subclasses of 'String'
if the subclass doesn't also overload the methods) these methods behave
the same as the equivalent C operators - that is, they increment (or
decrement) the value of the receiver 'String' by one or more characters.

Here is an example that demonstrates a few of the methods.


     int main () {

       String new s;
       String new t;
       Integer new halfLength;
       Integer new i;

       s = "Hello, world!";

       i = 0;
       halfLength = 7;

       t = s;

       printf ("%s\n", s);

       while (i++ <= halfLength)
         printf ("%s\n", t++);

       while (t-- != NULL)
         printf ("%s\n", t);
     }


When run, this program produces the following output.


     Hello, world!
     Hello, world!
     ello, world!
     llo, world!
     lo, world!
     o, world!
     , world!
      world!
     world!
     world!
      world!
     , world!
     o, world!
     lo, world!
     llo, world!
     ello, world!
     Hello, world!
     (null)


Note that 'String' and 'Integer' objects get iterated separately.
There's a slight semantic difference from C because Ctalk doesn't
overload subscripts - a Ctalk program would use 't at i' to refer to the
I'th character in a 'String'.

As you might expect, though, the expression '*str' returns the first
element of 'str' as a 'Character' object.

'Array' Class
-------------

An 'Array' in Ctalk is similar to arrays in every other programming
language.  Ctalk arrays are collections of objects, indexed sequentially
from index '0' to the last element in the Array.

To add an element to an 'Array' object, use the method 'atPut.'
     Array new myArray;
     String new myString;

     myString = "Hello, world!";

     myArray atPut 0, myString;

The 'atPut' method has two arguments, the index of the array element,
and the object you want to store there.

To retrieve an 'Array' element, use the method 'at.' The 'at' method
takes one argument, the index of the array element.

Using the previous example, this statement retrieves the first element
of 'myArray' and prints it.
     printf ("%s\n", myArray at 0);

You do not have to predeclare an array to a specific size.  Objects of
'Array' class can hold as many objects as necessary.

If you want to know how many elements an 'Array' object contains, use
the method 'size,' which returns the number of elements as an 'Integer'
object.
     printf ("myArray has %d elements.\n", myArray size);

If you add an object to an array at an index that already contains an
object, 'atPut' replaces the array element with the new object.
     Array new myArray;

     myArray atPut 0, "My";
     myArray atPut 1, "name";
     myArray atPut 2, "is";
     myArray atPut 3, "Bill";

     WriteFileStream classInit;

     stdoutStream printOn "%s %s %s %s.\n", myArray at 0,
       myArray at 1, myArray at 2, myArray at 3;

     myArray atPut 3, "Joe";

     stdoutStream printOn "%s %s %s %s.\n", myArray at 0, myArray at 1,
       myArray at 2, myArray at 3;

The 'WriteFileStream classInit' statement initializes the program's
standard output.  You need to include it (also run by the
'WriteFileStream' method 'new') before printing to the console with
Ctalk methods.  Later chapters describe file input and output in greater
detail.

4.1 Repeating Operations for Each Element of a Collection
---------------------------------------------------------

Generally, if you want to repeat an operation on all members of an
array, you can use C's 'for', 'while', or 'do' loops.

If you want to iterate over a class using Ctalk, many classes implement
the method 'map.'

The 'map' method can take the name of another method as its argument.
'map' then calls the method with each element of the array as its
receiver.

Here is a more complete implementation of the example above, written
using 'map.'
     Array instanceMethod printArrayElement (void) {
       printf ("%s ", self);
       return NULL;
     }

     int main () {
       Array new myArray;

       myArray atPut 0, "My";
       myArray atPut 1, "name";
       myArray atPut 2, "is";
       myArray atPut 3, "Bill";

       myArray map printArrayElement;
       printf ("\n");

       myArray atPut 3, "Joe";
       myArray map printArrayElement;
       printf ("\n");
     }

In the 'printArrayElement' method, 'self' refers to each successive
element of 'myArray' (in 'main'.)  Each element of 'myArray' is an
instance of class 'String.'

However, you should note that 'Array' elements, like elements of any
other collection, can be objects from any class, and C does not
necessarily handle classes that correspond to complex data so easily.

In this case, it is relatively easy for the program to determine how to
deal with a 'String' object.  Mapping over other collection types,
'AssociativeArray's, requires that methods examine receivers of unknown
classes.  *Note Collections::.

If 'Array' elements are instances of complex classes, or the elements
represent complex C data types, then the method may need to determine
the class of its receiver, which is discussed in the following chapters,
and the method may need to translate objects from one class to another.
*Note Variable Promotion and Type Conversion::.

The 'map' method can also use a block of code as its argument, as in
this example.
     int main () {

       List new l;
       String new sPrefix;
       String new s;

       sPrefix = "This element is ";

       l push "l1";
       l push "l2";

       l map {
         s = sPrefix + self;
         printf ("%s\n", s);
       }
       exit(0);
     }

You should note that the block has a different scope than the function
or method where it occurs.  Objects declared in the method are also
visible within the block, but not vice versa.  Also, 'self', when it
occurs inside a code block in this manner, refers to each successive
element of the receiver collection (each member of 'List' L in the
example above), and 'super', is overloaded so that, when used as a
receiver, refers to the receiver of the method that contains the block
of code; i.e., the 'self' of the method that contains the block.

While you can use a 'break' statement to exit that 'map' block, you
cannot (at least currently), 'return' from the method from within the
block.  Otherwise, control structures within a block work just as you
would expect.  Here is an example from 'Object' class.
     Object instanceMethod libraryPath (void) {
       Array new searchDirs;
       Application new docApp;
       String new s;
       String new libraryPathName;
       String new receiverName;
       FileStream new f;
       returnObjectClass String;

       s = docApp classSearchPath;
       s split ':', searchDirs;
       receiverName = self value;
       searchDirs map {
         libraryPathName = self + "/" + receiverName;
         if (f exists libraryPathName)
           break;
       }
       return libraryPathName;
     }

Once again, 'self' within the argument block refers to each successive
member of the 'searchDirs' array.

You can use 'self' in argument blocks even if a block occurs in a C
function.  Otherwise, either Ctalk or the compiler, depending on the
context, will not be able to find the receiver that 'self' should refer
to, and Ctalk or the compiler, or both, will issue warning or error
messages.

If the program tries to use 'super' within a C function, Ctalk prints a
warning and uses the receiver of the entire code block itself-generally,
that's the receiver of a 'map' method.

Many collection classes declare their own versions of 'map'.  All of
them use the '__ctalkInlineMethod ()' library function to actually
perform the in-line call.  Programs that implement inline calls
elsewhere can (and should) use this function.  Refer to the
'__ctalkInlineMethod ()' description in the 'Ctalk Language Reference'
for the gritty details.

It's worth noting here that 'map' with an argument block does not allow
certain constructs.  You can nest argument blocks, but they cannot be
called recursively.  In addition, if the first argument to 'map' is a
separate method, some classes, like 'List', allow you to provide further
arguments to the target method.  *Note MapArguments::.

Occasionally, references to 'self' within code blocks can be ambiguous.
This mostly happens when 'self' is used as an argument to a method
inside the block.  Consider the following example, which uses
'mapInstanceVariables' (defined in class 'Object').
     myObject mapInstanceVariables {
       if (self name != "value") {
         s_element = self formatInstanceVariable self asSymbol; /* Here, "self" refers to s_element. */
         s = s + s_element;
       }
     }

Here, the statement
     s_element = self localFormatInstanceVariable self asSymbol;
can cause trouble, because 'self' refers to 's_element', not the
receiver of the block.  The program can find the
'formatInstanceVariable' method (defined in 'ObjectInspector' class) due
to the way that 'mapInstanceVariables' defines receivers, but the 'self
asSymbol' refers to 's_element' (the receiver of '='), instead of
referring to the receiver of the block.

To make this construct clear, the block can appear, somewhat
artificially, as the following.


     rcvrCopy copy self;             /* Here, "self" is the method's receiver. */
     myObject mapInstanceVariables {
       if (self name != "value") {  /* Here, "self" is the block's receiver. */
         selfVarSymbol = self;       /* Assigning to a Symbol creates a reference. */
         s_element = rcvrCopy formatInstanceVariable selfVarSymbol;
         s = s + s_element;
       }
     }


However, it's also useful to use 'super' in the same manner.  So the
example above gets slightly abbreviated.


     myObject mapInstanceVariables {
       if (self name != "value") {  /* Here, "self" is the block's receiver. */
         selfVarSymbol = self;       /* Assigning to a Symbol creates a reference. */
         s_element = super formatInstanceVariable selfVarSymbol;
         s = s + s_element;
       }
     }


Use of the 'mapInstanceVariable' method is discussed further in the
following sections.  *Note The -> Method::.

4.2 Using Math Operators with Arrays (More about Looping)
---------------------------------------------------------

'Array' objects, like other subclasses of 'Collection', can use
overloaded math operators to loop through the collection's elements.
These methods include '--' and '++'.  Here's a brief example.


     int main (int argc, char **argv) {

       Array new a;
       Key new k;

       a atPut 0, "value0";
       a atPut 1, "value1";
       a atPut 2, "value2";
       a atPut 3, "value3";

       k = *a;

       while (++k)
         printf ("%s\n", *k);

     }


When run the program produces output like this.


     value0
     value1
     value2
     value3


There's a more complete discussion of how math operators work with
'Collection' objects and 'Collection's' subclasses further on.  *Note
CollectionMathOperators::.

Compound Statements
-------------------

The result of evaluating one message can be the receiver of another
message, as in the following example.
     int main () {

       ReadFileStream new infileStream;
       Array new pathDirs;
       Integer new nDirs;
       SystemErrnoException new e;

       /* Substitute the path of the file here. */
       infileStream openOn "/path/name/here";
       if (e pending)
         e handle;

       nDirs = infileStream streamPath split '/', pathDirs;

       printf ("%i\n", nDirs);
       printf ("%s\n", pathDirs at 0);
       printf ("%s\n", pathDirs at 1);
       printf ("%s\n", pathDirs at 2);
     }

The receiver of the method 'split,' in the statement
     nDirs = infileStream streamPath split '/', pathDirs;
is the result of sending the message 'streamPath' to 'infileStream.' The
result is the path name of 'infileStream,' a 'String.'

The result of one message must be a member of the same class as the
receiver of the next message, or a member of a subclass if the message
refers to a method.

Note the use of the 'SystemErrnoException' object, 'e.' This class is
used for recording system errors from methods that interact with the
operating system.  The later sections describe exception handling in
more detail.

The 'Ctalk Language Reference' describes the class and instance
variables of each class, and the return classes of methods.

Expressions as Receivers
------------------------

If you enclose a simple expression in parentheses, then Ctalk can treat
the complete expression as a receiver.  This expression provides an
example.

     ("Hello, " + "world!") length;

This expression returns the result '13', because the expression '"Hello,
" + "world!"' returns a 'String' object containing the result, the
complete 'String', '"Hello, world!"', the receiver of the 'length'
message.

C variables and objects work equivalently in receiver expressions.  So
the following example,

     String new s1;
     String new s2;

     s1 = "Hello, ";
     s2 = "world!";

     (s1 + s2) length;
is equivalent to the example above, as is this example:
     char s1[MAXLABEL];
     char s2[MAXLABEL]

     strcpy (s1, "Hello, ");
     strcpy (s2, "world!);

     (s1 + s2) length;

Method parameters and 'self' also work normally within simple receiver
expressions.  The following example does exactly what you would expect
it to do.

     String instanceMethod catLengthArg (String sArg) {
       printf ("%d\n", (self + sArg) length);
     }

     int main () {
       String new s;
       String new sArg;
       s = "Hello, ";
       sArg = "world!";
       s catLengthArg sArg;
     }

You can overload common C math operators in just about any case where
you have an expression as a receiver.  Operator precedence in Ctalk
works a little differently than C, however, because non-operator methods
bind more tightly than math operators; that is, they have a higher
precedence.

So an expression like the following doesn't do what you expect.

     ("Hello, " + "world ") + ("again" + "!") length;

That is because the 'length' message has a higher precedence that '+',
so 'length' evaluates only the subexpression, '("again" + "!")', which
then generates an invalid operand exception when the second '+' is
evaluated, due to the fact that the 'length' method returns an
'Integer', while the receiver of the second '+' message is a 'String'.

To get 'length' to evaluate the complete expression, enclose the
expression in parentheses.

     (("Hello, " + "world ") + ("again" + "!")) length;

Here's another example of an expresison where it's necessary to add
parentheses.


     (*itemPtr) org x = self resources integerAt "scrollWidth" +
       self resources integerAt "leftMargin";


This expression is ambiguous because the '+' operator in the argument
list is overloaded in both 'String' and 'Integer' classes.  So if Ctalk
is to interpret the argument list, it might consider the first
'integerAt' token to use the rest of the expression as its single
argument, in which case Ctalk would interpret the argument expression
like this, and try to perform an increment of the "scrollWidth" token,
which isn't (as yet) supported, and would (probably) make no sense,
because "scrollWidth" is a key in the 'AssociativeArray,' "resources".


     (*itemPtr) org x = self resources integerAt ("scrollWidth" +
       self resources integerAt "leftMargin");


Instead, what we really want is to interpret the complete argument
expression to the '=' operator as this.


     (*itemPtr) org x = (self resources integerAt "scrollWidth") +
       (self resources integerAt "leftMargin");


This causes Ctalk to first evaluate each operand of the '+' operator,
which results in 'Integer' operands, so Ctalk evaluates the entire
expression as an integer addition, and it uses the 'Integer: +' method,
and returns the addition of the two 'Integer' values that are stored in
the "resources" 'AssociativeArray'.

Variable Promotion and Type Conversion
--------------------------------------

This section could also be titled _When to use become, copy, or =._

Because objects can be much more complex than C data types, variable
promotion and type conversion become much more complex operations in
object oriented languages than in C. This will become apparent later on.

For now, because we're discussing basic object classes, it should be
sufficient to look at the methods of class 'Magnitude' for our examples,
which is the superclass of classes like 'Character,' 'String' (a
subclass of 'Character'), 'Integer,' and 'LongInteger.'

You need to use the 'Magnitude' methods 'asCharacter,' 'asInteger,' and
'asLongInteger' to perform type conversions explicitly.  The 'Ctalk
Language Reference' describes the type conversion methods for each
class.

When making assignments, you can use '=' for receivers and arguments
that a function or method declares explicitly, or with constant
receivers and objects.  The classes 'Integer,' 'Character,' and 'String'
each implement a '=' method, so a program would use '=' with objects
that are instances of these classes, or with constants like '1,' 'a,' or
'"Hello, world!"'

In other cases, if a statement needs to make an assignment and the
statement contains receiver or instance variables, or the expression
contains an operand that the program cannot determine until run time, or
if the receiver or operand are of completely different classes, then
'become' (class 'Object') can in most cases perform the type conversion
and assignment.  This is often the case with classes that represent
complex data, like files or windows.

The 'become' method takes into account situations where the type of a
receiver or local object may change during the course of a program's
execution.

*Warning:* However, the method 'become' _alters or even deletes the
original object._  That means you should not use it with objects that
are passed as 'Symbol' values, or other expressions where an application
uses an object outside of it original scope.

Here's a partial example, from the 'attachTo' method in 'X11CanvasPane'.
The 'become' method mutates the instance variables, 'paneBuffer' and
'paneBackingStore' into 'X11Bitmap' objects.  Because the front end does
not know for certain that the objects have been mutated (because there's
nothing syntactically special about a method like 'become' that
indicates its function).  So when the front end encounters the
'initialize' method (which is defined in class 'X11Bitmap'), the
language may only be able to assume that 'paneBuffer' and
'paneBackingStore' are still 'Symbol' objects, which do not have an
'initialize' method.  So the front end generates a warning and informs
you that the statement's evaluation is going to wait until run time.

     X11CanvasPane instanceMethod attachTo (Object parentPane) {
       X11Bitmap new xPaneBuffer;
       X11Bitmap new xPaneBackingStore;
       self super attachTo parentPane;
       self paneBuffer become xPaneBuffer;
       self paneBackingStore become xPaneBackingStore;
       if (parentPane containerMode == "full") {
         self viewWidth = parentPane size x;
         self viewHeight = parentPane size y;
         self size x = parentPane size x;
         self size y = parentPane size y;
         /*
          * These two statements generate warnings, and
          * Ctalk waits until run time to evaluate them.
          */
         self paneBuffer initialize self size x, self size y,
           self depth;
         self paneBackingStore initialize self size x, self size y,
           self depth;
       } else {
         fprintf (stderr,
     	     "attachTo (class X11CanvasPane) : undefined containerMode.\n");
       }
       return NULL;
     }

If you want better statement checking, then you can try performing
whatever operations you need first (in this example, those are the
statements that contain the 'initialize' method), and _then_ mutating
the objects with 'become' second.
     X11Bitmap new xPaneBuffer;
     X11Bitmap new xPaneBackingStore;
     ...
     xPaneBuffer initialize self size x, self size y,
           self depth;
     xPaneBackingStore initialize self size x, self size y,
           self depth;
     ...
     self paneBuffer become xPaneBuffer;
     self paneBackingStore become xPaneBackingStore;

Classes like 'X11PaneDispatcher', 'X11CanvasPane', and 'X11TextPane' use
a lot of object references.  There are some factors that you need to
watch out for when working with 'Symbol' objects that refer to other
objects.

We use 'X11Bitmap' objects because they allow us to maintain graphics
features, like colors and fonts, within the 'X11Bitmap' object, which
considerably simplifies the classes of higher level objects of the
'Pane' subclasses.  It also helps guarantee that we need to set graphics
features only at the beginning of the program, or once again only when
the program requests that the window display at different font or color,
or some other graphics operation.

There's more discussion about graphics further on, and the next sections
talk more about object references.

When a statement needs to duplicate objects of the same class, then it
should use the 'copy' (class 'Object') method.  Remember, though, that
the receiver of the 'copy' message is the _target_ of the copy
operation.  The 'copy' method _completely_ replaces the receiver with
the source object that is 'copy''s argument.  That means the original
receiver object is no longer available.

If a class contains data that requires a special protocol to duplicate
objects, then it can implement its own versions of these methods, or use
any other way it needs to assign objects.

Object References
-----------------

The 'Symbol' class gives programs the ability to use the same object
anywhere in a program, and makes it much easier to maintain multiple
references to objects.  'Symbol' objects accomplish this by maintaining,
instead of a unique sub-object, a reference to another, original object.

From here to the end of the tutorial, you'll see a lot of information
about object references.  If the information seems to be repetitive,
it's because references are essential to writing complex programs and
add a level of complexity to the language that you need to be aware of.

Passing objects by reference allows programs to modify objects just
about anywhere.  Then, in many cases, the application can use an object
without knowing beforehand exactly what class the object is, or what
data the object contains, until an expression is actually evaluated.
It's something that you need to be aware of when writing complex
programs.

The '=' method of class 'Symbol' behaves differently depending on its
context.  It can either assign an object to a 'Symbol's' label, or it
can duplicate the symbol's reference, depending on whether the 'Symbol'
object is the receiver a method like '*'.

The '*' method always provides access to the object referred to by the
receiver.  In this sense, '*' acts very much like C's '*' operator.
It's also convenient to refer to 'Symbols' in this context as
_pointers,_ following the C terminology.  The following example might
make this a little clearer.


     int main () {

       Symbol new sym1;
       Symbol new sym2;
       Symbol new sym3;
       Integer new i;

       i = 2;

       sym3 = sym1;   /* Save the original value of sym1. */

       sym1 = i;
       printf ("%d\n", sym1);

       *sym2 = i;     /* Pointer context - refer to the object using '*'. */
       printf ("%d\n", *sym2);

       sym1 = sym3;  /* Restore sym1 to the original object. */

       i = 4;

       *sym1 = i;    /* Pointer context again. */

       printf ("%d\n", *sym1);
     }


The '*' method is also a convenient shorthand for the 'setValue' and
'getValue' methods, which can fit into places where a prefix operator
might be confusing or just plain syntactically incorrect, and which have
a higher operator precedence (remember that method labels bind more
tightly than operators).  This somewhat hypothetical example shows one
case where the precedence of an operator can cause unpredictable
behavior.


     TreeNode new head;
     TreeNode new tChild;
     Symbol new tSib;

     tSib = TreeNode basicNew "Sibling Node";
     head makeSibling tSib;

     ....                                  /* Do some stuff */

     head siblings map {
       *tSib = self;

       tChild = TreeNode basicNew "Child Node";

       ...                               /* Do some more stuff. */

       tSib getValue addChild tChild;    /* This expression
                                            evaluates correctly. */

       *tSib addChild tChild;            /* This expression doesn't
                                            evaluate left-to-right as
                                            you might expect, because
                                            "addChild" has a higher
                                            precedence than "*". */

       (*tSib) addChild tChild;          /* Adding parentheses causes the
                                            "*" operator to be evaluated
                                            first, so this expression
                                            evaluates left-to-right. */
     }


In some cases, object references tell Ctalk to wait until the
application actually runs before trying to evaluate an expression.
Consider another somewhat hypothetical example.

If we declare an instance variable like this:
     X11Pane instanceVariable container Object NULL;
And then, further down, the program contains an expression like this:
     self container deleteAndClose;
Ctalk cannot generate the correct code, because the value of 'container'
is actually an 'Object', and it can't determine beforehand from the
'Object' class library where to find the 'deleteAndClose' method.  We
might assume in this case that 'container' is also a 'X11Pane,' but
using class membership to bind receivers and methods raises all sorts of
havoc; for example, when performing math operations with instance
variables.  And in some cases, the application needs to take care that
the method's class-here, the 'X11Pane' class defines the
'deleteAndClose' method-actually has been evaluated in order to avoid an
undefined forward reference.

Instead, a class might declare an instance variable like this.
     X11Pane instanceVariable container Symbol NULL;
Noting that a method like 'getValue' (defined in class 'Symbol') returns
'Any' class of object, Ctalk then knows that it should wait until the
program is run before trying to evaluate the expression.  So expressions
like this example, from the 'subPaneResize' method above, isn't actually
evaluated until the program runs.
     __subPaneRef getValue displayText;
In some cases, if you try to use an instance variable message with an
object reference, Ctalk generates a warning that the instance variable
message is ambiguous.

For example, the 'x' and 'y' messages in the 'printf(3)' arguments are
ambiguous.
     int main () {
       Point new p;
       Symbol new s;

       p x = 125;
       p y = 175;

       s = p;
       /*  Ambiguous messsages, "x," and, "y." */
       printf ("%d %d\n", s getValue x value, s getValue y value);
     }
In these cases, Ctalk generates a warning message, so when building this
program, the output looks like this (assuming the input file is named
'example.c').
     $ ctcc example.c -o example
     /usr/local/bin/ctalk    example.c  -o example.i && /usr/bin/gcc  example.i -o example -lctalk -L/usr/local/gcc-current/lib -L/usr/local/lib -L/usr/lib -L/usr/local/lib -L/usr/lib
     example.c:10: Ambiguous operand: Warning: Message, "x," follows method, "getValue," which returns "Any" class object.
     example.c:10: Ambiguous operand: Warning: Message, "y," follows method, "getValue," which returns "Any" class object.

When evaluating references, Ctalk can generally figure out that
successive calls to 'getValue' (or '*') mean the same reference, but a
program shouldn't depend on this behavior, especially when there are
instance variable messages or other method messages in the expression.

The following examples might help explain this.
     Symbol new mySym;
     Integer new myInt;

     myInt = 1;

     mySym = myInt;
     printf ("%d", mySym getValue value);           /* Correct. */


     mySym = myInt asSymbol;
     printf ("%d", mySym getValue value);           /* Still correct. */

     printf ("%d", mySym getValue getValue value);  /* Not necessarily correct. */
In the third example, Ctalk can still figure the expression out because
the receiver, 'mySym' is the same for both 'getValue' messages.  To
repeat, programs shouldn't depend on this being the case for complex
expressions.

These characteristics also apply to the subclasses of 'Symbol;' for
example, the 'Key' class.  'Key' objects are mainly used as the indices
of 'Collection' objects and its subclasses.  'Keys' help simplify the
task of looping through 'Collection' members.  They also help more
specialized subclasses extend the basic 'Collection' object.  There's
more discussion of how to use 'Keys' and references to them below.
*Note Collections::.

Multiple Indirection
....................

The previous section described how to assign object references in
relatively simple expressions.  However, in C it is often necessary to
provide multiple levels of indirection.  Declarations like 'char **argv'
and 'char *myvar[512]' occur frequently in C programs.

If objects need to use multiple levels of referencing and dereferencing,
We've already mentioned 'Symbol' class's 'getValue' method, and its
synonym, '*'.  Ctalk also provides several other methods for this
purpose: 'addressOf' (defined in 'Object' class) and 'deref' (defined in
'Symbol' class).

These two methods make it possible to construct expressions like those
in the following example.
     int main () {
       Integer new i;
       Symbol new s;

       i = 1;
       s = i addressOf;
       printf ("%d\n", i);
       printf ("%d\n", s deref);
     }
When run, the output of the two 'printf' statements is identical.

The following examples also describe shorthands for the methods.
'addressOf' is functionally equivalent to the C '&' unary operator, and
'deref' is functionally equivalent to the unary '*' operator.

If a program needs to use multiple levels of indirection, it can use the
'addresOf' and 'deref' messages multiple times, as in this example.


     int main () {
       Point new p;
       Symbol new s;

       p x = 1;
       s = p x addressOf addressOf;
       printf ("%d\n", p x);
       printf ("%d\n", s deref deref);
     }


Or even,


     int main () {

       Point new p;
       Symbol new s;

       p x = 1;
       s = p x addressOf addressOf addressOf;
       printf ("%d\n", p x);
       printf ("%d\n", s deref deref deref);

     }


In each case, the output of the 'printf' statements is the same.

The main difference between the 'addressOf' and 'deref' expressions,
compared with '=' and 'getValue', is that '=' only converts a symbol
value once, while 'addressOf' always returns a 'Symbol' object that
points to the receiver.

In practice, it works out that 'deref' allows statements with a little
more precision than a series of 'getValue' statements would allow.

The '->' Method and C Object Members
------------------------------------

Ctalk also overloads the C language's dereference ('->') operator so you
can obtain the value of any object's C members by referring to the C
name that Ctalk uses internally.

The member names of a C 'OBJECT' typedef are:
     __o_name
     __o_classname
     __o_class
     __o_superclassname
     __o_superclass
     __o_p_obj
     __o_value
     instance_methods
     class_methods
     instancevars
     classvars
     scope
     nrefs
     next
     prev

_Note:_ The use of '__o_classname' and '__o_superclassname' are being
phased out.  You should use the 'CLASSNAME' and 'SUPERCLASSNAME' macros
instead.

If the '->' operator is a method, then Ctalk recognizes both the old and
new names.  However, if '->' is used with an 'OBJECT *' as a C operator,
then it is necessary to use the CLASSNAME and SUPERCLASSNAME macros.

Ctalk uses some special semantics with the '->' method.  First of all,
when given a C name as an argument, Ctalk returns a 'Symbol', 'String'
or 'Integer' object with a reference to the original object whenever
necessary.

That means, where an object contains a reference to its class object,
for example, the '->' method returns a reference to the actual object,
so you can work with the actual object representation of the C value.

This can be a bit tricky in practice, because you need to make sure that
a program knows what class of object to expect in return - a 'String,'
'Integer,' or 'Symbol'.

Often Ctalk can tell by the context of a statement what class of object
to expect, as in this example.


     int main () {
       Integer new i;
       Integer new mbrInteger;
       String new mbrString;
       Symbol new mbrSymbol;

       mbrString = i -> __o_name;
       printf ("name: %s\n", mbrString);
       mbrString = i -> __o_classname;
       printf ("classname: %s\n", mbrString);
       mbrSymbol = i -> __o_class;
       printf ("class: %p\n", mbrSymbol);
       mbrString = i -> __o_superclassname;
       printf ("superclassname: %s\n", mbrString);
       mbrSymbol = i -> __o_superclass;
       printf ("superclass: %p\n", mbrSymbol);
       mbrSymbol = i -> __o_p_obj;
       printf ("parent: %p\n", mbrSymbol);
       mbrString = i -> __o_value;
       printf ("value: %s\n", mbrString);
       mbrInteger = i -> scope;
       printf ("scope: %d\n", mbrInteger);
       mbrInteger = i -> nrefs;
       printf ("references: %d\n", mbrInteger);
       mbrSymbol = i -> instancevars;
       printf ("instancevars: %p\n", mbrSymbol);
       mbrSymbol = i -> classvars;
       printf ("classvars: %p\n", mbrSymbol);
       mbrInteger = i -> instance_methods;
       printf ("instance methods: %p\n", mbrInteger);
       mbrInteger = i -> class_methods;
       printf ("class methods: %p\n", mbrInteger);
       mbrSymbol = i -> prev;
       printf ("prev: %p\n", mbrSymbol);
       mbrSymbol = i -> next;
       printf ("next: %p\n", mbrSymbol);
     }


That's because the '=' method of each receiver - 'mbrString',
'mbrInteger', and 'mbrSymbol' - perform the necessary type conversions.

However, if you use the '->' method inline, as in this statement:
     stdoutStream printOn "name: %s\n", self -> __o_name;
You need to make sure that the method 'printOn' (from 'WriteFileStream'
class in this example) knows what class the argument 'self -> __o_name'
is going to return.  For arguments that are members of common classes
like 'String' and 'Integer' objects, this normally isn't a problem.

Symbol objects, however, can be trickier, because they are references.
So to get the actual C pointer to an 'OBJECT' type, a program needs to
use a statement like the following.
     stdoutStream printOn "superclass: %p\n", self -> __o_superclass asSymbol;

This can lead to some very convoluted statements.  To retrieve the
'value' instance variable of an object reference, you would need a
statement or two like these examples.
     __objectRef getValue -> instancevars getValue value;
Or even more confusingly,
     refValue become __objectRef getValue -> instancevars getValue value;

As mentioned in the last section, assigning an object to a 'Symbol' or
using the 'asSymbol' method have the effect of dereferencing an object,
similar to referencing and dereferencing objects in C with the '*', '&',
'->', and '.' operators.  The effective use of these C operators takes
practice, and the same is true of Ctalk.

So you can have a series of statements like the following example.
     Symbol new varValue;
     ...
     varValue = self -> instancevars;
     myString printOn "value: %s (%s)\n",
       varValue getValue value -> __o_value,
       varValue getValue value -> __o_classname;
But you can also reference and then dereference an object multiple
times.
     Symbol new varValue;
     ...
     varValue = self -> instancevars asSymbol;
     myString printOn "value: %s (%s)\n",
       varValue getValue getValue value -> __o_value,
       varValue getValue getValue value -> __o_classname;

There's another, more serious issue when parsing instance variables.
That is, if Ctalk needs to make a copy of an instance variable, it
cannot also copy the links to the object's other instance variables.  To
work reliably, Ctalk would need to copy the entire set of objects.  That
means, normally, you would not be able to loop through a set of instance
variables to examine their contents.

Instead, you would need to create statements like these:
     __objectRef getValue -> instancevars -> next getValue value;
     __objectRef getValue -> instancevars -> next -> next getValue value;
     ...
And this is probably not what you want, and Ctalk does not provide
special handling for '->' arguments, because '->', as much as possible,
needs to work like any other method.

Instead, Ctalk provides a method, 'mapInstanceVariables', defined in
'Object' class, that performs this work for you.  (There is also a
'mapClassVariables' method, described below.)  It works similarly to the
'map' methods in 'List' and other collection classes, except that it
works specifically on instance variable lists.  It's also designed to
handle object references differently.

For example, this program looks rather simple.
     int main () {
       Symbol new sym;
       Point new p;
       p x = 100;
       p y = 150;

       sym = p;

       sym getValue mapInstanceVariables {
         if (self -> __o_name != "value") {
           printf ("name:  %s\n", self -> __o_name);
           printf ("value: %d\n", self value -> __o_value asInteger);
         }
       }
     }
Except that there is a slight pitfall - 'sym' is a 'Symbol', that is a
reference to a 'Point' object, 'p', and Ctalk can't determine the actual
class of the block's receiver until the program is run.  (The '=' method
in the statement 'sym = p;' doesn't have very many special semantics,
either.)

However, 'mapInstanceVariables' can take this factor into account, and
it will check for possible receiver classes and if necessary issue a
warning.

The output of the example above looks something like this.
     Warning: From mapInstanceVariables (class Object):
     Warning: The argument block thinks the receiver's class is, "Symbol,"
     Warning: when it is actually, "Point."
     name:  x
     value: 100
     name:  y
     value: 150

If you want to avoid the warning, you can rewrite the program like this.
     int main () {
       Point new p;
       p x = 100;
       p y = 150;

       p mapInstanceVariables {
         if (self -> __o_name != "value") {
           printf ("name:  %s\n", self -> __o_name);
           printf ("value: %d\n", self value -> __o_value asInteger);
         }
       }
     }

You should also note that '->' returns the value of an object as a
'String' object.  That means if the program needs to perform any numeric
conversions, it should first morph the result into an 'Integer',
'Float', or other class, using 'asInteger' (defined in 'Magnitude' and
'String' classes), and so on.

Here is an example of how you might manage some simple numeric
conversions, with class variable receivers provided by the
'mapClassVariables' method, defined in 'Object' class.  When working
with objects, methods like 'printOn' and 'writeFormat' (defined in
'String' and 'WriteFileStream' classes) are better at formatting the
values of objects than simply using 'printf(3)'.

     int main () {
       WriteFileStream new w;
       String new s;
       String new s_element;
       Symbol new varRef;

       s = "";
       w mapClassVariables {
         varRef = self;
         s_element printOn "%s (%s)\n",
           varRef getValue -> __o_name,
           varRef getValue -> __o_classname;
         s = s + s_element;
         s_element printOn "%d (%s)\n",
           varRef getValue -> __o_value asInteger,
           varRef getValue -> __o_classname;
         s = s + s_element;
       }
       stdoutStream writeFormat "%s\n", s;
     }
Here the use of 'writeFormat' is mainly for illustration.  It is likely
that 'writeFormat' will be deprecated in future releases.

There will certainly be times when you need to work with object
references in C. and there are a number of Ctalk library API functions
that can help you translate between object values (which are represented
internally as formatted 'char *''s), and C variables, and vice versa.
These functions and others appear in many of the examples in this this
document and are described in more detail in the 'Ctalk Language
Reference.'
     void *__ctalkGenericPtrFromStr (char *);
     void __ctalkObjValPtr (OBJECT *, void *);
     void *__ctalkStrToPtr (char *);
     char   __ctalk_to_c_char (OBJECT *);
     double __ctalk_to_c_double (OBJECT *);
     int    __ctalk_to_c_int (OBJECT *);
     char   *__ctalk_to_c_char_ptr (OBJECT *);
     void   *__ctalk_to_c_ptr (OBJECT *);
     long long int __ctalk_to_c_longlong (OBJECT *);
     OBJECT *obj_ref_str (char *);

Default Methods and Instance Variable Messages
----------------------------------------------

We should mention explicitly one other point about methods and messages,
and it is related to some of the examples in the previous sections.
Ctalk objects also respond to messages that name instance variables.

All Ctalk objects contain the instance variable, 'value,' which is
inherited from class 'Object.' Because of this, if you use an object
without a message, Ctalk uses the 'value' message by default.

In this simple example, the following two statements are equivalent.
     printf ("%d\n", myInt);

     printf ("%d\n", myInt value);

With more complex objects, for example like those in the 'Stream' and
'Pane' subclasses, statements that contain instance variable messages
can quickly become complex.  The later chapters and code snippets in
'The Ctalk Language Reference' describe how to use instance and class
variable messages with complex objects.

The example from the previous section is typical.
     Point new p;
     p x = 100;
     p y = 150;
     ...
Here 'x' and 'y' are not methods, but instance variables defined in
'Point' class.  These messages often work like method messages in
expressions, except that you can also assign values to them, by giving
the name of the instance variable and the object it belongs to.

Assigning and Evaluating Complete Objects
-----------------------------------------

The rules for using a default 'value' method have a few exceptions.
They occur mainly when Ctalk translates between objects and C. That's
partly because C normally assigns objects by value, while Ctalk works
with object references.  This manual discusses object references here
and in more detail later on, but here we'll mention the exceptions so
that you're aware of them.

As we'll get to, objects are represented internally as an 'OBJECT *' C
type, and that's how programs access them using C.

So we can assign an object to a C variable with a set of statements like
the following.


     Object new myObj;       /* A Ctalk object. */
     OBJECT *myObj_alias;    /* A C reference to an object. */

     myObj_alias = myObj;


Then you can access the object using the 'myObj_alias' variable.

In this case, Ctalk doesn't try to cast the object - it's already an
'OBJECT *'.  That is, Ctalk doesn't consider that there's an implicit
'value' message following the object.  (Though you can, of course, add a
'value' message to the statement if you actually do want the value.)

The same is true of using 'printf ()' to print an object.  If Ctalk sees
that you want to print a pointer, and there's no message following the
object, then Ctalk does just that.  These statements simply print the
address of an object.


     printf ("%p\n", myObject);
     printf ("%#x\n", myObject);


The second 'printf ()' statement might generate a warning with some
compilers, but as long as pointers are the same size as 'ints', the
statement should work fine.

The other case where the complete object is used on its own is in the
case of the 'self' keyword.  Ctalk doesn't consider that it has a
default 'value' message following it.  So the examples above are true
for 'self' also.


     OBJECT *self_alias;    /* A C reference to an object. */

     self_alias = self;

     printf ("%p\n", self);
     printf ("%#x\n", (unsigned int)self_alias);  /* The cast prevents
                                                     a warning from the
                                                     compiler. */


Finally, if there's a C statement that you _don't_ want Ctalk to
evaluate as a value assignment, you can always use the 'eval' keyword to
so that Ctalk interprets the statement verbatim.


     myObj_alias = myObj;      /* These two statements are equivalent. */
     myObj_alias = eval myObj;


Class Objects and Introspection
-------------------------------

No object oriented programming manual would be complete without some
discussion of the way objects refer to themselves.  The semantics of
objects might seem obvious after a bit, but they cause Ctalk to use
another set of rules when referring to classes themselves.

For example, if a program contains the statements,


     myString = "Key";                     /* Select the Key class. */
     printf ("%s\n", myString superclassName);


The program will display, 'Character,' which is the superclass of
'String' class, and not 'Symbol', which is the superclass of 'Key'
class.

For these cases, the method 'classObject' (in 'Object' class), provides
the actual class object when you give it a class name.

With the use of 'classObject', the code sample would become this.


     myString = "Key";
     myClassObj = myString classObject;
     printf ("%s\n", myClassObj superclassName);


As a general rule, if you're working with elements of an object, it's
safer to work on the actual object, and not another object that simply
contains a classes' name.

However, if you're trying to find information that's external to an
object, for example, its file path in the class library, it's safe to
use the name of a class expressed as the value of a 'String' object.

The difference is not always clear-cut, and it might take some checking
of what kind of receiver the method expects and what its function is in
order to figure out how a class argument's semantics are going to work.
Here's a fragment from the 'classdoc' program that provides a small
illustration of this.  Refer to the manual page, 'classdoc(1)' for more
information about 'classdoc.'

     Application new classDocApp;
     String new classArg;
     Object new classObj;

     classObj = classArg classObject;  /* classArg contains the class name
                                          supplied by the user. */

     printf ("%s\n", classObj superclassName);
     printf ("%s\n", classArg libraryPath);
     printf ("%s\n", classDocApp classDocString classObj);



File: tutorial.info,  Node: File input and output,  Next: Self and super,  Prev: Basic classes,  Up: Top

Input and Output
================

This chapter describes how Ctalk performs basic file operations -
opening, closing, reading, and writing files.

There are three classes that provide file input and output:
'ReadFileStream,' which implements objects and methods for reading from
files, 'WriteFileStream,' which provides methods and objects for writing
to files, and their superclass, 'FileStream,' which provides methods and
class definitions that are common to both reading and writing files.
There is also a 'DirectoryStream' class, which this chapter describes
below.

Ctalk provides many of the same facilities that C's 'stdio.h' library
functions provide, although the language implements them as objects.

Here is an example that shows how to use the 'openOn' method (class
'ReadFileStream').
     ReadFileStream new myInput;

     myInput openOn "myFileName";

If the program was able to to open the file, you can then read input
from the 'myInput' stream.

We should note here that Ctalk also provides classes and methods that
handle file I/O errors.  We will deal with them later on.  If you need
to see how to catch file I/O errors right now, look at some of the
example programs in the Ctalk package, especially 'ctwc.c.'

Opening a file for output is similar to opening a file for input, except
that the stream is an instance of class 'WriteFileStream.'
     WriteFileStream new myOutput;

     myOutput openOn "outputFileName";

After a program has opened the file streams successfully, you can read
and write from them with the following methods.
     Operation                           Reading    Writing
     ---------                           -------    -------
     Read or write one character.        readChar   writeChar
     Read or write one line.             readLine   -
     Read or write all the data.         readAll    writeStream
     Read or write formatted data.       readFormat printOn
     Read fixed length data.             readRec

Here is a simple example that shows opening a file, and reading each
character.
     ReadFileStream new inputChars;
     Character new c;

     inputChars openOn "inputFileName";

     while ((c = inputChars readChar) != EOF)
       printf ("%c", c);

When 'readChar' reaches the end of a file, it returns an 'EOF'
character, which is '-1' on most systems.

Using the method 'streamEof' (class 'FileStream') to check for the end
of the input is slightly more reliable than looking for an 'EOF'
character, because it distinguishes the end of the input caused by an
error from the end of the input caused by reaching the end of a file.
     ReadFileStream new inputChars;
     Character new c;

     inputChars openOn "inputFileName";

     while (TRUE) {             /* Loop until the end of the input. */
       c = inputChars readChar;
       if (inputChars streamEof)
         break;
     }

If you don't need to examine each character as it is read, however, then
you can simply use 'readAll' (class 'ReadFileStream'), which provides
the complete input as a 'String' object.
     ReadFileStream new inputStream;
     String new inputString;

     inputStream openOn "myInput";
     inputString = inputStream readAll;
     printf ("%s", inputString);

Simple applications can use the methods 'readLine' (class
'ReadFileStream') and 'writeStream' (class 'WriteFileStream') together
to process input.

Here is a portion of the program 'ctrep.c.' You find the program in the
Ctalk package.  It checks the input for occurrences of a character
string, and replaces the string before writing the output.
     /*
      *  Loop until the end of input.
      */
     while (TRUE) {
       line = stdinStream readLine;
       if (stdinStream streamEof)
         break;
       inputLineLength = line length;

       word = "";

       for (i = 0; i < inputLineLength; i = i + 1) {
         inputChar = line at i;
         if (inputChar isSpace) {
         if (word == pattern) {
           stdoutStream writeStream replacement;
         } else {
           stdoutStream writeStream word;
         }
           stdoutStream writeStream inputChar;
           word = "";
         } else {
           word = word + inputChar asString;
         }
       }
     }

Standard Input and Standard Output
----------------------------------

Notice that the previous example used 'stdinStream' and 'stdoutStream'
as its input and output streams.

These two objects are class variables of 'ReadFileStream' and
'WriteFileStream,' respectively.  They represent the program's standard
input ('stdin') and standard output ('stdout') file streams.

Because 'ctrep.c' is a filter program, it uses these two streams instead
of streams that work with normal files.

Class 'WriteFileStream' also implements the 'stderrStream' class
variable, which represents the application's standard error ('stderr')
stream.

You should notice, also, that most of the examples so far have used
'printf' to print output.  You can accomplish the same task with the
following Ctalk statement.
     stdoutStream writeStream "Hello, world!\n";

This is equivalent to:
     printf ("Hello, world!\n");

Ctalk initializes 'stdinStream' automatically when the program creates
the first 'ReadFileStream' object, and it initializes 'stdoutStream' and
'stderrStream' when the program creates the first 'WriteFileStream'
object.

If the program simply needs to use 'stdinStream,' 'stdoutStream,' or
'stderrStream' without opening files, then it can call the class method
'classInit' with either the class 'ReadFileStream' or 'WriteFileStream'
as the receiver.
     ReadFileStream classInit;    /* Initialize stdinStream. */
     WriteFileStream classInit;   /* Initialize stdoutStream and stderrStream. */

Here is the example from the previous chapter that printed elements of
arrays.  This version uses 'stdoutStream' to output the array elements.
     Array instanceMethod printArrayElement (void) {

       WriteFileStream classInit;

       stdoutStream writeStream self;

       return NULL;
     }

     int main () {

       Array new myArray;

       myArray atPut 0, "My";
       myArray atPut 1, "name";
       myArray atPut 2, "is";
       myArray atPut 3, "Bill";

       myArray map printArrayElement;

       printf ("\n");

       myArray atPut 3, "Joe";

       myArray map printArrayElement;

       printf ("\n");
     }

The 'printArrayElement' method initializes class 'WriteFileStream.' You
need to perform the class initialization before the class is first used
in the program.  There is no problem with calling 'classInit' multiple
times, however, because the method checks to determine if the class is
already initialized.

Directories
-----------

The class 'DirectoryStream' provides the methods 'mkDir' and 'rmDir'
which create and delete directories.  The methods function exactly as
their C library counterparts, except that they raise a
'SystemErrnoException' on error and return an 'Integer' with the value
'-1'.

Ctalk uses '0755' ('drwxr-xr-x') as the default mode for new
directories.  Programs can change that value by redefining the macro
'CTALK_DIRECTORY_MODE'.

Here is a program that creates a new directory.
     /*
      * Define more restrictive permissions for
      * new directories. Undefine the macro first
      * to avoid a warning message.
      */
     #undef CTALK_DIRECTORY_MODE
     #define CTALK_DIRECTORY_MODE 0700

     int main () {

       DirectoryStream new thisDir;

       thisDir mkDir "testDir";

     }

The 'rmDir' method works similarly to the 'mkDir' method.
     int main () {

       DirectoryStream new thisDir;

       thisDir rmDir "testDir";

     }

Standard Input and Standard Output Implementations
--------------------------------------------------

The C99 standard requires that 'stdin,' 'stdout,' and 'stderr' should be
implemented as macros, which on some systems (notably Solaris) causes
problems with C-to-object translation.

If Ctalk cannot register the macros as C variables, then you must call C
functions like 'sscanf(3)' and 'fscanf(3)' with only C variables, or use
a method with 'stdoutStream' or 'stderrStream' ('WriteFileStream'
class), or 'stdinStream' ('ReadFileStream' class).

Console Input
-------------

The method 'consoleReadLine' (in class 'String') prints a prompt string,
and then waits for you to enter a line of text.  What makes this method
special is that it uses the GNU readline library's standard command
editing and history features, if you built Ctalk with readline support
(see the options to the configure script for details).  In that case,
Ctalk also defines the 'HAVE_GNU_READLINE' macro to '1'.  Here is an
simple example of how to use 'consoleReadLine'.
     int main (int argc, char **argv)    String new s;
       String new promptStr;

       if (argc > 1)
         promptStr = argv[1];
       else
         promptStr = "Prompt ";

       printf ("Readline test.  Type ^C or, \"quit,\" to exit.\n");
     #if HAVE_GNU_READLINE
       printf ("Ctalk built with GNU Readline Support.\n");
     #else
       printf ("Ctalk built without GNU Readline Support.\n");
     #endif
       while (1)      s consoleReadLine promptStr;
         printf ("You typed (or recalled), \"%s.\"\n", s);
         /*
          *  Matches both, "quit," and, "quit\n."
          */
         if (s match "quit")
           break;
       }
     }


File: tutorial.info,  Node: Self and super,  Next: Collections,  Prev: File input and output,  Up: Top

'self' and 'super'
==================

The 'self' and 'super' keywords refer to receivers and superclass
methods at run time.  They allow you to write methods without knowing
beforehand what objects called them.

'self' as a Receiver
--------------------

Within a method, 'self' refers to the receiver of the method that 'self'
appears in.  Within the method, you can use self interchangeably with
other receivers.

When used as a receiver, Ctalk's 'self' works much like the 'self'
keyword in Smalltalk and the 'this' keyword in C++.

In this example, 'self' in the method 'add2' refers to the method's
receiver, 'myInt,' which is declared in 'main.'
     Integer instanceMethod add2 (void) {
       methodReturnInteger(self + 2);
     }

     int main () {
       Integer new myInt;
       Integer new myTotal;

       myInt = 2;
       myTotal = myInt add2;
       printf ("%d\n", myTotal);
     }

You need to be careful of using 'self' within a constructor (a 'new'
method), because the method's receiver is the class object of the
instance you are creating, and not the new object itself, and that is
probably not what you want.  Ctalk prints a warning message in this case
if you enable verbose warnings with the '-v' command line option.

The 'super' Keyword
-------------------

When used before a message, 'super' tells Ctalk that the message refers
to a method in the superclass of the receiver.

One use of 'super' is in constructors of subclass objects.  The keyword
allows constructor methods, which are almost always called 'new,' to
refer to the constructor of a superclass, which allows subclass objects
to inherit the instance variables of its superclasses.

The example in the first chapter, of how 'FileStream' and its subclasses
inherit instance variables, describes how constructors can call class
constructors.  *Note Class Hierarchy::.

To show how 'super' is used, here is the 'new' method from class
'WriteFileStream'.
     WriteFileStream instanceMethod new (char *name) {

       WriteFileStream super new name;

       __ctalkInstanceVarsFromClassObject (name);

       WriteFileStream classInit;

       return name;
     }

'super' Used as a Receiver
--------------------------

When used within an argument block, 'super' can refer to the receiver of
the method that contains the argument block.

This overloading of 'super' conveniently allows methods to refer to both
the collection that maps the argument block (by referring to 'super'
within the block), and to each element of the collection (by referring
to 'self' within the block).

To help make this clear, look at the following example.


     List instanceMethod mapPrint (void) {
       String new sPrefix;
       String new s;
       Integer new n;
       sPrefix = "This element is ";
       n = 0;

       /*
        *   Here, "self," refers to the receiver of the mapPrint method,
        *   the List l that was declared in main ().
        */
       self map {

         /*
          *  Within the code block, though, "self," refers to each element
          *  of List l in succession.
          */
         s = sPrefix + self;
         printf ("%s\n", s);

         /*
          *  Here, "super," refers to the List l, because it's
          *  the receiver of the mapPrint method which contains
          *  the argument block.
          */
         super push "l3";

         /* break after printing "...l1," "... l2," and four "... l3"
            strings. */
         n = n + 1;
         if (n >= 6)
           break;
       }
       return NULL;
     }

     int main () {

       List new l;

       l push "l1";
       l push "l2";

       l mapPrint;

       exit(0);
     }


If you use 'super' in an argument block within a function, which doesn't
have a receiver object, then Ctalk uses the object that is the receiver
of 'map' or whatever iterative method has the code block as its
argument.

In this case, Ctalk issues a warning so that you know which receiver the
argument block actually refers to.

Determining the Class of 'self'
-------------------------------

Generally, the receiver object that 'self' refers to belongs to the same
class as the method where it appears.  But there are many occasions when
a method cannot assume that it knows in advance the class of 'self', or
the result of an expression that contains 'self'.  This section
describes a few of these situations and how to deal with them.

In many cases, programs can use the method 'is' (defined in 'Object'
class) to determine the class of an object.  The argument to 'is' must
be a declared class, and the method returns True or False, depending on
whether the receiver is an instance of the class given as the argument.

To determine if an object is a class object, use 'isClassObject' (also
defined in 'Object' class), to determine if an object is a class object.

These examples illustrate the different expressions.


     if (self is String) {   /* OK - String is a defined class. */
      ...
     }

     if (self is Class) {    /* Not OK - 'Class' is not a defined class. */
      ...
     }

     if (self isClassObject) {  /* OK - Just check whether the object is
      ...                           its own class object. */
     }


But there are also many cases where the class of a receiver is not be so
clear-cut.  A method might be declared in a superclass of the receiver,
or the method might need to work objects that are members of a
collection, as in this example.  A method might belong to the class of a
collection like 'List' or 'AssociativeArray', but the collection's
elements may be another class entirely.

In collections, the receiver object is actually a group of 'Key' class
objects, which is the "glue" class that provides the organization of the
collection's members.  Each 'Key' object contains a reference to an
object that is part of the collection's actual contents.

The method below is from the 'ctcheckquery.c' example program, and the
receiver contains the parameters and values of a CGI query.

This method can be relatively simple because it can assume beforehand
that the values it is going to print are instances of 'String' class.
The actual receiver is an instance of 'Key' class, so 'self' in this
method understands both the 'name' and 'getValue' methods, which are
defined in 'Symbol' class, which is the superclass of 'Key' class.

     AssociativeArray instanceMethod printQueryParamPair (void) {
       printf ("<tt>%s=", self name);
       printf ("\"%s\"</tt><br>\n", self getValue);
       return NULL;
     }

If a method needs to perform more complex operations on collection
members, it can often cast the collection member to an object of a known
class with either 'become' or just plain '=', depending on the class.
This hypothetical example shows one example of this.


     TreeNode new head;
     TreeNode new siblingObject;

     ... /* Do some stuff. */

     head siblings map {
       siblingObject become self;  /* Ctalk waits until run-time to evaluate a
                                      "self" argument. */

       siblingObject children map {

       ... /* Do some more stuff. */

       }
     }


You can also use a 'Symbol' object to refer to 'self.' Symbol class is
designed to handle references of different classes, so this example also
works.


     TreeNode new head;
     TreeNode new tChild;
     Symbol new tSib;

     ....  /* Do some stuff. */

     head siblings map {
       *tSib = self;
       content = "Child Node";
       tChild = TreeNode basicNew content;
       tChild setContent content;
       tSib getValue addChild tChild;
     }


Still easier, but less flexible, is the 'eval' operator, which tells the
compiler to wait until run time before actually evaluating the complete
expression.


     X11Pane instanceMethod deleteAndClose (void) {

       self children map {
         eval self deleteAndClose;
       }

       ...
     }


And finally, you can use a cast operator to tell the compiler the class
of 'self'.  This feature is still experimental, but it is often more
convenient than using 'eval' or creating an intermediate object.


     TreeNode new head;

     head siblings map {

       printf ("%s\n", self content);

       (TreeNode *)self children map {      /* Here, "(TreeNode *)" tells the
                                                compiler that we expect self
                                                to be a TreeNode object. */
         printf ("  %s\n", self content);
       }

     }


Method Dispatchers
..................

If you must use a complete, original receiver object from a collection
class, then the method cannot alias the original receiver to a local
object.

In this case, the program can use another method to dispatch the
receiver's message to the correct at run time.  For this, the dispatch
method can use the 'eval' keyword.

This situation is frequently the case with complex objects.  Here is an
example from 'ANSIYesNoBoxPane' class that selects the highlight of an
already selected input pane.

The receiver of the 'focusButton' method's 'map' message is the widget's
list of child windows (a 'List'), and this method checks the list
element's class and dispatches the program to the 'highlightButton'
method of class 'ANSIButtonPane'.

     ANSIButtonPane instanceMethod highlightButton (void) {
       if (self hasFocus) {
         self focusHighlightOnOff;
       } else {
         self resetGraphics;
       }
       return NULL;
     }

     List instanceMethod highlightButton (void) {
       Exception new e;
       if (self value is ANSIButtonPane) {
         eval self highlightButton;
       } else {
         e raiseCriticalException INVALID_RECEIVER_X,
           "Receiver of \"highlightButton\" is not an ANSIButtonPane object";
       }
       return NULL;
     }

     ANSIYesNoBoxPane instanceMethod focusButton (void) {
       self children map highlightButton;
       return NULL;
     }

Note that when checking the class, the program uses
     if (self value is ANSIButtonPane) { ...

This is because the receiver, a button widget, is an instance variable
of an 'ANSIYesNoBoxPane' object, so its member class is also
'ANSIYesNoBoxPane', but its _value_ is 'ANSIButtonPane'.

'Exception' handling, for example the use of the 'Exception' object in
the 'List' implementation of 'highlightButton', is discussed further in
the section, 'Error Handling and Debugging.' *Note Debugging::.

You can also write most of a method in C, if necessary.

Here is the 'asInteger' method from class 'Magnitude.' Generally, only
the 'Object' class is completely evaluated before this method, so
'asInteger' needs to perform many of its operations in C. However, it
can use the method 'is' from 'Object' class to determine the class of
the receiver.


     Magnitude instanceMethod asInteger (void) {
       OBJECT *self_value;
       int i;
       long long int l;

       returnObjectClass Integer;

       self_value = self value;

       if (self is Integer) {
         return self;
       } else {
         if (self is LongInteger) {
           sscanf (self_value -> __o_value, "%lld", &l);
           if (l > MAX_UINT)
     	_warning ("Overflow in type conversion.\n");
           i = (int)l;
         }
         /*
          *  Character to int conversion, plus escape sequences.
          */
         if (self is Character) {
           if (*self_value -> __o_value == '\'') {
     	if (self_value -> __o_value[1] == '\\') {
     	  switch (self_value -> __o_value[2])
     	    {
     	    case 'a':
     	      i = 1;
     	      break;
     	    case 'b':
     	      i = 2;
     	      break;
     	    case 'f':
     	      i = 6;
     	      break;
     	    case 'n':
     	      i = 10;
     	      break;
     	    case 'r':
     	      i = 13;
     	      break;
     	    case 't':
     	      i = 9;
     	      break;
     	    case 'v':
     	      i = 11;
     	      break;
     	    case '0':
     	      i = 0;
     	      break;
     	    default:
      	      i = (int) self_value -> __o_value[2];
     	      break;
     	    }
     	} else {
      	  i = (int) self_value -> __o_value[1];
     	}
           } else {
      	i = (int) *self_value -> __o_value;
           }
         }  /* if (self is Character) { */

         if (self is Float) {
           /*
            *  In case Exception class isn't loaded yet, simply
            *  print a warning.
            */
           _warning ("asInteger (class Magnitude): Receiver truncated to Integer.\n");
           i = (int)atof (self);
         }
       }
       methodReturnInteger (i);
     }

Class of a Method Return Object
-------------------------------

Often a program can determine the class of a method's return object from
the class of the receiver.  Sometimes, however, the 'returnObjectClass'
statement is necessary.  Consider the following example from
'X11TerminalStream' class.


     X11TerminalStream instanceMethod parentPane (void) {
       OBJECT *receiver_alias,
         *parent_alias;
       returnObjectClass X11Pane;
       receiver_alias = self;
       if (receiver_alias -> __o_p_obj) {
         parent_alias = receiver_alias -> __o_p_obj;
       } else {
         parent_alias = NULL;
       }
       return parent_alias;
     }
     ...
     self parentPane origin x = event_data1;


If Ctalk couldn't determine that 'parentPane' returns a 'X11Pane'
object, it would not be able to determine that the class of 'origin' (an
instance variable of 'X11Pane') is a 'Point', and that 'x' is an
instance variable of 'origin'.

Defining the object return class also helps in checking the class of
arguments in complex statements.  This helps Ctalk determine what is and
isn't a method argument, as in this example.


     Integer new intA;
     Integer new intB;

     if (intA + intB == 4)
       do something;


Here, Ctalk can determine that '==' isn't part of the argument to '+',
because it returns a 'Boolean', while '+' expects an 'Integer' or an
expression that returns an 'Integer' as its argument.

The method's return class does not actually need to be defined when
Ctalk encounters the 'returnObjectClass' statement.  Ctalk checks later,
after evaluating all of the input, that the class is defined and prints
a warning if it still can't find the class.

Determining the Class of Method Arguments
-----------------------------------------

While we're on the subject, we should mention that methods do not always
know the class of their arguments, either.  If the class of a method
argument can vary, that makes it even more difficult to handle complex
objects that contain numerous instance variables.

One way to deal with arguments of different classes is to duplicate the
argument into the class the method needs, as in this example, the '='
method from 'Integer' class.
     Integer instanceMethod = set_value (int __i) {
       Integer new localInt;
       localInt become __i asInteger;
       __ctalkAddInstanceVariable (self, "value", localInt value);
       return self;
     }

Remember, a method can specify the class or type of an argument, but
that doesn't mean, when the program runs, that the argument actually
_is_ the class that the method expects.

Another issue is trying to print objects.  If you were to write a method
like the following.
     MyClass instanceMethod myMethod (Object myArg) {
        printf ("%s\n", myArg myInstanceVariable);
        return NULL;
     }
Then you would need to make sure that myInstanceVariable is a 'String'.
If possible, Ctalk tries to match the class of an expression with its
context; in the example above, if Ctalk cannot determine the class of
'myInstanceVariable' from the context of the method, it will try to
translate it into a 'char *' argument for 'printf'.

There are a few ways that a method can determine the class of an
expression.  One is to use the 'Object' method 'is', as in the
'asInteger' method in the previous section.

Another solution is to "cast" the argument to a local object using, for
example, the 'Object' method 'become', as in the '=' (class 'Integer')
example above.

Yet another way to deal with an unknown argument class is to use a
'printOn' method.  The method is better than 'printf' at determining an
object's class at run time.
     MyClass instanceMethod myMethod (Object myArg) {
        WriteFileStream classInit;
        stdoutStream printOn "%s\n", myArg myInstanceVariable;
        return NULL;
     }

Many classes implement a 'printOn' method, and it is relatively easy for
a class that you write to define a 'printOn' method also.  The Ctalk
libraries take care of much of the work of translating objects of
different classes and formatting them correctly.

The 'printOn' methods can also use receivers other than stream classes,
so a method could use printOn to format a String, as in this example.
     String instanceMethod myIntConv (int myArg) {
        self printOn "%s\n", myArg myIntVariable;
        return self;
     }


File: tutorial.info,  Node: Collections,  Next: Classes,  Prev: Self and super,  Up: Top

Collections
===========

Collections are groups of objects.  Ctalk has the following main classes
of collections.
   * 'Array' class, which orders elements of a group by a numerical
     index.
   * 'AssociativeArray' class, which orders and retrieves elements using
     a key value.
   * 'List' class objects, which contain groups of objects that you can
     treat sequentially.
   * 'Stream' class objects, which are generally groups of characters
     similar to 'String' class objects, that allow reading and writing
     to the collection.

These classes are subclasses of 'Collection' class.  Here is the section
of the class library that shows the organization of 'Collection' and its
subclasses.
      Collection
       Array
       List
        AssociativeArray
       Stream
        FileStream
         DirectoryStream
         ReadFileStream
         WriteFileStream
        TerminalStream
         ANSITerminalStream
         Win32TerminalStream
         X11TerminalStream
       TreeNode
This chapter provides a description of the basic collection classes,
'AssociativeArray,' 'List,' and 'TreeNode.'

The previous chapters described 'Array' and 'Stream' subclasses (the
classes 'FileStream,' 'ReadFileStream,' and 'WriteFileStream').

The later sections that discuss graphics also discuss the
'TerminalStream' subclasses in the context of providing user input,
because these classes are intended to be used for input from devices
like keyboards and mice.

'List' Class
------------

'List' objects contain, as the class's name says, lists of objects.

If you want to add an item to the end of a 'List,' use the method
'push.'
     List new l;
     Integer new i;
     Integer new i2;

     l push i;
     l push i2;

To remove items from the end of a list and return them, use the method
'pop.'
     List new l;
     Integer new i;
     Integer new i2;
     Integer new i3;
     Integer new i4;

     l push i;
     l push i2;

     i3 = l pop;
     i4 = l pop;

The methods 'shift' and 'unshift' are similar to 'push' and 'pop,'
respectively, but they add and remove items from the front of the list.

Here is a simple, if slightly unwieldy, example of how these methods
work.  You can find this program in 'test/basiclist.c'.
     int main () {

       List new l;
       Integer new i1;
       Integer new i2;
       Integer new i3;
       Integer new i4;
       Integer new i5;
       Integer new i6;

       i1 = 1;
       printf ("%d ", i1);
       i2 = 2;
       printf ("%d ", i2);
       i3 = 3;
       printf ("%d ", i3);
       printf ("\n");

       l push i1;
       l push i2;
       l push i3;

       i4 = l pop;
       printf ("%d ", i4);
       i5 = l pop;
       printf ("%d ", i5);
       i6 = l pop;
       printf ("%d ", i6);
       printf ("\n");

       l shift i1;
       printf ("%d ", i1);
       l shift i2;
       printf ("%d ", i2);
       l shift i3;
       printf ("%d ", i3);
       printf ("\n");

       i4 = l unshift;
       printf ("%d ", i4);
       i5 = l unshift;
       printf ("%d ", i5);
       i6 = l unshift;
       printf ("%d ", i6);
       printf ("\n");

       return 0;
     }
Generally, however, you want to be able to work with 'Lists' of any
length.  The basic method for working sequentially with every item in a
list is the method 'map.'
     List instanceMethod printItem (void) {
       Integer new element;
       element = self;
       printf ("%d ", element);
       return NULL;
     }

     int main () {

       List new l;
       Integer new i1;
       Integer new i2;
       Integer new i3;

       i1 = 1;
       i2 = 2;
       i3 = 3;

       l push i1;
       l push i2;
       l push i3;

       l map printItem;
       printf ("\n");
     }
The argument to 'map,' in this example 'printItem,' must be an instance
method of class 'List,' even though the receiver of each call to
'printItem,' which is each successive member of 'List' 'l' (in
'main()'), can have its own class.

This example uses 'Integers' as list items, so we can assume that 'self'
in the 'printItem' method is always going to be an 'Integer.' But
programs cannot always make assumptions about what class of items a
'List' stores.  *Note self Class Resolution::, for a detailed
discussion.

Some classes, including 'List', allow you to provide an additional
argument to the target method.  In that case, you must use that argument
as the second argument to 'map,' after the name of the method that's
going to do work on each 'List' item.  These sorts of expressions are
easier to write than to describe.  So here's a revised version of the
example above which should make this clearer.

                                   /* Here, "leftMargin" is passed as    */
                                   /* the second argument to map, below. */
     List instanceMethod printItem (String leftMargin) {
       Integer new element;
       element = self;
       printf ("%s%d ", leftMargin, element);
       return NULL;
     }

     int main () {

       List new l;
       Integer new i1;
       Integer new i2;
       Integer new i3;
       String new leftMargin;

       leftMargin = "  ";

       i1 = 1;
       i2 = 2;
       i3 = 3;

       l push i1;
       l push i2;
       l push i3;

       l map printItem, leftMargin;  /* "leftMargin" is the first argument when */
                                    /* printItem is called.                    */
       printf ("\n");
     }

This syntax works only when the argument to 'map' is a separate method,
not with argument blocks.  *Note ArgumentBlocks::.

'List' class actually allows you to pass two additional arguments to the
method that the list maps over.  Extending the number of arguments is
beyond the scope of this tutorial, but Ctalk internally can support a
range of conventions when mapping over 'List' and other 'Collection'
objects.

When initializing 'Lists', you can also use the '=' method to add items
to the 'List', which you may find more convenient.  You could replace
the 'push' methods in the example above with this expression.


       l = i1, i2, i3;


If you also want to skip the assignment statements for 'i1, i2,' and
'i3,' the example above could also be written like this.


       l = 1, 2, 3;


There's more information about initializing 'Lists' and other types of
collections later in the Tutorial.  *Note InitializingCollections::.

To remove all of the items from a 'List' and leave the list as it was
when it was first created, you can simply use the 'delete' method.


     myList delete;


Otherwise, a method like 'pop' removes the object and returns it,
leaving it up to the program to either delete the object or use it
elsewhere.  So if you want to remove (and in this case delete)
individual objects from a 'list,' you can use an expression like this.


     while ((item = myList pop) != NULL)
       item delete;


Or even an expression like this one.


     While (item = myList pop)
           item delete;


Though if you simply say,


     while (myList pop)
      ;


Then the program does nothing with the objects that were formerly stored
in 'myList,' and the expression causes memory leaks, which is especially
noticeable if the program replaces the objects in the 'myList' one or
more times.

Creating Objects on the Fly
...........................

It's often tedious or impractical to declare each 'List' member
separately.  For cases like that, Ctalk has a method called 'basicNew',
which creates objects on the fly, as in this hypothetical example.


     List new myList;
     Integer new listMember;
     Integer new i;
     String new nameStr;
     String new valueStr;

     for (i = 0; i < 10; i = i + 1) {

         nameStr = "List Member " + i asString;
         valueStr = i asString;

         listMember = Integer new nameStr, valueStr;

         myList push listMember;

     }


The 'basicNew' method has several flavors, which are described in the
'Ctalk Reference Manual.'

'AssociativeArray' Class
------------------------

'AssociativeArray' objects store their elements using a 'Key' object.

Programs use the name of the 'Key' object, normally a 'String,' to store
and retrieve elements of the array.  The value of the 'Key' object is
the object that you want to store in the array.

The 'AssociativeArray' class does the work of assigning keys and storing
objects in the arrays for you, using the methods 'at' and 'atPut'.

For example, to store an object, use a statement similar to the
following.
     myAssociativeArray atPut "keyName", myObject;

To retrieve an object, use the method 'at'.
     myObjectFromBefore = myAssociativeArray at "keyName";

You can also treat 'AssociativeArray' elements sequentially, using the
methods 'map' and 'mapKeys'.  The 'Ctalk Language Reference' contains
examples of their use.

If you want to remove an object from an 'AssociativeArray' or another
subclass of 'Collection', use the 'removeAt' method.  The 'removeAt'
method returns the object that was stored in the collection.

The 'Ctalk Language Reference' describes the details of storing and
retrieving 'Key' object names and values.

'TreeNode' Class
----------------

A 'TreeNode' object is a component of a tree data structure.  Each
'TreeNode' object can have sibling and child objects.  The 'TreeNode'
class provides basic methods to add objects to a tree, set each
'TreeNode's' content, and to traverse the tree.

The example program shows two different ways to construct trees.  It
actually builds two trees, which are identified by their head nodes,
'head' and 'head2'.

     TreeNode instanceMethod printNode (void) {
       printf ("%s\n", self content);
     }

     int main () {

       TreeNode new head;
       TreeNode new head2;
       TreeNode new sibling;
       String new content;
       Symbol new sib;
       Symbol new child;
       TreeNode new tSib;
       TreeNode new tChild;
       TreeNode new tChildChild;
       Integer new i;

       content = "Head Node";

       head setContent content;

       head2 setContent content;

       printf ("%s\n", head content);

       for (i = 1; i <= 10; i++) {
         content = "1. Sibling Node " + (i asString);

         *sib = TreeNode basicNew content, content;
         *sib setContent content;
         head makeSibling *sib;

         content = "Child Node";
         tChild = TreeNode basicNew content, content;
         tChild setContent content;
         (*sib) addChild tChild;

         content = "2. Sibling Node " + (i asString);

         tSib = tSib basicNew content, "TreeNode", "Symbol", content;
         tSib setContent content;
         head2 makeSibling tSib;

         content = "Child Node";
         tChild = TreeNode basicNew content;
         tChild setContent content;
         tSib addChild tChild;

       }

       head2 siblings map {
         content = "Child Node 2";
         tChild = TreeNode basicNew content, content;
         tChild setContent content;
         tSib = TreeNode basicNew "Sibling of Child";
         tSib setContent "Sibling of Child";
         tChild makeSibling tSib;
         (TreeNode *)self addChild tChild;

         content = "Child of Child";
         tChildChild = TreeNode basicNew content, content;
         tChildChild setContent content;
         tChild addChild tChildChild;

       }

       printf ("--------------------\n");

       head2 map printNode;
     }

The program uses two different methods to add nodes to a tree, both
contained within the 'for' loop.


         /* Build the first tree by using Symbol objects to refer to the
            tree's nodes. */

         content = "1. Sibling Node " + (i asString);

         *sib = TreeNode basicNew content, content;
         *sib setContent content;
         head makeSibling *sib;

         content = "Child Node";
         tChild = TreeNode basicNew content, content;
         tChild setContent content;
         (*sib) addChild tChild;


         /* Programs can also build trees by using TreeNode objects directly,
            though for complex programs this method may be less convenient. */

         content = "2. Sibling Node " + (i asString);

         tSib = tSib basicNew content, "TreeNode", "Symbol", content;
         tSib setContent content;
         head2 makeSibling tSib;

         content = "Child Node";
         tChild = TreeNode basicNew content;
         tChild setContent content;
         tSib addChild tChild;


Referring to 'TreeNode' objects directly and by 'Symbol' references
produces similar results here.  Using 'Symbol' references, however,
might be more flexible in the case of complex programs.

In each case, adding nodes to the tree uses the same four methods:
'basicNew,' 'setContent,' 'makeSibling,' and 'addChild.'

When run, the program produces output similar to this (somewhat
shortened) example.

     Head Node
     --------------------
     2. Sibling Node 1
     Child Node
     Child Node 2
     Child of Child
     Sibling of Child
     2. Sibling Node 2
     Child Node
     Child Node 2
     Child of Child
     Sibling of Child

     ...

     2. Sibling Node 10
     Child Node
     Child Node 2
     Child of Child
     Sibling of Child


If you want each level of the tree indented, you can use either the
'print' method to print the tree to the screen, or 'format' to format
the tree to a 'String' object.  The class provides the 'levelMargin' and
'levelMarginLength' instance variables, which allow programs to specify
the indentation of each level.

Collection Elements as Receivers
--------------------------------

When using collection elements, programs often don't know until run time
exactly what the class of a receiver might be - elements of object.  In
addition methods like 'map', use each element of a collection as a
receiver.

Collections all use 'Key' objects to store the actual data.  In methods
that use collection elements, programs can either declare a 'Key' object
explicitly, or it can rely on a method in a superclass to determine
whether the receivers are valid.  The 'Ctalk Web Utilities' manual
provides examples of both techniques.

Here is 'getValue' in 'Collection' class, which determines that the
actual receiver of a 'getValue' message at run time is a 'Key' object
and generates an exception otherwise.
     Collection instanceMethod getValue (void) {
       Exception new e;

       if (self is Key) {
         return self getValue;
       }
       e raiseCriticalException INVALID_RECEIVER_X,
         "Message \"getValue\" sent to a Collection object, not a Key object.";
       return NULL;
     }

Ctalk has several ways to cope with ad-hoc classes, which this tutorial
describes further on.  *Note self Class Resolution::.

Using Math Operators with Collections (Still More about Looping)
----------------------------------------------------------------

Earlier this tutorial discussed how overloaded math operators work with
different classes.

Once again, Ctalk overloads the math operators '+', '-', '++', '--',
'+=', '-=', and '*' operators so they can work with collection elements.

More specifically, the operators work with 'Key' objects, so this
section describes the 'Collection' subclasses that use 'Key' objects to
maintain their elements - the classes 'List,' 'Array,'
'AssociativeArray,' and any of their subclasses that a program
implements.

The methods also work with elements of 'TreeNode' objects, with a few
extra steps, and they are discussed below.

Here's an example that saves and prints the elements of a 'List' object.


     int main (int argc, char **argv) {

       List new a;
       Key new k;
       Key new j;
       Integer new i;

       a push "value1";
       a push "value2";
       a push "value3";
       a push "value4";

       k = *a;
       i = 0;

       while (++k) {
         printf ("%s\n",*k);
         if (i == 1) {
             j = k;
             printf ("j = k: %s\n", *k);
         }
         ++i;
       }

       printf ("-------------------\n");
       printf ("%s\n", *j);

     }


When run, the program produces the following output.


     value2
     value3
     j = k: value3
     value4
     -------------------
     value3


You should note that the elements get printed starting with 'value2'.
The reason for this is discussed in the next section.

The expression


       k = *a;


sets the 'Key' object 'k' to the first element of 'a', which is a
'List'.  When the operator '*' is used with a 'Collection', it refers to
the first element of the collection.  When '*' is used with a the 'Key'
object itself, though, it refers to the contents of list element.

That means an expression like


     **a;


can refer to the first element of 'a' also, so an expression like


     printf ("%s\n", **a);


would print


     value1


Further down, the expression


       while (++k) {
         printf ("%s\n",*k);
         if (i == 1) {
             j = k;
             printf ("j = k: %s\n", *k);
         }
         ++i;
       }


sets 'k' to each successive member of the list, then prints its value
(using the expression "'*k'"), and, if 'k' refers to the second element
of the list, sets 'j' to it, so the program can refer to the list
element later.

When 'k' reaches the end of the list, it is set to 'NULL', so the loop
terminates and the program proceeds with the instructions further down.

The main limitation of these operators is that they operate only on
objects that a program declares with 'new' (and 'basicNew' in most
cases).  That means the operators don't have any effect on instance and
class variables.

It is often possible, though, to refer to an object's instance variable
by another object, which the math operators _can_ work with - so, for
example, to loop through a 'TreeNode' object, you might use an
expression like this one.

 test/expect/examples/tree3.c

     TreeNode new tree;
     Key new s;

     _... Add nodes to the tree. ..._

     s = *tree siblings;

     while (s++) {

     _... do stuff ..._

     }


Ctalk's operator precedence evaluates method and instance variable
labels before math operators, so the expressions "'*tree siblings'" and
"'*(tree siblings)'" are equivalent.

Some Things to Look Out For with Math Operators
...............................................

There are a few cautions that you need to observe when overloading math
operators, however.  One of the main cautions is trying to assign a
'Key' to an empty collection, which is almost guaranteed to cause a
program to crash.  So if you're in doubt about the contents of the input
you can check that it isn't empty, or you can check the size of the
tokenized output, as in this code.


     List new tokenList;

     aString tokenize tokenList;

     if (tokenList size > 0) {   _Make sure the list isn't empty..._

     _... then do stuff ..._

     }


Another very critical issue is trying to use math with 'self', if the
program 'maps' over a collection.  That's because 'self' is already the
value of each successive item in the collection, and it's not always
guaranteed that 'self' is going to be a class that you can apply pointer
math to.


     aString tokenize tokenList;

     tokenList map {

       aTok = self + 1;   _Wrong... self is not a Key object._

     }


If you must use math within an argument block, you can try storing the
tokens in an 'AssociativeArray', and then using 'mapKeys' to iterate
over it.


     aString tokenize assocArray;

     assocArray mapKeys {

       aTok = self + 1;

     }


But this relies on what 'self' actually refers to within the code block,
which you need to watch carefully.  And changing the value of 'self' is
almost certain to cause the loop to behave unpredictably.

Also, programs need to take care when trying to cast 'self' to
particular class.


     aString tokenize aList;

     aList map {

       aTok = (Key *)self + 1;

     }

This example only works if 'aList' is, for example, a list of 'Key'
objects, which have the semantics to do what you expect the math
operators to do.

Another caveat is using '++' or '--' in a 'while' loop.  This can cause
the loop to miss members of the collection.


     tok = *aList;

     while (tok++) {          /* tok gets iterated after it retrieves the
                                  value... */

       printf ("%s\n", *tok); /*  so here, tok points to the next member
                                  of the collection.

     }


And here, if you use a prefix operator, the loop still misses members of
the collection.


     while (++tok) {

       printf ("%s\n", *tok);

     }


It's usually more correct to use a 'do'...  'while' loop to iterate over
a collection, as in this example.


     tok = *aList;

     do {

       printf ("%s\n", *tok);

     } while (++tok);


And placing the iteration at the end of a 'while' loop also works.


     tok = *aList;

     while (tok) {

       printf ("%s\n", *tok);

       ++tok;
     }


Another place to exercise caution is when using complex expressions
in-line, for example, as an argument to 'printf ()'.


       // Trim leading spaces.
       if (str matchRegex "^ *\"", offsets > 0)
         printf ("%s\n", str + str matchLength);   // Produces the wrong result.


Ctalk can decide to evaluate the argument separately, which can cause
the receiver to be assigned to the result before the entire expression
is evaluated.  If the operator seems to have no effect, you can try
using 'eval' to tell Ctalk to evaluate the entire expression at once, or
simplifying the terms of the expression.

Both of these examples produce the correct results.


       if (str matchRegex "^ *\"", offsets > 0)
         printf ("%s\n", eval str + str matchLength);

       _... or ..._

       if (str matchRegex "^ *\"", offsets > 0) {
         matchStart = str matchLength;
         printf ("%s\n", str + matchStart);
       }


Another place to be careful is when you try to assign a collection
element to a Key directly.


       *destListPtr = *globalList;

       for (_..._) {
          _... do stuff..._
          (*destListPtr) = (*(globalList + myInt));
       }


This has the effect of changing the object that 'destListPtr' refers to;
basically it reshuffles the members of 'globalList', so you need to be
careful if an expression contains a '*' on the left-hand side of an
assignment.  If you only want to iterate 'destListPtr' over the list,
use something like this.


       destListPtr = *globalList;

       for (_..._) {
          _... do stuff..._
          ++destListPtr;
       }


Here's example of how dereferencing works when using a numerical offset
to retrieve a 'List' element.


     Object class ListWrapper;

     ListWrapper instanceVariable items List NULL;

     int n = 1;


     ListWrapper instanceMethod prOffset (void) {
       String new item;

       self items map {
         item = *(super items + n);
         printf ("%s\n", item);
       }
     }

     int main () {
       ListWrapper new lw;

       lw items push "Item 0";
       lw items push "Item 1";
       lw items push "Item 2";
       lw items push "Item 3";
       lw items push "Item 4";

       lw prOffset;
     }


The main action in this case occurs in the 'prOffset' method.  Here, we
want to retrieve only the _n'th_ element in the receiver list.  We've
placed it inside an argument block, so the keyword 'super' refers to
'prOffset's' receiver while the program is executing in the argument
block's scope.

The important thing to note is the dereference operator in this
expression.


     item = *(super items + n);


Here, 'item' is a 'String' object.  When we want to set its value, we
need to get the list element's content.

The result of the right-hand side of the expression,


     (super items + n)


is a 'Key' object.  That's why the '*' dereference operator is there -
it retrieves the object that the _nth_ position in the list refers to.

Here is another, less compact way to write the 'prOffset' method.


     ListWrapper instanceMethod prOffset (void) {
       Key new item;
       String new content;

       self items map {
         item = super items + l_offset;
         content = *item;
         printf ("%s\n", content);
       }
     }


The main difference is where the dereference operator, '*', occurs
within the method.

And here is yet a third way that we can retrieve the content of the
_n'th_ list element.


     ListWrapper instanceMethod prOffset (void) {
       Key new item;

       self items map {
         item = super items + n;
         printf ("%s\n", *item);
       }
     }


Here, the retrieval of the list's 'String' element occurs when the
'printf' statement is executed.

Class Casting
-------------

Ctalk allows you to cast an object to any class you like.  This allows
programs to take advantage of the semantics that one class provides in
case they're needed for some other class, among having other advantages.

For example, when iterating over collections, a cast can be useful when
you want to work with the actual collection element, instead of a copy.
Look at this hypothetical example


     List new myListOfInts;
     Integer new listElement;
     Key new listKey;

     listKey = *myListOfInts;

     while (listKey) {

       (Object *)listElement = *listKey;  /* This causes the program to
                                             use Object : =, which assigns
                                             by reference, instead of
                                             Integer : = which assigns by
                                             value, so that listElement
                                             is the actual list item, not
                                             just a copy of its value. */

       _... do stuff with listElement..._

       ++listKey;
     }


Of course, it's up to you to insure that the object is valid for the
class you're casting it to.  Class casts, however, work equally well
with objects and 'OBJECT *' C variables.

To find out more about class casting, refer the the section titled,
'Class casting' in the 'Ctalk Language Reference'.

Initializing Collections
------------------------

Most of the examples in this tutorial use a series of 'push' or 'atPut'
methods to initialize collections.  However, several of the subclasses
of 'Collection' class (namely, 'List' and 'AssociativeArray' classes)
also overload the '=' and '+=' math operators so you can initialize a
new collection or add members to an existing collection with one
expression.

The following example initializes 'myList' with a group of 'String'
objects using one statement.


     myList = "string1", "string2", "string3", "string4";


This statement initializes 'myList' to contain exactly the four 'String'
objects given as arguments.  If the program added any members to
'myList' before this statement, they are first removed from the list.

To add members to 'myList' without affecting the current contents of the
list, use the method, '+=.'


     myList = object1, object2, object3, object4;

     myList += object5, object6, object7, object8;


This results in 'myList' containing eight member objects.

Here is the example from the section discussing 'Lists', slightly
abbreviated.  *Note ListClass::.


                                   /* Here again, "leftMargin" is passed as */
                                   /* the second argument to map, below. */
     List instanceMethod printItem (String leftMargin) {
       Integer new element;
       element = self;
       printf ("%s%d ", leftMargin, element);
       return NULL;
     }

     int main () {

       List new l;
       String new leftMargin;

       leftMargin = "  ";

       l = 1, 2, 3;

       l map printItem, leftMargin;  /* "leftMargin" is the first argument when */
                                    /* printItem is called.                    */
       printf ("\n");
     }

'AssociativeArray' class also overloads '=' and '+=,' but the methods
interpret the argument list as a set of _key_, _value_ pairs.


     myArray = _key1_, _value1_, _key2_, _value2_, _key3_, _value3_, ... ;


The 'keyN' arguments may be either a String constant or simply a label-
Ctalk interprets them as the key names regardless of their class when it
creates the receiver's keys.  The 'valueN' argument can be whatever the
receiver 'AssociativeArray' needs to contain.

Here's a brief example program that initializes and then prints the
contents of an 'AssociativeArray'.


     int main () {
       AssociativeArray new a;

       a = "key1", "first", "key2", "second", "key3", "third", "key4", "fourth";
       a += "key5", "fifth", "key6", "sixth", "key7", "seventh", "key8", "eighth";

       a mapKeys {
         printf ("%s --> %s\n", self name, *self);
       }
     }


As the tutorial mentioned above, the 'keyN' objects do not need to be
'String' contsants, they can simply be objects that are created when the
argument is parsed, and can be used to name the 'Key' objects in the
receiver collection.

That means that statements like these would work equally well to
initialize the 'AssociativeArray' in the previous example.


       a = key1, "first", key2, "second", key3, "third", key4, "fourth";
       a += key5, "fifth", key6, "sixth", key7, "seventh", key8, "eighth";



File: tutorial.info,  Node: Classes,  Next: Methods,  Prev: Collections,  Up: Top

Defining Classes and Objects
============================

The previous chapters described some of the methods that the Ctalk
classes define.  This chapter discusses in further detail how to define
Classes and variables that belong to the classes, and discusses some of
the ways that Ctalk initializes instances of a class.

Many of the methods used in this chapter are _primitive_ methods.  The
primitive method definitions are in the 'Object' class, and any class
can use them.

Superclasses
------------

At a minimum, a class definition defines the name of the new class and
its superclass.  The primitive method 'class' ('Object' class) takes the
name of a new class as its argument.  The new class is defined in the
class library as a subclass of the receiver's class.

This statement defines a class with the name 'WriteFileStream' as a
subclass of the receiver, 'FileStream.'
     FileStream class WriteFileStream;

Or, more generically,
     SUPERCLASSNAME class NEWCLASSNAME <DOCSTRING>;

This declaration is necessary for Ctalk to identify the file as a class.

The SUPERCLASSNAME indicates where the class fits into the class
library, and that determines which methods and instance data the new
class inherits.  The only class that does not have a SUPERCLASSNAME is
'Object,' the topmost class in the class library.  'Object' class is
loaded by default and doesn't require a class declaration.

The DOCSTRING element is optional; it's a human readable description of
the class.  It's simply text enclosed in double quotes between the
CLASSNAME and the final semicolon.  Here's the previous example with a
possible documentation string added.


     FileStream class WriteFileStream
     "Defines the methods and instance variables that write data to files. Also
     defines the class variables stdoutStream and stderrStream, which are the
     object representation of the standard output and standard error streams.";


It's necessary that the superclasses of the new class already be
defined.  That statement may seem obvious, but the definitions of class
and instance variables that the new class inherits must already be
present.  That can sometimes be tricky when defining basic classes.

Another reason is that, when you define an instance or class variable,
the variable _is a member of your new class,_ unless you specify that
the variable belongs to another class.  If your class can inherit class
variables, instance variables, and methods from the class's
superclasses, then they get used by the new class also.  Any new
variables and methods only need to be referenced by the class you're
defining.

However, you can direct Ctalk to initialize other classes if your class
needs them, by using, for example, statements like 'require,' as
described below.

_Note:_ As mentioned above, when dealing with a basic class like
'Object' or 'Symbol', a method _can't_ always depend on a class being
defined.  During initialization, Ctalk programs 'require' a number of
basic classes: 'Object,' 'Symbol,' 'Integer,' and 'ArgumentList,' and
their required classes 'Magnitude' and 'Character.'

If, for example, you define a method in class 'Symbol' to print objects,
you cannot use 'WriteFileStream' class, which needs 'Symbol' and its
methods already defined.  That would mean 'Symbol' class needs to look
up 'WriteFileStream,' which needs to look up 'Symbol,' which needs to
look up 'WriteFileStream' again, and so on.

Ctalk doesn't necessarily stop you from writing programs with circular
class references - its method prototyping mechanism can often compensate
by checking definitions from different classes as needed, but in cases
where Ctalk can't resolve circular references, then it's necessary to
add methods or instance variables in subclasses.

The previous chapters have described some of the ways that you can work
with instance data using C. Many of the Ctalk library's API functions
also check for the type and value instance data.  The method API is
described later on.

Instance Variables
------------------

We mentioned already that all objects have a default instance variable
named 'value.' However, many classes define other instance variables.
Classes define instance variables with the 'instanceVariable' method.

Here is an example of an instance variable definition.
     MyNewClass instanceVariable textMessage String NULL;

This example declares that all instances of 'MyNewClass' will have an
instance variable named 'textMessage,' and that it is an instance of
class 'String,' and it has the initial value 'NULL.'

The second and third arguments of 'instanceVariable' are optional.  Here
is the syntax of the 'instanceVariable' method.
     CLASSNAME instanceVariable VARNAME [VARCLASS|TYPECAST_EXPR] [INITIALVALUE]

Remember that 'instanceVariable' only _defines_ variables.  The method
does not actually create them.  When you create an object that is an
instance of your class, the object gets its own copy of the variable.

If the program declares a variable with a type cast instead of a native
class for the variable, Ctalk matches the type cast to a class.  If the
type cast of the variable is a pointer to some data type that is not
commonly used in Ctalk or C programs, then Ctalk simply translates the
native type to 'Symbol'.  This is because the program needs to implement
its own methods for handling the data, and 'Symbol' is the most generic
class that Ctalk can use for referring to C data in memory.

Class Variables
---------------

On the other hand, the 'classVariable' method creates the single copy of
a class variable that the instances of a class (and most other classes)
can use.  Creating a class variable is similar to creating an instance
variable.
     MyNewClass classVariable systemError Integer 0;

For completeness, here is the 'classVariable' method's syntax.
     CLASSNAME classVariable VARNAME [VARCLASS|TYPECAST_EXPR] [INITIALVALUE]

Remember that if you define a variable as a different class than its
member class, then the variable responds to messages of its own class.
In these cases, you need to take care that you are working with the
variable, and not the class that it belongs to.

If the variable's native type is declared with a type cast, then Ctalk
tries to translate the type cast into a Ctalk class, as described in the
previous section.

Class Initialization
--------------------

Although you can define an initial value for a class variable, in many
cases you need to wait until the program is run before setting the
actual value of a class variable.  An example of this is 'stdoutStream'
(class 'WriteFileStream').

In many cases, a constructor method (which in Ctalk are named 'new'),
can call a class initialization method.

Here is a hypothetical class with 'classInit' a method.  This example
simply sets the the name of the system in a class variable called
'hostName.'

     MySuperClass class MyClass;

     MyClass classVariable myClassVar String NULL;

     _..._
     _Other class and instance variable definitions._
     _..._

     MyClass classMethod classInit (void) {

       OBJECT *classObject_object,
         *classInitVar_object,
         *myClassVar_object;
       char buf[MAXLABEL];

       /*
        *  Return if we've already initialize the class.
        */
       if (self classInitDone)
         return NULL;


       /*
        *  Retrieve the class object, because we'll need it below.
        */

       classObject_object = __ctalkGetClass("MyClass");

       /*
        *  Look for myClassVar.
        *  The third argument of __ctalkGetClassVariable instructs the
        *  function not to print a warning if it doesn't find the
        *  variable.  If the variable is not present, then the class
        *  is not completely initialized, so return.
        */

       if ((myClassVar_object =
         __ctalkGetClassVariable (self, "myClassVar", FALSE)) == NULL) {
         return NULL;
       }

       _..._
       _Initialize myClassVar here._
       _..._

       classInitVar =
         __ctalkCreateObjectInit ("classInitDone", "Integer",
                                  "Magnitude", GLOBAL_VAR, "1");
       __ctalkAddClassVariable (classObject, "classInitDone", classInitVar);

       return NULL;
     }

     _..._
     _Other methods._
     _..._

When writing classes, you need to remember that Ctalk initializes the
class and its methods and data in the following order.
  1. The class itself and its superclass.
  2. The class' instance and class methods.
  3. Instance variables.
  4. Class variables.

Remember that a class definition only requires a superclass.  All of the
other elements are optional.

It is possible, when initializing complex classes, to construct objects
before the class is completely defined.  That's why 'classInit' above
checks for the class variable 'myClassVar' and returns if it is not
present.

However, Ctalk checks the class initialization every time it creates an
instance of 'MyClass,' so a constructor method for MyClass might look
like the following.

     MyClass instanceMethod new (char *myObjectName) {

       MyClass super new myObjectName;

       __ctalkInstanceVarsFromClassObject (myObjectName);

       MyClass classInit;

       return myObjectName;
     }

The program then initializes the class variables when the class is
completely defined.  If 'classInitDone' is 'TRUE,' then the program
won't initialize the class again.

_Note:_ Ctalk does not automatically create a copy of a class's instance
variables when creating objects.  Your program must call
'__ctalkInstanceVarsFromClassObject' to create the instance variables in
the new object.

If you simply want to initialize a class without creating a new object,
you can add a statement like this to your program.
     MyClass classInit;

Another example of a method that performs class initialization is the
method 'initDigits' (class 'ClockDigit') in the program 'ltime.c.' The
method is too long to list here, but you can find 'ltime.c' in the Ctalk
distribution's 'demos' subdirectory.

The later chapters describe methods and library functions that perform
class initialization in more detail.

'require' Keyword
-----------------

Ctalk programs initialize the basic classes before starting to
initialize the application's class and method definitions.  However, if
your definition needs a class that Ctalk does not automatically include,
you can initialize the class and include its method and variable
definitions before defining your own class by using the keyword
'require.'


     require Boolean;


This can be useful if you write a class and Ctalk outputs a message like
this one.


     prefix34.c:13: Method raiseException," (class Exception)
          used before it is defined.


In that case, you might want to add 'require Exception;' at the
beginning of the class.

If that doesn't help, another tactic is to add a method to the new class
that duplicates the function of the yet-to-be- defined method.  Yet
another tactic is to create a unique subclass that contains the method
you need.

One issue is that the superclass of 'require's' operand (in the example
above, that's 'Boolean's' superclass, 'Object') is already completely
defined, or the definitions in the input file that contains the
'require' statement can cause circular class references.

However, these errors occur during compilation.  If you can write a
method that does what you want at run time, then that may be another yet
strategy that you can use.  For example, if you write an expression like
this in a basic class like 'Symbol', you'll get "Method used before
definition" errors.


     /* The reference to Key class requires methods that aren't defined yet. */

     if ((arg is Symbol) || (arg is Key)) {
        ...
     }


Instead, 'Object' class contains the method 'isSubClassOf', which
doesn't require the compiler to determine the class of 'arg' beforehand,
because the method evaluates the class of 'arg' at run time.


     if (arg isSubClassOf "Symbol") {

        ...

     }


It's useful for Ctalk to limit additions the basic classes.  You can add
a method to an existing class by defining the method in a source file
(which is evaluated after all of the basic classes are evaluated), but
you can't add another library file to an existing class.  This requires
more planning when adding subclasses and methods, but it also makes the
compiler trimmer.

Where Ctalk Looks for Class Libraries
-------------------------------------

When compiling programs, Ctalk looks for class libraries in the
following order.
  1. Directories named as arguments to the '-I' command line option.
  2. Directories named by the 'CLASSLIBDIRS' environment variable.
  3. Ctalk's directory for the standard libraries.

Ctalk applications occasionally need to look up a class library when
they are run.  In that case, the program searches directories in the
following order.
  1. Directories named by the 'CLASSLIBDIRS' environment variable.
  2. Ctalk's directory for the standard libraries.

The directory where the standard libraries are located is determined
when Ctalk is built and installed.  This directory defaults to
'/usr/local/include/ctalk' on UNIX systems.  For more details, refer to
the entry for the '__classLibraryPath()' function in the language
reference.

Ctalk expands directories to their fully qualified names, so if you
build a program with a command like this:
     $ ctcc -I . myprogram.c -o myprogram
Then Ctalk expands the '.' to the full path of the current directory,
and searches for class libraries in the current directory in addition to
the directories it normally searches.

In addition, for each search directory, if a subdirectory named 'ctalk'
exists, then Ctalk searches that subdirectory also.

The 'classSearchPath' method, defined in 'Application' class, returns a
'String' that contains the class search path.  This example prints the
search path, with each directory separated by a colon (':').
     int main () {
       Application new app;
       printf ("%s\n", app classSearchPath);
     }

The '--printlibdirs' command line option prints the directories that
Ctalk searches, one directory per line.

Instance Variables and Method Overloading
-----------------------------------------

One consequence of all this convenient instance data and overloaded
methods is that it is easy to confuse which method a message actually
translates into.  That is because the member class of an instance or
class variable might not be the class of the variable's own instance
data.

Here is an example.  The 'openOn' message in the first statement
translates to the 'openOn' method in the 'ANSITerminalPane' class, while
the 'openOn' message in the second statement translates to the 'openOn'
method in the 'ReadFileStream' class.
     ANSITerminalPane new mainWindow;

     mainWindow paneStream openOn "/dev/ttyS0";               /* Correct.  */

     mainWindow paneStream inputHandle openOn "/dev/ttyS0";   /* Incorrect. */

This is because 'inputHandle' in the second statement is actually a
'ReadFileStream', while the program actually wants to call is the
'openOn' method from 'ANSITerminalStream', which is the effect of the
first statement.  The 'Stream' classes have many classes in common.  In
most cases this makes things simpler, but not always.

There are several ways to work around this issue.  This first is to use
stack walkbacks and exception handlers whenever a program opens a file.
That allows you to see what methods the program's statements actually
translate into.  *Note Debugging::.

If you can't avoid an incorrect message translation in a program, you
can write your own method that only one of your program's classes
responds to.  For example, instead of yet another 'openOn' method, your
program might define a method like, for example, 'openOnInputData'.

Finally, if the program cannot determine in advance which class is going
to receive a message, you can write a method that dispatches the
receiver to a method of the correct class.  Here is an example.
     Stream instanceMethod openOnTerminal (String pathName) {
       Exception new e;
       if (self is ANSITerminalStream) {
         if (pathName isATty) {
           self openOn pathName;
         } else {
           e raiseException NOT_A_TTY_X, pathName;
         }
       } else {
         e raiseException INVALID_RECEIVER_X, pathName;
       }
       return self;
     }


File: tutorial.info,  Node: Methods,  Next: Graphics,  Prev: Classes,  Up: Top

Writing Methods
===============

Languages like C identify and call functions by matching a label in the
source code against an identifier in an object module, and the compiler
(or more properly, the linker or interpreter) inserts a call to the
function in the program.

In Ctalk, like many other object oriented languages, objects respond to
_messages_ that refer to methods defined by the object's class or the
object's superclasses.

_Note:_ The following sections contain a lot of material, the importance
of which may not be immediately clear.  If necessary, you should skip
ahead to the section, 'Assigning Values,' to see how these concepts fit
together.  *Note Assigning Values::.

Here is an example.  If you wanted to create a new 'WriteFileStream'
object, you would add a statement like this to the program.
     WriteFileStream new myOutputStream;

For the moment, we should also mention that most constructor methods
should first contain a 'super new' message like this one.  (We'll
discuss the process in more detail later on.)
     WriteFileStream super new fileStreamName;

When the receiver, 'WriteFileStream,' receives the message, 'new,' the
process of executing the methods that create a 'WriteFileStream' object
works in the following manner.
     Class                  Message    Action
     -----                  -------    ------
     |- Object <-------------- new        2. Return new, generic object.
     |                           ^                  |
     |- Stream                    \                 |
     |                             \                |
     |- FileStream                  \               |
     |                               \              |
     |- WriteFileStream <----- new     1.Execute    |
                                       "super new." |
                                                    v
                                                   3. Add the instance variables
                                                   that WriteFileStream objects
                                                   need and initialize the class
                                                   if necessary.

Here is a typical method.  This is the instance method
'parseQueryString' (class 'CGIApp.') The 'CGIApp' class is in the Ctalk
'demos/cgi' subdirectory and is used by the Common Gateway Interface
programs in that directory.

     CGIApp instanceMethod parseQueryString (void) {
       String new queryString;
       String new paramString;
       Array new queryParams;
       Array new paramArray;
       Integer new nParams;
       String new paramKey;
       String new paramValue;
       Integer new i;
       Integer new j;

       queryString = self serverEnvironment at "QUERY_STRING";

       if ((queryString length == 0) || (queryString isNull)) {
         return NULL;
       }

       nParams = queryString split '&', queryParams;

       for (i = 0; i < nParams; i = i + 1) {
         paramString = queryParams at i;
         j = paramString split '=', paramArray;
         if (j == 1) {
           self queryValues atPut (paramArray at 0), "1";
         } else {
           if (j == 2) {
     	self queryValues atPut (paramArray at 0), (paramArray at 1);
           }
         }
       }
       return NULL;
     }

The 'parseQueryString' method parses the parameters of a CGI query and
places them in the application's 'queryValues' instance variable, an
'AssociativeArray.' The 'queryValues' instance variable then contains
the key-value pairs of each of CGI application's parameters.

If you call a CGI application with a URL like the following example
     http://my-web-server/cgi-bin/mysearchprog?term=ctalk&case=ignore&showresults=10
Then 'parseQueryString' sets the application's 'queryValues'
'AssociativeArray' to the following.
                       Key          Value
     queryValues  at   term         ctalk
     queryValues  at   case         ignore
     queryValues  at   showresults  10
The 'parseQueryString' method uses the 'split' method (class 'String')
several times to split the query string at the '&' delimiters, and then
each parameter and its value at the '=' character.  If a parameter is
defined but does not have a value associated with it, 'parseQueryString'
assigns it the value of '1'.

You should also note that the method checks for both a zero-length input
value, and an _uninitialized_ input value with the method 'isNull',
which might occur, in this example, if the environment variable
'QUERY_STRING' is not defined.

Overview of the Method Application Programming Interface
--------------------------------------------------------

You might recall from the earlier chapters that if a program uses an
operator like '+' or '-' with a C variable, then Ctalk treats the
operator as a C math operator.  However, if you use a math operator with
an object as the receiver, then Ctalk uses a method to perform the
operation.

Ctalk's base classes and methods are located in Ctalk's class library.
On UNIX systems, the class library normally resides in
'/usr/local/include/ctalk', although the location may vary depending on
the operating system.

If you write your own methods, you might want to keep them in their own
directory.  In that case, the '-I' command line option includes the
directory given as its argument in the class search path.  To include
the current directory in the class search path, the command line option
'-I .' is a convenient shorthand.

Primitive Methods
.................

One exception is the way Ctalk implements _primitive methods._  Ctalk
implements these methods in C, and you can call them without worrying if
a program defines a class.

These methods are available to all classes, so they effectively belong
to the 'Object' class.  You can also subclass these methods, as is often
the case with the constructor 'new'.  The previous chapters have
described in general how to subclass methods, and this manual describes
the process in detail later on.

Here are the primitive methods that Ctalk defines.
'class CLASSNAME'
     Defines a new class.  The receiver is the name of the superclass,
     and the argument is the name of the class that you want to create.

'classMethod ALIAS SELECTOR (ARGS)'
     Declares a new class method.  The next section describes the syntax
     of method declarations.  *Note Method Declarations::.

'classVariable VARNAME VARCLASS INITIAL-VALUE'
     Declare a class variable.  The receiver is the class of the
     variable.  You must provide a NAME for the class variable.  The
     statement also allows you to define a class for the class variable
     and an initial value.  *Note Class Variables::.

'instanceMethod ALIAS SELECTOR (ARGS)'
     Declares a new instance method.  The next section describes the
     syntax of method declarations.  *Note Method Declarations::.

'instanceVariable VARNAME VARCLASS INITIAL-VALUE'
     Define an instance variable.  The receiver is the class of the
     variable.  Unlike class variables, 'instanceVariable' only defines
     a variable's declaration.  A constructor like 'new' creates the
     actual instance variables when it creates an object.  *Note
     Instance Variables::.

'new NEWOBJECTNAME'
     Create a new object.  The receiver of 'new' is the object's class.

_Note:_ You might need to use only primitive methods and library
functions if you need to define a method in a basic class like 'Object'
or 'Symbol', where a method can't always depend on a class being
defined.  During initialization, Ctalk programs 'require' a number of
basic classes: 'Object,' 'Symbol,' 'Integer,' and 'ArgumentList,' and
their required classes 'Magnitude' and 'Character.' If, for example, you
define a method in class 'Symbol' to print objects, you cannot use
'WriteFileStream' class, which needs 'Symbol' and its methods already
defined.  So if you write a method that needs classes other than these
basic classes, it is better to define a class specifically for your
program.

Instance and Class Variable Messages
....................................

For completeness, we should mention that the other exception in the
method API is the use of instance and class variable names as messages.

The 'value' message is an example of a message that refers to an
instance variable.  Remember that a statement like the following example
returns only the instance variable, and not the complete object.
     return self value;

Instance variable messages are useful mainly when creating C references
to objects.  Methods, on the other hand, generally work with complete
objects.  An example is the 'at' method in class 'Array'.
     myElement = myArray at 0;

The message 'at' returns the _0_th array element.

When you use objects with C, you must also check to determine that the
object references are really the objects that the program expects.

The following sections describe the Ctalk interface to C, and the many
of the examples in this manual describe Ctalk's C API.

Method Declarations
-------------------

As you probably noticed from the example above, you can declare methods
in much the same manner as C functions.

However, method declarations have a different meaning, and the
declarations allow for multiple methods with the same name in different
classes.

The following example is the basic syntax of an instance method
declaration.
     CLASS instanceMethod [ALIAS] SELECTOR (ARGS) {
     ... Method body
     }

The third term, ALIAS, is optional.  It is often used to alias a method
to an operator like '+', '-', or another operator that you want to
overload in CLASS.

The syntax of a class method declaration is similar, but it uses the
'classMethod' method.
     CLASS classMethod [ALIAS] SELECTOR (ARGS) {
     ... Method body
     }

How Methods Interface with C
----------------------------

Methods can be either labels or C operators.  Although Ctalk's syntax is
similar to C, it allows more flexibility in the construction of
statements.

As we noted earlier, you can change characters from upper case to lower
case and vice versa by toggling the fifth bit of the character.  Here is
that example again.
     Character new upperCase;
     Character new lowerCase;
     Integer new toggleBit;

     upperCase = 'Z';
     lowerCase = 'z';
     toggleBit = 32;

     printf ("%c\n", upperCase ^ toggleBit);
     printf ("%c\n", lowerCase ^ toggleBit);

The '^' operator in these statements is actually a method in class
'Character'.

Ctalk also provides two methods in 'Character' class, 'toUpper' and
'toLower', that provide the same function, and the methods also check
that the receiver is a letter of the appropriate case before changing
the case.

Here is the 'toLower' method.
     Character instanceMethod toLower (void) {
       Character new result;

       if (self isAlpha && self isUpper) {
         result = self asInteger ^ 32;
       } else {
         result = self;
       }
       return result;
     }

We could omit the 'asInteger' message, but using 'asInteger', which is
implemented in 'Magnitude' class, allows us to reliably check that the
receiver of '^' is actually a valid number, even if the receiver of
'toLower' is the result of another statement that translates its value
from a completely different receiver elsewhere in the program.

The result of 'self asInteger' is an 'Integer' object, so it uses '^'
from 'Integer' class to perform the translation.

The 'asCharacter' method, like 'asInteger', is defined in 'Magnitude'
class.

The 'value' message in the example above is optional.  Ctalk sends
method arguments as complete objects.

Ctalk statements can appear in many of the places that a C expression
can appear.  Here is another simple example.
     int main () {
       String new ten;
       ten = "10";
       printf ("%d\n", ten asInteger);
     }

As a general rule, keep in mind that receiver objects and other methods
that are part of complex statements work with objects.

There are many cases, however, when you need to use a message like
'value' in a statement to return an instance variable - generally when
you are using objects with C statements, which the next section
describes.

The 'value' Message and Interfacing with C
------------------------------------------

We have already described how refer to objects with C variables in many
places.  This section provides a slightly more formal definition of how
and when to use 'value'.

If you are assigning an object to a C variable, then in most cases you
want to use the 'value' message.  This message, you might remember from
previous chapters, returns the receiver's 'value' instance variable.

So if you want to assign an object's value to a C variable, you might
use a set of statements like the following.
     OBJECT *value_object;
     value_object = self value;

You should _not,_ however, simply use an object like 'self' on its own,
because Ctalk cannot determine exactly how you plan to use the result.
The following example will provide the complete object, which is not
what you want.
     OBJECT *value_object;
     value_object = self;

It is okay, however, to use an object name on its own when used with
other objects.
     Object new receiverObjectCopy;
     receiverObjectCopy = self;

Once you have assigned an object to a C variable, you can treat it as a
C 'struct'.  The next section describes the 'OBJECT' C 'typedef'.

The 'OBJECT' Type
.................

Ctalk represents objects internally as an 'OBJECT' typedef, so when you
need to use an object in a C statement, you can create a C alias for the
object by declaring and initializing a C 'OBJECT *'.

Here is the 'OBJECT' type declaration, without some of the
machine-specific definitions.  It is located in the file
'classes/ctalklib', and several other places.
     struct _object {
       int sig;
       char __o_name[MAXLABEL];
       char __o_classname[MAXLABEL];
       OBJECT *__o_class;
       char __o_superclassname[MAXLABEL];
       OBJECT *__o_superclass;
       OBJECT *__o_p_obj;
       VARENTRY *__o_varentry;
       char *__o_value;
       METHOD *instance_methods,
         *class_methods;
       int scope;
       int nrefs;
       struct _object *classvars;
       struct _object *instancevars;
       struct _object *next;
       struct _object *prev;
       int attrs;
     };

So when a program uses statements like those in the following example,
the program is actually creating a C reference to an object.
     OBJECT *rcvr_value;
     rcvr_value = self value;
Here, '=' is a C operator.  Ctalk evaluates the 'value' message, and
then determines that it doesn't need to perform further translation on
the objects because the receiver simply needs the 'value' instance
variable as C 'struct'.

Generally, C programs are mainly interested in the '__o_value' field of
an 'OBJECT *', because this is where objects store their data as C 'char
*''s.

There are also API C functions, like '__ctalk_to_c_char_ptr ()' and
'__ctalk_to_c_int ()', that translate objects to C. The 'Ctalk Language
Reference' describes these functions.

Return Values
-------------

Methods can return any type of value.  Ctalk can usually figure out what
how to translate a C language value into a form that it can use
internally.

These are all valid return statements.


     return "hello!";
     return a;
     return a + 2;
     return TRUE;
     return self;
     return myObject className;


Occasionally, a method may need to return the result of a complex
expression or an expression whose result isn't known until run time.  In
that case, you can use the 'eval' keyword to tell Ctalk to wait until
the program is run before evaluating the expression, as in this example.
     return eval <expression>;

Ctalk treats methods that return arrays a little differently.  For a
method to return a C array, the array must be explicitly declared; that
is, the following definition is translatable into an 'Array' object,
     int i[10];
while this statement is not.
     int *i;
For a method to return a C array, the method's definition must specify
that it returns an 'Array' class object.

Otherwise, the object might not be directly translatable to a basic
Ctalk class, and in that case you should consider assigning the variable
to a 'Symbol' object and returning a reference to the variable.  The
same is true of multi-dimensional arrays, like this one.
     int i[10][10];
Again, if a method needs to return a multi-dimensional array, it should
consider assigning to to a 'Symbol' object and returning a reference to
the method.

The size of a returned 'Array' is the same as the size of the array
declared in C, regardless of how the method initializes the C array
members.  You need to keep that in mind when returning C arrays that may
or may not have their members initialized.

Ctalk treats arrays declared as 'char[SIZE]' as 'String' objects, unless
the method's definition says it returns an 'Array', in which case the
method returns an 'Array' with each member being a 'Character' object;
otherwise, methods return 'String' objects for 'char[]' declarations.

Occasionally, you may find that you need to write a method that declares
a return value's class explicitly.  In these cases, Ctalk also provides
a number of method return statements; e.g.; 'methodReturnInteger' and
'methodReturnTrue'.  The 'Ctalk Language Reference' contains a complete
list of them.

Object References within Methods
--------------------------------

In a previous section, we described a few of the principles of object
references.  *Note Object References::.  This section briefly mentions a
few aspects of working with actual references within methods.

There are many examples of methods that use object references in the
Ctalk class libraries.  Here, we'll mention only a few things to keep in
mind when using references in your own methods.

Each member of a collection like an 'AssociativeArray' object, is a
'Key' object.  A 'Key' object has two components: a name that is used as
a _key_ to look up the object, and a _value_ that is a reference to the
object that belongs to the collection.  'Key' objects are a more
specialized subclass of 'Symbol', and the 'Key' class implements several
methods to work with 'Key' objects' labels.

The most important thing to note when working with references, however,
_is that they can originate anywhere in a program,_ and your method
should not make assumptions about where that object was declared.

However, your method can use the scope of an object to determine how it
is used.  For example, it can add or remove a 'VAR_REF_SCOPE' or
'METHOD_USER_OBJECT' scope from an object.  Object scopes are described
more thoroughly in the 'Ctalk Language Reference'.

It's important to remember that the main point of using object
references is that when you change the value of an object, that value
changes for _every_ occurrence of that object in a program.

This is often useful for complex objects that persist throughout the
life of a program, like 'Pane' objects, which are described below, but
it can also cause confusing and seemingly unrelated errors elsewhere in
programs if you are not careful.

Just as often, however, you may only need to change the value of an
object within a method.  In that case, it is often easier and safer to
work with a copy of the object.  In addition to library functions like
'__ctalkCreateObjectInit' that create objects, Ctalk provides several
methods that can alter or duplicate objects.  *Note Variable Promotion
and Type Conversion::.

Assigning Values
----------------

The preceding sections contain a lot of material to digest, and that is
at least partially because there can often be several different ways to
write a method.

One basic method that many classes implement is an overloaded '='
operator, which Ctalk refers to internally as 'set_value', 'setEqual',
or another similar identifier.

The function of the '=' method is simple-it sets the value of the
receiver object to its argument.  However, an assignment operator needs
to be able to handle any type of object it is likely to encounter, which
makes the method more complicated.  The following sections discuss some
of these factors.

The '=' Method from 'Integer' Class
...................................

One thing objects have in common is that they all have _values._
Generally, the value of an object is contained in an instance variable
named, naturally enough, 'value.' All new objects have a 'value'
instance variable, though some classes (like 'List' class) may
re-implement its value object(s) differently.

The 'Object' class defines a method, 'addInstanceVariable', which works
nicely for this purpose.  So a basic '=' method could simply use
'addInstanceVariable'.
     Integer instanceMethod = set_value (int __intArg) {
       self addInstanceVariable ("value", __intArg value);
       return self;
     }
Note that the method declares its argument, '__intArg,' as an 'int', not
'Integer.' Ctalk commonly uses C arguments in its basic classes in order
to avoid circular object references.  (I.e., we couldn't easily define
an 'Integer' object while the 'Integer' class itself is still being
defined.)

The method above works fine, assuming that the argument is also an
'Integer' object.  However, often you might want to assign a
'Character', or a 'LongInteger', or a 'Float' to an 'Integer' object.

Ctalk methods can handle arguments of any class.  Internally, it uses
the parameter definition to implement basic argument checking, but the
definition is mainly a prototype that tells the method what sort of
argument to _expect,_ though the parameter definition is not a
hard-and-fast rule.  Generally, methods can implement their own argument
checking when it's necessary.

Ctalk provides another method, 'asInteger,' defined in 'Magnitude'
class, which you can use for the purpose of type conversion.  The
'asInteger' method converts other basic scalar types into
'Integer'-compatible values.

If we add an 'asInteger' message, our '=' method might look like this.
     Integer instanceMethod = set_value (int __intArg) {
       self addInstanceVariable ("value", __intArg asInteger value);
       return self;
     }
Now we'll discuss one of the curves in the road.  Suppose that
'__intArg' is referred to somewhere else in the program.  (It doesn't
matter where else, it could be _anywhere_ else.)

The receiver's value must be unique within its scope.  While it sounds
nice in theory to be able to refer to a single object everywhere, the
program must still regard scoping rules.  (Though there are many
classes, like the 'Pane' class and subclasses, where programs need to
pass objects by reference in many different places.)

If that's the case, the method can work on a unique instance of the
argument.  The method does this with the 'copy' (class 'Object') method
and a local object.
     Integer instanceMethod = set_value (int __intArg) {
       Integer new localInt;
       localInt copy __intArg asInteger;
       __ctalkAddInstanceVariable (self, "value", localInt value);
       return self;
     }
The 'copy' and 'become' methods (both of them are in 'Object' class)
allow you to change objects from one class to another, but there is an
important difference.  The 'copy' method creates a unique copy of its
argument, while 'become' converts the original object into the receiver.
(Variable promotion and type conversion are discussed in detail
elsewhere.  *Note Variable Promotion and Type Conversion::.)  So in this
case, the '=' method needs to use the 'copy' message.

Now we need to consider another factor.  That is, _the class of an
object's value does not need to be the same class as the object itself._
This is often the case with instance variables, which belong to the
parent object's class but contain values of a different class.

Let's return to an earlier example, where we defined a class called
'PositiveInteger', which could hold only positive numbers.  *Note
PositiveInteger Example::.

Using the '=' method above, the following program from the earlier
section does not work.
     Integer class PositiveInteger;
     ...
     int main () {
       Exception new e;
       PositiveInteger new p;

       p = 1;   /* Wrong - p's value becomes an Integer. */

       printf ("%d\n", p + 1);

       printf ("%d\n", p - 2);
       if (e pending)
         e handle;
     }

That's because the 'PositiveInteger' class also defines a '-' method.
So when Ctalk sees the expression 'p - 2', it looks for '-' from
'Integer' class, because 'p's' value is now an 'Integer'.  There is no
unambiguous way to tell 'PositiveInteger's' value class really isn't
correct, so the only alternative is to redesign the '=' method to cope
with this issue.

A program can deal with this issue by using Ctalk's library API and work
with the object directly in C.
     Integer instanceMethod = set_value (int __intArg) {
       OBJECT *self_alias;
       char buf[MAXLABEL];
       self_alias = self;
       sprintf (buf, "%d", __intArg);
       __ctalkSetObjectValueVar (self_alias, buf);
       return self;
     }
Here, we use 'sprintf(3)' and the Ctalk library function
'__ctalkSetObjectValueVar' to format the new value and replace the C
object's value directly.  Since the method only replaces the value in
the object's internal structure, the class of the value is unchanged,
and the example program above works correctly.

However, this version of '=' does not have the ability to perform type
conversions or handle objects out of scope.  As with so much in Ctalk, a
more advanced version of this method might combine the two approaches.

Ctalk's 'Object' class provides yet another method 'is', that tells you
if an object is a member of a certain class.  So we'll use that in the
'=' method to determine if the value of the receiver actually is an
Integer.
     Integer instanceMethod = set_value (int __i) {
       OBJECT *self_alias;
       char buf[MAXLABEL];
       Integer new localInt;
       if (self value is Integer) {
         localInt copy __i asInteger;
         __ctalkAddInstanceVariable (self, "value", localInt value);
       } else {
         self_alias = self;
         sprintf (buf, "%d", __i);
         __ctalkSetObjectValueVar (self_alias, buf);
       }
       return self;
     }
Further versions of this method need more checking than this.  For
example, methods frequently need to take into account a receiver's
context, which we'll discuss below.

In many cases, it's either convenient or necessary (or both) to tailor a
'=' method to a particular class, as the next section discusses.

The 'setValue' Method in 'Symbol' Class
.......................................

This manual often mentions the fact that programs need to pass objects
by reference.  The 'Symbol' class handles these chores.

When we want to assign a reference to a 'Symbol' object, we generally
mean one of several things.
   * If the argument is also a 'Symbol', copy its value to the receiver
     as a duplicate reference, after first removing a previous
     reference.
   * If the argument belongs to some other class, perform a conversion
     to a 'Symbol'-compatible value and create a new reference to the
     argument.
   * If the argument is 0, 'NULL', or '(null)' (in either Ctalk or C),
     reflect that assignment in the receiver.


     Symbol instanceMethod setValue (void *v) {
       // Set the value of the receiver to refer to the argument.
       // If the argument is also a Symbol object, set the
       // receiver's value to refer to the same object.
       // Otherwise, set the receiver's value to refer to
       // the argument object.  The referenced object's
       // scope includes VAR_REF_OBJECT scope.
       OBJECT *rcvr_val, *arg;
       char buf[MAXLABEL];

       self removeValue;

       rcvr_val = self value;
       arg = ARG(0);
       if (arg) {
         __ctalkSetObjectScope (arg, arg -> scope | 512);
         if (v is Symbol) {
           __ctalkSetObjectValue (rcvr_val,
     			     (arg->instancevars ?
     			      arg->instancevars : arg)->__o_value);
         } else {
     #if defined (__GNUC__) && defined (__x86_64) && defined (__amd64__)
           sprintf (buf, "%#lx", (unsigned long int)arg);
     #else
           sprintf (buf, "%#x", (unsigned int)arg);
     #endif
           __ctalkSetObjectValue (rcvr_val, buf);
         }
       } else {
         /* Needs to evaluate to a NULL C pointer, not a (null) object. */
         __ctalkSetObjectValue (rcvr_val, "0x0");
       }
       return self;
     }


Receiver Contexts
-----------------

In many cases, copying the value of one object to another is good
enough.  The number 2 and the string "Hello, world!"  are the same no
matter where they occur.

There are many other cases, however, where you want one object to become
another object, or you want a method to refer to the same object using
multiple labels, or you want to perform some manipulations on 'Symbol'
objects.

In that case, you can write methods that take into account the context
the receiver occurs in.  This matters mostly with 'Symbol' objects,
which need to represent other objects, but you can use the receiver's
context with other objects as well.

In the section 'Object References' we presented an example of how
manipulate references to objects.  *Note Object References::.

More briefly here, this section discusses the inner workings of the
different contexts taken from that example, like these three:


       Symbol new sym1;
       Symbol new sym2;
       Symbol new sym3;
       Integer new i;

       ...

       sym3 = sym1;

       ...

       sym1 = i;

       ...

       *sym2 = i;

       ...


This should look a little like C, and in fact it works similarly.  The
statement, 'sym3 = sym1' assigns the object 'sym1' to the identifier
'sym3'.

Likewise, the statement 'sym1 = i' assigns the object 'i' to the
identifer 'sym1'.

However, the statement '*sym2 = i' creates a reference to 'i'.  'sym2'
is still a 'Symbol' that points to an 'Integer' object.

To determine how we want the assignment to behave, we can use the method
'hasPointerContext' (in 'Object' class), which returns True if the
object to the left of the '=' operator has a '*' operator in front of
it.  If it does, we create a reference to the object.  In a non-pointer
context, we use the library function '__ctalkAliasObject ()' (or its
companion, '__ctalkAliasReceiver ()'), to assign the argument to the
identifier on the left-hand side of the '=' operator.

The method itself is actually quite simple.


     Symbol instanceMethod = setEqual (OBJECT *__newObject) {
       // Alias the argument to the receiver's indentifier.
       // If the receiver refers to an object reference (it's
       // preceded by a '*' operator), or if the receiver wasn't
       // declared as a global or local object (e.g., it's an
       // instance variable), then create a reference to the
       // argument object using Symbol : setValue .

       if (self hasPointerContext) {
         self setValue __newObject;
       } else {
         if (__ctalkAliasObject (self, __newObject) != 0) {
           self setValue __newObject;
         }
       }

     }


You might have noticed, after Ctalk executes a statement like 'sym1 =
i', that 'sym1' is no longer a 'Symbol' object; it's an 'Integer'.

Basically Ctalk handles this by following the same process in the '='
method in 'Integer' class as it does for 'Symbol' class.  That allows us
to use the object's class to find the right '=' method; we don't need to
worry nearly as much about type checking when making assignments.

However, if the need arises, you can add type checking to a method.  You
can do this, simply enough, by adding a check of an object's class with
the 'is' method from 'Object' class.


     if (arg is Float) {
        warning ("Assigning a Float object (or value) to an incompatible receiver.");
     }


The '=' Method in 'Integer' Class, Revisited
............................................

You may have noticed, from the previous examples, that the class of a
receiver can change if we assign it a new value.  The way that the
language's semantics work is that this is really only an issue when we
change from a 'Symbol', which is a reference, to a which is an actual
values, like 'Integers,' 'Characters,' 'Floats', and so on.

Normally, when you assign, say, a character to an 'Integer' object, the
compiler and libraries take care of the conversion from one type to
another.  When converting from 'Symbols' to other classes, however,
Ctalk allows us to add this support in a method.

So, for example, if we want to assign as Symbol object to a receiver
that is an 'Integer' (this isn't so far-fetched), we might want to look
at this code again.


       Symbol new sym1;
       Symbol new sym2;
       Symbol new sym3;
       Integer new i;

       ...

       sym3 = sym1;

       ...

       sym1 = i;  /* sym1 is now an Integer. */

       ...

       sym1 = sym3;  /* Now we want sym1 to be a Symbol again. */

       ...


In the statement, 'sym1 = i', the statement would use the '=' method
from 'Symbol' class.  But in the following statement, 'sym1 = sym3',
Ctalk would use the '=' method from 'Integer' class.

Fortunately, we can write the 'Integer' '=' method to support this.
Parts of the method are similar to the '=' method in 'Symbol' class, and
parts of it look like the previous 'Integer' '=' methods.  And we can
add a convenient warning message if the argument belongs to a class for
which the Ctalk libraries don't normally support type conversions.

     Integer instanceMethod = set_value (int __i) {
       char buf[MAXLABEL];
       if (self hasPointerContext) {
         __ctalkAliasObject (self, __i);
       } else {
         if (__i is Symbol) {
           __ctalkAliasObject (self, __i);
         } else {
           if ((__i value is Integer) || (__i value is LongInteger) || (__i value is Character) || (__i value is Float)) {
     	sprintf (buf, "%d", __ctalkToCInteger(ARG(0), 1));
     	__ctalkSetObjectValueVar (__ctalk_self_internal (), buf);
           } else {
     	_warning
     	("Integer : = : Argument, \"__i,\" class %s is not (yet) supported.\n",
     	 __i className);
           }
         }
       }
       return self;
     }

Coping with Semantic Issues
...........................

It's up to the method to handle any special semantics that the class's
objects use.  For example, the following statements should function
equivalently.


     String new myString;
     Integer new myIntArg;

     myIntarg = 123;

     myString = "123";             /* These two statements should produce
                                      identical results, even though one argument
                                      is a constant and the other is an expression.*/
     myString = myIntArg asString;


Programs generally expect 'String' constants to be assigned to unique
objects, so Ctalk provides the '__ctalkStringifyName ()' function to
help deal with this semantic peculiarity.  There may be others, and it's
up to the method to handle them.


     String instanceMethod = setEqual (OBJECT *__stringArg) {
       // String assignment method. Assigns the argument  to the
       // receiver label.  Also does some String-specific
       // semantic stuff for different sorts of String objects.
       // Returns the new String object.

       __ctalkStringifyName (self, __stringArg);
       if (__ctalkAliasReceiver (self, __stringArg) != 0) {
         self addInstanceVariable "value", __stringArg;
         return self;
       } else {
         return __stringArg;
       }
     }


Constructor Methods
-------------------

Constructor methods are the methods that actually create objects.  Ctalk
provides built-in constructors for basic classes, but they can be (and
often are) overridden by constructors in the class libraries

Nearly every program example in this tutorial uses at least one
constructor.  This section describes constructors in more detail and
discusses why and how to write them.

In many object oriented languages, and Ctalk among them, constructor
methods are almost always named 'new.' In an application program, their
use is simple.

Basic Constructors
..................

Here is an example of a simple constructor.
     Integer new myInt;
This statement creates a new object, 'myInt,' that is an instance of
'Integer' class.

The statement performs several tasks.  First, it creates the object
'myInt' and makes sure it has the correct links to 'Integer's' class and
superclass objects, and sets the initial value to '(null)'.

Secondly, it registers the object and sets its scope depending on where
the statement appears.  If the statement appears in a method or C
function, the object is local to that function, and the name 'myInt' is
visible only within that method or function, or code blocks within the
method or function.  However, if the statement appears outside of a
method or function, then the object's scope is global to the entire
program.  (To be absolutely correct, though, we should mention that the
constructor itself does not set an object's scope.  That happens after
the constructor is finished creating the object.)

Thirdly, if the class and its superclasses define instance variables,
the constructor creates and initializes instance variables for the new
object.

Because classes inherit methods, the constructor used by class 'Integer'
is the constructor from 'Object' class.  If 'Integer' class defined its
own 'new' method, it would use that constructor instead.  This point is
important and is worth repeating.  The process is described in the first
section.  *Note Class Hierarchy::.  Here again, a diagram should help
clarify this concept.
     Class                  Defines Constructor?    Statement or Action
     -----                  --------------------    -------------------
     Object                 Yes                     Create object.
                                                         ^
                                                         |
     Magnitude              No                      Look up method in superclass.
                                                         ^
                                                         |
     Integer                No                      Integer new myInt;
                                                    Look up method in superclass.

Initializing Objects
....................

The main reason that a class needs to define a constructor is to
initialize whatever data the classes's objects need.

Suppose we wanted to create Integers that were initialized with the
value '0' instead of '(null)'.  To do this we might define a subclass of
'Integer.' Let's do that and call the class 'InitializedInteger.'

The first thing we need to do is define the class.
     Integer class InitializedInteger;
Then we need to write the constructor for instances of
'InitializedInteger'.
     InitializedInteger instanceMethod new (String newObjectName) {
       InitializedInteger super new newObjectName;
       newObjectName = 0;
       return newObjectName;
     }
You should take note of the first statement.
     InitializedInteger super new newObjectName;
The statement does a lot of things.  First, 'super' (which is a keyword,
not a method), looks up the 'new' message starting with the receiver's
superclass.  It first creates a normal instance of 'Object' class, then
promotes it to an instance of 'InitializedInteger' class.  After this
statement, 'newObjectName' is no longer simply a method parameter, but a
fully fledged object.

Now the process looks like this.
     Class               Has Constructor?  Statement or Action
     -----               ----------------  -------------------
     Object              Yes               2. Create Object instance. -> 3. Return Object
                                                    ^                    instance to caller.
                                                    |                          |
     Magnitude           No                    Look up method in superclass.   |
                                                    ^                          |
                                                    |                          |
     Integer             No                    Look up method in superclass.   |
                                                    ^                          |
                                                    |                          |
     InitializedInteger  Yes               InitializedInteger new myInt;       |
                                           1. Look up method in superclass.    |
                                           4. Perform initialization <---------
                                           5. Return object to application.

The class definition and constructor could go in their own class
library, but this example is brief enough to include in the main source
file.  Here is the complete program.
     Integer class InitializedInteger;

     InitializedInteger instanceMethod new (String newObjectName) {
       InitializedInteger super new newObjectName;
       newObjectName = 0;
       return newObjectName;
     }

     int main () {
       InitializedInteger new i;
       printf ("%d\n", i);
     }

Class Initialization
....................

Another reason you might want to write your own constructor is to
initialize a class.  This is the case with 'FileStream' subclasses.  The
program needs to initialize the standard input, standard output, and
standard error file handles.

Initializing a class variable is much like initializing an object,
except that the class variable only needs to be initialized once.  To
make sure that a program doesn't initialize the class every time it
creates an object, The class definition needs to include a variable that
tells the constructor that class data is already initialized.  Here is
an abbreviated example from 'ReadFileStream' class, where the
constructor 'new' calls the method 'classInit,' which initializes
'stdin'.
     FileStream class ReadFileStream;
     ...
     ReadFileStream classVariable stdinStream;
     ReadFileStream classVariable classInitDone Integer 0;
     ...
     ReadFileStream classMethod classInit (void) {

       OBJECT *classObject,
         *stdinStreamVar,
         *classInitVar;

       if (self classInitDone)
         return NULL;

       classObject = __ctalkGetClass ("ReadFileStream");
       stdinStreamVar = __ctalkFindClassVariable ("stdinStream", TRUE);

       __ctalkObjValPtr (stdinStreamVar, stdin);

       classInitVar =
         __ctalkCreateObjectInit ("classInitDone", "Integer",
     			     "Magnitude",
     			     classObject -> scope, "1");
       __ctalkAddClassVariable (classObject, "classInitDone", classInitVar);

       return NULL;
     }
     ...
     ReadFileStream instanceMethod new (char *__streamName) {

       ReadFileStream super new __streamName;

       ReadFileStream classInit;

       return __streamName;
     }

These methods contain a lot of C code.  There are several reasons for
this.  The first is that it is often easier, and sometimes necessary, to
work directly with operating system functions and data in C.

The second reason is that when working with complex objects, it is
possible that the program might contain a circular class reference -
when a definition requires a class that isn't defined yet, and the
second class in turn relies on definitions from the first class.

Instance Variable Initialization
................................

If the declaration of the new object contains complex instance
variables, especially instance variables that have constructor methods
of their own, your constructor needs to construct them also.

For classes that have only a 'value' instance variable, it is generally
okay to let Ctalk's internal object creation routines create a simple
object.  But constructors do not automatically call other constructors,
so simply declaring instance variables of complex classes does not mean
they get constructed automatically.

If the constructor needs to create a complex instance variable, it must
call that instance variable's constructor explicitly.

Here's an example, somewhat abbreviated, from the
'ANSIScrollingListBoxPane' class, which contains several 'ANSILabelPane'
instance variables and an 'ANSIScrollPane' instance variable.  The
constructor creates the variables like normal objects, then adds them to
the new object using 'become' ('Object' class).


     ANSIWidgetPane class ANSIScrollingListBoxPane;

       ...

     ANSIScrollingListBoxPane instanceVariable selectedContent ANSILabelPane NULL;
     ANSIScrollingListBoxPane instanceVariable oldSelectedContent ANSILabelPane NULL;

       ...

     ANSIScrollingListBoxPane instanceVariable scrollBar ANSIScrollPane NULL;

       ...

     ANSIScrollingListBoxPane instanceMethod new (String __paneName) {

       ANSIWidgetPane super new __paneName;
       ANSIScrollPane new scrollPane;
       ANSILabelPane new selectedContent;
       ANSILabelPane new oldSelectedContent;

         ...

       __paneName scrollBar become scrollPane;

         ...

       __paneName selectedContent become selectedContent;
       __paneName oldSelectedContent become oldSelectedContent;

         ...

       return __paneName;
     }


Note that the 'scrollPane' is a local object, while '__paneName
scrollBar' is an instance variable.  The 'become' method creates
separate objects for the instance variables.  The same is true of the
'selectedContent' and 'oldSelectedContent' objects.

This procedure works with objects of any class, whether or not the
instance variable's class is related to the constructor's receiver
class.  To create the instance variables from the class's superclasses,
the constructor uses the statement 'ANSIWidgetPane super new
__paneName'.

Using an expression like 'ANSIWidgetPane super new __paneName' is a
normal way to tell the constructor to instantiate the new object's
instance variables from its superclasses.  As this section explained
earlier, this is the statement that performs a search back up the class
hierarchy and adds the instance variables that each superclass defines.

However, it's necessary, both for reliability and to avoid serious
confusion later in the program, to use 'super new' when the object is
first created.

If, for some reason, a program needs to instantiate instance variables
from the superclasses elsewhere in a program, the
'__ctalkInstanceVarsFromClassObject ()' library function performs the
same task.  It replaces the previous instance variables with fresh
copies.  But the program should take care that both the old and new
variables are either correctly referenced or disposed of, since the
interactions between them can become quite complex.

C Macros for the Method API
---------------------------

Ctalk defines many macros that provide a standard interface to C
language features.  The macros are defined in the include file
'ctalkdefs.h'.  They include macros like 'IS_OBJECT,' which checks if a
pointer is a valid object; 'FMT_0XHEX,' which formats a pointer into its
string representation, and 'STR_0XHEX_TO_PTR,' which does the converse;
when used with a function like 'sscanf(),' it converts the string
representation of a pointer into an actual pointer.

To include the definitions in a program, include 'ctalkdefs.h' in a
source or class library file.


     #include <ctalk/ctalkdefs.h>


The 'Ctalk Language Reference' provides a complete list of the macros
that 'ctalkdefs.h' defines.


File: tutorial.info,  Node: Graphics,  Next: Debugging,  Prev: Methods,  Up: Top

Panes and Graphics
==================

So far, this tutorial has used either C's 'printf' function or 'printOn'
and other methods of various classes to display information on a
terminal.

This section describes how to use 'Pane' class and its subclasses to
display information in windows, handle user input, and retrieve the
information.

There are 'Pane' subclasses for the following graphics libraries and
display types.

'ANSI Compatible, Text-mode Displays'
     Most UNIX consoles, 'xterms', VT-100 and many other serial RS-232
     terminals, and in some cases, Win32 'cmd.exe' windows and OS X
     terminal apps.  *Note ANSIGraphics::.
'X Window System'
     GUIs that use a X server, window manager, and Xlib libraries.
     *Note X11Graphics::.
'GLUT'
     The 'GLUTApplication' class provides support for the GLUT and
     OpenGL 3-D graphics libraries and runs on many different platforms.
     *Note GLUTGraphics::
'GLX'
     The 'GLXCanvasPane' class is another toolkit that provides OpenGL's
     3-D graphics capabilities on systems that have a X display.  *Note
     GLXGraphics::.

Closely related to these 'Pane' classes are several 'Stream' subclasses
that handle the chores of processing keyboard and mouse input.
Graphical User Interfaces use more sophisticated input devices than
simple text prompts, and the following sections also describe how to
process and respond to different types of input.

5 'Hello, world!' in a Text Window
==================================

For the sake of portability and (relative) simplicity, we'll start with
an example that uses the 'Pane' subclass, 'ANSIMessageBoxPane'.  This
class is a widget that pops up a message window on a the screen of a
'xterm' or physical serial terminal, then waits for the user's input,
and then closes the window.

The program itself is relatively simple.  Here is the listing.


     int main () {
       ANSIMessageBoxPane new messageBox;
       messageBox withText "Hello, world!";
       messageBox show 10, 10;
       messageBox cleanup;
     }


The program displays the message until the user presses 'Enter' to close
the window.  Pressing 'Esc' also closes windows, but, for most widget
classes, 'Esc' signals that the user wants to close the window without
returning any input.

As you might expect, what happens behind the scenes is a little more
involved.

6 'Pane' and 'Stream' Classes
=============================

When a program creates a new instance of a widget (in this case, a
subclass of 'ANSIWidgetPane'), the new object initializes the instance
variables it inherits from its superclasses, initializes the storage to
hold the information that is to be displayed, and a 'Stream' object that
handles the window's input and output.  In the case of 'ANSIWidgetPane'
subclasses, the input and output is handled by an 'ANSITerminalStream'
object, which is also an instance variable of the widget.

Here are the classes that handle Pane graphics, and their corresponding
'Stream' classes.  This organization makes it relatively easy to add
widgets and support for other text-mode and GUI interfaces.
      Pane                       Stream
       ANSITerminalPane           TerminalStream
        ANSIWidgetPane             ANSITerminalStream
         ANSIButtonPane
         ANSIMessageBoxPane
         ANSITextBoxPane
         ANSITextEntryPane
         ANSIYesNoBoxPane
       X11Pane                    X11TerminalStream

This example demonstrates a little of what 'ANSITerminalPane' and its
subclasses can do.  There are also many other graphics classes and
methods, though.

The next sections begin relatively simply, with an app for text-mode
terminals.  The tutorial then progresses to the classes and methods that
support the X Window System's drawing and user interface capabilities.
If you're already familiar with GUI programming, then feel free to skip
ahead, and refer back to these sections if some concept or capability
seems unfamiliar to you.

7 'InputEvent' Class
====================

Ctalk uses 'InputEvent' objects to communicate between the 'Pane's'
stream object, which receives its information from the serial tty device
that communicates with the 'xterm' or physical serial terminal, and the
pane objects that you see on the screen.  Ctalk uses 'InputEvent'
objects extensively, and you need to know about them to write a
graphical app.

Text-mode displays use instances of 'ANSITerminalStream' class to handle
user input.  The input can come from either a console (if you're the
superuser or your system doesn't have a GUI), a 'xterm', or a physical
serial terminal.

When a program creates an 'ANSITerminalStream' object, Ctalk initializes
its input and output to the application's standard input and output
channels.  For the sake of simplicity, the following examples use
standard input and output.

Text-mode displays use the 'getCh' method (class 'ANSITerminalStream')
to receive characters and return them to the application.
'ANSITerminalStream' also provides some basic terminal capabilities, and
you can also use the class independently of a window.

Here is a brief example that echoes characters to the display.
     int main () {
       ANSITerminalStream new term;  /* Initializes input and output */
                                     /* to stdin and stdout.         */
       Character new c;

       term rawMode;
       term clear;
       term gotoXY 1, 1;

       while ((c = term getCh) != EOF)
         term printOn "%c", c;

       term restoreTerm;
     }

There are a few things to note about this example.  The first is that
the program sets the terminal to _raw_ mode.  That means the characters
you type at the keyboard are received directly by the application,
without any buffering or echoing by the terminal device itself.  All
terminal output is handled by the methods 'clear', 'gotoXY', and
'printOn'.

It also means that the program _must_ restore the terminal to its
original state before exiting.  That is the purpose of the 'restoreTerm'
method.  If the application did not restore the terminal before exiting,
the display would likely be unusable, so be sure to use 'restoreTerm'
whenever you use 'rawMode' in your applications.

The 'ANSITerminalStream' version of 'printOn' notes what mode the
terminal is in, so the program can display output regardless of whether
the terminal is raw mode or not.

You should note that 'getCh' recognizes an 'EOF' ('C-z') character, but
in practice it is often difficult or impossible to enter an 'EOF' from
the keyboard.

The example above would have difficulty handling many control
characters, and it doesn't recognize terminal escape sequences; for
example, of the type generated when you press a cursor key.

That is why applications that use panes use 'InputEvent' objects.
'InputEvent' objects contain information about what type (or _class_) of
input is coming from the terminal, and the actual _data_.

In the case of terminal input, there are two event classes: 'KBDCUR,'
for terminal escape sequences, and 'KBDKEY,' for alphanumeric
keypresses.

The terminal stream queues these events, and the pane can retrieve then
and process them in whatever manner it needs to.

Programs that use GUI displays don't actually need to use input events,
but you will find that handling input beyond a simple press of the
'Return' key can become quite involved.  For an example, look at the
'ANSITerminalPane' section of the language reference.

8 Using Queued 'InputEvents'
============================

If you're wondering how to go about adding all of this to a program,
don't worry.  All of the 'ANSIWidgetPane' subclasses implement a method
'handleInput', which directs the pane's 'ANSITerminalStream' to queue
the events, and handles the events as it receives them.

In addition, all instances of 'ANSITerminalPane' and its subclasses
contain an instance variable ('paneStream') that is an
'ANSITerminalStream' object.  You might recall from the previous
sections that 'ANSITerminalStream' initializes its input and output to
'stdin' and 'stdout'.  Most applications need not handle that chore
themselves.

If you plan to write widgets, you might need to see to the I/O
initialization yourself.  However, if the widget is a subclass of
'ANSITerminalPane', then the constructor in that class takes care of I/O
initialization anyway.

For now, we'll just describe 'ANSIWidgetPane''s implementation of the
'handleInput' method.  Here it is, minus a few comments omitted for
space reasons.
     ANSIWidgetPane instanceMethod handleInput (void) {

       Integer new c;
       InputEvent new iEvent;

       while ((c = self paneStream getCh) != EOF) {
         iEvent become self paneStream nextInputEvent;
         switch (iEvent eventClass)
           {
           case KBDCHAR:
           case KBDCUR:
             switch (iEvent eventData)
               {
               case ESC:
                 self withdraw;
                 self paneStream restoreTerm;
                 return NULL;
                 break;
               }
             break;
           }
       }
       return NULL;
     }

This method is very basic-it handles only one key sequence: 'ESC', which
withdraws the pane from the display (_Withdraw,_ in this case, is
functionally synonymous with, _close,_ although it's the following
methods that close the terminal connection and delete the pane object.)
This method also uses the 'getCh' and 'restoreTerm' methods that we
mentioned earlier, with the pane's 'paneStream' instance variable as the
receiver.

More involved implementations of 'handleInput' also use the
'openInputQueue' method from 'ANSITerminalPane' to enable event
queueing.  You might want to look at the 'handleInput' methods of other
classes to see how this is accomplished.

9 The Widget API
================

Ctalk widget classes generally implement a set of methods that handle
the common chores of displaying information and handling input.  The
methods listed here are a minimum set of methods.  Widget classes can
implement additional methods as needed.

Here we'll describe the API for the ANSITerminalPane classes and its
subclasses.  We'll discuss the API for X11 panes later on.  *Note X
Widget API::.
'cleanup'
     Clean up any additional data used by the widgets.  This includes
     the 'paneBuffer' and 'paneBackingStore' storage, and any additional
     storage.  Deletion of the widget objects themselves is handled by
     the normal object cleanup mechanisms.
'handleInput'
     Receive 'InputEvent' objects from the receiver's 'paneStream', and
     take action based on the keyboard input.
'new'
     Initializes the pane and its sub-panes, and sets whatever
     parameters are necessary.
'parent'
     Attach a sub-widget to its parent widget.
'refresh'
     Update the pane and its child panes on the display.

It's also likely that a widget class needs to implement its own 'map'
and 'unmap' methods, similar to those in 'ANSITerminalStream' class.

Many 'ANSITerminalPane' subclasses also implement a 'show' method, which
pops up the window at a specified 'x, y' position on the terminal.
Strictly speaking, however, 'show' is a convenience method.

This section has not discussed adding shadows, borders, titles, and
other graphical effects to pane objects.  There are a lot of them, and
they are described in each class's section of the language reference.

There is one point that we should note about graphics effects here,
however.  In order to keep the widget classes and their libraries as
fast as possible, when refreshing subpanes, the terminal's graphics
attributes (the graphical effects other than borders and shadows; i.e.,
bold, reverse, or blinking text, graphics character sets, and so forth)
are _not_ automatically updated when a parent window is refreshed.  The
program needs to update the subpanes individually.  As in this example,
from the 'ANSITextBoxPane' 'show' method.
     self refresh;                    /* Refresh the main widget.    */
     self dismissButton               /* Toggle the button's focus   */
                                      /* highlight.                 */
        focusHighlightOnOff;
     self dismissButton refresh;      /* Refreshes the button widget */
                                      /* independently.              */

If the method did not independently refresh the receiver's
'dismissButton' subwidget, the change to the button's focus highlight
would not be visible.

Complex widgets that have more than one button or text input box need to
keep track of the input focus and its display.  There is a bit more
about these issues in the next section.

10 Serial Terminals
===================

Applications that handle input and output for serial terminals must also
use the 'openOn' and 'setTty' methods of 'ANSITerminalStream' class.
Their use is relatively simple.
     ANSIYesNoBoxPane new myWidget;  /* Initialize stdin and stdout. */

     myWidget paneStream openOn "/dev/ttyS0"; /* A Linux tty device. */
     myWidget paneStream setTty 9600, 8, 'n', 1;
The 'ANSIWidgetPane' subclasses can, but don't always, handle all of
sequences defined by the ANSI, VT-100, or 'xterm' specifications.  It's
up to each class and subclass to determine how to handle the escape
sequences it needs.

11 'X11Pane' Class
==================

The 'X11Pane' class can display text in a X window and handle a set of X
input events, both from the X server and the window manager.

The next few sections describe basic drawing with 'X11Pane' objects.
This provides a more gentle introduction to all of the features of
'X11Pane' objects and the 'Pen,' 'X11Font,' 'Point,' 'Line,' and
'Rectangle' objects which provide specific drawing features.  We'll
describe the X widget API later on.  *Note X Widget API::.

We'll just mention here that 'X11Pane' objects use the X window's
default visual, but they also maintain a copy of the window's graphics
context, so you can create your own visuals if necessary.  If you're not
certain what that means, it allows classes to be flexible enough that
you can still create complex windows using the Xlib API if a class
doesn't provide a specific feature that the application needs.

12 'Points,' 'Lines,' and 'Rectangles'
======================================

Now that we've described how to communicate with pane objects and
windows, we can finally discuss drawing things on the screen.  The
classes 'Point', 'Line', and 'Rectangle' provide the ability to draw on
'X11Pane' windows.

Each of these classes provides a 'draw' method that lets you draw the
object on a X window.  The dimensions of these objects are determined by
their instance variables, which are all 'Point' objects.

For example, to draw a point on a window an application might use the
following code.


     Point new myPoint;

     myPoint x = 35;
     myPoint y = 35;

     myPoint draw xPane;


Note that the argument to 'draw' is the 'X11Pane' object.  'X11Pane'
class has its own 'draw' method as well, so an application could also
use the following statement, and the result would be the same as the
previous example.


     xPane draw myPoint;


A 'Line' object has two 'Point' objects as instance variables, which
describe the start and end of the line.
     Line new myLine;

     myLine start x = 90;
     myLine start y = 10;
     myLine end x = 10;
     myLine end y = 90;

     xPane draw myLine;

Similarly, a 'Rectangle' object has four 'Line' instance variables that
describe the sides of the rectangle.

Here is the declaration from 'Rectangle' class.


     Rectangle instanceVariable top Line NULL;
     Rectangle instanceVariable right Line NULL;
     Rectangle instanceVariable bottom Line NULL;
     Rectangle instanceVariable left Line NULL;


When creating a rectangle, you might use statements like these.


     rectangle top start x = 10;
     rectangle top start y = 10;
     rectangle right end x = 80;
     rectangle right end y = 80;
     _..._

     xPane draw rectangle;


As a shortcut, the 'dimensions' method uses the upper left and lower
right corners of the rectangle to fill in the instance variables.


     rectangle dimensions 10, 10, 100, 100;


If you want to draw a solid rectangle, instead of an outline, use the
'fill' method instead of 'draw'.


     xPane fill rectangle;


13 'Pens'
=========

If a program provides only the dimensions of a shape, the default width
of a point or line is 1 pixel, and the shape's color is black.

If you want to set the width and color of a shape; for example, to a
thick green line, you can provide a 'Pen' object that contains the color
and width information.


     Line new myLine;
     Pen new greenPen;

     greenPen width = 10;
     greenPen color = "green";

     xPane drawWithPen myLine, greenPen;


Instead of using 'draw' in these cases, you would use the 'drawWithPen'
method (or 'fillWithPen' for solid 'Rectangle' objects).

The 'Ctalk Language Reference' contains simple examples for drawing each
of these classes.  Here, however, is a demonstration program that draws
red, green, and blue dots inside a window.
     int main () {
       X11Pane new xPane;
       InputEvent new e;
       Pen new bluePen;
       Pen new redPen;
       Pen new greenPen;
       Point new redPoint;
       Point new bluePoint;
       Point new greenPoint;

       xPane initialize 10, 10, 250, 250;
       xPane map;
       xPane raiseWindow;
       xPane openEventStream;

       xPane background "yellow";
       xPane clearWindow;

       redPen width = 100;
       redPen colorName = "red";
       redPoint x = 40;
       redPoint y = 40;

       greenPen width = 100;
       greenPen colorName = "green";
       greenPoint x = 120;
       greenPoint y = 40;

       bluePen width = 100;
       bluePen colorName = "blue";
       bluePoint x = 80;
       bluePoint y = 90;

       while (TRUE) {
         xPane inputStream queueInput;
         if (xPane inputStream eventPending) {
           e become xPane inputStream inputQueue unshift;
           switch (e eventClass value)
             {
             case WINDELETE:
               xPane deleteAndClose;
               exit (0);
               break;
             case EXPOSE:
             case RESIZENOTIFY:
     	  xPane drawWithPen redPoint, redPen;
     	  xPane drawWithPen greenPoint, greenPen;
     	  xPane drawWithPen bluePoint, bluePen;
               break;
             default:
               break;
             }
         }
       }
     }

The program first initializes the window and starts receiving messages
from the X server with the 'initialize' and 'openEventStream' messages.
Only then can the program perform any drawing on the window, including
setting the background and updating the window (with the 'background'
and 'clearWindow' messages).  It is necessary for X client programs to
send and receive window system requests in synchronization with the
display hardware.

14 Fonts
========

'X11Pane' objects also provide simple font support.

If you set the 'fontDesc' instance variable to a X Logical Font
Descriptor, as in this example, then text is displayed using that font.


     myPane fontDesc = "-*-courier-medium-r-*-*-12-120-*-*-*-*-*-*";


Modern operating systems provide many different types of fonts.  For
now, though, this tutorial discusses the basic X fonts and their
descriptions.  If you're not familiar with them, the manual page for
'xfontsel(1)' provides a good starting point.

Ctalk's libraries determine the actual font from the font descriptor
that you provide (like the descriptor given by 'xfontsel'), and fill in
the metrics in the pane's 'font' instance variable, which is a 'X11Font'
object.

If you want to specify a font simply by setting the 'fontDesc' instance
variable, then you must do it _before_ the program calls the
'initialize' method and Ctalk initializes the actual window parameters.

If, however, you want to change fonts in the middle of a program, then
use the 'useFont' method, as in this example.
     myPane useFont "-*-courier-medium-r-*-*-12-120-*-*-*-*-*-*"

In either case, Ctalk fills in the font's dimensions: its ascender,
descender, and total height; and the width of its widest character.

If you simply want to find the dimensions of a font without actually
using it, then you can use the 'getFontInfo' method (class 'X11Font'),
and it will fill in the dimensions in an X11Font's instance variables.

If the program doesn't specify a font, then text is displayed using the
system's fixed font.

15 The X Widget API
===================

The widget API is still in development.  So far, it is composed of three
classes: 'X11PaneDispatcher,' 'X11CanvasPane,' and 'X11TextPane.' To do
the mechanics of actual drawing, these classes rely on the 'X11Bitmap'
class.

Most of the information in the previous sections also applies here.
However, the widget API also provides the methods to dispatch events to
subpanes and other methods to handle the events.  The API's design can
also allow multiple panes within a single window, although at present
only one subpane may occupy a window.

The Pane Hierarchy
------------------

The basic way to create an application that uses subpanes is to attach a
'X11PaneDispatcher' object to a 'X11Pane' object, and then a pane class
like 'X11CanvasPane' to the 'X11PaneDispatcher' object.

Each class handles specific chores for drawing in the windows and
handling input from the user and the display system.  The following
diagram should make this clearer.

      ------------------
     |                  |     Receives events from the display system
     |    X11Pane       |     via the inputStream instance variable,
     |                  |     and sends them to subpanes, if any.
      ------------------
             |
             v
      ------------------
     |                  |     Defines the basic handler methods
     | X11PaneDispatcher|     for different types of events, and
     |                  |     dispatches various events to subpane
      ------------------      handlers if they exist.
             |
             v
      ------------------
     | X11CanvasPane,   |     Provides the methods and instance data
     | X11TextPane, etc.|     used by the application for drawing text
     |                  |     or graphics in the subpane's window,
      ------------------      and updating the main window.
             |
             v
      ------------------
     | X11Bitmap        |     Contains information about the
     |                  |     resources used by the hardware and
     |                  |     system libraries for drawable surfaces,
      ------------------      colors, fonts, and so on.

As with other complex pane objects, programs attach subpanes to their
parent panes.  As an example, here is the dots program from earlier in
this chapter.  In this case, the application uses a 'X11CanvasPane'
object for drawing.
     int main () {
       X11Pane new xPane;
       InputEvent new e;
       X11PaneDispatcher new xTopLevelPane;
       X11CanvasPane new xCanvasPane;
       Application new paneApp;

       paneApp enableExceptionTrace;
       paneApp installExitHandlerBasic;

       xPane initialize 10, 10, 250, 250;
       xTopLevelPane attachTo xPane;        /* The attachTo methods also */
       xCanvasPane attachTo xTopLevelPane;  /* set the dimensions of the */
                                            /* subpanes before they are  */
                                            /* mapped and raised along   */
                                            /* with the top-level pane.  */

       xPane map;
       xPane raiseWindow;
       xPane openEventStream;               /* Before we can do any      */
                                            /* drawing on the window, we */
                                            /* need to start sending and */
                                            /* receiving events from the */
                                            /* X server.  That is what   */
                                            /* openEventStream does.     */

       xPane background "yellow";           /* Setting the background of */
       xPane clearWindow;                   /* an X11Pane object sets the*/
                                            /* background of the actual  */
                                            /* window.                   */

       xCanvasPane background "yellow";     /* Setting the background of */
                                            /* a buffered pane like a    */
                                            /* X11CanvasPane sets the    */
                                            /* background color of its   */
                                            /* buffer.                   */

       xCanvasPane clearRectangle 0, 0, 250, 250; /* In both cases, we   */
                                                  /* need to update the  */
                                                  /* pane before the new */
                                                  /* color is visible,   */
                                                  /* with either,        */
                                                  /* "clearWindow," or,  */
                                                  /* "clearRectangle."   */
       xCanvasPane pen width = 100;
       xCanvasPane pen colorName = "red";
       xCanvasPane drawPoint 40, 40;
       xCanvasPane pen colorName = "green";
       xCanvasPane drawPoint 120, 40;
       xCanvasPane pen colorName = "blue";
       xCanvasPane drawPoint 80, 90;

       while (TRUE) {
         xPane inputStream queueInput;
         if (xPane inputStream eventPending) {
           e become xPane inputStream inputQueue unshift;
           xPane subPaneNotify e;          /* We need to notify subPanes */
                                           /* e.g., xCanvasPane of the   */
                                           /* input events from the GUI. */
           switch (e eventClass value)
             {
             case WINDELETE:
               xPane deleteAndClose;
               exit (0);
               break;
             case EXPOSE:
             case RESIZENOTIFY:
     	  xCanvasPane pen width = 100;
     	  xCanvasPane pen colorName = "red";
     	  xCanvasPane drawPoint 40, 40;
     	  xCanvasPane pen colorName = "green";
     	  xCanvasPane drawPoint 120, 40;
     	  xCanvasPane pen colorName = "blue";
     	  xCanvasPane drawPoint 80, 90;
               break;
             default:
               break;
             }
         }
       }
     }

For another example program, look at the simple drawing program in the
'X11CanvasPane' section of the 'Ctalk Language Reference.'

X Window System Events
----------------------

Like other graphical programs, objects of 'X11Pane' class and its
subclasses respond to events from the keyboard, mouse, and display.

Here are events types that the API provides.  An application program
does not need to handle all of them - only the events that relate to the
application's functions.

The table also lists the data that each event type provides, and the
data contained in each of the event's instance variables.
     eventclass     eventdata1 eventdata2 eventdata3 eventdata4 eventdata5
     -------------  ---------- ---------- ---------- ---------- ----------
     BUTTONPRESS    x          y          state      button     -
     BUTTONRELEASE  x          y          state      button     -
     KEYPRESS       x          y          state      keycode    X11 keysym
     KEYRELEASE     x          y          state      keycode    X11 keysym
     MOTIONNOTIFY   x          y          state      is_hint
     MAPNOTIFY      event      window id  -          -          -
     EXPOSE         x          y          width      height     count
     MOVENOTIFY     x          y          width      height     border width
     RESIZENOTIFY   x          y          width      height     border width
     WINDELETE      -          -          -          -          -

Some of the data provided by these events are defined by the window
system protocol.  Other information is provided by the Ctalk libraries.
For example, the X11 keysym information provided by a 'KEYPRESS' or
'KEYRELEASE' event translates a hardware specific keycode into a
portable X11 keysym, so an application doesn't need to worry about what
type of keyboard the system has.

If you're exploring the X Window System API, you might find it useful to
have the application monitor these events.  The 'demos/xhello.c' sample
program provides an example of how applications might monitor these
events.

'GLUTApplication' Class
-----------------------

The GLUT toolkit, which is available on most platforms that support the
OpenGL graphics API, is a cross-platform toolkit that greatly simplifies
writing applications for 3D modeling and graphics.

The GLUTApplication class provides methods that help you define
callbacks for the various GUI events, pointer and keystroke handlers,
background and animation callbacks, and a simplified API for creating
and managing windows that is compatible with most systems that have
GUI's.

To do the actual drawing, 'GLUTApplication' class programs use the
OpenGL API. OpenGL is a large library that flexibly supports application
specific graphics.

There are many books and tutorials that describe OpenGL and the subject
of 3D graphics.  Here, we'll just show a simple program that integrates
some of the basic Ctalk methods with GLUT and OpenGL. This program is in
the Ctalk source package, as the file, 'demos/glut/tetra.ca'.


     /*
       Demonstration that draws a tetrahedron, manually rendered with
       blended colors between vertexes.

       Pressing [F1] toggles a full screen display.
       Pressing [Esc] exits the program.
     */

     /*
       To build manually with Linux/UNIX use a series of commands like the following.

         $ ctalk tetra.ca -o tetra.i
         $ gcc tetra.i -o tetra -lctalk -lreadline -lhistory -lGL -lGLU -lglut

       or simply,

         $ ctcc -x tetra.ca -o tetra

       On OS X, to build with the GLUT framework (but with the standard GL includes):

         $ ctalk -I /usr/X11R6/include tetra.ca -o tetra.i
         $ gcc -framework GLUT tetra.i -o tetra -lctalk -lreadline \
             -L/usr/X11R6/lib -lGL -lGLU
      */

     #ifndef ESC
     #define ESC 27
     #endif
     #define WINWIDTH 640
     #define WINHEIGHT 480

     GLUTApplication new tetra;
     Boolean new isFullScreen;

     #include <ctalk/ctalkGLUTdefs.h>

     float face1[3][3] = {{0.0f, 2.0f, 0.0f},
     		     {-2.0f, -2.0f, 2.0f},
     		     {2.0f, -2.0f, 2.0f}};
     float face2[3][3] = {{0.0f, 2.0f, 0.0f},
     		     {2.0f, -2.0f, 2.0f},
     		     {2.0f, -2.0f, -2.0f}};
     float face3[3][3] = {{0.0f, 2.0f, 0.0f},
     		     {2.0f, -2.0f, -2.0f},
     		     {-2.0f, -2.0f, -2.0f}};
     float face4[3][3] = {{0.0f, 2.0f, 0.0f},
     		     {-2.0f, -2.0f, -2.0f},
     		     {-2.0f, -2.0f, 2.0f}};

     float base[4][3] = {{2.0f, -2.0f, 2.0f},
     		    {2.0f, -2.0f, -2.0f},
     		    {-2.0f, -2.0f, -2.0f},
     		    {-2.0f, -2.0f, 2.0f}};
     float angle = 0.0f;

     void mydisplay (void) {
       glEnable (GL_NORMALIZE);
       glEnable(GL_DEPTH_TEST);
       glClearColor(0.0, 0.0, 0.0, 1.0);
       glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
       glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
       glLineWidth (1.0f);

       glLoadIdentity ();
       glColor4f (1.0f, 1.0f, 1.0f, 1.0f);

       glRotatef (angle, 0.0f, 1.0f, 0.0f);
       glRotatef (10.0f, 0.0f, 0.0f, 1.0f);

       glBegin (GL_TRIANGLES);
       glColor3f (1.0f, 0.0f, 0.0f);
       glVertex3fv (face1[0]);
       glColor3f (0.0f, 1.0f, 0.0f);
       glVertex3fv (face1[1]);
       glColor3f (0.0f, 0.0f, 1.0f);
       glVertex3fv (face1[2]);

       glColor3f (1.0f, 0.0f, 0.0f);
       glVertex3fv (face2[0]);
       glColor3f (0.0f, 1.0f, 0.0f);
       glVertex3fv (face2[1]);
       glColor3f (0.0f, 0.0f, 1.0f);
       glVertex3fv (face2[2]);

       glColor3f (1.0f, 0.0f, 0.0f);
       glVertex3fv (face3[0]);
       glColor3f (0.0f, 1.0f, 0.0f);
       glVertex3fv (face3[1]);
       glColor3f (0.0f, 0.0f, 1.0f);
       glVertex3fv (face3[2]);

       glColor3f (1.0f, 0.0f, 0.0f);
       glVertex3fv (face4[0]);
       glColor3f (0.0f, 1.0f, 0.0f);
       glVertex3fv (face4[1]);
       glColor3f (0.0f, 0.0f, 1.0f);
       glVertex3fv (face4[2]);
       glEnd ();

       glBegin (GL_QUADS);

       glColor3f (1.0f, 0.0f, 0.0f);
       glVertex3fv (base[0]);
       glColor3f (0.0f, 1.0f, 0.0f);
       glVertex3fv (base[1]);
       glColor3f (0.0f, 0.0f, 1.0f);
       glVertex3fv (base[2]);
       glColor3f (1.0f, 0.0f, 1.0f);
       glVertex3fv (base[3]);

       glEnd ();

       glutSwapBuffers ();
     }

     void animation (void) {
       angle += 0.2f;
       if (angle >= 360.0f)
         angle = 0.0f;
       glutPostRedisplay();
     }

     void fn_key (int keycode, int x, int y) {
       if (keycode == GLUT_KEY_F1) {
         if (!isFullScreen) {
           tetra fullScreen;
         } else {
           tetra reshape WINWIDTH, WINHEIGHT;
         }
       }
       isFullScreen = !isFullScreen;
     }

     void key (unsigned char c, int x, int y) {
       if (c == ESC)
         exit (0);
     }

     int main (int argc, char **argv) {
       tetra initGLUT(argc, argv);
       tetra initWindow (WINWIDTH, WINHEIGHT);
       tetra createMainWindow ("Tetrahedron -- GLUTApplication Class");
       tetra defineDisplayFn mydisplay;
       tetra defineIdleFn animation;
       tetra defineSpecialFn fn_key;
       tetra defineKeyboardFn key;
       tetra installCallbackFns;
       tetra run;

     }

'GLXCanvasPane' Class
---------------------

'GLXCanvasPane' is another class that provides support for 3-D graphics
using OpenGL. GLX provides visual classes that allow OpenGL to perform
3-D modeling in a X window.  Because it is integrated with the X server,
GLX is available on nearly all modern systems that use X desktops.

Like other OpenGL utility libraries, 'GLXCanvasPane' doesn't provide
many of the actual drawing routines, leaving that to OpenGL itself.
However, the class does provide a framework that facilitates 3-D
modeling on as many compatible systems as possible.

Printed below is a sample 'GLXCanvasPane' application.  This program is
included in the Ctalk distribution as 'demos/glx/glx.ca'.

The program is similar to the example program in the 'GLUTApplication'
section, except that the event handling methods that provide the
callbacks are defined in 'GLXCanvasPane', so you can subclass and modify
application classes as necessary.

For detailed information about 'GLXCanvasPane' class, refer to the
'GLXCanvasPane' section of the 'Ctalk Language Reference'.


     #include <X11/Xlib.h>
     #include <GL/glx.h>

     #define DEFAULT_WIDTH 500
     #define DEFAULT_HEIGHT 500

     float face1[3][3] = {{0.0f, 2.0f, 0.0f},
     		     {-2.0f, -2.0f, 2.0f},
     		     {2.0f, -2.0f, 2.0f}};
     float face2[3][3] = {{0.0f, 2.0f, 0.0f},
     		     {2.0f, -2.0f, 2.0f},
     		     {2.0f, -2.0f, -2.0f}};
     float face3[3][3] = {{0.0f, 2.0f, 0.0f},
     		     {2.0f, -2.0f, -2.0f},
     		     {-2.0f, -2.0f, -2.0f}};
     float face4[3][3] = {{0.0f, 2.0f, 0.0f},
     		     {-2.0f, -2.0f, -2.0f},
     		     {-2.0f, -2.0f, 2.0f}};

     float base[4][3] = {{2.0f, -2.0f, 2.0f},
     		    {2.0f, -2.0f, -2.0f},
     		    {-2.0f, -2.0f, -2.0f},
     		    {-2.0f, -2.0f, 2.0f}};

     float angle = 20.0;

     GLXCanvasPane instanceMethod draw (void) {
       glEnable (GL_NORMALIZE);
       glEnable(GL_DEPTH_TEST);
       glClearColor(0.0, 0.0, 0.0, 1.0);
       glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
       glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
       glLineWidth (1.0f);

       glLoadIdentity ();
       glColor4f (1.0f, 1.0f, 1.0f, 1.0f);

       glRotatef (angle, 0.0f, 1.0f, 0.0f);
       glRotatef (10.0f, 0.0f, 0.0f, 1.0f);

       glBegin (GL_TRIANGLES);
       glColor3f (1.0f, 0.0f, 0.0f);
       glVertex3fv (face1[0]);
       glColor3f (0.0f, 1.0f, 0.0f);
       glVertex3fv (face1[1]);
       glColor3f (0.0f, 0.0f, 1.0f);
       glVertex3fv (face1[2]);

       glColor3f (1.0f, 0.0f, 0.0f);
       glVertex3fv (face2[0]);
       glColor3f (0.0f, 1.0f, 0.0f);
       glVertex3fv (face2[1]);
       glColor3f (0.0f, 0.0f, 1.0f);
       glVertex3fv (face2[2]);

       glColor3f (1.0f, 0.0f, 0.0f);
       glVertex3fv (face3[0]);
       glColor3f (0.0f, 1.0f, 0.0f);
       glVertex3fv (face3[1]);
       glColor3f (0.0f, 0.0f, 1.0f);
       glVertex3fv (face3[2]);

       glColor3f (1.0f, 0.0f, 0.0f);
       glVertex3fv (face4[0]);
       glColor3f (0.0f, 1.0f, 0.0f);
       glVertex3fv (face4[1]);
       glColor3f (0.0f, 0.0f, 1.0f);
       glVertex3fv (face4[2]);
       glEnd ();

       glBegin (GL_QUADS);

       glColor3f (1.0f, 0.0f, 0.0f);
       glVertex3fv (base[0]);
       glColor3f (0.0f, 1.0f, 0.0f);
       glVertex3fv (base[1]);
       glColor3f (0.0f, 0.0f, 1.0f);
       glVertex3fv (base[2]);
       glColor3f (1.0f, 0.0f, 1.0f);
       glVertex3fv (base[3]);

       glEnd ();

       glRotatef (20.0, 0.0f, 0.0f, 1.0f);
       glRotatef (angle, 0.0f, 1.0f, 0.0f);

       self swapBuffers;
     }

     GLXCanvasPane instanceMethod initGL (void) {
       glViewport (0, 0, DEFAULT_WIDTH, DEFAULT_HEIGHT);
       glClearColor(0.0, 0.0, 0.0, 1.0);
       glLineWidth (1.0);
       glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
       glEnable (GL_LINE_SMOOTH);
       glHint (GL_LINE_SMOOTH_HINT, GL_DONT_CARE);
       glMatrixMode (GL_PROJECTION);
       glLoadIdentity ();
       if (DEFAULT_WIDTH <= DEFAULT_HEIGHT) {
         glOrtho (-5.0, 5.0,
     	     -5.0 * ((float)DEFAULT_HEIGHT / (float)DEFAULT_WIDTH),
     	     5.0 * ((float)DEFAULT_HEIGHT / (float)DEFAULT_WIDTH),
     	     -5.0, 5.0);
       } else {
         glOrtho (-5.0, 5.0,
     	     -5.0 * ((float)DEFAULT_WIDTH / (float)DEFAULT_HEIGHT),
     	     5.0 * ((float)DEFAULT_WIDTH / (float)DEFAULT_HEIGHT),
     	     -5.0, 5.0);
       }
       glMatrixMode (GL_MODELVIEW);
       glLoadIdentity ();
     }

     GLXCanvasPane instanceMethod myTimerTickHandler (void) {
       angle += 1.0;
       self draw;
     }

     /* This definition comes from the machine's X11/keysymdef.h file. */
     #define XK_Escape 0xff1b

     GLXCanvasPane instanceMethod myKeyPressMethod (Integer xKeySym,
     					       Integer keyCode,
     					       Integer shiftState) {
       if (xKeySym == XK_Escape) {
         self deleteAndClose;
         exit (0);
       }
     }

     GLXCanvasPane instanceMethod myExposeMethod (Integer nEvents) {
       if (nEvents == 0)
         self draw;
     }

     GLXCanvasPane instanceMethod myResizeMethod (Integer width,
     					     Integer height) {
       float ar;

       glViewport (0, 0, width, height);
       glMatrixMode (GL_PROJECTION);
       glLoadIdentity ();
       if (width <= height)
         ar = (float)height / (float)width;
       else
         ar = (float)width / (float)height;
       glOrtho (-5.0, 5.0, -5.0 * ar, 5.0 * ar, -5.0, 5.0);
       glMatrixMode (GL_MODELVIEW);
       glLoadIdentity ();
     }

     int main () {
       GLXCanvasPane new pane;

       pane initialize (1, 150, 500, 500);
       pane title "GLXCanvasPane Demonstration";
       pane map;
       pane raiseWindow;

       pane onKeyPress "myKeyPressMethod";
       pane onExpose "myExposeMethod";
       pane onTimerTick "myTimerTickHandler";
       pane onResize "myResizeMethod";

       pane initGL;

       pane run;

     }



Command Line Options
--------------------

Support for command line options in terminal programs is relatively
straightforward.  There are many examples of how to use 'argc' and
'argv' that the system provides as arguments to the 'main ()' function.

Ctalk has more support for command line options than that.  The tutorial
discusses it here because the way an application handles command line
options helps determine how a program interacts with the desktop.

First, the 'Application' class provides the method, 'parseArgs'.  This
method, given the 'argc' and 'argv' arguments that the system provides
to 'main (),' saves them in the Application's 'cmdLineArgs' instance
variable, which is an 'Array'.

Most of the time, an application parses the command line arguments as
soon as possible when starting, as in this example, which also has a
simple method for setting the application's objects from the command
line arguments.


     Application instanceMethod appOptions (void) {

       Integer new i;
       Integer new nParams;
       String new param;

       nParams = self cmdLineArgs size;

       for (i = 1; i < nParams; i++) {

         param = self cmdLineArgs at i;

         if (param  == "-g") {
           geomString = self cmdLineArgs at i + 1;
           i = i + 1;
           continue;
         }

         if (param  == "-fg") {
           fgColor = self cmdLineArgs at i + 1;
           i = i + 1;
           continue;
         }

         if (param  == "-bg") {
           bgColor = self cmdLineArgs at i + 1;
           i = i + 1;
           continue;
         }

         if (param  == "-h")
           exit_help ("myApp");

       }
     }

     int main (int argc, char **argv) {

         Application new myApp;

         myApp parseArgs argc, argv;

         myApp appOptions;
         ...
     }


That's most of the command line processing that a text-mode application
needs.  For GUI applications, unless they are very simple, it's normal
to allow the user the option of setting the window size and position.
For that purpose, the 'Application' class provides the
'parseX11Geometry' method.

Extending the example above, if the user provided a geometry
specification on the command line, the application can check for it, as
in this code snippet.


       if (geomString length > 0)
         myApp parseX11Geometry geomString;


A window geometry specification, if you're not familiar with them, is a
string that specifies a window's dimensions and placement.  For example,
the string


     300x300+100+150


places a window with a width and height of 300 pixels at 100 pixels to
the right and 150 pixels down from the screen's upper left-hand corner.

The geometry string is only a _hint_ to the window manager.  The user
option is called that because it's a recommendation.  When drawing the
application's window, the window manager also takes into account the
width of the window's frame, title bar, and any menus and buttons on the
window frame.  This has some implications that the further examples take
into account.

For example, if you provide a geometry like this one,

     +0+0

then the window manager places the window's frame at the upper left hand
corner of the screen.  The window described by our application's
'X11Pane' object is actually inset within the window frame.

You can also give a negative position.  In that case, the window manager
uses a different corner of the screen as its origin.

For example, the position


     -0-0


places the window at the lower right-hand corner of the screen.

To handle this, the 'X11Pane' class overloads the 'initialize' method.
In its simplest form, 'initialize' takes two arguments, the width and
height of the window in pixels, and lets the window system handle the
window placement.

So for very simple applications, you can simply start the application
with several expressions like these.


     int main () {

         X11Pane new myPane;

         myPane initialize 200, 250; // Set the window's initial size.

     ...
     }


For more complete applications, to set the window size and placement
with a command line option, you need to use the version of 'initialize'
that takes five arguments - the position and size of the window in
pixels, and a fifth argument, the geometry flags that that the
'parseX11Geometry' method provides.

That way the window manager can handle specifications like negative
positions, and positions off the screen.  Even with this support, the
window initialization can become quite complex, depending on what
options the user provided.

This example is abbreviated from the 'ctxlogo' program, and takes into
account whether or not the user provided the window's size and placement
as a command line option, and tries to provide some reasonable default
values.


     int main (int argc, char **argv) {
       Integer new xWindowSize;
       Integer new yWindowSize;
       Integer new xWindowOrg;
       Integer new yWindowOrg;

       X11Pane new xPane;
       X11PaneDispatcher new xTopLevelPane;
       X11CanvasPane new xCanvasPane;
       Application new ctxlogo;

       ctxlogo parseArgs argc, argv;
       ctxlogo ctxlogoOptions;
       if (geomString length > 0)
         ctxlogo parseX11Geometry geomString;

       // The window needs to have a height and a width, so check
       // for dimensions of zero.
       //
       // winWidth and winHeight are filled in by the parseArgs method,
       // above.

       if (ctxlogo winWidth > 0)
         xWindowSize = ctxlogo winWidth;
       else
         xWindowSize = 230;

       if (ctxlogo winHeight > 0)
         yWindowSize = ctxlogo winHeight;
       else
         yWindowSize = 230;

       // A zero in the x or y coordinate could also be negative,
       // so we need to wait to check the geometry flags in the
       // initialize method.
       xWindowOrg = ctxlogo winXOrg;
       yWindowOrg = ctxlogo winYOrg;


       //
       // The geomFlags instance variable is filled in by the
       // parseX11Geometry method, above.
       //
       xPane initialize xWindowOrg, yWindowOrg, xWindowSize, yWindowSize,
         ctxlogo geomFlags;
       xTopLevelPane attachTo xPane;
       xCanvasPane attachTo xTopLevelPane;

       xPane map;
       xPane raiseWindow;


       ...

X Example Programs
------------------

Because the X Window System API is still being developed, for now you
should look at the example programs provided with the Ctalk package.
The 'xhello.c' program mentioned above is one of them.  The example
programs from this manual and the 'Ctalk Language Reference' are in the
'test/expect/examples-x11' and 'test/expect/x11-tests' subdirectories.
(They're part of the Ctalk package.)


File: tutorial.info,  Node: Debugging,  Next: GNU Free Documentation License,  Prev: Graphics,  Up: Top

Error Handling and Debugging
============================

In addition to the process of debugging the internals of the Ctalk front
end and libraries, which is described in the 'Ctalk Language Reference',
there are a few classes and methods that programs can use to display
diagnostic information when they are run.

'ObjectInspector' Class
-----------------------

The 'ObjectInspector' class contains methods to print the contents of
objects, and an interactive object inspector.

The 'inspect' method is implemented in 'Object' class as a convenience
wrapper for the 'inspect' method in 'ObjectInspector' class.  That
allows you to open an interactive object inspector by sending the
message 'inspect' to any object.


     int main () {

         String new myStr;

         myStr inspect;

     }


Typing '?' or 'help' at the inspector's command prompt displays a brief
list of commands.  There is a more detail description in the
'inspect(3ctalk)' manual page and in the 'Ctalk Tools' Texinfo manual.

'Exception' Class
-----------------

Ctalk's main error handling class is 'Exception' class.  'Exception'
objects contain information about errors so that applications can handle
the errors as necessary.

Here again is the method 'highlightButton' from the section, 'Method
Dispatchers'.  *Note highlightButtonExample::.

     List instanceMethod highlightButton (void) {
       Exception new e;
       if (self value is ANSIButtonPane) {
         eval self highlightButton;
       } else {
         e raiseCriticalException INVALID_RECEIVER_X,
           "Receiver of \"highlightButton\" is not an ANSIButtonPane object";
       }
       return NULL;
     }

There are two methods that generate exceptions: 'raiseException' and
'raiseCriticalException'.

The first argument to these methods is the class of the exception, which
helps determine how Ctalk should handle the exception.  There is a
complete list of exception classes in the 'Exception' class section of
'Ctalk Language Reference'.  The second argument is text that is
provided by the method, and this text is printed when the exception's
message is displayed.

The main difference between 'raiseException' and
'raiseCriticalException' is that exceptions that are generated
internally by Ctalk are not treated as critical, and Ctalk handles them
automatically.  Critical exceptions, however, are generated by methods
and applications, and it is up to an application to handle them.

Remember that raising an exception only _records_ information about the
error condition.  To report the error condition, 'Exception' class
provides the 'pending' and 'handle' methods, which provide basic error
notification and reporting.  Here a code segment that shows a simple way
to handle an exception.

     int main () {
        Exception new myException;

        _do something..._

       if (myException pending)
         myException handle;
     }

If some previous operation raised an exception, then the 'myException
handle' deals with the error, generally, but not always, by printing an
error message on the terminal.

System Errors and 'SystemErrnoException' Class
----------------------------------------------

When programming with C, it is often necessary errors generated by C
functions.  This procedure is so common that these error conditions have
their own class, 'SystemErrnoException'.  The 'SystemErrnoException'
class simply translates an error as reported by the C library into a
Ctalk exception.

'SystemErrnoException' objects work similarly to 'Exception' objects,
but instead of providing an exception class as an argument,
'SystemErrnoException' objects record the type of error automatically
using the C library's error code.  When handling a
'SystemErrnoException', the error report is composed of the system's
text for that error code, and also the text provided by the application
when the exception is raised.

Here is an example of a 'SystemErrnoException' object.  This example is
part of the 'openOn' method from class 'ReadFileStream'.
     SystemErrnoException new __errnoException;

     _..._

     if ((f = fopen (__streamPathName, "r")) != NULL) {
       __ctalkObjValPtr (selfval, f);
       self streamPath = __streamPathName;
       self statStream;
     } else {
       __errnoException raiseException __streamPathName;
     }

'SystemErrnoException' objects are always treated as critical
exceptions, so it is up to the application to handle them by using the
'pending' and 'handle' methods as described in the previous section.

Printing Call Sequences for Exceptions
--------------------------------------

While exceptions are convenient for recording error conditions,
reporting an error later can also make it difficult to determine exactly
where or when in the program the error occurred.  For this reason,
exceptions also record the program's call stack at the time the
exception occurred.

The method 'enableExceptionTrace' in class 'Object' enables the printing
of the program's call stack to the console's standard error channel when
a program deals with an exception using 'handle' (class 'Exception').

A program can turn off the display of the call stack with the
'disableExceptionTrace' method, also in class 'Object'.  The method
'traceEnabled' in class 'Object' returns 'TRUE' or 'FALSE' depending on
whether call stack displays are enabled.

A program can print an exception's call stack using
'printExceptionTrace' in class 'Exception'.  Here is the code from the
'handle' method that calls 'printExceptionTrace'.
     if (self traceEnabled) {
       self printExceptionTrace;
     }

Application Specific Exception Handlers
---------------------------------------

Sometimes simply printing an error message to the terminal is not
useful, so 'Exception' class allows you to define application specific
exception handlers.

When handling exceptions, Ctalk handles the 'Exception' object using the
highest-level handler _that is installed by the application,_ or the
default handler otherwise.

Briefly, custom exception handlers are 'Method' objects that are defined
by an application and implemented in 'Exception' class.  Applications
use the 'installHandler' method, also from 'Exception' class, to install
them.

There is an example of an application specific exception handler in the
'Exception' class section of the 'Ctalk Language Reference', as well as
a discussion of how an application might handle exceptions.

One common use of custom handlers is a Web CGI program.  Simply
outputting error messages to the terminal does not provide any useful
information; instead, using a custom exception handler, the application
can print error messages in the Web browser window.

Here is the exception handler from the 'wiki.c' example program.
     Exception instanceMethod errorToBrowser (void) {
       String new msg;
       wikiApp httpHeader;
       wikiApp htmlPageHeader "Ctalk Wiki | Error";
       wikiApp outputString "<h2>Ctalk Wiki Error:</h2>";
       msg = __ctalkPeekExceptionTrace ();
       wikiApp outputString "<pre>" + msg + "</pre><br>";
       msg = __ctalkPeekRunTimeException ();
       wikiApp outputString "<pre>" + msg + "</pre>";
       wikiApp outputString "Please contact your system adminstrator or " +
         "the Ctalk language project at rk3314042@gmail.com.";
       error = TRUE;
       return NULL;
     }

Then, when the application is run, it installs the handler using
statements like these.
     Exception new postDataException;
     _..._
     postDataException installHandler "errorToBrowser";

Examining Objects with Inspectors
---------------------------------

Ctalk provides a basic set of methods that can inspect and print the
contents of objects.

The 'inspect' method in 'Object' class is an interactive utility that
lets you examine a program's objects as the program is running.

To inspect an object, simply send it the message, 'inspect' - it's a
shortcut for the 'inspect' method in 'ObjectInspector' class, which a
program can also call directly.


     String new globalString;

     int main () {
       Integer new i;

       globalString = "global string";

       i inspect;
     }


In either case, the program stops execution when it reaches the
'inspect' method, and presents a prompt where you can type commands.

Here's a transcript of a brief inspector session.


     $ ./inspect
     > p
     p
     name:       i
     class:      Integer (0x48bf4958)
     superclass: Magnitude (0x48bf29f0)
     value:      (null) (Integer)

     > p g globalString
     p g globalString
     name:       globalString
     class:      String (0x48cce8d0)
     superclass: Character (0x48c8acc0)
     value:      global string (String)

     > c
     c
     $


At the inspector prompt, '> ', the command 'p' prints the inspector's
receiver object, and 'p g globalString' prints the named global object,
'globalString'.  The 'c' command exits the inspector and continues
running the program.

There are several commands that the inspector recognizes.  Typing '?,'
'h,' or 'help' at the prompt displays a list of them.

The inspector uses the method 'formatObject' to print the contents of
individual objects.

If you want to print a formatted object directly, without stopping the
program, Ctalk also has the method 'dump' in 'Object' class, which
simply calls 'formatObject' with its receiver object to print the object
and then returns so the program can continue running.

You can also debug Ctalk apps (and Ctalk itself) at the source code
level with the GNU 'gdb' debugger.  This requires that you build Ctalk
and/or its application programs with the source information.  Refer to
the "Debugging" section of the 'Ctalk Language Reference' for more
information.

Exit Handlers and Error Tracing
-------------------------------

Ctalk provides two C handlers that you can use for debugging,
'installExitHandlerBasic' and 'installAbortHandlerBasic'.  They are
written in C and are more robust, though less flexible, than signal
handlers written using 'SignalHandler' objects.

These signal handlers provide basic cleanup of the class dictionaries
before exiting, and, if stack tracing is enabled, optionally print a
stack trace of where the program was executing when the signal occurred.

For example, to enable the handlers with stack tracing, you could use
the following code.
     Application new myApp;
     Object new anyObject;
     ...
     anyObject enableExceptionTrace;
     myApp installExitHandlerBasic;
     myApp installAbortHandlerBasic;

The 'enableExceptionTrace' method is defined in class 'Object', so you
can send the message to any object in a program to enable exception
tracing.

The 'installExitHandlerBasic' method provides a handler that exits a
program neatly when the user presses 'C-c' in a UNIX terminal or
'C-break' in a DJGPP text window.

The 'installAbortHandlerBasic' method is useful for printing traces when
a system library detects an error.

If the application enables exception tracing, these methods print a
stack trace from the point where a signal is received before causing the
application to exit.

It is relatively easy to write handlers for whatever signals a program
needs to catch.  The methods in the 'Application' and 'SignalHandler'
classes should provide a starting point for writing application-specific
handlers.  Also, you might want to look at 'timeclient.c' and
'timesignal.c' in the 'demos' subdirectory of the Ctalk distribution.


File: tutorial.info,  Node: GNU Free Documentation License,  Next: Index,  Prev: Debugging,  Up: Top

GNU Free Documentation License
==============================


                             Version 1.1, March 2000
          Copyright (C) 2000  Free Software Foundation, Inc.
          59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

          Everyone is permitted to copy and distribute example copies
          of this license document, but changing it is not allowed.



       0. PREAMBLE

          The purpose of this License is to make a manual, textbook, or other
          written document "free" in the sense of freedom: to assure everyone
          the effective freedom to copy and redistribute it, with or without
          modifying it, either commercially or noncommercially.  Secondarily,
          this License preserves for the author and publisher a way to get
          credit for their work, while not being considered responsible for
          modifications made by others.

          This License is a kind of "copyleft", which means that derivative
          works of the document must themselves be free in the same sense.
          It complements the GNU General Public License, which is a copyleft
          license designed for free software.

          We have designed this License in order to use it for manuals for
          free software, because free software needs free documentation: a
          free program should come with manuals providing the same freedoms
          that the software does.  But this License is not limited to
          software manuals; it can be used for any textual work, regardless
          of subject matter or whether it is published as a printed book.
          We recommend this License principally for works whose purpose is
          instruction or reference.


       1. APPLICABILITY AND DEFINITIONS

          This License applies to any manual or other work that contains a
          notice placed by the copyright holder saying it can be distributed
          under the terms of this License.  The "Document", below, refers to
          any such manual or work.  Any member of the public is a licensee,
          and is addressed as "you."

          A "Modified Version" of the Document means any work containing the
          Document or a portion of it, either copied example, or with
          modifications and/or translated into another language.

          A "Secondary Section" is a named appendix or a front-matter
          section of the Document that deals exclusively with the
          relationship of the publishers or authors of the Document to the
          Document's overall subject (or to related matters) and contains
          nothing that could fall directly within that overall subject.
          (For example, if the Document is in part a textbook of
          mathematics, a Secondary Section may not explain any mathematics.)
          The relationship could be a matter of historical connection with
          the subject or with related matters, or of legal, commercial,
          philosophical, ethical or political position regarding them.

          The "Invariant Sections" are certain Secondary Sections whose
          titles are designated, as being those of Invariant Sections, in
          the notice that says that the Document is released under this
          License.

          The "Cover Texts" are certain short passages of text that are
          listed, as Front-Cover Texts or Back-Cover Texts, in the notice
          that says that the Document is released under this License.

          A "Transparent" copy of the Document means a machine-readable copy,
          represented in a format whose specification is available to the
          general public, whose contents can be viewed and edited directly
          and straightforwardly with generic text editors or (for images
          composed of pixels) generic paint programs or (for drawings) some
          widely available drawing editor, and that is suitable for input to
          text formatters or for automatic translation to a variety of
          formats suitable for input to text formatters.  A copy made in an
          otherwise Transparent file format whose markup has been designed
          to thwart or discourage subsequent modification by readers is not
          Transparent.  A copy that is not "Transparent" is called "Opaque."

          Examples of suitable formats for Transparent copies include plain
          ASCII without markup, Texinfo input format, LaTeX input format,
          SGML or XML using a publicly available DTD, and
          standard-conforming simple HTML designed for human modification.
          Opaque formats include PostScript, PDF, proprietary formats that
          can be read and edited only by proprietary word processors, SGML
          or XML for which the DTD and/or processing tools are not generally
          available, and the machine-generated HTML produced by some word
          processors for output purposes only.

          The "Title Page" means, for a printed book, the title page itself,
          plus such following pages as are needed to hold, legibly, the
          material this License requires to appear in the title page.  For
          works in formats which do not have any title page as such, "Title
          Page" means the text near the most prominent appearance of the
          work's title, preceding the beginning of the body of the text.


       2. EXAMPLE COPYING

          You may copy and distribute the Document in any medium, either
          commercially or noncommercially, provided that this License, the
          copyright notices, and the license notice saying this License
          applies to the Document are reproduced in all copies, and that you
          add no other conditions whatsoever to those of this License.  You
          may not use technical measures to obstruct or control the reading
          or further copying of the copies you make or distribute.  However,
          you may accept compensation in exchange for copies.  If you
          distribute a large enough number of copies you must also follow
          the conditions in section 3.

          You may also lend copies, under the same conditions stated above,
          and you may publicly display copies.


       3. COPYING IN QUANTITY

          If you publish printed copies of the Document numbering more than
          100, and the Document's license notice requires Cover Texts, you
          must enclose the copies in covers that carry, clearly and legibly,
          all these Cover Texts: Front-Cover Texts on the front cover, and
          Back-Cover Texts on the back cover.  Both covers must also clearly
          and legibly identify you as the publisher of these copies.  The
          front cover must present the full title with all words of the
          title equally prominent and visible.  You may add other material
          on the covers in addition.  Copying with changes limited to the
          covers, as long as they preserve the title of the Document and
          satisfy these conditions, can be treated as example copying in
          other respects.

          If the required texts for either cover are too voluminous to fit
          legibly, you should put the first ones listed (as many as fit
          reasonably) on the actual cover, and continue the rest onto
          adjacent pages.

          If you publish or distribute Opaque copies of the Document
          numbering more than 100, you must either include a
          machine-readable Transparent copy along with each Opaque copy, or
          state in or with each Opaque copy a publicly-accessible
          computer-network location containing a complete Transparent copy
          of the Document, free of added material, which the general
          network-using public has access to download anonymously at no
          charge using public-standard network protocols.  If you use the
          latter option, you must take reasonably prudent steps, when you
          begin distribution of Opaque copies in quantity, to ensure that
          this Transparent copy will remain thus accessible at the stated
          location until at least one year after the last time you
          distribute an Opaque copy (directly or through your agents or
          retailers) of that edition to the public.

          It is requested, but not required, that you contact the authors of
          the Document well before redistributing any large number of
          copies, to give them a chance to provide you with an updated
          version of the Document.


       4. MODIFICATIONS

          You may copy and distribute a Modified Version of the Document
          under the conditions of sections 2 and 3 above, provided that you
          release the Modified Version under precisely this License, with
          the Modified Version filling the role of the Document, thus
          licensing distribution and modification of the Modified Version to
          whoever possesses a copy of it.  In addition, you must do these
          things in the Modified Version:

          A. Use in the Title Page (and on the covers, if any) a title
          distinct    from that of the Document, and from those of previous
          versions    (which should, if there were any, be listed in the
          History section    of the Document).  You may use the same title
          as a previous version    if the original publisher of that version
          gives permission.
          B. List on the Title Page, as authors, one or more persons or
          entities    responsible for authorship of the modifications in the
          Modified    Version, together with at least five of the principal
          authors of the    Document (all of its principal authors, if it
          has less than five).
          C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.
          D. Preserve all the copyright notices of the Document.
          E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.
          F. Include, immediately after the copyright notices, a license
          notice    giving the public permission to use the Modified Version
          under the    terms of this License, in the form shown in the
          Addendum below.
          G. Preserve in that license notice the full lists of Invariant
          Sections    and required Cover Texts given in the Document's
          license notice.
          H. Include an unaltered copy of this License.
          I. Preserve the section entitled "History", and its title, and add
          to    it an item stating at least the title, year, new authors, and
            publisher of the Modified Version as given on the Title Page.
          If    there is no section entitled "History" in the Document,
          create one    stating the title, year, authors, and publisher of
          the Document as    given on its Title Page, then add an item
          describing the Modified    Version as stated in the previous
          sentence.
          J. Preserve the network location, if any, given in the Document for
            public access to a Transparent copy of the Document, and
          likewise    the network locations given in the Document for
          previous versions    it was based on.  These may be placed in the
          "History" section.     You may omit a network location for a work
          that was published at    least four years before the Document
          itself, or if the original    publisher of the version it refers
          to gives permission.
          K. In any section entitled "Acknowledgements" or "Dedications",
          preserve the section's title, and preserve in the section all the
           substance and tone of each of the contributor acknowledgements
          and/or dedications given therein.
          L. Preserve all the Invariant Sections of the Document,
          unaltered in their text and in their titles.  Section numbers
          or the equivalent are not considered part of the section titles.
          M. Delete any section entitled "Endorsements."  Such a section
          may not be included in the Modified Version.
          N. Do not retitle any existing section as "Endorsements"    or to
          conflict in title with any Invariant Section.

          If the Modified Version includes new front-matter sections or
          appendices that qualify as Secondary Sections and contain no
          material copied from the Document, you may at your option
          designate some or all of these sections as invariant.  To do this,
          add their titles to the list of Invariant Sections in the Modified
          Version's license notice.  These titles must be distinct from any
          other section titles.

          You may add a section entitled "Endorsements", provided it contains
          nothing but endorsements of your Modified Version by various
          parties-for example, statements of peer review or that the text has
          been approved by an organization as the authoritative definition
          of a standard.

          You may add a passage of up to five words as a Front-Cover Text,
          and a passage of up to 25 words as a Back-Cover Text, to the end
          of the list of Cover Texts in the Modified Version.  Only one
          passage of Front-Cover Text and one of Back-Cover Text may be
          added by (or through arrangements made by) any one entity.  If the
          Document already includes a cover text for the same cover,
          previously added by you or by arrangement made by the same entity
          you are acting on behalf of, you may not add another; but you may
          replace the old one, on explicit permission from the previous
          publisher that added the old one.

          The author(s) and publisher(s) of the Document do not by this
          License give permission to use their names for publicity for or to
          assert or imply endorsement of any Modified Version.


       5. COMBINING DOCUMENTS

          You may combine the Document with other documents released under
          this License, under the terms defined in section 4 above for
          modified versions, provided that you include in the combination
          all of the Invariant Sections of all of the original documents,
          unmodified, and list them all as Invariant Sections of your
          combined work in its license notice.

          The combined work need only contain one copy of this License, and
          multiple identical Invariant Sections may be replaced with a single
          copy.  If there are multiple Invariant Sections with the same name
          but different contents, make the title of each such section unique
          by adding at the end of it, in parentheses, the name of the
          original author or publisher of that section if known, or else a
          unique number.  Make the same adjustment to the section titles in
          the list of Invariant Sections in the license notice of the
          combined work.

          In the combination, you must combine any sections entitled
          "History" in the various original documents, forming one section
          entitled "History"; likewise combine any sections entitled
          "Acknowledgements", and any sections entitled "Dedications."  You
          must delete all sections entitled "Endorsements."


       6. COLLECTIONS OF DOCUMENTS

          You may make a collection consisting of the Document and other
          documents released under this License, and replace the individual
          copies of this License in the various documents with a single copy
          that is included in the collection, provided that you follow the
          rules of this License for example copying of each of the
          documents in all other respects.

          You may extract a single document from such a collection, and
          distribute it individually under this License, provided you insert
          a copy of this License into the extracted document, and follow
          this License in all other respects regarding example copying of
          that document.


       7. AGGREGATION WITH INDEPENDENT WORKS

          A compilation of the Document or its derivatives with other
          separate and independent documents or works, in or on a volume of
          a storage or distribution medium, does not as a whole count as a
          Modified Version of the Document, provided no compilation
          copyright is claimed for the compilation.  Such a compilation is
          called an "aggregate", and this License does not apply to the
          other self-contained works thus compiled with the Document, on
          account of their being thus compiled, if they are not themselves
          derivative works of the Document.

          If the Cover Text requirement of section 3 is applicable to these
          copies of the Document, then if the Document is less than one
          quarter of the entire aggregate, the Document's Cover Texts may be
          placed on covers that surround only the Document within the
          aggregate.  Otherwise they must appear on covers around the whole
          aggregate.


       8. TRANSLATION

          Translation is considered a kind of modification, so you may
          distribute translations of the Document under the terms of section
          4.  Replacing Invariant Sections with translations requires special
          permission from their copyright holders, but you may include
          translations of some or all Invariant Sections in addition to the
          original versions of these Invariant Sections.  You may include a
          translation of this License provided that you also include the
          original English version of this License.  In case of a
          disagreement between the translation and the original English
          version of this License, the original English version will prevail.


       9. TERMINATION

          You may not copy, modify, sublicense, or distribute the Document
          except as expressly provided for under this License.  Any other
          attempt to copy, modify, sublicense or distribute the Document is
          void, and will automatically terminate your rights under this
          License.  However, parties who have received copies, or rights,
          from you under this License will not have their licenses
          terminated so long as such parties remain in full compliance.


      10. FUTURE REVISIONS OF THIS LICENSE

          The Free Software Foundation may publish new, revised versions of
          the GNU Free Documentation License from time to time.  Such new
          versions will be similar in spirit to the present version, but may
          differ in detail to address new problems or concerns.  See
          http://www.gnu.org/copyleft/.

          Each version of the License is given a distinguishing version
          number.  If the Document specifies that a particular numbered
          version of this License "or any later version" applies to it, you
          have the option of following the terms and conditions either of
          that specified version or of any later version that has been
          published (not as a draft) by the Free Software Foundation.  If
          the Document does not specify a version number of this License,
          you may choose any version ever published (not as a draft) by the
          Free Software Foundation.


     ADDENDUM: How to use this License for your documents

        To use this License in a document you have written, include a copy of
     the License in the document and put the following copyright and license
     notices just after the title page:

          Copyright (C)  YEAR  YOUR NAME.
          Permission is granted to copy, distribute and/or modify this document
          under the terms of the GNU Free Documentation License, Version 1.1
          or any later version published by the Free Software Foundation;
          with the Invariant Sections being LIST THEIR TITLES, with the
          Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
          A copy of the license is included in the section entitled "GNU
          Free Documentation License."

        If you have no Invariant Sections, write "with no Invariant Sections"
     instead of saying which ones are invariant.  If you have no Front-Cover
     Texts, write "no Front-Cover Texts" instead of "Front-Cover Texts being
     LIST"; likewise for Back-Cover Texts.

        If your document contains nontrivial examples of program code, we
     recommend releasing these examples in parallel under your choice of
     free software license, such as the GNU General Public License, to
     permit their use in free software.



File: tutorial.info,  Node: Index,  Prev: GNU Free Documentation License,  Up: Top

16 Index
========

 [index ]
* Menu:

* & method (Character class):            Basic classes.      (line   96)
* * instance method (Collection class):  Collections.        (line  519)
* * instance method (Key class):         Collections.        (line  519)
* * instance method (String class):      Basic classes.      (line  288)
* * method (Symbol class):               Basic classes.      (line  908)
* + instance method (Key class):         Collections.        (line  519)
* + instance method (String class):      Basic classes.      (line  288)
* + method (Character class):            Basic classes.      (line   68)
* + method (String class):               Basic classes.      (line  128)
* ++ instance method (Collection class): Basic classes.      (line  598)
* ++ instance method (Key class):        Collections.        (line  519)
* ++ instance method (String class):     Basic classes.      (line  288)
* += instance method (Key class):        Collections.        (line  519)
* += instance method (String class):     Basic classes.      (line  288)
* - (Character class):                   Basic classes.      (line   84)
* - instance method (Key class):         Collections.        (line  519)
* - instance method (String class):      Basic classes.      (line  288)
* -- instance method (Collection class): Basic classes.      (line  598)
* -- instance method (Key class):        Collections.        (line  519)
* -- instance method (String class):     Basic classes.      (line  288)
* --printlibdirs command line option:    Classes.            (line  371)
* -= instance method (Key class):        Collections.        (line  519)
* -= instance method (String class):     Basic classes.      (line  288)
* -> instance method (Object class):     Basic classes.      (line 1164)
* -I command line option:                Classes.            (line  335)
* = instance method (Integer class):     Methods.            (line  506)
* = instance method (Integer class) <1>: Methods.            (line  810)
* = instance method (List class):        Collections.        (line  214)
* = instance method (String class):      Methods.            (line  880)
* = method (Character class):            Basic classes.      (line  801)
* = method (Integer class):              Basic classes.      (line  801)
* = method (Integer class) <1>:          Methods.            (line  792)
* = method (List class):                 Collections.        (line  982)
* = method (List class) <1>:             Collections.        (line  993)
* = method (String class):               Basic classes.      (line  128)
* = method (String class) <1>:           Basic classes.      (line  801)
* = method (Symbol class):               Basic classes.      (line  908)
* = method (Symbol class) <1>:           Methods.            (line  708)
* == method (String class):              Basic classes.      (line  128)
* ^ method (Character class):            Basic classes.      (line   96)
* ^ method (Character class) <1>:        Methods.            (line  255)
* __ctalkAliasObject () function:        Methods.            (line  759)
* __ctalkAliasReceiver () function:      Methods.            (line  759)
* __ctalkCreateObjectInit function:      Methods.            (line  479)
* __ctalkInlineMethod function:          Basic classes.      (line  532)
* __ctalkInstanceVarsFromClassObject () function: Classes.   (line  232)
* __ctalkInstanceVarsFromClassObject () function <1>: Methods.
                                                             (line 1178)
* __ctalkPrintObject function:           Debugging.          (line  258)
* __ctalkStringifyName () function:      Methods.            (line  896)
* __ctalk_to_c_char_ptr() function:      Methods.            (line  381)
* __ctalk_to_c_int() function:           Methods.            (line  381)
* | method (Character class):            Basic classes.      (line   96)
* addChild method (TreeNode class):      Collections.        (line  448)
* addInstanceVariable instance method (Object class): Methods.
                                                             (line  512)
* addressOf instance method (Object class): Basic classes.   (line 1103)
* ANSIMessageBoxPane:                    Graphics.           (line   42)
* ANSITerminalStream Class:              Collections.        (line   18)
* argc C variable:                       Hello.              (line  119)
* Argument blocks:                       Basic classes.      (line  466)
* Arguments, class of:                   Self and super.     (line  471)
* argv C variable:                       Hello.              (line  119)
* Array class:                           Basic classes.      (line   10)
* Array class <1>:                       Basic classes.      (line  356)
* Array Class:                           Collections.        (line    7)
* asCharacter method (Magnitude class):  Basic classes.      (line  796)
* asCharacter method (Magnitude class) <1>: Methods.         (line  284)
* asInteger instance method (Magnitude class): Basic classes.
                                                             (line 1364)
* asInteger instance method (Magnitude class) <1>: Methods.  (line  536)
* asInteger instance method (String class): Basic classes.   (line 1364)
* asInteger method (Magnitude class):    Basic classes.      (line  796)
* asInteger method (Magnitude class) <1>: Methods.           (line  275)
* asLongInteger method (Magnitude class): Basic classes.     (line  796)
* AssociativeArray Class:                Collections.        (line    7)
* AssociativeArray Class <1>:            Collections.        (line  300)
* asString method (Magnitude class):     Basic classes.      (line  161)
* at method (Array class):               Hello.              (line   97)
* at method (Array class) <1>:           Basic classes.      (line  371)
* at method (Array class) <2>:           Methods.            (line  195)
* at method (AssociativeArray class):    Collections.        (line  306)
* atPut method (Array class):            Basic classes.      (line  360)
* atPut method (AssociativeArray class): Collections.        (line  306)
* basicNew method (Object class):        Collections.        (line  271)
* basicNew method (Object class) <1>:    Collections.        (line  448)
* become method (Object class):          Basic classes.      (line  808)
* become method (Object class) <1>:      Methods.            (line 1115)
* bitComp method (Integer class):        Basic classes.      (line   43)
* break within an argument block:        Basic classes.      (line  495)
* C Macros:                              Methods.            (line 1189)
* CalendarTime class:                    Hello.              (line  193)
* CGIApp class:                          Methods.            (line   48)
* char C data type:                      Basic classes.      (line   10)
* Character class:                       Basic classes.      (line   10)
* Character class <1>:                   Basic classes.      (line   29)
* Class:                                 Objects.            (line   32)
* Class hierarchy:                       Objects.            (line   40)
* Class hierarchy <1>:                   Objects.            (line  214)
* class method (Object class):           Classes.            (line   18)
* class method (Object class) <1>:       Methods.            (line  145)
* Class variable:                        Objects.            (line  123)
* classdoc program:                      Basic classes.      (line 1557)
* classInit method (ReadFileStream class): File input and output.
                                                             (line  152)
* classInit method (WriteFileStream class): File input and output.
                                                             (line  152)
* CLASSLIBDIRS environment variable:     Classes.            (line  335)
* classMethod keyword:                   Methods.            (line  211)
* classMethod method (Object class):     Methods.            (line  149)
* classObject instance method (Object class): Basic classes. (line 1538)
* classSearchPath instance method (Application class): Classes.
                                                             (line  363)
* classVariable method (Object class):   Classes.            (line  123)
* classVariable method (Object class) <1>: Methods.          (line  153)
* cleanup instance method (ANSIWidgetPane class): Graphics.  (line  248)
* clear instance method (ANSITerminalStream class): Graphics.
                                                             (line  143)
* cmdLineArgs instance variable (Application class): Graphics.
                                                             (line 1112)
* Collection Class:                      Collections.        (line   18)
* Command line options:                  Graphics.           (line 1104)
* Compound statements:                   Basic classes.      (line  637)
* consoleReadLine method (String class): File input and output.
                                                             (line  247)
* Constructor:                           Objects.            (line  144)
* Constructor methods:                   Methods.            (line  921)
* Constructors:                          Basic classes.      (line   29)
* copy instance method (Object class):   Methods.            (line  556)
* copy method (Object class):            Basic classes.      (line  894)
* ctalkdefs.h include file.:             Methods.            (line 1189)
* CTALK_DIRECTORY_MODE macro:            File input and output.
                                                             (line  205)
* ctcc command:                          Hello.              (line   35)
* ctcc command <1>:                      Hello.              (line  102)
* CTime class:                           Hello.              (line  152)
* CTime class <1>:                       Hello.              (line  193)
* ctpath example program:                Hello.              (line   54)
* Debugging:                             Debugging.          (line    6)
* Default method:                        Basic classes.      (line 1421)
* delete instance method (List class):   Collections.        (line  232)
* deref instance method (Symbol class):  Basic classes.      (line 1103)
* dimension instance method (Rectangle class): Graphics.     (line  408)
* Directories:                           File input and output.
                                                             (line  199)
* DirectoryStream class:                 File input and output.
                                                             (line    9)
* DirectoryStream class <1>:             File input and output.
                                                             (line  199)
* Dispatch methods:                      Self and super.     (line  281)
* double C data type:                    Basic classes.      (line   10)
* draw instance method (Line class):     Graphics.           (line  348)
* draw instance method (Point class):    Graphics.           (line  348)
* draw instance method (Rectangle class): Graphics.          (line  348)
* drawWithPen instance method (Line class): Graphics.        (line  428)
* drawWithPen instance method (Point class): Graphics.       (line  428)
* drawWithPen instance method (Rectangle class): Graphics.   (line  428)
* dump instance method (Object class):   Debugging.          (line  258)
* enableExceptionTrace method (Object class): Debugging.     (line  275)
* eval keyword:                          Basic classes.      (line 1510)
* eval keyword <1>:                      Self and super.     (line  285)
* Exception class:                       Debugging.          (line   39)
* Expressions as receivers:              Basic classes.      (line  679)
* FileStream class:                      File input and output.
                                                             (line    9)
* FileStream Class:                      Collections.        (line   18)
* fillWithPen instance method (Rectangle class): Graphics.   (line  428)
* float C data type:                     Basic classes.      (line   10)
* Float class:                           Basic classes.      (line   10)
* Float class <1>:                       Basic classes.      (line   29)
* FMT_0XHEX macro:                       Methods.            (line 1189)
* Fonts:                                 Graphics.           (line  515)
* format method (TreeNode class):        Collections.        (line  476)
* formatObject instance method (Object class): Debugging.    (line  258)
* getCh instance method (ANSITerminalStream class): Graphics.
                                                             (line  122)
* getCh instance method (ANSITerminalStream class) <1>: Graphics.
                                                             (line  232)
* getFontInfo instance method (X11Font class): Graphics.     (line  545)
* getValue method (Collection class):    Collections.        (line  496)
* getValue method (Symbol class):        Basic classes.      (line  908)
* GLUTApplication class:                 Graphics.           (line  733)
* GLX:                                   Graphics.           (line  907)
* GLXCanvasPane class:                   Graphics.           (line  907)
* GNU Free Documentation License:        GNU Free Documentation License.
                                                             (line    6)
* GNU Readline:                          File input and output.
                                                             (line  247)
* gotoXY instance method (ANSITerminalStream class): Graphics.
                                                             (line  143)
* Graphics:                              Graphics.           (line    6)
* Graphics, 3D:                          Graphics.           (line  733)
* Graphics, 3D <1>:                      Graphics.           (line  907)
* Graphics, OpenGL:                      Graphics.           (line  733)
* Graphics, OpenGL <1>:                  Graphics.           (line  907)
* handle instance method (Exception class): Debugging.       (line   73)
* handleInput instance method (ANSITerminalPane class): Graphics.
                                                             (line  187)
* handleInput instance method (ANSIWidgetPane class): Graphics.
                                                             (line  206)
* handleInput instance method (ANSIWidgetPane class) <1>: Graphics.
                                                             (line  248)
* hasPointerContext instance method (Symbol class): Methods. (line  759)
* hello example program:                 Hello.              (line   14)
* highlightButton instance method (List class): Debugging.   (line   46)
* Inheritance:                           Objects.            (line  144)
* initialize instance method (X11Pane class): Graphics.      (line 1222)
* Inline methods:                        Basic classes.      (line  414)
* inspect instance method (Object class): Debugging.         (line   17)
* inspect instance method (Object class) <1>: Debugging.     (line  202)
* Inspectors:                            Debugging.          (line   14)
* installAbortHandlerBasic method (Application class): Debugging.
                                                             (line  275)
* installExitHandlerBasic method (Application class): Debugging.
                                                             (line  275)
* installHandler instance method (Exception class): Debugging.
                                                             (line  163)
* Instance variable:                     Objects.            (line  123)
* Instance variable <1>:                 Objects.            (line  130)
* instanceMethod keyword:                Methods.            (line  211)
* instanceMethod method (Object class):  Methods.            (line  159)
* instanceVariable method (Object class): Classes.           (line   93)
* instanceVariable method (Object class) <1>: Methods.       (line  163)
* Integer class:                         Basic classes.      (line   10)
* Integer class <1>:                     Basic classes.      (line   29)
* invert method (Integer class):         Basic classes.      (line   43)
* is method (Object class):              Classes.            (line  305)
* is method (Object class) <1>:          Methods.            (line  797)
* isNull method (String class):          Methods.            (line  105)
* isSubClassOf method (Object class):    Classes.            (line  313)
* IS_OBJECT macro:                       Methods.            (line 1189)
* Key class:                             Collections.        (line  300)
* Key class <1>:                         Collections.        (line  324)
* Key class <2>:                         Methods.            (line  454)
* levelMargin instance variable (TreeNode class): Collections.
                                                             (line  476)
* levelMarginLength instance variable (TreeNode class): Collections.
                                                             (line  476)
* Library search path:                   Classes.            (line  335)
* Line class:                            Graphics.           (line  343)
* List Class:                            Collections.        (line    7)
* List Class <1>:                        Collections.        (line   49)
* localTime method (CTime class):        Hello.              (line  152)
* localTime method (CTime class) <1>:    Hello.              (line  193)
* localtime(3) C function:               Hello.              (line  152)
* long int C data type:                  Basic classes.      (line   10)
* long long int C data type:             Basic classes.      (line   10)
* LongInteger class:                     Basic classes.      (line   10)
* LongInteger class <1>:                 Basic classes.      (line   29)
* Magnitude class:                       Basic classes.      (line  791)
* makeSibling method (TreeNode class):   Collections.        (line  448)
* map (Array class):                     Basic classes.      (line  414)
* map instance method (ANSITerminalPane class): Graphics.    (line  272)
* map method (AssociativeArray class):   Collections.        (line  316)
* map method (List class):               Collections.        (line  127)
* mapClassVariables instance method (Object class): Basic classes.
                                                             (line 1308)
* mapInstanceVariables instance method (Object class): Basic classes.
                                                             (line  545)
* mapInstanceVariables instance method (Object class) <1>: Basic classes.
                                                             (line 1308)
* mapKeys method (AssociativeArray class): Collections.      (line  316)
* Message:                               Objects.            (line   52)
* Method:                                Objects.            (line   52)
* Method declarations:                   Methods.            (line  211)
* Method used before it is defined exception: Classes.       (line  281)
* Methods:                               Methods.            (line    6)
* mkDir method (DirectoryStream class):  File input and output.
                                                             (line  199)
* Modeling, 3D:                          Graphics.           (line  733)
* Modeling, 3D <1>:                      Graphics.           (line  907)
* new instance method (ANSIWidgetPane class): Graphics.      (line  248)
* new method (ANSIScrollingListBoxPane class): Methods.      (line 1115)
* new method (Object class):             Objects.            (line  144)
* new method (Object class) <1>:         Basic classes.      (line   29)
* new method (Object class) <2>:         Methods.            (line  137)
* new method (Object class) <3>:         Methods.            (line  170)
* new method (WriteFileStream class):    Objects.            (line  144)
* new method (WriteFileStream class) <1>: Self and super.    (line   57)
* OBJECT typedef:                        Methods.            (line  340)
* ObjectInspector class:                 Debugging.          (line   14)
* ObjectInspector class <1>:             Debugging.          (line  258)
* OpenGL graphics:                       Graphics.           (line  733)
* OpenGL graphics <1>:                   Graphics.           (line  907)
* openInputQueue instance method (ANSITerminalStream class): Graphics.
                                                             (line  240)
* openOn instance method (ANSITerminalStream class): Graphics.
                                                             (line  309)
* openOn instance method (ReadFileStream class): Debugging.  (line  109)
* openOn method (ReadFileStream class):  File input and output.
                                                             (line   20)
* Operator overloading:                  Objects.            (line  105)
* Options, command line:                 Graphics.           (line 1104)
* Pane class:                            Graphics.           (line   10)
* Panes:                                 Graphics.           (line    6)
* parent instance method (ANSIWidgetPane class): Graphics.   (line  248)
* parseArgs instance method (Application class): Graphics.   (line 1112)
* parseQueryString method (CGIApp class): Methods.           (line   48)
* parseX11Geometry instance method (Application class): Graphics.
                                                             (line 1170)
* Pen class:                             Graphics.           (line  425)
* pending instance method (Exception class): Debugging.      (line   73)
* Point class:                           Graphics.           (line  343)
* Polymorphism:                          Objects.            (line  105)
* pop method (List class):               Collections.        (line   60)
* Primitive methods:                     Methods.            (line  133)
* print method (TreeNode class):         Collections.        (line  476)
* printf(3) C function.:                 File input and output.
                                                             (line  139)
* printOn instance method (ANSITerminalStream class): Graphics.
                                                             (line  143)
* printOn instance method (String class): Basic classes.     (line 1370)
* printOn instance method (WriteFileStream class): Basic classes.
                                                             (line 1370)
* push method (List class):              Collections.        (line   51)
* quickSearch instance method (String class): Basic classes. (line  205)
* raiseCriticalException instance method (Exception class): Debugging.
                                                             (line   57)
* raiseException instance method (Exception class): Debugging.
                                                             (line   57)
* rawMode instance method (ANSITerminalStream class): Graphics.
                                                             (line  150)
* readAll method (ReadFileStream class): File input and output.
                                                             (line   40)
* readAll method (ReadFileStream class) <1>: File input and output.
                                                             (line   78)
* readChar method (ReadFileStream class): File input and output.
                                                             (line   40)
* ReadFileStream class:                  File input and output.
                                                             (line    9)
* ReadFileStream Class:                  Collections.        (line   18)
* readLine method (ReadFileStream class): File input and output.
                                                             (line   40)
* readLine method (ReadFileStream class) <1>: File input and output.
                                                             (line   88)
* readRec method (ReadFileStream class): File input and output.
                                                             (line   40)
* Receiver:                              Objects.            (line   52)
* Rectangle class:                       Graphics.           (line  343)
* References to objects:                 Methods.            (line  446)
* refresh instance method (ANSIWidgetPane class): Graphics.  (line  248)
* removeAt method (Collection class):    Collections.        (line  320)
* require keyword:                       Classes.            (line   63)
* require keyword <1>:                   Classes.            (line  267)
* restoreTerm instance method (ANSITerminalStream class): Graphics.
                                                             (line  150)
* restoreTerm instance method (ANSITerminalStream class) <1>: Graphics.
                                                             (line  232)
* rmDir method (DirectoryStream class):  File input and output.
                                                             (line  199)
* search instance method (String class): Basic classes.      (line  205)
* self:                                  Objects.            (line  252)
* self <1>:                              Self and super.     (line    6)
* self, class of:                        Self and super.     (line  143)
* self, class of <1>:                    Self and super.     (line  281)
* setContent method (TreeNode class):    Collections.        (line  448)
* setTty instance method (ANSITerminalStream class): Graphics.
                                                             (line  309)
* setValue instance method (Symbol class): Methods.          (line  654)
* setValue method (Symbol class):        Basic classes.      (line  908)
* shift method (List class):             Collections.        (line   74)
* size method (Array class):             Basic classes.      (line  381)
* split method (String class):           Hello.              (line   97)
* split method (String class) <1>:       Basic classes.      (line  175)
* split method (String class) <2>:       Methods.            (line   99)
* sscanf () function:                    Methods.            (line 1189)
* stderr:                                File input and output.
                                                             (line  238)
* stderrStream (WriteFileStream class):  File input and output.
                                                             (line  238)
* stderrStream class variable (WriteFileStream class): File input and output.
                                                             (line  135)
* stdin:                                 File input and output.
                                                             (line  238)
* stdinStream (ReadFileStream class):    File input and output.
                                                             (line  238)
* stdinStream class variable (ReadFileStream class): File input and output.
                                                             (line  125)
* stdout:                                File input and output.
                                                             (line  238)
* stdoutStream (WriteFileStream class):  File input and output.
                                                             (line  238)
* stdoutStream class variable (WriteFileStream class): File input and output.
                                                             (line  125)
* strcat(3) C function:                  Basic classes.      (line  128)
* strcmp(3) C function:                  Basic classes.      (line  128)
* strcpy(3) C function:                  Basic classes.      (line  128)
* Stream Class:                          Collections.        (line    7)
* Stream class:                          Graphics.           (line   33)
* streamEof method (FileStream class):   File input and output.
                                                             (line   63)
* String class:                          Basic classes.      (line   10)
* String class <1>:                      Basic classes.      (line  125)
* STR_0XHEX_TO_PTR macro:                Methods.            (line 1189)
* Subclass:                              Objects.            (line   40)
* subString instance method (String class): Basic classes.   (line  199)
* super:                                 Objects.            (line  252)
* super <1>:                             Self and super.     (line    6)
* super keyword:                         Self and super.     (line   44)
* super used as a receiver:              Self and super.     (line   72)
* Superclass:                            Objects.            (line   40)
* Superclass <1>:                        Objects.            (line  214)
* Symbol class:                          Basic classes.      (line  908)
* Symbol class <1>:                      Methods.            (line  454)
* SystemErrnoException class:            Debugging.          (line   95)
* TerminalStream Class:                  Collections.        (line   18)
* timeclient.c example program:          Debugging.          (line  308)
* timesignal.c example program:          Debugging.          (line  308)
* toLower method (Character class):      Basic classes.      (line   68)
* toLower method (Character class) <1>:  Methods.            (line  258)
* toUpper (Character class):             Basic classes.      (line   84)
* toUpper method (Character class):      Methods.            (line  258)
* TreeNode Class:                        Collections.        (line   18)
* TreeNode Class <1>:                    Collections.        (line  330)
* Type conversion:                       Basic classes.      (line  785)
* unmap instance method (ANSITerminalPane class): Graphics.  (line  272)
* unshift method (List class):           Collections.        (line   74)
* useFont instance method (X11Pane class): Graphics.         (line  538)
* utcTime method (CTime class):          Hello.              (line  152)
* utcTime method (CTime class) <1>:      Hello.              (line  193)
* value instance variable:               Classes.            (line   93)
* value message.:                        Methods.            (line  309)
* value method (Object class):           Basic classes.      (line 1421)
* Variable promotion:                    Basic classes.      (line  785)
* Win32TerminalStream Class:             Collections.        (line   18)
* writeChar method (WriteFileStream class): File input and output.
                                                             (line   40)
* WriteFileStream class:                 File input and output.
                                                             (line    9)
* WriteFileStream Class:                 Collections.        (line   18)
* writeFormat instance method (String class): Basic classes. (line 1370)
* writeFormat instance method (WriteFileStream class): Basic classes.
                                                             (line 1370)
* writeStream method (WriteFileStream class): File input and output.
                                                             (line   40)
* writeStream method (WriteFileStream class) <1>: File input and output.
                                                             (line   88)
* X Widget API:                          Graphics.           (line  555)
* X11Bitmap class:                       Graphics.           (line  555)
* X11CanvasPane class:                   Graphics.           (line  555)
* X11Pane class:                         Graphics.           (line  324)
* X11PaneDispatcher class:               Basic classes.      (line  820)
* X11PaneDispatcher class <1>:           Graphics.           (line  555)
* X11TerminalStream Class:               Collections.        (line   18)
* X11TextPane class:                     Basic classes.      (line  820)
* X11TextPane class <1>:                 Graphics.           (line  555)



Tag Table:
Node: Top681
Node: Preface2159
Node: Objects3976
Ref: PositiveInteger Example10058
Ref: Class Hierarchy11057
Ref: Self and Super12349
Node: Hello14940
Ref: ctpath.c16255
Node: Basic classes22074
Ref: String_pointer_math31836
Ref: Array33469
Ref: ArgumentBlocks37321
Ref: Variable Promotion and Type Conversion48070
Ref: Object References53835
Ref: The -> Method63547
Node: File input and output79348
Node: Self and super88819
Ref: self Class Resolution93006
Ref: highlightButtonExample98219
Node: Collections105941
Ref: ListClass107532
Ref: MapArguments110280
Ref: CollectionMathOperators120742
Ref: InitializingCollections132194
Node: Classes135334
Ref: Instance Variables139460
Ref: Class Variables140915
Node: Methods151877
Ref: Method Declarations160965
Ref: Working with Object References169446
Ref: Assigning Values171557
Ref: Constructor Methods187719
Node: Graphics199685
Ref: ANSIGraphics201191
Ref: X11Graphics213052
Ref: X Widget API220282
Ref: GLUTGraphics228450
Ref: GLXGraphics233570
Node: Debugging246224
Node: GNU Free Documentation License257808
Node: Index279017

End Tag Table
