This is ctalk.info, produced by makeinfo version 6.7 from ctalk.texi.

INFO-DIR-SECTION Ctalk
START-INFO-DIR-ENTRY
* ctalk: (ctalk).	The Ctalk language reference manual.
END-INFO-DIR-ENTRY

This file documents Ctalk version 0.67 2021-03-11.

Copyright (C) 2007-2021 Robert Kiesling

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled, "GNU
Free Documentation License."


File: ctalk.info,  Node: ANSIListBoxPane,  Next: ANSIMessageBoxPane,  Prev: ANSILabelPane,  Up: Classes

'ANSIListBoxPane' Class
-----------------------

An 'ANSIListBoxPane' object displays a list of items, and allows the
user to select one of the items in the list by using the cursor motion
keys.

Each item in the list is an 'ANSILabelPane'.  To modify the appearance
of the items, refer to the 'ANSILabelPane' class.  *Note
ANSILabelPane::.

After exiting by pressing Escape or Enter, a program can retrieve the
text of the selected item.

Here is a simple program that displays a list of items, then prints the
selected item's text before exiting.


     int main () {
       ANSIListBoxPane new listBox;

       listBox appendLine "Item 1";
       listBox appendLine "Item 2";
       listBox appendLine "Item 3";
       listBox appendLine "Item 4";
       listBox appendLine "Item 5";

       listBox show 2, 2;   // Waits for the user to press Escape or Enter
                            // before returning.

       printf ("\nYou selected %s.\n", listBox selectedText);

       listBox cleanup;
     }


Instance Variables
------------------

'items'
     A 'List' of 'ANSILabelPane' items that contain the text of the list
     selections.

'oldSelectedContent'
     An 'ANSILabelPane' object that contains the content of the previous
     selection.  Used for erasing the previous selection before drawing
     the new selection.

'prevSelectedLine'
     An 'Integer' that contains the index of the previously selected
     item.  The 'ANSIListBoxPane' indexes items starting with 1 for the
     first item.

'selectedContent'
     An 'ANSILabelPane' object that contains the contents of the
     currently selected item.

'selectedLine'
     An 'Integer' that contains the index, counting from 1, of the
     currently selected item.

'totalLines'
     An 'Integer' that contains the number of items to be displayed.

Instance Methods
................

'appendLine (String TEXT)'
     Creates a new 'ANSILabelBox' object with the contents TEXT, then
     adds the 'ANSILabelBox' to the 'items' list.

'cleanup (void)'
     Deletes the buffers associated with the 'ANSIListBoxPane' object
     and its items.

'handleInput (void)'
     Waits for input from the user and processes it.  Pressing a cursor
     key or an Emacs or vi next/previous line key shifts the selection.
     Pressing Escape or Enter causes the method to return.

'new (LISTPANE1, LISTPANE2, ...;)'
     The 'ANSIListBoxPane' constructor.  The argument contains the names
     of one or more new 'ANSIListBoxPane' objects.

'refresh (void)'
     Draw the list pane and items on the terminal.

'refreshSelectionFirst (void)'
     Highlight the initially selected item.  Should only be called after
     a call to 'refresh'.

'refreshSelection (void)'
     Redraw the highlightd selected item, and un-highlight the
     previously selected item.  Should only be called after a call to
     'selectNext' or 'selectPrev'

'selectedText (void)'
     Returns the text of the selected item as a 'String' object.

'selectNext (void)'
'selectPrev (void)'
     Select the next or previous item of the list box's contents.  Also
     saves the index and contents of the previously selected item.


File: ctalk.info,  Node: ANSIMessageBoxPane,  Next: ANSIProgressBarPane,  Prev: ANSIListBoxPane,  Up: Classes

'ANSIMessageBoxPane' Class
--------------------------

'ANSIMessageBox' objects present users with a pop-up dialog that
contains a messages, and an 'ANSIButtonPane' 'Ok' button to close the
widget.

Here is a simple example.
     int main () {
       ANSIMessageBoxPane new messageBox;
       messageBox withText "Hello, world!";
       messageBox show 10, 10;
       messageBox cleanup;
     }

Subclasses can always implement convenience methods to set input and
output stream parameters if necessary.

You should also take care of the differences between xterms, consoles,
and serial terminals.  In particular, even though the 'parent' method
(class 'ANSIWidgetPane') *Note ANSITerminalStream::.

Instance Variables
------------------

'okButton'
     An 'ANSIButtonPane' object that contains the pane's 'Ok' button.
'messageText'
     A 'String' object that contains the text that appears in the
     message box.

Instance Methods
................

'cleanup (void)'
     Delete the receiver's extra data before deletion.  The receiver
     objects themselves are deleted normally.

'new (String MESSAGE_BOX_NAME)'
     Create one or more new 'ANSIMessageBox' objects.

'withText (String TEXT)'
     The argument is the text that will appear in the message box.  The
     method adjusts the pane's dimensions to fit the text.

'show (int X_ORIGIN, int Y_ORIGIN)'
     Display the receiver at X_ORIGIN, Y_ORIGIN.  If the receiver is
     displayed independently, the origin is relative to the upper
     left-hand corner of the display, or if the receiver is to be
     displayed over a parent pane, it is mapped to the parent pane with
     the origin relative the the parent pane's upper left-hand corner.


File: ctalk.info,  Node: ANSIProgressBarPane,  Next: ANSIScrollingListBoxPane,  Prev: ANSIMessageBoxPane,  Up: Classes

'ANSIProgressBarPane' Class
---------------------------

An 'ANSIProgressBarPane' object displays a horizontal progress bar on a
serial terminal or xterm.  If you display a progress bar pane
independently (using the 'show' method), you can close the pane by
pressing 'Enter' or 'Esc'.

The 'progress' instance variable specifies how much of the progress bar
is highlighted.  It's better to use the 'percent' method, though, which
calculates the progress bar's hightlighted area and sets the percent
legend.

As with all other ANSI pane widgets, you either display or omit the
border and shadow decorations.  Progress bars can also display a title
string, which you can set using the 'title' method, implemented in
'ANSIWidgetPane' class.  *Note ANSIWidgetPane::.

Here is an example program that displays an 'ANSIProgressBarPane'
object.


     int main () {
       ANSIProgressBarPane new progressBar;


       progressBar shadow = 1;
       progressBar border = 1;

       progressBar title "Progress";

       progressBar percent 65.0;

       progressBar show 2, 2;

       progressBar cleanup;
     }


You can set the size of a progres bar using the 'dimension' method.  In
that case, setting the progress bar using the 'percent' method adjusts
for the pane's width.  The widget's display area is always drawn as one
character row tall, however.

If you display the progress bar as a widget in an application, then you
can update the progress bar on the screen using the 'display' method
instead of 'show', because 'display' does not wait for user input before
returning.

Instance Variables
------------------

'pctLabelMargin'
     An 'Integer' that specifies where to draw the percent legend in the
     progress bar's content area.

'percentInt'
     An 'Integer' that specifies percent of the progress bar's internal
     area that is highlighted.  Setting this using the 'percent' method,
     below, also adjusts the hightlight's dimensions for the progress
     bar's width.  This variable is also used to display the text of the
     percent logo in the widget's content area.

'progress'
     An 'Integer' that specifies the number of character columns to
     highlight in the progress bar's viewable area.

'viewHeight'
     An 'Integer' that specifies the height in character rows of the
     widget's viewable area.  The progress bar highlight is always drawn
     as one character row in height.

'viewWidth'
     An 'Integer' that specifies the width in character rows of the
     widget's viewable area.

Instance Methods
................

'dimension (Integer WIDTH, Integer HEIGHT)'
     Set the width and height of the pane in character columns.

'show (Integer X, Integer Y)'
     Display the pane at row and column X,Y, and return immediately.

'handleInput (void)'
     Wait for the user's input.  Pressing 'Esc' or 'Enter' closes the
     pane.  and returns.

'new (String PANENAME)'
     Create new 'ANSIProgressBarPane' objects, one for each label given
     in the method's argument list.

'percent (Float PERCENT)'
     Set the percent of the progress bar's highlighted area.  This
     method adjusts for the width of the progress bar and sets the text
     for the percent logo.

'refresh (void)'
     Redraw the progress bar on the terminal.

'show (Integer X, Integer Y)'
     Display the pane at row and column X,Y, and wait for the user's
     input.


File: ctalk.info,  Node: ANSIScrollingListBoxPane,  Next: ANSIScrollPane,  Prev: ANSIProgressBarPane,  Up: Classes

'ANSIScrollingListBoxPane' Class
--------------------------------

An 'ANSIScrollingListBoxPane' object is similar to an 'ANSIListBoxPane';
it displays a list of items in a text mode terminal or 'xterm' and
allows the user to use the terminal's 'Cursor-Up'/'Cursor-Down' keys,
Emacs compatible 'C-n'/'C-p' keys, or vi compatible 'j'/'k' keys to
select an item in the list.

Pressing 'Enter' or 'Escape' closes the widget.  An application can
retrieve the selected item's text with the 'selectedText' method, which
is described below.

In addition, an 'ANSIScrollingListBoxPane' object can scroll the list if
the number of items is greater than the height of the widget's viewable
area, in order to keep the selected item visible.  The widget also
displays a read-only scroll bar that indicates which portion of the list
is visible.


     int main () {
       ANSIScrollingListBoxPane new sListBox;

       sListBox enableExceptionTrace;

       sListBox withShadow;
       sListBox noBorder;    /* Not all terminals support line
                                drawing characters.            */

       sListBox appendLine "Item 1";
       sListBox appendLine "Item 2";
       sListBox appendLine "Item 3";
       sListBox appendLine "Item 4";
       sListBox appendLine "Item 5";
       sListBox appendLine "Item 6";
       sListBox appendLine "Item 7";
       sListBox appendLine "Item 8";
       sListBox appendLine "Item 9";
       sListBox appendLine "Item 10";
       sListBox appendLine "Item 11";
       sListBox appendLine "Item 12";
       sListBox appendLine "Item 13";
       sListBox appendLine "Item 14";
       sListBox appendLine "Item 15";
       sListBox appendLine "Item 16";
       sListBox appendLine "Item 17";
       sListBox appendLine "Item 18";
       sListBox appendLine "Item 19";
       sListBox appendLine "Item 20";
       sListBox appendLine "Item 21";
       sListBox appendLine "Item 22";
       sListBox appendLine "Item 23";
       sListBox appendLine "Item 24";
       sListBox appendLine "Item 25";
       sListBox appendLine "Item 26";
       sListBox appendLine "Item 27";
       sListBox appendLine "Item 28";
       sListBox appendLine "Item 29";
       sListBox appendLine "Item 30";
       sListBox appendLine "Item 31";
       sListBox appendLine "Item 32";

       sListBox show 5, 6;

       printf ("%s\n", sListBox selectedText);

       sListBox cleanup;
     }


Instance Variables
------------------

'items'
     A 'List' of the items that the receiver displays.  *Note List::.

'oldSelectedContent'
     An 'ANSILabelPane' object that contains previously selected item.
     *Note ANSILabelPane::.

'prevSelectedLine'
     An 'Integer' that contains the index of the previously selected
     item.  *Note Integer::.

'selectedContent'
     An 'ANSIScrollPane' object that draws the widget's scroll bar.
     *Note ANSIScrollPane::.

'selectedContent'
     An 'ANSILabelPane' object that contains selected item.  *Note
     ANSILabelPane::.

'selectedLine'
     An 'Integer' that contains the index of the selected item.  *Note
     Integer::.

'totalLines'
     An 'Integer' that contains total number of list items.  *Note
     Integer::.

'viewStartLine'
     An 'Integer' that specifies which item begins the list's viewable
     portion.  *Note Integer::.

'viewHeight'
     An 'Integer' that contains the height in text lines of the widget's
     visible area.  *Note Integer::.

'viewWidth'
     An 'Integer' that contains the height in character columns of the
     widget's visible area.  *Note Integer::.

Instance Methods
................

'appendLine (String ITEM_TEXT)'
     Adds ITEM_TEXT to the list's contents.

'cleanup (void)'
     Deletes the display buffers associated with the list box and scroll
     bar.

'handleInput (void)'
     Waits for the user's input.  Changes the selected item when the
     user cursors through the list using the terminal's cursor keys,
     Emacs compatible 'C-n'/'C-p', or vi compatible 'j'/'k'.  Restores
     the terminal and returns when the user presses 'Enter' or 'Escape'.

'noBorder (void)'
'withBorder (void)'
     Set or unset the border for the main scroll pane and the scroll
     bar.  These methods are equivalent to the following expressions.


            /* To display borders. */
            listPane border = 1;
            listPane scrollBar border = 1;

            /* To hide the borders. */
            listPane border = 0;
            listPane scrollBar border = 0;


     Note that not all terninals support line drawing characters.

'noBorder (void)'
'withBorder (void)'
     Set or unset the shadow for the main scroll pane and the scroll
     bar.  The methods are a shortcut for these statements.


            /* To display shadows. */
            listPane shadow = 1;
            listPane scrollBar shadow = 1;

            /* To hide the shadows. */
            listPane shadow = 0;
            listPane scrollBar shadow = 0;


'new (String OBJECT_NAME)'
     Constructs a new 'ANSIScrollingListBoxPane' for each label given in
     the argument list.  Sets the dimensions for the viewable areas,
     decorations, and creates the display buffers for the list box and
     the scroll bar.

'refresh (void)'
     Redraws the list box.

'refreshSelection (void)'
     Un-highlights the previously selected item and highlights the
     currently selected item.

'refreshSelectionFirst (void)'
     Highlights the currently selected item, which is normally the first
     item in the list when first drawing the widget-i.e., when there is
     no previously selected item.

'scrollThumbSize (void)'
     Sets the 'scrollBar' instance variable's 'thumbHeight' instance
     variable based on which portion of the list is visible.  *Note
     ANSIScrollPane::.

'scrollThumbStart (void)'
     Sets the 'scrollBar' instance variable's 'thumbStartLine' instance
     variable based on which portion of the list is visible.  *Note
     ANSIScrollPane::.

'selectedText (void)'
     Returns a 'String' containing the text of the selected item.  *Note
     String::.

'selectNext (void)'
     Sets the next 'selectedLine' and 'selectedContent' instance
     variables to the next item in the list.  If the selected item is
     already the last item in the list, the method does nothing.

'selectPrev (void)'
     Sets the next 'selectedLine' and 'selectedContent' instance
     variables to the previous item in the list.  If the selected item
     is already the first item in the list, the method does nothing.

'show (Integer X, Integer Y)'
     Displays the widget an character row and column X,Y on the terminal
     display, then calls the 'handleInput' method to process user input.


File: ctalk.info,  Node: ANSIScrollPane,  Next: ANSITextBoxPane,  Prev: ANSIScrollingListBoxPane,  Up: Classes

'ANSIScrollPane' Class
----------------------

An 'ANSIScrollPane' object draws a vertical scroll box on a text-mode
terminal or X terminal.  Applications can use the pane's instance
variables to set the position and height of the scroll thumb, and the
border and shadow decorations.

The class provides a 'handleInput' method that allows users to move the
scroll thumb independently if the pane is used by itself.

This app draws a scroll pane independently.


     int main () {
       ANSIScrollPane new scrollBox;

       scrollBox shadow = 0;
       scrollBox border = 1;

       scrollBox thumbHeight = 3;    // Sets the position and height
       scrollBox thumbStartLine = 1; // of the scroll thumb.

       scrollBox show 2, 2;          // The Up and Down arrow keys
                                     // move the scroll thumb while
                                     // the pane is displayed.

       scrollBox cleanup;
     }



When used to indicate the position of other panes, applications should
set and read the scroll thumb's using the 'thumbHeight' and
'thumbStartLine' instance variables.  If the application wants to use
the 'ANSIScrollPane' object to set another pane's position, it needs to
handle the Up and Down cursor motion keys in the app's 'handleInput'
method,

In that case, the app should use the classes' 'display' method instead
of 'show' to display the 'ANSIScrollPane' object, because 'display'
doesn't wait for user input on its own.

There's no terminal independent way, however, to indicate that the
'ANSIScrollPane' object has the input focus.  An app might do this by
either setting or omitting the pane's shadow, but that can occupy an
extra line of terminal space.

The class is simplified by keeping the width of the scroll thumb at one
column.  Apps can draw a wider scroll pane, but that does not affect the
scroll thumb's width.

Instance Variables
..................

'viewHeight'
     An 'Integer' that specifies the height of the scroll channel in
     character rows.

'viewWidth'
     An 'Integer' that specifies the width of the scroll channel in
     character columns.

'thumbHeight'
     An 'Integer' that specifies the height of the scroll thumb in
     character rows.

'thumbStartLine'
     An 'Integer' that specifies the row of the top of the scroll thumb.
     This should be less than the 'viewHeight' instance variable for the
     thumb to be visible.

Instance Methods
................

'cleanup (void)'
     Delete the buffers associated with the pane object.

'dimension (Integer WIDTH, Integer HEIGHT)'
     Set the width and height of the receiver pane.  Also adjusts the
     width of the 'viewWidth' and 'viewHeight' instance variables.

'display (Integer X, Integer Y)'
     Draw the pane on the terminal at row and column X,Y, and return
     immediately.

'handleInput (void)'
     Waits for user input from the pane's 'ANSITerminalStream' object.
     Pressing Enter or Escape withdraws the pane from the display and
     returns.  Pressing the Up or Down arrow keys moves the scroll
     thumb.

'new (String PANENAME)'
     Create a new 'ANSIScrollPane' object, with the name PANENAME.  If
     more than one name is given in the argument list, create new
     'ANSIScrollPane' objects with the arguments' names.

'refresh (void)'
     Draw the pane on the terminal.

'show (Integer X, Integer Y)'
     Draw the pane on the terminal at row and column X,Y, and wait for
     the user's input.


File: ctalk.info,  Node: ANSITextBoxPane,  Next: ANSITextEntryPane,  Prev: ANSIScrollPane,  Up: Classes

'ANSITextBoxPane' Class
-----------------------

An 'ANSITextBoxPane' object displays a text-mode dialog box with an
application's text in the window, and a "Dismiss" button at the bottom
of the display area.  Like other widgets that are subclasses of
'ANSIWidgetPane,' you can close the window by pressing 'Esc' or 'Enter',
and you can scroll through the text with the terminal's up and down
arrow keys, the 'vi' keys 'j' and 'k', and the 'emacs' keys 'C-n' and
'C-p'.

Here is a brief example of how to open and display text in an
'ANSITextBoxPane' object.
     int main () {
       ANSITextBoxPane new textBox;

       textBox resize 75, 30;

       textBox appendLine "Hello, world!";
       textBox appendLine "This is another line of text.";
       textBox appendLine "More text to follow.";

       textBox show 1, 1;

       textBox cleanup;
     }

Instance Variables
------------------

'dismissButton'
     An 'ANSIButtonPane' object that displays a "Dismiss" button at the
     bottom of the pane's display area.
'text'
     A 'List' object that contains the text to be displayed in the pane,
     one line per list element.
'viewStartLine'
     An 'Integer' object that indicates the topmost line of text to be
     displayed in the pane.
'viewHeight'
     An 'Integer' that contains the height of the pane's text display
     area.  The text display area is the width and height of the pane,
     not including a window border if any, and not including the bottom
     five lines of the pane, which is used to display the
     'dismissButton' widget.
'viewWidth'
     An 'Integer' that contains the width of the viewable text area.  As
     mentioned above, the 'viewWidth' dimension is the width of the pane
     minus the window borders, if any.
'viewXOffSet'
     An 'Integer' that contains the starting column of each line within
     the window.

Instance Methods
................

'appendLine (String TEXT)'
     Append a line to the widget's 'text' (class 'List') instance
     variable.  The text will be visible after the next 'refresh'
     message.

'cleanup (Integer LINENUMBER)'
     Delete the extra buffers that the receiver uses for screen data.
     The normal object cleanup routines delete the receiver pane itself.

'clearLine (Integer LINENUMBER)'
     Erase the line LINENUMBER in the pane's view area.

'handleInput (void)'
     Wait for the user's input from the keyboard and redisplay or
     withdraw the receiver widget depending on which key the user
     presses.

'new (String PANENAME)'
     Constructs a new 'ANSITextBoxPane' object.  The object's dimensions
     are 40 columns wide by 20 rows high, with a "Dismiss" button at the
     bottom of the window, and with a border and shadow.

     If more that one name is given in the argument list, construct new
     'ANSITextBoxPane' objects with the labels' names.

'refresh (void)'
     Redraws the receiver object and any text to be displayed in the
     pane's visible area.

'resize (Integer XSIZE, Integer YSIZE)'
     Resize the pane to the dimensions XSIZE, YSIZE.

'show (Integer XORIGIN, Integer YORIGIN)'
     Pop up the pane's window at the terminal coordinates XORIGIN,
     YORIGIN, and wait for the user's input.


File: ctalk.info,  Node: ANSITextEntryPane,  Next: ANSIYesNoBoxPane,  Prev: ANSITextBoxPane,  Up: Classes

'ANSITextEntryPane' Class
-------------------------

A 'ANSITextEntryPane' object prompts the user for text input and returns
the input to the application program.  Like other subclasses of
'ANSIWidgetPane', this class uses the methods of that class or
re-implements them as necessary.  *Note ANSIWidgetPane::.

The widget can be displayed independently; that is, it can be popped up
on its own, as in this example.
     int main () {
       ANSITextEntryPane new textEntry;
       String new inputText;

       textEntry withPrompt "Please enter some text: ";
       inputText = textEntry show 10, 10;
       printf ("\nYou typed: %s\n", inputText);
       textEntry cleanup;
     }
To pop up an 'ANSITextEntryPane' over another pane, the program must
also configure and define the widget's parent pane.
     int main () {
       ANSITerminalPane new mainPane;
       ANSITextEntryPane new textEntry;
       String new inputText;

       mainPane initialize 1, 1, 80, 24;
       mainPane refresh;

       mainPane gotoXY 29, 10;
       mainPane printOn "Parent Pane";
       mainPane gotoXY 25, 11;
       mainPane printOn "Please press [Enter].";
       mainPane refresh;

       getchar ();  /* Actual apps should use getCh, etc. */

       textEntry parent mainPane;
       textEntry withPrompt "Please enter some text: ";
       inputText = textEntry show 10, 10;
       mainPane refresh;

       printf ("\nYou typed: %s\n", inputText);

       getchar ();

       textEntry cleanup;
       mainPane cleanup;
     }

Instance Variables
------------------

'promptText'
     The text of the entry pane's prompt.  The default is an empty
     'String' object.

'inputBuffer'
     A 'String' object that contains the user's input.

'inputLength'
     The width in characters of the text entry.  The default is 20.

Instance Methods
................

'handleInput (void)'
     Process 'InputEvent' objects from the receiver's 'paneStream' input
     handle.

'inputWidth (Integer WIDTH)'
     Set the width, in characters, of the input entry box.  The default
     is 20.

'new (String PANENAME)'
     Creates a new 'ANSITextEntryPane' object.  Also uses the
     'withShadow' and 'withBorder' messages from 'ANSITerminalPane'
     class, and the 'openInputQueue' message from 'ANSITerminalStream'
     class.

     If more that one argument is given in the argument list, create new
     'ANSITextEntryPane' objects with the arguments' names.

'show (int X_ORIGIN, int Y_ORIGIN)'
     Display the receiver pane and return input from the user.

'withdraw'
     Remove the receiver widget from the display.  If the widget is
     drawn over another pane object, unmap the receiver from the parent
     pane.  If the receiver is displayed independently, clear the
     display before returning.

'withPrompt (String PROMPTTEXT)'
     Set the receiver's prompt to PROMPTTEXT.


File: ctalk.info,  Node: ANSIYesNoBoxPane,  Next: X11Pane,  Prev: ANSITextEntryPane,  Up: Classes

'ANSIYesNoBoxPane' Class
------------------------

An 'ANSIYesNoBoxPane' object presents the user with a dialog that
contains a text message and waits for the user's 'Yes' or 'No' response.

Here is an example of opening an 'ANSIYesNoBoxPane' object using
standard input and output (e.g., when displaying the pane on a xterm).
     int main () {
       ANSIYesNoBoxPane new messageBox;
       String new answer;

       messageBox withText "Do you want to quit?";
       answer = messageBox show 10, 10;
       messageBox cleanup;
       printf ("You answered, \"%s\"\n", answer);
     }

Here is an example of opening an 'ANSIYesNoBoxPane' object in a serial
terminal (for a Linux serial device).  For other systems, change the
'/dev/ttyS1' argument to the device node that connects to the serial
terminal.  It's necessary to adjust the arguments to 'setTty' to match
the terminal's settings.

     int main () {
       ANSIYesNoBoxPane new messageBox;
       String new answer;

       messageBox paneStream openOn "/dev/ttyS1";  /* Linux serial device. */
       messageBox paneStream setTty 9600, 1, 'n', 8;

       messageBox noBorder;  /* Not all terminals support line drawing characters. */

       messageBox withText "Are you sure you want to quit?";
       answer = messageBox show 10, 10;
       messageBox cleanup;
       printf ("You answered, \"%s\"\n", answer);
     }

As with any dialog widget, pressing 'Esc' or 'Return' closes the
'ANSIYesNoBoxPane' object.  The 'Tab' key selects between the "Yes" and
"No" buttons, as do the 'Y' and 'N' keys,

Instance Variables
------------------

'button1'
     The 'ANSIButtonPane' widget that controls the 'Yes' response.
'button2'
     The 'ANSIButtonPane' widget that controls the 'No' response.
     ('ANSIYesNoBoxPane' class)
'messageText'
     A 'String' object that contains the text displayed in the pane.

Instance Methods
................

'cleanup (void)'
     Delete the widget's data before exiting.

'getFocusWidgetText (void)'
     Return the text associated with the button that has the input
     focus.

'handleInput (void)'
     Wait for the user's input and return the response from the widget.

'new (NEWPANENAME'
     Create a new 'ANSIYesNoBox' object with the name given as an
     argument.  If the argument list contains more than one name, create
     'ANSIYesNoBoxPane' objects for each argument.


          ANSIYesNoBoxPane new yesnobox1, yesnobox2;


'nextFocus (void)'
     Set the input focus to the next button widget.

'noBorder (void)'
'withBorder (void)'
     Set or unset the border for the main pane and the button labels.
     These methods are equivalent to the following expressions.


            /* To display borders. */
            yesnoBox border = 1;
            yesnoBox button1 border = 1;
            yesnoBox button2 border = 1;

            /* To hide the borders. */
            yesnoBox border = 0;
            yesnoBox button1 border = 0;
            yesnoBox button2 border = 0;


     Note that not all terninals support line drawing characters.

'noBorder (void)'
'withBorder (void)'
     Set or unset the shadow for the main pane and the buttons.  The
     methods are a shortcut for these statements.


            /* To display shadows. */
            yesnoBox shadow = 1;
            yesnoBox button1 shadow = 1;
            yesnoBox button2 shadow = 1;

            /* To hide the shadows. */
            yesnoBox shadow = 0;
            yesnoBox button1 shadow = 0;
            yesnoBox button2 shadow = 0;


'show (int X_ORIGIN, int Y_ORIGIN)'
     Display the 'ANSIYesNoBoxPane' object at X_ORIGIN, Y_ORIGIN.  If
     displayed over another pane, the origin is relative to the parent
     pane's origin.  If displayed independently, the origin is relative
     the the upper left-hand corner of the terminal.

'withText (char *TEXT)'
     Defines the text that is to appear within the pane.  This method
     adjust's the pane's size to fit the text.


File: ctalk.info,  Node: X11Pane,  Next: GLXCanvasPane,  Prev: ANSIYesNoBoxPane,  Up: Classes

'X11Pane' Class
---------------

The 'X11Pane' class provides the basic methods and instance variables
for creating and displaying a window on a X display.

The 'X11Pane' class does not, itself, provide methods for moving,
resizing, or handling input or changing focus.

The 'X11TerminalStream' class handles X input events.  The 'X11Pane'
constructor 'new' also creates a 'X11TerminalStream' object in the
'X11Pane's' 'inputStream' instance variable.  There is a short example
program in the 'X11TerminalStream' section.  *Note X11TerminalStream::.

This class uses the default visual or a X window without buffering, so
applications need to be careful to handle InputEvents correctly, or
graphics drawing may result in flicker, depending how the window manager
handles X Window System events.  See the 'Ctalk Tutorial' for
information about how to use 'InputEvent' objects in applications.

However, 'X11Pane' class provides the address of the window's graphics
context in the 'xGC' instance variable, so applications that use this
class for graphical displays can create and use their own visuals if
necessary.

Instance Variables
------------------

'backgroundColor'
     A 'String' object that contains the name of the window's background
     color.  The value is the background color of the window,
     independent of the background color of any buffers used by
     subpanes.  Normally this value is set by the 'background' method,
     described below.

     Note that if a subclass of 'X11Pane' has set a 'backgroundColor'
     resource, then that color overrides this variable's value when a
     program creates subpane windows.  The window creation generally
     happens when attaching a pane object to its parent pane, with an
     'attachTo' method.

     If unset, the default background color is black.

'borderWidth'
     An 'Integer' object that contains the window's border width in
     pixels.  The default is 1 pixel.

'container'
     A 'Symbol' that refers to a pane's container (i.e., parent) Pane
     object.  For top-level 'X11Pane' objects this value should be
     'NULL'.

'depth'
     An 'Integer' that contains the default depth of the display screen.
     Ctalk sets this value when creating the window of a 'X11Pane'
     object or an instance of one of 'X11Pane's' subclasses.  Normally
     applications should not need to change this value.

'displayPtr'
     A 'Symbol' that holds the pointer to the display connection; i.e.,
     the 'Display *' returned by 'XOpenDisplay(3)'.  Most windows use
     the display connection opened when the main window is created.
     Dialogs, which create their own main windows, open their own
     connection to the display.  Generally, programs should not need to
     change this.

     When using subpanes, it's convenient to set the subpane's
     'displayPtr' variable to the value of the main window pane's value.
     This is generally done in the 'attachTo' methods, with a line that
     looks something like this.

'haveXft'
     A 'Boolean' that has the value of 'true' if Ctalk is built with the
     Xft and Fontconfig libraries, and they have been initialized with a
     call to 'X11FreeTypeFont : initFontLib'.

'modal'
     A 'Boolean' that determines how Ctalk draws in the window.  True
     for popup windows, false otherwise.


          self displayPtr = self mainWindow displayPtr;


'fontVar'
     A 'X11Font' object that contains information about the Window or
     Pane's current font.

'fontDesc'
     A 'String' that contains a X Logical Font Descriptor for the font
     to be used by the window.  If the value is '(null)', the window
     uses the system's fixed font.

'foregroundColor'
     A 'String' object that contains the name of the window's foreground
     color.  If unset, the default foreground color is black.

'ftFontVar'
     An 'X11FreeTypeFont' object that contains the pane's current font,
     if the 'X11TextEditorPane' object uses outline fonts.

     If, on the other hand, the pane uses X11 bitmap fonts, the Pane
     uses the 'fontVar' instance variable.  Which requires no additional
     initialization.

     To determine whether a machine has outline fonts available, a
     program could use a set of statements like this in its
     initialization.


          Boolean new useXFonts;
          X11Pane new myPane;

          ...

          if (myPane ftFontVar version >= 10) {
            myPane ftFontVar initFontLib;
            useXFonts = false;
          } else {
            useXFonts = true;
          }


'inputStream'
     A 'X11TerminalStream' object that provides 'InputEvent' objects to
     the application.  *Note X11TerminalStream::.

'resources'
     This is an 'AssociativeArray' that an object can use to store any
     data that determine its run-time appearance, like colors,
     dimensions, or options.  Generally a 'Pane' class sets default
     resources in its 'new' method, which application programs can then
     update with its own resources after the 'Pane' object has been
     constructed.

     As a brief example, here's a sample initialization from the
     'X11MessageBoxPane' : 'new' method.


          paneName resources atPut "backgroundColor", "gray";
          paneName resources atPut "pad", 10;
          paneName resources atPut "messageText", "Your\nMessage\nHere";
          paneName resources atPut "buttonText", "Ok";


     Then, when an application program constructs the widgets when it is
     run, it can use a line like this.


          l_label background self resources at "backgroundColor";
          l_label multiLine self resources at "messageText";


     Remember that the 'Collection : atPut' method does not check for an
     existing key, so be sure to remove the old value first.  This is
     done with the 'Collection : removeAt' method, or simply with the
     'Collection : replaceAt' method.


          if (l_label resources keyExists "backgroundColor")
            l_label resources removeAt "backgroundColor";
          l_label resources atPut "backgroundColor", "blue";


     or,


          if (!l_label resources replaceAt "backgroundColor", "blue")
            l_label resources atPut "backgroundColor", "blue";


     Refer to the 'Collection' class section for more information about
     the methods it defines.  *Note Collection::.

'xGC'
     A 'Symbol' that contains the address of the window's graphics
     context.  The 'X11Pane' class does not, at this time, provide
     methods or instance data for drawables, so the application needs to
     implement its own drawable for each window.

'xWindowID'
     An 'Integer' that contains the window's id that a program can use
     with X library functions.

Class Variables
---------------

'xColormap'
     An 'Integer' that contains the resource ID of the default color
     map.

Instance Methods
----------------

'attachTo (Object PARENTPANE)'
     Attach the receiver to PARENTPANE.  The value of PARENTPANE's
     SUBWIDGET instance variable is the receiver.

'background (String COLOR_NAME)'
     Sets the background color of the pane object's window.  For
     buffered Panes, programs need to set the background color of that
     Pane independently.  This method also has the effect of clearing
     the window.

     If a program doesn't set a background color for the window, the
     default background color is white.

'clearRectangle (int X, int Y, int WIDTH, int HEIGHT)'
     Clear the area of the receiver's window with the dimensions given
     as the arguments.

'clearWindow (void)'
     Clear the receiver's window.  This method clears only the main
     window and does not affect any image buffers associated with the
     pane object.  To also clear the pane object's image buffers, use
     'clearRectangle', above.

'defaultCursor (void)'
     Restore the window's default cursor, which is normally the cursor
     of the parent window.

'deleteAndClose (void)'
     Delete the receiver window and close the display.

'displayHeight (void)'
     Returns an 'Integer' with the display's height in pixels.

'displayWidth (void)'
     Returns an 'Integer' with the display's width in pixels.

'faceRegular (void)'
'faceBold (void)'
'faceItalic (void)'
'faceBoldItalic (void)'
     These methods select which 'X11FreeTypeFont' typeface a pane should
     use.  These methods need the program to initialize the Xft
     libraries (with the 'initFontLib' method in 'X11FreeTypeFont'
     class), and the pane has established a connection to the X server
     (with the 'openEventStream' method).

'font (String FONT_DESC)'
     Set the X font used for drawing on the window.  This font can be
     set independently of the fonts used by subpanes.  *Note
     X11TextPane::, and *Note X11Bitmap::.

     Because the Ctalk libraries use shared memory to manage font
     information, it is generally necessary to call this method after
     the 'openEventStream' method, for the program to calculate the
     character spacing of multiple typefaces correctly.

'foreground (String COLORNAME)'
     Sets the window's foreground color (the default color for drawing
     on the window) to COLORNAME.  If a program doesn't set the window's
     foreground color, the default color is black.

'ftFont (String FAMILY, Integer SLANT,'
     'Integer' WEIGHT 'Integer' DPI, 'Float' POINTSIZE) Selects an
     outline font for use by the 'X11Pane' object.  The method selects
     the font, and fills in the 'ftFontVar' instance variable with the
     font's information.  Programs should first determine if FreeType
     fonts are available on the system, by using the 'X11FreeTypeFont'
     method 'version' first, as in this example.


          Boolean new useXFonts;
          X11Pane new myPane;

          ...

          if (myPane ftFontVar version >= 10) {
            myPane ftFontVar initFontLib;
            useXFonts = false;
          } else {
            useXFonts = true;
          }

          ...

          /* Selects the font DejaVu Sans Mono, regular slant, normal weight,
             72 dpi, 12 points. */
          myPane ftFont "DejaVu Sans Mono", 0, 80, 72, 12.0;


     The 'X11FreeTypeFont' class also provides methods that use Xft and
     X11 font descriptors to select fonts.  *Note X11FreeTypeFont::.

'initialize (int WIDTH, int HEIGHT)'
'initialize (int X, int Y, int WIDTH, int HEIGHT)'
     Create the window and its graphics context with the width and
     height given as the arguments.  This method also opens a connection
     to the X server if necessary.  This method uses the window system
     to set the window's initial position.

     Create the window and its graphics context with the dimensions
     given as the arguments.  This method also opens the connection to
     the X server if necessary.

     This method is here for older programs, or programs that set the
     window position directly.  Otherwise, use the form of 'initialize',
     below, that takes the window's geometry flags as an argument, and
     only set the window's position if the user provides one on the
     command line and the program retrieves it with 'parseX11Geometry'.

     Even more simply, a program can set X_ORG and Y_ORG to zero, and
     let the window system handle any positioning.  Or use the form of
     'initialize' that uses only the WIDTH and HEIGHT arguments.

'initialize (int X, int Y, int WIDTH, int HEIGHT, int GEOM_FLAGS)'
     Create the window and its graphics context with the dimensions
     given as the arguments.  Like the other forms of 'initialize', this
     method also opens the connection to the X server if necessary.

     The GEOM_FLAGS argument provides placement hints for the window's
     initial position.  It has the format provided by the
     'parseX11Geometry' method in 'Application' class.  *Note
     parseX11Geometry::.

     The X and Y parameters can also be given directly if the program
     sets the window position itself.  If these arguments are zero, then
     the window manager or the user supplied window geometry determine
     the window placement.

'initialize (int X, int Y, int WIDTH, int HEIGHT, int GEOM_FLAGS, char *WIN_TITLE)'
     This method is similar to the five-argument form of 'initialize',
     and additionally sets the window's title using the contents of the
     string WIN_TITLE.

'isTopLevel (void)'
     Return 'TRUE' if the receiver's container pane is 'NULL'.

'mainWindow (void)'
     Returns the 'X11Pane' object that manages a program's main window.
     The method retrieves the main window object by following the
     references of each subpane's 'container' instance variable.  If the
     top-level pane object is not a 'X11Pane', the method prints a
     warning.

'map (void)'
     Map the receiver window onto the X display.

'openEventStream (void)'
     Open the window's input stream, a 'X11TerminalStream' object.  The
     'X11TerminalStream' section of the manual describes X input event
     handling.  *Note X11TerminalStream::.

'putStrXY (Integer XORG, Integer YORG, String STR)'
     Draw the string on the receiver's drawable surface at XORG, YORG,
     using the selected font.

'putStrXY (Integer XORG, Integer YORG, String STR)'
     Draw the string on the receiver's drawable surface at XORG, YORG.
     Currently this method is the same as 'putStrXY,' above.

'raiseWindow (void)'
     Display the receiver window above other windows on the X display.
     Note that the method's name was changed from 'raise' to avoid
     warnings when including the C 'raise(3)' function.

'setResources (String RESOURCENAME, String RESOURCECLASS)'
     Set the resource name and class of the main window.  Normally the
     resource name is the name of the application, which may vary from
     the window title.  The resource class should be used to identify
     the window for X resources.

     A program can call this method either before or after connecting to
     the server with the 'openEventStream' method.  Generally, if the
     resources affect the appearance of decorations provided by the
     system, like the window frame or icon, the window needs to be
     remapped for the changes to be visible, but this may vary with the
     application and the type of window manager.

'setWMTitle (char *TITLE)'
     Set the window's title.  Because setting a X window's title
     requires communication between the window and the display server,
     this method requires that the window is first mapped and raised
     (with the 'map' and 'raiseWindow' methods, above), and has a
     connection to the display server (which is done with the
     'openEventStream' method, also above).

     In other words, when setting a window's title for the first time,
     this method works best when used just before processing any other
     events.

'subPaneNotify (InputEvent EVENT)'
     Called by applications that need to invoke sub-pane handlers in
     response to window events.  For examples of its usage, refer to the
     section for 'X11CanvasPane', *Note X11CanvasPane::, and other
     'X11Pane' subclasses.

'useCursor (Cursor CURSOR_OBJECT)'
     Display the X11 cursor defined by CURSOR_OBJECT, a 'X11Cursor'
     object, in the receiver's window.  To create cursors, *Note
     X11Cursor::.

'useXRender (Boolean B)'
     If B is true, draw graphics using the X Render extension if it is
     available.  If B is false, use Xlib for graphics drawing.  The
     default is to draw using the X Render extension if it is available.

'usingXRender (void)'
     Returns a 'Boolean' value of True if the program is using the X
     Render extension for drawing, False otherwise.


File: ctalk.info,  Node: GLXCanvasPane,  Next: X11PaneDispatcher,  Prev: X11Pane,  Up: Classes

'GLXCanvasPane' Class
---------------------

The 'GLXCanvasPane' class displays 3 dimensional graphics drawn with
OpenGL in a X window.  The class requires that the display server
supports GLX visuals, which is the case with most modern X server
installations.

The class includes instance variables that select GLX visual properties,
methods that create and display the window, and provides a simple API
for the window's application program.

There is an example program that displays a 'GLXCanvasPane' window at
the end of this section.  *Note GLXExampleProgram::.

GLXCanvasPane Applications
--------------------------

The 'GLXCanvasPane' class provides a simple application framework that
is compatible with OpenGL's single threading model.  The framework
consists of a number of callback methods and a 'run' method, that are
configured when the program starts.

The methods that install callbacks are:


     onButtonPress
     onIdle
     onKeyPress
     onExpose
     onPointerMotion
     onResize
     onTimerTick
     onAnimation


There is a complete description of each of these methods in the section,
'Instance Methods.'

Typically, a program installs its callback methods and initializes the
OpenGL system, and then calls the method 'run' to begin the program's
event loop.  The example program given at the end of this section
follows this process.  The program's initialization and startup, which
is contained in 'main ()', is shown here.


     int main () {
       GLXCanvasPane new pane;

       pane initialize (1, 150, 500, 500);
       pane title "GLXCanvasPane Demonstration";
       pane map;
       pane raiseWindow;

       pane onKeyPress "myKeyPressMethod";
       pane onExpose "myExposeMethod";
       pane onTimerTick "myTimerTickHandler";
       pane onResize "myResizeMethod";

       pane initGL;

       pane run;

     }


Selecting GLX Visuals
---------------------

The 'GLXCanvasPane' class selects visuals based on the values of many of
the instance variables.  These instance variables correspond with the
attributes recognized by the 'glXChooseVisual(3)' library call.

The instance variables' default settings select a double buffered,
TrueColor or DirectColor visual, with 24 color bits per pixel, and a
stencil buffer with 8 bit planes, which is supported by many common GLX
servers.  The equivalent C code for these attributes, formatted as an
argument for 'glXChooseVisual(3)', would be:


     static GLint att[] = {GLX_RGBA, GLX_DEPTH_SIZE, 24, GLX_STENCIL_SIZE, 8,
                           GLX_DOUBLEBUFFER, None};


These attributes also correspond to the available attributes output by a
program like 'glxinfo(1)'.  Refer to the 'glXChooseVisual(3)' and
'glxinfo(1)' manual pages for more information

Drawing with X Fonts
--------------------

The 'GLXCanvasPane' class defines three methods, 'useXFont', 'drawText',
'drawTextW', and 'freeXFont' that facilitate drawing text with X fonts.

Typically, a program calls 'useXFont' with the name of the X font when
it initializes OpenGL (that is, after first creating the window and
mapping the GLX context to the display), then using 'drawText' to draw
the text in the program's drawing routine.  Finally, the program calls
'freeXFont' to release the font data before exiting, or when changing
fonts if the program uses multiple fonts for drawing.


     myPane useXFont "fixed";    /* Call during OpenGL initialization. */
                                 /* The argument, "fixed," is the name */
                                 /* of the font to be used.            */

     ...

                                 /* Called from within the program's   */
                                 /* drawing routine.                   */
     myPane drawText "Text to appear in the window";


     ...

     myPane freeXFont;           /* Called during program cleanup or   */
                                 /* before calling useXFont again to   */
                                 /* draw text in a different font.     */


The Ctalk distribution contains an example program in the 'demos/glx'
subdirectory, 'xfont.ca' that demonstrates this drawing method.

Drawing with FreeType Fonts
---------------------------

The methods to draw text using the freetype libraries are similar to
those that render X bitmap fonts.  The Freetype libaries support text
rendering using Freetype, Truetype, and Postscript Type1 fonts.

The main differences are that, because of the way the fonts are rendered
on the screen, their measurements are given in the coordinates of the
current viewing and transformation matrices.

In addition, when loading a font using 'useFTFont', the method uses the
path name of the font file, not an identifier.  This is the only
interface that the Freetype libraries use.  To use the system's font
caching, refer to *Note X11FreeTypeFont::.

There is a demo program that renders Freetype fonts in the 'demos/glx'
subdirectory of the Ctalk source package, 'ftfont.ca'.

Display Synchronization
-----------------------

On OpenGL releases that support synchronization, 'GLXCanvasPane'
applications can synchronize buffer swapping with the video display's
refresh rate.  'GLXCanvasPane' class provides the methods
'syncSwap,refreshRate,' and 'frameRate' which allow programs to adjust
buffer swapping to match the video refresh rate.  The demonstration
program, 'demos/glx/glxchaser.ca' provides an example of how to use
these methods.

To find out which GLX extensions the display server supports, the
'extensions' method, below, returns the extensions as a 'String' object.

Currently, video syncronization support is limited to MESA releases that
provide the 'GLX_MESA_swap_control' and 'GLX_OML_sync_control'
extensions.

Instance Variables
..................

'animationHandler'
     Defines the callback method that is called 24 times a second to
     perform animation.

'buttonPressHandler'
     A 'Method' object that defines the callback method that is executed
     when a mouse button is pressed.

'buttonState'
     An 'Integer' that records whether a mouse button is currently
     pressed.  The class defines macro constants to record the states,
     and you can include these definitions in your programs to interpret
     the value of 'buttonState'.


          #define buttonStateButton1 (1 << 0)
          #define buttonStateButton2 (1 << 1)
          #define buttonStateButton3 (1 << 2)
          #define buttonStateButton4 (1 << 3)
          #define buttonStateButton5 (1 << 4)


     So to check if the mouse button 1 is pressed, the program could
     contain an expression like the following.


          if (myPane buttonState & buttonStateButton1) {
             printf ("Button 1 pressed.\n");
          }


'colormap'
     An 'Integer' that contains the X resource ID of the default
     colormap of the current display and screen.

'displayPtr'
     A 'Symbol' that contains the address of the X server's display
     handle as provided to the application.  The 'displayPtr' instance
     variable is filled in by the 'initialize' methods.

'exposeHandler'
     Defines the method that is called each time the program's window
     receives an Expose event from the display.  This handler is
     essential to displaying the window in coordination with other
     display events.  If this variable is not initialized, then the
     'run' method calls the 'swapBuffers' method.

'glxContextPtr'
     A 'Symbol' that contains the address of the 'GLXContext' that is
     current for the 'GLXCanvasPane's' window.  This variable is
     normally filled in by the 'map' method.

'idleHandler'
     A 'Method' that contains the callback that the program executes
     when not processing events from the display.

'keyPressHandler'
     A 'Method' that handles the KeyPress events that the display sends
     to the program's window.  This variable should be set during
     program initialization using the 'onKeyPress' method before the
     program starts the 'run' method.

'pointerMotionHandler'
     A 'Method' that is called whenever the window receives a
     MotionNotify event.

'resizeHandler'
     A 'Method' that is called whenever the window receives a
     ConfigureNotify event.  The variable should be set using the
     'onResize' method before the program starts the 'run' method.

'shiftState'
     An 'Integer' that records whether the any of the Shift, Control, or
     Alt keys is currently pressed.  The class defines macro constants
     to record the states, and you should also include the definitions
     in your program if it needs to monitor the state of the modifier
     keys.


          #define shiftStateShift (1 << 0)
          #define shiftStateCtrl  (1 << 1)
          #define shiftStateAlt   (1 << 2)


     So, for example, to test whether a Control key is pressed, you can
     use an expression like the following.


          if (myPane shiftState & shiftStateCtrl)
             printf ("Control key pressed.\n");


'timerMSec'
     An 'Integer' that defines the time in milliseconds between
     'onTimerTick' handler calls.  The default is 1 millisecond.

'timerTickHandler'
     A 'Method' that defines the callback that is executed when the
     classes' interval timer reaches 0.

'visualAuxBuffers'
     An 'Integer' that, in combination with 'visualSetAuxBuffers',
     defines the minimum number of auxiliary buffers that the selected
     visual must have.

'visualBufferSize'
     An 'Integer' that defines the desired color index buffer size.  The
     instance variable 'visualSetBufferSize' must also be set to true.

'visualDepthSize'
     An 'Integer' that contains the size of the visual's depth buffer.
     The 'visualSetDepthSize' instance variable must also be true for
     this value to take effect.

'visualDoubleBuffer'
     A 'Boolean' that selects a double-buffered GLX visual if true, or a
     single-buffered visual if false.

'visualInfoPtr'
     A 'Symbol' that contains the address of a X visual selected when
     the pane's window is created, which normally happens when a program
     calls one of the 'initialize' methods described below.

'visualRedSize'
'visualGreenSize'
'visualBlueSize'
'visualAlphaSize'
     'Integer' values that, if greater than zero, try to select thea
     largest buffer for that color channel of at least the specified
     size.  If one of the values is zero, then 'glXChooseVisual(3)'
     tries to select the smallest available buffer for that color
     channel.

'visualRedAccumSize'
'visualGreenAccumSize'
'visualBlueAccumSize'
'visualAlphaAccumSize'
     'Integer' values that, if greater than zero, try to select thea
     largest accumulator buffer for that color channel of at least the
     specified size.  If one of the values is zero, then
     'glXChooseVisual(3)' tries to select a visual with no accumulator
     buffer for that color channel.

'visualRGBA'
     A 'Boolean' that selects a TrueColor or DirectColor visual if true,
     or a PseudoColor or StaticColor visual if false.  Also, the
     'visualSetBufferSize' and 'visualBufferSize' instance variables are
     ignored when this variable is true.

'visualStencilPlanes'
     An 'Integer' the selects the number of stencil bitplanes if greater
     than zero.  If zero, then a visual with no stencil buffer is
     selected if possible.

'visualStereo'
     A 'Boolean' value that selects a stereo visual if true.

'xLineHeight'
     An 'Integer' that contains the line height in pixels of a font that
     has been selected by the 'useXFont' method.  This variable is read
     only.

'xMaxCharWidth'
     An 'Integer' that contains the maximum width in pixels of a
     character for a X font that has been selected by 'useXFont'.  This
     value is read only.

Instance Methods
................

'alpha (Float ALPHA)'
     Sets the alpha channel (opacity) when rendering outline fonts.
     Values should be between 0.0 (transparent) and 1.0 (opaque).  The
     Ctalk library's default value is 1.0.  Calling this method also
     sets the value of the receiver pane's 'ftFontVar fgAlpha' instance
     variable.

'deleteAndClose (void)'
     Releases the receiver pane's GLX context and deletes the X11
     window, and shuts down the application's X11 input client.

'displayHeigth (void)'
'displayWidth (void)'
     These methods return an 'Integer' with the display height and width
     in pixels, respectively.

'drawFmtText (Float XORG, Float YORG, String FMT, ...)'
     Draws the text given by FMT and its arguments at the matrix
     position given by XORG,YORG.

'drawFmtTextFT (Float XORG, Float YORG, String FMT, ...)'
     Display the string given by FMT and its arguments at the matrix
     coordinates XORG, YORG in the currently selected Freetype font.
     This call, like all calls that render text, should be preceded by a
     call to 'useFTFont'.

'drawFmtTextW (Integer XORG, Integer YORG, String FMT, ...)'
     Draws the formatted text of FMT and its arguments at the pixel
     position given by XORG, YORG.  OpenGL uses the lower left-hand
     corner of the window as the origin for pixel coordinates.

'drawText (Float XORG, Float YORG, String TEXT)'
'drawText (Float XORG, Float YORG, Float RED, Float GREEN, Float BLUE, String TEXT)'
     Draws TEXT at the matrix position given by XORG,YORG.

     The program must have registered a X font for drawing with a
     previous call to the 'useXFont' method.

     If the RED, GREEN, and BLUE arguments are given, the method draws
     the text in that color.  Otherwise, the method (via OpenGL) draws
     the text using the last OpenGL color setting.

'drawTextFT (Float XORG, Float YORG, String TEXT)'
'drawTextFT (Float XORG, Float YORG, Float RED, Float GREEN, Float BLUE, Float ALPHA, String TEXT)'
     Draws the string given by TEXT at the matrix coordinates XORG,
     YORG.

     The RED, GREEN, BLUE, and ALPHA arguments, if used, should be
     between the values of 0.0 and 1.0, so they can be passed along to
     the OpenGL API directly, and also to set the receiver's 'ftFontVar'
     instance variable (a 'X11FreeTypeFont' values for its instance
     variables: 'fgRed, fgGreen, fgBlue,' and 'fgAlpha' *Note
     X11FreeTypeFont::.

'drawTextW (Float XORG, Float YORG, String TEXT)'
'drawTextW (Float XORG, Float YORG, Float RED, Float GREEN, Float BLUE, String TEXT)'
     Draws TEXT using the window's XORG,YORG pixel as the origin.

     If the RED, GREEN, and BLUE arguments are given, the method draws
     the text in that color.  Otherwise, the method (via OpenGL) draws
     the text using the last OpenGL color setting.

     This method allows text to be positioned relative to the window's
     pixels, which avoids the need for programs to translate a matrix
     position into a pixel position manually.  This allows a program to
     position text more easily when it is necessary to measure spaces
     using the dimensions of the text and font that are being displayed.

     The coordinates' origin (0,0) is at the lower left-hand corner of
     the window, and the pixel coordinates increase as the position
     moves toward the top and right of the window.

     The GL function 'glWindowPos2i', which this method uses internally,
     is an extension in many GL implementations.  Ctalk checks for the
     function when building the Ctalk libraries.  If 'glWindowPos2i' is
     not present in the machine's GL libraries, then programs that try
     to use these methods display an error message on the terminal and
     exit.

'extensions (void)'
     Returns the supported GLX extensions from the display server as a
     'String' object.

'frameRate (void)'
     Returns the rate that the program updates the display, in frames
     per second.  The algorithm that calculates the frame rate measures
     frames over a five-second interval.

'freeFTFont (void)'
     Releases the Freetype font in use.

'freeXFont (VOID)'
     Frees the font data that was allocated by a previous call to
     'useXFont'.  Programs should call this method when cleaning up
     before program exit, or when switching fonts by a subsequent call
     to 'useXFont'.

'initialize (Integer X, Integer Y, Integer WIDTH, Integer HEIGHT, Integer GEOMFLAGS)'
'initialize (Integer X, Integer Y, Integer WIDTH, Integer HEIGHT)'
'initialize (Integer WIDTH, Integer HEIGHT'
     Creates the receiver pane's window and configures the window for
     display.  The 'initialize' method also fills in the receiver's
     'visualInfoPtr' instance variable with a pointer the X visual info
     structure specified by the receiver, which is provided by the
     receiver's instance variables.

     With two arguments, the method initializes the receiver window with
     the width and height given as arguments.

     With four arguments, the method initializes the receiver window
     with the window's x and y origin and the width and height given as
     arguments.

     With five arguments, the GEOM_FLAGS argument provides placement
     hints for the window's initial position.  It has the format
     provided by the 'parseX11Geometry' method in 'Application' class.
     *Note parseX11Geometry::.

     When used, the X and Y parameters can be given directly if the
     program sets the window position itself.  If these arguments are
     zero, then the window manager or the user supplied window geometry
     determines the window placement.

'hasExtension (String EXTENSIONNAME)'
     Returns a 'Boolean' value of true if the system's OpenGL library
     supports the GLX extension EXTENSIONNAME, false otherwise.

'map (void)'
     Maps the 'GLXCanvasPane's' window to the display, and internally
     creates a 'GLXContext' for the window, and makes the 'GLXContext'
     current.

     This method fills in the receiver's 'glxContextPtr' instance
     method.

'namedColorFT (String COLORNAME, Float REDOUT, Float GREENOUT, Float BLUEOUT)'
     Return the GLX compatible color values for COLORNAME; i.e., the
     red, green, and blue values are 'Floats' between 0.0 and 1.0.  The
     COLORNAME argument can be any of the colors supported by the X11
     display server.  Refer to 'showrgb(1)' for a list of colors.

'onAnimation (String ANIMATIONHANDLERNAME)'
     Installs the callback method that the program calls 24 times a
     second.  The method needs to have the prototype:


          GLXCanvasPane instanceMethod <methodName> (void);


'onButtonPress (String BUTTONPRESSHANDLERNAME)'
     Installs the callback method that handles ButtonPress events from
     the display.  The callback method needs to have this prototype.


          GLXCanvasPane instanceMethod <methodName> (Integer winX, Integer winY,
                                                     Integer screenX, Integer screenY,
                                                     Integer buttonState,
                                                     Integer eventTime);


     The parameters WINX and WINY give the position of the pointer
     relative to the window's origin.  The parameters SCREENX and
     SCREENY give the pointer's position relative to the upper left-hand
     corner of the root window.

     Note this does not generally mean that the program can receive
     events when a button is pressed outside of the program's window.
     This depends on how the desktop GUI interprets button presses; with
     many desktop programs, the program doesn't receive events when a
     button is clicked outside of the program's window.

     The BUTTONSTATE parameter's value records which buttons are pressed
     at the time of the event.  Note that many systems interpret a
     multiple button click (a "chord") as a unique button.  For example,
     pressing the left and right buttons of a two-button mouse at the
     same time results in a buttonState that indicates button 2 is
     pressed, not that button 1 and button 3 are pressed simultaneously.

     The TIME parameter is the time that the event occurred, so programs
     can interpret a series of ButtonPress events as multiple mouse
     clicks if necessary.

     To install a buttonPress callback method, the program needs to
     include an expression like this one in its initialization code.


          myGLXPane onButtonPress "myButtonPressHandler";


'onExpose (String EXPOSEHANDLERNAME)'
     Installs the callback method to handle Expose events received from
     the display.  The callback method should have the following
     prototype.


          GLXCanvasPane instanceMethod <methodName> (Integer nEvents);


     To install the callback method, the program's initialization should
     contain an expression like this one.


          myPane onExpose "myExposeHandler";


     The parameter NEVENTS contains the number of Expose events that the
     window is waiting to receive.  This allows programs to execute the
     handler's statements once per group of Expose events; that is, when
     NEVENTS reaches 0.

     This handler is important because it updates the window in
     coordination with other display events.  If a callback method is
     not installed, then the 'run' method calls the 'swapBuffers'
     method.

'onIdle (String CALLBACKMETHODNAME)'
     Installs a callback method that the program executes when it is not
     processing events from the display.

     The callback method has the prototype:


          GLXCanvasPane instanceMethod <idleHandler> (void);


     To install the handler, the program's initialization needs to
     contain an expression like this.


          myPane onIdle "myIdleCallback";


'onKeyPress (String CALLBACKMETHODNAME)'
     Configures the receiver's 'keyPressHandler' instance variable to
     refer to the application's actual KeyPress handler method, which is
     called when the program's window receives a KeyPress event from the
     display.

     The actual callback method has the prototype:


          GLXCanvasPane instanceMethod <methodName> (Integer xKeySym,
                                                     Integer keyCode,
                                                     Integer shiftState);

     This example shows a simple KeyPress handler that closes the window
     and exits the program when the 'Escape' key is pressed.


          /* This definition comes from the machine's X11/keysymdef.h file. */
          #define XK_Escape 0xff1b

          GLXCanvasPane instanceMethod myKeyPressMethod (Integer xKeySym,
          					       Integer keyCode,
          					       Integer shiftState) {
            if (xKeySym == XK_Escape) {
              self deleteAndClose;
              exit (0);
            }
          }



     The first parameter is the X Window System symbol for the key,
     which is specific to the machine's keyboard configuration.  The
     complete set of X key symbols is located in the machine's
     'X11/keysymdef.h' file.

     The second parameter is the ASCII value of alphanumeric keys and
     punctuation keys.  In the case of alphabetic characters, the value
     is the same whether the keypress is shifted or unshifted.  That
     means that pressing 'A' and 'a' both result in the 'keyCode'
     argument having the value 97.

     The third parameter, shiftState, indicates whether a modifier key
     is currently being pressed.  The parameter is the receiver's
     'shiftState' instance variable.  The variable's description
     describes how to interpret its value.

     Then, during the program's initialization the program's code should
     include an expression like the following.


          myProgram onKeyPress "myKeyPressMethod";


     There is a more detailed description of how to configure callback
     methods in section that discusses 'Method' class.  *Note
     CallbackSetup::.

'onPointerMotion (String CALLBACKMETHODNAME)'
     Installs the callback method that handles pointer motion events
     from the display.  The callback method must have the prototype:


          GLXCanvasPane instanceMethod <methodName> (Integer winX,
                                                     Integer winY,
                                                     Integer screenX,
                                                     Integer screenY);


     The program's initialization should contain an expression like this
     one:


          myPane onPointerMotion "myPointerMotionMethod";


'onResize (String CALLBACKMETHODNAME)'
     Installs the callback method that handles resize notifications from
     the display.  The callback method needs to have the prototype:


          GLXCanvasPane instanceMethod <methodName> (Integer width,
                                                     Integer height);


     The program's initialization code should contain an expression like
     this one.


          myPane onResize "myResizeMethod";


'onTimerTick (String CALLBACKMETHODNAME)'
     Installs the callback method to be executed when the classes'
     interval timer reaches zero.  The callback method needs to have the
     following prototype.


          GLXCanvasPane instanceMethod <methodName> (void);


     The interval in milliseconds between the callback method's
     execution is set in the 'timerMSec' instance variable,

'pixelHeightFT (Integer PXHEIGHT)'
     Set the pixel height of the selected font to the argument.  The
     default height for rendering fonts with the Freetype libraries is
     18 pixels.

'refreshRate (void)'
     Returns a 'Float' with the display's refresh rate.  If the
     machine's OpenGL does not support reporting the refresh rate,
     returns -1.

'run (void)'
     Runs the event loop that receives X events from the display server,
     and sends them to the callback methods that are configured for the
     application.

     Without any callback methods defined, the 'run' method handles only
     'Expose' events (by calling 'swapBuffers'), and 'ClientMessage'
     events, which check for the 'WM_DELETE_WINDOW' Atom and if present,
     delete the pane's window and GLX context, and exit the program.

'swapBuffers (void)'
     Swaps the pane window's offscreen rendering buffer with the
     window's visible buffer.

'syncSwap (Integer INTERVAL)'
     If INTERVAL > 0, sets the swap interval to 1/INTERVAL, which
     enables swap synchronization with the display's vertical refresh
     rate if the machine's OpenGL installation supports the
     'GLX_MESA_swap_control' extension.

     An INTERVAL value of 0 disables swap synchronization.

     Returns 0 on sucess, or -1 if the extension is not supported.

'textWidth (String TEXT)'
     Returns an 'Integer' with the width of TEXT in pixels in the
     currently selected X font.  If no font is selected, the method
     returns '-1'.

'textWidthFT (String TEXT)'
     Returns a 'Float' with the width of TEXT in matrix coordinates for
     the currently selected Freetype font.

'title (String TITLE_STRING)'
     Set's the window's title.  This method should be called as soon as
     possible after the program calls the 'initialize' method.

'useFTFont (String FONTFILENAME)'
     Load a TrueType, FreeType or Type 1 font.  Also initializes the
     font and GLEW libraries if needed.

     The method uses the font's file name as its argument.  To use a
     system's font aliasing and lookup, refer to *Note
     X11FreeTypeFont::.

'useXFont (String FONTNAME)'
     Register a X font for use with drawing text in the receiver pane.
     The argument, FONTNAME, is th X Logical Font Descriptor of a X font
     that is available on the system - refer to 'xlsfonts(1)' or
     'xfontsel(1)' for more information.

     This method should be called during OpenGL initialization (that is,
     after the 'GLXCanvasPane' object has been created and the GLX
     context established).

'xpmToTexture (Symbol XPMDATA, Integer WIDTHOUT, Integer HEIGHTOUT, Symbol TEXELDATAOUT)'
'xpmToTexture (Symbol XPMDATA, Integer ALPHA Integer WIDTHOUT, Integer HEIGHTOUT, Symbol TEXELDATAOUT)'

     Translates a XPM pixmap into an OpenGL texture.  The argument
     XPM_DATA is the pixmap's 'char *pixmap_name[]' declaration.  If no
     ALPHA argument is given, then '1.0' is used to create an opaque
     texture.

     Alpha values can range from 0 (completely transparent) - 0xffff
     (completely opaque), although in practice, the alpha channel's
     effect might not be apparent, because OpenGL has its own set of
     functions that perform texture blending.

     The method sets the arguments WIDTH_OUT, HEIGHT_OUT, and
     TEXEL_DATA_OUT with the height, width and data of the texture.

     Mesa OpenGL textures, used with Linux systems, internally have the
     format GL_RGBA and the data type GL_UNSIGNED_INT_8_8_8_8, so you
     can create a 2D texture from a pixmap with statements like these.


          Integer new xpmWidth;
          Integer new xpmHeight;
          Symbol new texData;

          /*
           *  Note that the xpm_data argument should not normally need a
           *  translation from C.
           */
          myGLUTApp xpmToTexture xpm_data, xpmWidth, xpmHeight, texData;
          glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, xpmWidth, xpmHeight, 0,
                        GL_RGBA, GL_UNSIGNED_INT_8_8_8_8, texData);


     Apple OpenGL implementations use a different internal format, so a
     program would create the equivalent texture like this.


          Integer new xpmWidth;
          Integer new xpmHeight;
          Symbol new texData;

          myGLUTApp xpmToTexture xpm_data, xpmWidth, xpmHeight, texData;
          glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, xpmWidth, xpmHeight, 0,
                        GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, texData);


     The 'xpmToTexture' method does not do any setup of the OpenGL
     texture environment.  For basic textures, OpenGL works better with
     textures that have a geometry that is an even multiple of 2; e.g.,
     128x128 or 256x256 pixels.

     Individual applications can add parameters for interpolation,
     blending, mipmap creation, and material rendering based on the
     program's requirements, though.

     The Ctalk library only stores the data for one texture at a time,
     so if a program uses multiple textures, it should save the texture
     data to a separate 'Symbol', in orderq to avoid regenerating the
     texture each time it's used.  Many OpenGL implementations also
     provide API functions for texture caching.

     For an example of how to draw with textures, refer to the
     'glxtexture.ca' program in the Ctalk distribution's 'demos/glx'
     subdirectory.

Sample GLXCanvasPane Application
--------------------------------


     #include <X11/Xlib.h>
     #include <GL/glx.h>

     #define DEFAULT_WIDTH 500
     #define DEFAULT_HEIGHT 500

     float face1[3][3] = {{0.0f, 2.0f, 0.0f},
     		     {-2.0f, -2.0f, 2.0f},
     		     {2.0f, -2.0f, 2.0f}};
     float face2[3][3] = {{0.0f, 2.0f, 0.0f},
     		     {2.0f, -2.0f, 2.0f},
     		     {2.0f, -2.0f, -2.0f}};
     float face3[3][3] = {{0.0f, 2.0f, 0.0f},
     		     {2.0f, -2.0f, -2.0f},
     		     {-2.0f, -2.0f, -2.0f}};
     float face4[3][3] = {{0.0f, 2.0f, 0.0f},
     		     {-2.0f, -2.0f, -2.0f},
     		     {-2.0f, -2.0f, 2.0f}};

     float base[4][3] = {{2.0f, -2.0f, 2.0f},
     		    {2.0f, -2.0f, -2.0f},
     		    {-2.0f, -2.0f, -2.0f},
     		    {-2.0f, -2.0f, 2.0f}};

     float angle = 20.0;

     GLXCanvasPane instanceMethod draw (void) {
       glEnable (GL_NORMALIZE);
       glEnable(GL_DEPTH_TEST);
       glClearColor(0.0, 0.0, 0.0, 1.0);
       glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
       glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
       glLineWidth (1.0f);

       glLoadIdentity ();
       glColor4f (1.0f, 1.0f, 1.0f, 1.0f);

       glRotatef (angle, 0.0f, 1.0f, 0.0f);
       glRotatef (10.0f, 0.0f, 0.0f, 1.0f);

       glBegin (GL_TRIANGLES);
       glColor3f (1.0f, 0.0f, 0.0f);
       glVertex3fv (face1[0]);
       glColor3f (0.0f, 1.0f, 0.0f);
       glVertex3fv (face1[1]);
       glColor3f (0.0f, 0.0f, 1.0f);
       glVertex3fv (face1[2]);

       glColor3f (1.0f, 0.0f, 0.0f);
       glVertex3fv (face2[0]);
       glColor3f (0.0f, 1.0f, 0.0f);
       glVertex3fv (face2[1]);
       glColor3f (0.0f, 0.0f, 1.0f);
       glVertex3fv (face2[2]);

       glColor3f (1.0f, 0.0f, 0.0f);
       glVertex3fv (face3[0]);
       glColor3f (0.0f, 1.0f, 0.0f);
       glVertex3fv (face3[1]);
       glColor3f (0.0f, 0.0f, 1.0f);
       glVertex3fv (face3[2]);

       glColor3f (1.0f, 0.0f, 0.0f);
       glVertex3fv (face4[0]);
       glColor3f (0.0f, 1.0f, 0.0f);
       glVertex3fv (face4[1]);
       glColor3f (0.0f, 0.0f, 1.0f);
       glVertex3fv (face4[2]);
       glEnd ();

       glBegin (GL_QUADS);

       glColor3f (1.0f, 0.0f, 0.0f);
       glVertex3fv (base[0]);
       glColor3f (0.0f, 1.0f, 0.0f);
       glVertex3fv (base[1]);
       glColor3f (0.0f, 0.0f, 1.0f);
       glVertex3fv (base[2]);
       glColor3f (1.0f, 0.0f, 1.0f);
       glVertex3fv (base[3]);

       glEnd ();

       glRotatef (20.0, 0.0f, 0.0f, 1.0f);
       glRotatef (angle, 0.0f, 1.0f, 0.0f);

       self swapBuffers;
     }

     GLXCanvasPane instanceMethod initGL (void) {
       glViewport (0, 0, DEFAULT_WIDTH, DEFAULT_HEIGHT);
       glClearColor(0.0, 0.0, 0.0, 1.0);
       glLineWidth (1.0);
       glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
       glEnable (GL_LINE_SMOOTH);
       glHint (GL_LINE_SMOOTH_HINT, GL_DONT_CARE);
       glMatrixMode (GL_PROJECTION);
       glLoadIdentity ();
       if (DEFAULT_WIDTH <= DEFAULT_HEIGHT) {
         glOrtho (-5.0, 5.0,
     	     -5.0 * ((float)DEFAULT_HEIGHT / (float)DEFAULT_WIDTH),
     	     5.0 * ((float)DEFAULT_HEIGHT / (float)DEFAULT_WIDTH),
     	     -5.0, 5.0);
       } else {
         glOrtho (-5.0, 5.0,
     	     -5.0 * ((float)DEFAULT_WIDTH / (float)DEFAULT_HEIGHT),
     	     5.0 * ((float)DEFAULT_WIDTH / (float)DEFAULT_HEIGHT),
     	     -5.0, 5.0);
       }
       glMatrixMode (GL_MODELVIEW);
       glLoadIdentity ();
     }

     GLXCanvasPane instanceMethod myTimerTickHandler (void) {
       angle += 1.0;
       self draw;
     }

     /* This definition comes from the machine's X11/keysymdef.h file. */
     #define XK_Escape 0xff1b

     GLXCanvasPane instanceMethod myKeyPressMethod (Integer xKeySym,
     					       Integer keyCode,
     					       Integer shiftState) {
       if (xKeySym == XK_Escape) {
         self deleteAndClose;
         exit (0);
       }
     }

     GLXCanvasPane instanceMethod myExposeMethod (Integer nEvents) {
       if (nEvents == 0)
         self draw;
     }

     GLXCanvasPane instanceMethod myResizeMethod (Integer width,
     					     Integer height) {
       float ar;

       glViewport (0, 0, width, height);
       glMatrixMode (GL_PROJECTION);
       glLoadIdentity ();
       if (width <= height)
         ar = (float)height / (float)width;
       else
         ar = (float)width / (float)height;
       glOrtho (-5.0, 5.0, -5.0 * ar, 5.0 * ar, -5.0, 5.0);
       glMatrixMode (GL_MODELVIEW);
       glLoadIdentity ();
     }

     int main () {
       GLXCanvasPane new pane;

       pane initialize (1, 150, 500, 500);
       pane title "GLXCanvasPane Demonstration";
       pane map;
       pane raiseWindow;

       pane onKeyPress "myKeyPressMethod";
       pane onExpose "myExposeMethod";
       pane onTimerTick "myTimerTickHandler";
       pane onResize "myResizeMethod";

       pane initGL;

       pane run;

     }



File: ctalk.info,  Node: X11PaneDispatcher,  Next: X11CanvasPane,  Prev: GLXCanvasPane,  Up: Classes

'X11PaneDispatcher' Class
-------------------------

'X11PaneDispatcher' objects manage events from the system's display,
control posititioning and rendering of subpanes within the main pane,
and help communicate events between the main window's pane and the
subwindows' panes.

The positioning of subwindows within the parent window is controlled by
the arguments to the 'attachTo' methods; in particular, these methods
accept a geometry specification, as an argument, which has the following
format.


     width[%]xheight[%][+x[%]+y[%]]


If a dimension does not contain a percent ('%') sign, the dimensions are
in pixels.  With a percent sign, the dimensions are a fractional
percentage of the parent pane's width or height.

Also, for some 'Pane' classes, like dialog windows, if the geometry does
not include the _x_ and _y_ dimensions, then the class positions the
window centered over its parent window.

The 'X11PaneDispatcher' method 'new' creates a X window, although the
window of the 'X11PaneDispatcher' itself is not normally visible, the
window is provided for subclass panes whose windows will appear within
the main 'X11Pane' window.

Subclasses can reimplement default methods like 'new' and the event
handler methods if necessary.  It is also possible for subclasses to
implement event handlers with other method messages than those given
here.  The 'X11PaneDispatcher' object can use these subclasses' methods
if they are available.

Subclasses, however, should use the 'setMethodHandler' method, described
below, to register these callback methods.

Handler Classes
...............

The following event handlers and the default names of the callback
method that handles the event, are available to 'X11PaneDispatcher'
objects and its subclasses.  Handler methods need to take as arguments a
reference to a subpane object, and the 'InputEvent' object from the
system.  *Note X11TerminalStream::.

     Handler Class  Event Class    Description                     Default Handler Method
     "resize"       RESIZENOTIFY   Called when the user            subPaneResize
                                   resizes a window.

     "move"         MOVENOTIFY     Called when a user              subPaneMove
                                   moves a window.
                                   Depending on the
                                   window manager, an
                                   application might also
                                   need to make sure the
                                   window is resized
                                   correctly.

     "expose"       EXPOSE         Called whenever the display     subPaneExpose
                                   server generates exposes a
                                   window due when raised,
                                   uncovered, resized, or other
                                   change.

     "kbdinput"     KEYPRESS       Called when the user presses    subPaneKbdInput
                    KEYRELEASE     a key and the application's
                                   window has the focus.

     "pointerinput" BUTTONPRESS    Called when a mouse button      subPanePointerInput
                    BUTTONRELEASE  is pressed or released.

     "pointermotion" MOTIONNOTIFY  Called whe the pointer is       subPanePointerMotion
                                   moved.

     "selectionrequest"
                  SELECTIONREQUEST Received when another program   subPaneSelectionRequest
                                   requests the X selection.
                                   This callback is here mainly
                                   for completeness; presently, X
                                   selection events are handled
                                   internally, and only with the
                                   library functions used by
                                   X11TextEditorPane objects.

     "selectionclear"
                    SELECTIONCLEAR Received when another program
                                   requests the X selection. Currently,
                                   on library functions used by
                                   X11TextEditorPane objects use this
                                   internally but applications can use this
                                   event to update their status if
                                   necessary.
     "wmfocuschange" WMFOCUSCHANGENOTIFY
                                   Received from the window manager when the
                                   pointer enters or leaves a window, or when
                                   the window manager raises a window.  The
                                   xEventData1 instance variable contains the
                                   type of X event, either FocusIn or FocusOut.

     "enternotify" ENTERWINDOWNOTIFY
                                   Received when the pointer enters a
                                   window from another window.

     "leavenotify" LEAVEWINDOWNOTIFY
                                   Received when the pointer leaves a
                                   window.

     "focusin"     FOCUSIN         Received when the application signals
     "focusout"    FOCUSOUT        a change of widget focus; for example,
                                   when the user presses the <Tab>
                                   key.

     "map"         MAPNOTIFY       Received when the pane's window is
                                   mapped onto the display.

     "destroy"     WINDELETE      Called when the user closes the
                                   application window.


Handler Methods
...............

A handler typically takes as its arguments a reference to a subpane, and
the event.  Although the subpane reference parameter can be declared as
an 'Object', it is in actual use a 'Symbol' object, with the reference
defined by the 'attachTo' method.  The handler should be able to pass
the event along to any subpanes of the receiver pane if necessary, by
checking whether subpanes implement their own handlers.  Here, for
example, is the 'X11PaneDispatcher' class's 'subPaneResize' method.


     X11PaneDispatcher instanceMethod subPaneResize (Object __subPane,
     					      InputEvent __event) {
       "Dispatch an Resize event to the subpanes of the
        receiver pane."
       X11Pane new containerPane;
       self size x = __event xEventData3;
       self size y = __event xEventData4;
       containerPane = *self container;
       XResizeWindow (containerPane xDisplay, containerPane xWindowID,
     		 self size x, self size y);
       if (__subPane isInstanceMethod "subPaneResize") {
         __subPane methodObjectMessage __subPane handleResize, __subPane,
           __event;
       }
       return NULL;
     }


The internals of the subpane API are likely to change and be expanded in
future releases.  Using the methods described here and in other sections
should help insure that applications are compatible with future Ctalk
releases.

Instance Variables
..................

'canFocus'
     A 'Boolean' that determines whether the widget is highlighed when
     the pointer passes over it, or the application sets the focus; for
     example, by pressing the <Tab> key.

     If this variable is true, which is the default, then the class
     should also declare event handlers for focus in and focus out
     events.  Otherwise, the program prints a warning each time the
     'shiftFocus' method, described below, calls a 'NULL' 'Method'
     object.

'handleDestroy'
     A 'Method' that provides the default handler to delete a subpane
     window and its data.

'handleEnterNotify'
'handleLeaveNotify'
     Handlers for events that are generated when a pointer crosses from
     one window to another.

'handleFocusIn'
'handleFocusOut'
     Handles highlighting or un-highlighting a widget when receiving a
     FOCUSIN or FOCUSOUT event from the application; for example, when
     the user presses the <Tab> key.

'handleKbdInput'
     A 'Method' that provides the default handler for subpanes to handle
     keyboard input.

'handleMap'
     Called when the program recieves a MAPNOTIFY event for the pane's
     window.

'handleMove'
     A 'Method' that provides the default handler for moving subpane
     windows.

'handlePointerInput'
     A 'Method' that provides the default handler for pointer input
     (mainly ButtonPress) events.

'handlePointerMotion'
     A 'Method' that provides the default handler for pointer motion
     events.

'handleResize'
     A 'Method' that provides the default handler for resizing subpane
     windows within the main window.

'handleSelectionClear'
     A 'Method' that provides the default handler for SelectionClear
     events.

'handleSelectionRequest'
     A 'Method' that provides the default handler for SelectionRequest
     events.  Currently, this callback is here for completeness; X
     selection events are handled internally, and only in the library
     functions used by 'X11TextEditorPane' objects.

'handleWMFocusChange'
     The method that handles the events received from the desktop's
     window manager when it changes the window focus in response to a
     pointer motion or click; or when the window manager raises a
     window.

'hasFocus'
     An 'Integer' that is true if the current subpane has the input
     focus.  For programs with only a single widget class, this variable
     is not used.

'highlight'
     A 'Boolean' that indicates whether the widget is displayed
     highlighted.

'modalWin'
     When a dialog window is popped up over the main window, this holds
     the window ID of the popup.  The 'handleSubPaneEvent' method uses
     this to determine how the application's main window should respond
     to X events; generally it keeps the dialog window above the main
     window until the dialog window is withdrawn.  When their is no
     window popped up over the main window, the value of 'modalWin' is
     zero ('0').

'tabFocus'
     A 'Boolean' that determines, if true (which is the default),
     whether the 'handleSubPaneEvent' method intercepts the <Tab> key in
     order to shift the input focus when it is pressed.  If 'tabFocus'
     is true, the subpane's class must implement methods to handle the
     'focusin' and 'focusout' events that shifting focus with the
     keyboard implements, or the program will display warning messages
     when it can't find the methods.

Instance Methods
................

'attachTo (Object PARENTPANE)'
'attachTo (Object PARENTPANE, String GEOMETRY)'
     Attach the receiver to its parent pane, typically a 'X11Pane' or
     'X11PaneDispatcher'.  Also creates a X window, although
     'X11PaneDispatcher' windows themselves are not normally visible.

     When the subwindow is attached to the parent window, the Ctalk
     library creates the pane object's window and graphics context, and
     clears the window to the background color of the pane object's
     'backgroundColor' instance variable; for example, with an
     expression like this:


          myCanvasPane backgroundColor = "blue";


     Otherwise, the method clears the subpane's window to black.

     The GEOMETRY argument, if present, defines the size and placement
     of the subpane's window within the parent window.  A geometry
     specification has the form:


          width[%]xheight[%]+x[%]+y[%]


     The dimensions are in pixels, unless a percent sign ('%') follows a
     dimension.  In that case, the dimension is a fractional percentage
     of the parent pane's width or height.  The 'String' may contain a
     combination of absolute and relative dimensions.

'handleSubPaneEvent (InputEvent EVENT)'
     Handle an input event from the window system.  Typically the parent
     pane's 'inputStream' provides the event.  *Note
     X11TerminalStream::.

     This method also checks keypresses for the <Tab> key, and calls the
     'shiftFocus' method in order to shift focus between a window's
     subpanes when the user presses <Tab>.

'new (DISPATCHERNAME)'
     Create a new 'X11PaneDispatcher' object.  Initializes the instance
     variables to the default subpane event handlers and the container
     mode to 'full'.  If the argument list contains more than one label,
     created new 'X11PaneDispatcher' objects with the names of each
     label.

'setMethodHandler (String HANDLERTYPE, Method HANDLERMETHOD)'
     Set the pane's handler for HANDLERTYPE to HANDLERMETHOD.  Currently
     supported handler types are: 'resize'.

'shiftFocus (void)'
     When the user presses <Tab>, 'handleSubPaneEvent' calls this
     method, which highlights a window's subpanes in succession, if the
     subpanes can take the input focus.

     Refer to the 'canFocus' instance variable, and the handlers for
     focus in and focus out events.  These event handlers are called by
     the program, and are not the same as the 'handleWMFocusChange'
     handler, which is called when the window focus changes on the
     desktop.

'clearFocus (void'
     Called before shifting the focus highlight to a new pane to insure
     that only one pane indicates that it should receive focus,
     including the synthetic focus that is assigned when shifting focus
     using the <Tab> key.

'registerClick (Integer CLICKX, Integer CLICKY'
     Registers a mouse click by saving its date and time.  If the click
     immediately follows another click in the same location, the method
     sets the internal variable 'double_click' to true.

     This method is only needed if a program uses double clicks for user
     input.

'subPaneDestroy (Object SUBPANEREF, InputEvent DESTROYEVENT)'
     The default handler for 'WINDELETE' events.  Like the other method
     handlers, SUBPANEREF is typically a 'Symbol' object.  The
     'X11TerminalStream' section describes these events.  *Note
     X11TerminalStream::.

'subPaneGeometry'
     A 'String' that stores a subpane's geometry specification, if any.
     For an explanation of geometry string's format, refer to the
     'attachTo' method, below.

'subPaneKbdInput (Object SUBPANEREF, InputEvent KBDINPUTEVENT)'
     The default handler for 'KEYPRESS' and 'KEYRELEASE' events.  Like
     the other method handlers, SUBPANEREF is typically a 'Symbol'
     object.  The 'X11TerminalStream' section describes these events.
     *Note X11TerminalStream::.

'subPaneMove (Object SUBPANEREF, InputEvent MOVENOTIFYEVENT)'
     The default event handler for 'MOVENOTIFY' events from the system's
     GUI. Like the other method handlers, SUBPANEREF is typically a
     'Symbol' object.  The 'X11TerminalStream' section describes these
     events.  *Note X11TerminalStream::.

     With some window managers, a 'subPaneMove' method might also need
     to handle 'RESIZENOTIFY' events.

'subPanePointerMotion (Object SUBPANEREF, InputEvent EVENT)'
'subPanePointerInput (Object SUBPANEREF, InputEvent EVENT)'
     The default handlers for 'MOTIONNOTIFY', and 'BUTTONPRESS' and
     'BUTTONRELEASE' events.  Like the other method handlers, SUBPANEREF
     is typically a 'Symbol' object.  The 'X11TerminalStream' section
     describes these events.  *Note X11TerminalStream::.

'subPaneResize (Object SUBPANEREF, InputEvent RESIZENOTIFYEVENT)'
     The default resize handler for subpane windows.  Typically
     SUBPANEREF is a 'Symbol' object that contains a reference to the
     subpane object.  The RESIZEEVENT argument is typically a
     'RESIZENOTIFY' event from the system's GUI. *Note
     X11TerminalStream::.


File: ctalk.info,  Node: X11CanvasPane,  Next: X11ButtonPane,  Prev: X11PaneDispatcher,  Up: Classes

'X11CanvasPane' Class
---------------------

The 'X11CanvasPane' class provides the instance variables and methods
for basic X window graphics operations like drawing points, lines, and
rectangles.  The width and color of shapes is controlled by the 'pen'
instance variable.

Here is brief drawing program that uses a 'X11CanvasPane' object.
Clicking on the pane's window draws a dot at that point.  If the program
is given the argument '-v', the program displays the X events it
receives from the display.

     int main (int argv, char **argc) {
       X11Pane new xPane;
       X11PaneDispatcher new xTopLevelPane;
       X11CanvasPane new xCanvasPane;
       InputEvent new e;
       Integer new nEvents;
       Integer new verbose;
       Exception new ex;
       String new text;
       Application new paneApp;

       paneApp enableExceptionTrace;
       paneApp installExitHandlerBasic;

       xPane initialize 0, 0, 200, 100;
       xPane inputStream eventMask =
         WINDELETE|BUTTONPRESS|BUTTONRELEASE|MOVENOTIFY|EXPOSE;
       xTopLevelPane attachTo xPane;
       xCanvasPane attachTo xTopLevelPane;
       xPane map;
       xPane raiseWindow;

       xPane openEventStream;

       xCanvasPane clear;
       xCanvasPane background "blue";
       xCanvasPane pen width = 5;
       xCanvasPane pen colorName = "white";

       xCanvasPane refresh;

       verbose = FALSE;
       if (argc == 2) {
         if (!strcmp (argv[1], "-v")) {
           verbose = TRUE;
         }
       }

       WriteFileStream classInit;

       while (TRUE) {
         xPane inputStream queueInput;
         if (xPane inputStream eventPending) {
           e become xPane inputStream inputQueue unshift;
           xPane subPaneNotify e;  /* Call the classes' event handlers. */
           if (ex pending)
      	ex handle;

           switch (e eventClass value)
     	{
     	  /*
     	   *  Handle both types of events in case the window
     	   *  manager doesn't distinguish between them.
     	   */
     	case MOVENOTIFY:
     	  if (verbose) {
     	    stdoutStream printOn "MOVENOTIFY\t%d\t%d\t%d\t%d\n",
     	      e xEventData1,
     	      e xEventData2,
     	      e xEventData3,
     	      e xEventData4;
     	    stdoutStream printOn "Window\t\t%d\t%d\t%d\t%d\n",
     	      xPane origin x,
     	      xPane origin y,
     	      xPane size x,
     	      xPane size y;
     	  }
     	  break;
     	case RESIZENOTIFY:
     	  if (verbose) {
     	    stdoutStream printOn "RESIZENOTIFY\t%d\t%d\t%d\t%d\n",
     	      e xEventData1,
     	      e xEventData2,
     	      e xEventData3,
     	      e xEventData4;
     	    stdoutStream printOn "Window\t\t%d\t%d\t%d\t%d\n",
     	      xPane origin x,
     	      xPane origin y,
     	      xPane size x,
     	      xPane size y;
     	  }
     	  break;
     	case EXPOSE:
     	  if (verbose) {
     	    stdoutStream printOn "Expose\t\t%d\t%d\t%d\t%d\t%d\n",
     	      e xEventData1,
     	      e xEventData2,
     	      e xEventData3,
     	      e xEventData4,
     	      e xEventData5;
     	  }
     	  break;
     	case BUTTONPRESS:
     	  xCanvasPane drawPoint e xEventData1, e xEventData2;
     	  if (verbose) {
     	    stdoutStream printOn "ButtonPress\t\t%d\t%d\t%d\t%d\t%d\n",
     	      e xEventData1,
     	      e xEventData2,
     	      e xEventData3,
     	      e xEventData4,
     	      e xEventData5;
     	  }
     	  xCanvasPane refresh;
     	  break;
     	case BUTTONRELEASE:
     	  if (verbose) {
     	    stdoutStream printOn "ButtonRelease\t\t%d\t%d\t%d\t%d\t%d\n",
     	      e xEventData1,
     	      e xEventData2,
     	      e xEventData3,
     	      e xEventData4,
     	      e xEventData5;
     	  }
     	  break;
     	case WINDELETE:
      	  xPane deleteAndClose;
     	  exit (0);
     	  break;
     	default:
     	  break;
     	}
         }
       }
     }



Instance Variables
------------------

'dragStart'
     A 'Point' object that records the beginning of a canvas motion
     operation within a window or view port.

'moveCursor'
     The 'X11Cursor' displayed when moving the 'X11CanvasPane' object
     within a window or view port.

'pen'
     A 'Pen' object that contains the width in pixels and color of lines
     and points drawn on the pane's window.

'regions'
     An 'AssociativeArray' that contains the rectangular regions defined
     by the 'defineRegion' method, below.

'viewHeight'
     An 'Integer' that contains the height of the pane's window and
     buffers in pixels.

'viewWidth'
     An 'Integer' that contains the height of the pane's window and
     buffers in pixels.

'viewXOrg'
     The X coordinate of the upper right-hand corner of a canvas'
     visible rectangle within a window or view port.

'viewYOrg'
     The Y coordinate of the upper right-hand corner of a canvas'
     visible rectangle within a window or view port.

Instance Methods
................

'attachTo (Object PARENT_PANE)'
'attachTo (Object PARENT_PANE, String GEOMETRY)'
'attachTo (Object PARENT_PANE, Integer XORG, Integer YORG)'
'attachTo (Object PARENT_PANE, Integer XORG, Integer YORG, Integer XSIZE, Integer YSIZE)'
     Attach a 'X11CanvasPane' object to its parent pane, which is
     typically a 'X11PaneDispatcher' object.  With one argument, this
     method initializes the size of the pane's window and buffers to the
     parent pane's dimensions, and positions the pane at the upper
     left-hand origin of the main window.

     If two arguments are present, the second is a 'String' with the
     geometry specifcation for the subpane.  Subpane geometry strings
     have the form:


          [-]width[%]x[-]height[%][+[-]x[%]+[-]y[%]]


     The dimensions are in pixels, unless a percent sign ('%') follows a
     dimension, or a minus sign ('-' precedes the dimension.

     When a percent sign follows the dimension, the width of the pane in
     pixels is the fractional percentage of the parent pane's width or
     height.

     If a minus sign precedes the dimension, the dimension is measured
     relative to the opposite edge of the parent window; i.e., a width
     of '-15' places the subpane's right edge 15 pixels in from the
     right edge of the parent window.  A x position of '-90' places the
     subpane's _top_ edge (not the subpane's bottom edge) 90 pixels from
     the bottom edge of the parent window.

     The 'String' may contain a combination of absolute and relative
     dimensions.

     With only the width and height given, the method positions the pane
     at XORG,YORG within the parent pane, which usually is relative to
     the upper left hand origin of the window.  This is generally used
     to center modal dialog panes over their parent window.

     With all four dimensions given, the method positions the pane at
     XORG,YORG within the parent pane, with the width and height
     XSIZE,YSIZE.

'background (String COLOR)'
     Set the background of the pane to COLOR.  You need to update the
     pane using, for example, 'clearRectangle', for the new background
     to be visible.  See the note for 'X11Bitmap' class's 'background'
     method.  *Note X11Bitmap::.

'clear (void)'
     Clear the pane to the background color.

'clearRectangle (Intger XORG, Integer YORG, Integer XSIZE, Integer YSIZE)'
     Clear the pane's image to the window background in a rectangle
     bounded by the method's arguments, and update the top-level pane's
     window.

'copy (X11Bitmap SRC_BITMAP, Integer SRC_X_ORT, Integer SRC_Y_ORG, Integer SRC_WIDTH, Integer SRC_HEIGHT, Integer DEST_X_ORG, Integer DEST_Y_ORG)'
     Copies the contents of SRC_BITMAP to the receiver's drawing
     surface.  The source dimensions are determined by SRC_X_ORG,
     SRC_Y_ORG, SRC_WIDTH, and SRC_HEIGHT.  The method draws the source
     bitmap's contents with the source's upper left-hand corner at
     DEST_X_ORG, DEST_Y_ORG.

     The 'X11Bitmap's' parent drawable must be the receiver's drawable
     surface, and the color depths of the source and destination must
     match.

     The process is similar to the 'refresh' method, below, so programs
     do not need to call both 'copy' and 'refresh' for the same
     operation.

     This slightly abbreviated example program is included in the Ctalk
     package at test/expect/examples-x11/canvas-copy.c as well as the
     XPM graphic, but almost any XPM should work as well.

          #include "coffee-cup.xpm"

          /*
             Set these to the width and height of your pixmap,
             and edit the pixmapFromData expression below to
             the xpm's declaration name.
          */
          #define XPM_WIDTH 127
          #define XPM_HEIGHT 141

          X11CanvasPane instanceMethod drawXPMs (X11Bitmap xpmBitmap) {
            Integer new i;

            for (i = 0; i < 5; i++) {
              self copy xpmBitmap, 0, 0, XPM_WIDTH, XPM_HEIGHT, (i* 40), (i * 40);
            }

            self refresh;
          }

          int main () {
            X11Pane new xPane;
            InputEvent new e;
            X11PaneDispatcher new xTopLevelPane;
            X11CanvasPane new xCanvasPane;
            Application new paneApp;
            X11Bitmap new srcBitmap;

            paneApp enableExceptionTrace;
            paneApp installExitHandlerBasic;

            xPane initialize 10, 10, 300, 300;
            xTopLevelPane attachTo xPane;
            xCanvasPane attachTo xTopLevelPane;

            srcBitmap create xCanvasPane xWindowID, XPM_WIDTH, XPM_HEIGHT,
              xCanvasPane depth;

            xPane map;
            xPane raiseWindow;
            xPane openEventStream;

            xCanvasPane background "white";

            srcBitmap pixmapFromData (0, 0, coffee_cup);

            xCanvasPane drawXPMs srcBitmap;

            while (TRUE) {
              xPane inputStream queueInput;
              if (xPane inputStream eventPending) {
                e become xPane inputStream inputQueue unshift;
                /* We don't have to use, "xPane subPaneNotify e" here, because
                   the program doesn't need to handle any X events for the
                   graphics classes. */
                switch (e eventClass value)
                  {
                  case WINDELETE:
                    xPane deleteAndClose;
                    exit (0);
                    break;
                  case EXPOSE:
                  case RESIZENOTIFY:
          	  xCanvasPane drawXPMs srcBitmap;
                    break;
                  default:
                    break;
                  }
              }
              usleep (100000);
            }
          }


     _Note:_ The 'copy' method retrieves the 'paneBuffer' instance
     variable.  If you use an expresion like the following, then the
     program calls the 'X11Bitmap : copy' method instead.  *Note
     X11Bitmap::.


            myRcvrPane paneBuffer copy ...


'defineRegion (String REGIONNAME, Integer XORG, Integer YORG, Integer XSIZE, Integer YSIZE)'
     Define a rectangular region with name REGIONNAME with the upper
     left-hand corner at XORG, YORG relative to the upper left-hand
     corner of the canvas.  The region has the width XSIZE and height
     YSIZE.  When handling input events, the window system clips the
     region to the canvas' viewable area.

'drawCircle (Circle ACIRCLE, Integer FILLED, String BGCOLOR)'
'drawCircle (Circle ACIRCLE, Pen APEN, Integer FILLED, String BGCOLOR)'
     Draw the circle defined by ACIRCLE in the receiver's paneBuffer.
     If FILLED is true, draws a filled circle.  If the APEN argument is
     given, draws the circle with the color and the line width defined
     by the 'Pen', and fills the interior of the circle with BGCOLOR.

     For an example program, refer to the 'Circle' section of this
     manual.  *Note Circle::.

'drawPoint (Intger X, Integer Y)'
     Draw a dot on the pane's window at the x and y coordinates given by
     the arguments.

'drawLine (Line ALINE)'
'drawLine (Line ALINE, Pen APEN)'
'drawLine (Intger STARTX, Integer STARTY, Integer ENDX, Integer ENDY)'
'drawLine (Intger STARTX, Integer STARTY, Integer ENDX, Integer ENDY, pen APEN)'
     With one argument, a 'Line' object, draws the line using the
     receiver's 'Pen' instance variable.  With two arguments, draws the
     'Line' object with the color and line width given by APEN.

     If given the line's endpoints as arguments, the method draws a line
     on the pane's window from the point given by the STARTX and STARTY
     arguments to the point given by the ENDX and ENDY arguments, with
     the color and the line width given by the receiver's 'Pen' object.

'drawLine (Intger XORG, Integer YORG, Integer XSIZE, Integer YSIZE)'
'drawLine (Intger XORG, Integer YORG, Integer XSIZE, Integer YSIZE, Pen APEN)'
     Draw a filled rectangle on the pane's window with the upper-left
     hand corner at the point given by the XORG and YORG arguments, with
     the width XSIZE and the height YSIZE.  If a 'Pen' argument isn't
     given, uses the line width and color defined by the receiver's
     'pen' instance variable; otherwise uses the line width and color
     defined by the APEN argument.

'drawRoundedRectangle (Intger XORG, Integer YORG, Integer XSIZE, Integer YSIZE, Integer RADIUS)'
'drawRoundedRectangle (Intger XORG, Integer YORG, Integer XSIZE, Integer YSIZE, Pen APEN, Pen APEN, Integer RADIUS)'
     Similar to 'drawFilledRectangle', but this method takes an extra
     argument, the radius of the corner arcs that round the rendered
     rectangle's corners.

     If the APEN argument is given, the method uses its color and line
     width for drawing.  Otherwise, the method uses the color and line
     width defined by the 'X11CanvasPane' object for drawing.

'drawRectangle (Intger XORG, Integer YORG, Integer XSIZE, Integer YSIZE)'
'drawRectangle (Intger XORG, Integer YORG, Integer XSIZE, Pen APEN, Integer YSIZE)'
     Draw the borders of a rectangle on the pane's window with the
     upper-left hand corner at the point given by the XORG and YORG
     arguments, with the width XSIZE and the height YSIZE.

     If the APEN argument is given, the method uses its color and line
     width for drawing.  Otherwise, the method uses the color and line
     width defined by the 'X11CanvasPane' object for drawing.

'drawRoundedRectangle (Intger XORG, Integer YORG, Integer XSIZE, Integer YSIZE, Integer RADIUS)'
'drawRoundedRectangle (Intger XORG, Integer YORG, Integer XSIZE, Integer YSIZE, Pen APEN, Integer RADIUS)'
     This method is similar to 'drawRectangle', except that it takes an
     extra argument, RADIUS, which specifies the radius of the arcs that
     form the rectangle's corners.

     If the APEN argument is given, the method uses its color and line
     width for drawing.  Otherwise, the method uses the color and line
     width defined by the 'X11CanvasPane' object for drawing.

'directCopy (X11Bitmap SRC_BITMAP, Integer SRC_X_ORT, Integer SRC_Y_ORG, Integer SRC_WIDTH, Integer SRC_HEIGHT, Integer DEST_X_ORG, Integer DEST_Y_ORG)'
     Similar to the 'copy' method, above, except 'directCopy' copies the
     'X11Bitmap' object given as its argument directly to the window.
     This might be quicker, and doesn't require that the program call
     'refresh' (below) to update the window contents, but this method
     may also cause flickering when the window is updated.

'foreground (String COLOR)'
     Set the background of the pane to COLOR.  See the note for
     'X11Bitmap' class's 'background' method.  *Note X11Bitmap::.

'new (String PANE_NAME)'
     Create a new 'X11CanvasPane' instance and initialize its event
     handlers.

     If the argument list contains more than one label, create a new
     'X11CanvasPane' object with the names given by the arguments; for
     example,


          X11CanvasPane new pane1, pane2, pane3;


'pixmapFromData (int X_ORG, int Y_ORG, char *XPM_DATA[])'
     Draw the X pixmap defined by XPM_DATA with the upper left corner at
     X_ORG,Y_ORG on the receiver's pane.

     The XPM_DATA argument is the name of the array declared at the
     start of a 'xpm' file's data array.

'putStrXY (Integer XORG, Integer YORG String TEXT)'
'putStrXY (Integer XORG, Integer YORG String TEXT, String FONT_DESC)'
'putStrXY (Integer XORG, Integer YORG String TEXT, String FONT_DESC, String COLOR_NAME))'
     Write TEXT on the receiver pane's drawing surface (usually a
     X11Bitmap) at position XORG,YORG.  *Note X11Bitmap::.

     If the fourth argument is FONT_DESC, the method draws the text
     using that font, which is either a X Logical Font Descriptor if
     using X bitmap fonts or a Fontconfig descriptor if using Freetype
     fonts.

     For information about Fontconfig descriptors, refer to the
     'X11FreeTypeFont' section *Note X11FreeTypeFont::.  For information
     about X Logical Font Descriptors, refer to the 'X11Font' section
     *Note X11Font::.

     If a COLOR_NAME argument is also given, draws the text using that
     color.

'selectFont (void)'
'selectFont (X11FreeTypeFont FONT)'
     This method selects the font and face defined by the reciever's
     'ftFontVar' instance variable (with no arguments), or the FONT
     given as a single argument.

     These methods ensure that the font-face selection is valid in any
     of the client-server memory spaces, and folds the font's weight and
     slant into one of Ctalk's predefined face slots: medium, bold,
     italic, or bold italic.  This is basically a holdover from
     calculating font-face combinations for .BDF fonts; future versions
     of Ctalk should be able to use the typeface parameters directly.

     This method is basically a combination of two other methods:
     'X11FreeTypeFont : selectFont,' and the library function
     '__ctalkSelectXFontFace', which is used in the 'X11Bitmap' methods:
     'faceBold, faceRegular, faceItalic,' and 'faceBoldItalic.'

     The four font face slots have definitions of that are given in both
     'X11Bitmap' class and 'ctalkdefs.h'.  The definitions are listed
     below.


          #define X_FACE_REGULAR     (1 << 0)
          #define X_FACE_BOLD        (1 << 1)
          #define X_FACE_ITALIC      (1 << 2)
          #define X_FACE_BOLD_ITALIC (1 << 3)


'refresh (void)'
     Redraw the pane on the main window.

'refreshReframe (void)'
     Redraw the pane on the main window.  If the user has moved the pane
     by clicking and dragging on it, then reposition the pane within the
     window.

'subPaneDestroy (Object SUBPANEREF, InputEvent EVENT)'
     Deletes the pane's window and its data when the user closes the
     pane's window.

'subPaneExpose (Object SUBPANEREF, InputEvent EVENT)'
     Redraws the pane's window whenever it is mapped or displayed after
     being covered by another window.

'subPanePointerInput (Object SUBPANEREF, InputEvent EVENT)'
     Default handler for mouse ButtonPress and ButtonRelease events.
     This method is a no-op here, but it can be re-implemented if
     necessary by subclasses.  The application receives pointer events,
     like all other events, via the top-level window's 'inputStream' (a
     'X11TerminalStream' object).

'subPaneResize (Object SUBPANEREF, InputEvent EVENT)'
     The handler for Resize events from the X display.  Resizes the
     pane's X window and adjusts the pane's dimensions.


File: ctalk.info,  Node: X11ButtonPane,  Next: X11CheckBoxPane,  Prev: X11CanvasPane,  Up: Classes

'X11ButtonPane' Class
---------------------

The 'X11ButtonPane' class defines instance variables and methods that
draw buttons on X windows.  The buttons' appearance is defined by the
values in the resources and instance variables, and they may be used to
define the format of customized buttons.

'X11ButtonPane' objects also contain a 'X11LabelPane' object, which is
used to render the visual elements, like the text, border, and
highlighting, on the button's face.

In many cases the button's 'X11LabelPane' subpane inherits the
definitions of the 'X11ButtonPane's' instance variables and resources,
generally when a program constructs the pane during a call to the
'attachTo' method.

Here are several example programs.  The first draws beveled buttons, the
second draws rounded, non-beveled buttons.


     /* -*-c-*- */

     /*
      *  buttons.ca - X11ButtonPane demonstration.
      *
      *    To build, use this command line:
      *
      *      ctcc -x buttons.ca -o buttons
      *
      *    There are several options that control the buttons' appearance.
      *    Some of them use the #defines below.  Consult the X11ButtonPane
      *    section in the Ctalk language reference for a full description
      *    of the X11ButtonPane class.
      */


     #include <ctalk/ctalkdefs.h>

     /* Uncomment this #define to use X bitmap fonts. */
     /* #define XFONTS */

     /* Also, uncomment this to draw multiline labels. */
     /* #define MULTILINE */

     /* Uncomment if you want the buttons to be highlighted with wider
        borders and a bold label (if the font supports it). */
     /* #define BOLD_HILITE */

     /* See the X11FreeTypeFont section of the the Ctalk reference. */
     #define FTFONT_BOLD   200
     #define FTFONT_MEDIUM 100

     int main (void) {
       X11Pane new mainWindow;
       X11PaneDispatcher new dispatcher;
       X11ButtonPane new lbutton;
       X11ButtonPane new rbutton;
       X11LabelPane new label;
       InputEvent new e;

       mainWindow backgroundColor = "blue";

       label canFocus = false;
       label ftFontVar initFontLib;
       label resources replaceAt "borderWidth", 0;

       label resources replaceAt "backgroundColor", "blue";
       label resources replaceAt "foregroundColor", "blue";
       label resources replaceAt "textColor", "white";
       lbutton resources replaceAt "backgroundColor", "blue";
       rbutton resources replaceAt "backgroundColor", "blue";
       lbutton resources replaceAt "ftFont", "sans serif-10";
       rbutton resources replaceAt "ftFont", "sans serif-10";

       mainWindow initialize 255, 200;
       mainWindow inputStream eventMask =
         EXPOSE|ENTERWINDOWNOTIFY|LEAVEWINDOWNOTIFY|BUTTONPRESS|BUTTONRELEASE|KEYPRESS|KEYRELEASE|WINDELETE|MOTIONNOTIFY;
       dispatcher attachTo mainWindow;
     #ifdef MULTILINE
       lbutton attachTo dispatcher, "100x60+25+100";
       rbutton attachTo dispatcher, "100x60+135+100";
     #else
       lbutton attachTo dispatcher, "90x50+25+100";
       rbutton attachTo dispatcher, "90x50+135+100";
     #endif
       label attachTo dispatcher, "147x80+c+15";

       mainWindow map;
       mainWindow raiseWindow;

       mainWindow openEventStream;

       mainWindow setWMTitle "X11ButtonPane Demo";

     #ifndef XFONTS
       label ftFontVar initFontLib;
     #else
       lbutton label font "fixed";
     #endif

       label multiLine "X11ButtonPane\nDemo";

     #ifndef MULTILINE
       lbutton label text "Left";
       rbutton label text "Right";
     #else
       lbutton label multiLine "Click\nHere";
       rbutton label multiLine "Click\nHere, Too";
     #endif

     #ifdef BOLD_HILITE
       lbutton label resources replaceAt "highlightForegroundColor",
         (lbutton resources at "foregroundColor");
       rbutton label resources replaceAt "highlightForegroundColor",
         (rbutton resources at "foregroundColor");
       lbutton label resources replaceAt "highlightBorderWidth", 2;
       rbutton label resources replaceAt "highlightBorderWidth", 2;
       rbutton label resources replaceAt "highlightTextBold", true;
       lbutton label resources replaceAt "highlightTextBold", true;
     #endif

       lbutton draw;
       lbutton refresh;
       rbutton draw;
       rbutton refresh;
       label draw;
       label refresh;

       while (TRUE) {
         mainWindow inputStream queueInput;
         if (mainWindow inputStream eventPending) {
           e become mainWindow inputStream inputQueue unshift;

           mainWindow subPaneNotify e;

           switch (e eventClass value)
     	{
     	case EXPOSE:
     	  lbutton subPaneExpose (lbutton, e);
     	  rbutton subPaneExpose (rbutton, e);
     	  label subPaneExpose (label, e);
     	  break;
     	case WINDELETE:
      	  mainWindow deleteAndClose;
     	  exit (0);
     	  break;
     	default:
     	  if (lbutton haveClick) {
     	    printf ("left button!\n");
     	    lbutton clearClick;
     	  } else if (rbutton haveClick) {
     	    printf ("right button!\n");
     	    rbutton clearClick;
     	  }
     	  break;
     	}
         } else {
           usleep (1000);
         }
       }

     }



     /* roundbuttons.ca - X11ButtonPane Rounded Buttons -*-c-*- */

     #include <ctalk/ctalkdefs.h>

     /* To avoid overlapping arcs, corner_radius < (button_minor_dimen / 2) */
     #define CORNER_RADIUS 13

     int main (void) {
       X11Pane new mainWindow;
       X11PaneDispatcher new dispatcher;
       X11ButtonPane new lbutton;
       X11ButtonPane new rbutton;
       X11LabelPane new label;
       InputEvent new e;

       mainWindow backgroundColor = "blue";
       label ftFontVar initFontLib;
       label resources replaceAt "backgroundColor", "blue";
       rbutton resources replaceAt "backgroundColor", "blue";
       lbutton resources replaceAt "backgroundColor", "blue";
       rbutton resources replaceAt "foregroundColor", "blue";
       lbutton resources replaceAt "foregroundColor", "blue";


       mainWindow initialize 225, 150;
       mainWindow inputStream eventMask =
         EXPOSE|ENTERWINDOWNOTIFY|LEAVEWINDOWNOTIFY|BUTTONPRESS|BUTTONRELEASE|KEYPRESS|KEYRELEASE|WINDELETE|MOTIONNOTIFY;
       dispatcher attachTo mainWindow;
       lbutton attachTo dispatcher, "80x30+22+100";
       rbutton attachTo dispatcher, "80x30+124+100";
       label attachTo dispatcher, "147x80+32+15";

       mainWindow map;
       mainWindow raiseWindow;

       mainWindow openEventStream;

       mainWindow setWMTitle "X11ButtonPane Demo";

       label multiLine "X11ButtonPane\nRounded Button\nDemo";
       label canFocus = false;
       label borderWidth = 0;
       label resources replaceAt "borderColor", "blue";
       label resources replaceAt "textColor", "white";
       label resources replaceAt "backgroundColor", "blue";
       label resources replaceAt "foregroundColor", "blue";

       rbutton resources replaceAt "foregroundColor", "blue";
       lbutton resources replaceAt "foregroundColor", "blue";
       rbutton resources replaceAt "textColor", "white";
       lbutton resources replaceAt "textColor", "white";


       lbutton label text "Left";
       rbutton label text "Right";

       lbutton bevelEdges = false;
       lbutton radius = CORNER_RADIUS;
       rbutton bevelEdges = false;
       rbutton radius = CORNER_RADIUS;

       lbutton draw;
       lbutton refresh;
       rbutton draw;
       rbutton refresh;
       label draw;
       label refresh;

       while (TRUE) {
         mainWindow inputStream queueInput;
         if (mainWindow inputStream eventPending) {
           e become mainWindow inputStream inputQueue unshift;

           mainWindow subPaneNotify e;

           switch (e eventClass value)
     	{
     	case EXPOSE:
     	  lbutton subPaneExpose (lbutton, e);
     	  rbutton subPaneExpose (rbutton, e);
     	  label subPaneExpose (label, e);
     	  break;
     	case WINDELETE:
      	  mainWindow deleteAndClose;
     	  exit (0);
     	  break;
     	default:
     	  if (lbutton haveClick) {
     	    printf ("left button!\n");
     	    lbutton clearClick;
     	  } else if (rbutton haveClick) {
     	    printf ("right button!\n");
     	    rbutton clearClick;
     	  }
     	  break;
     	}
         } else {
           usleep (1000);
         }
       }

     }


Retrieving Button States
------------------------

The 'X11ButtonPane' class provides several methods to retrieve the state
of a button object.

'haveClick'
     Returns true or false depending on whether the button has been
     clicked recently.  This means that programs do not need to
     constantly monitor a button's state.  If 'haveClick' returns true,
     then the click state can be cleared with the 'clearClick' method
     (below).

'isClicked'
     This method returns true or false depending on whether the
     pointer's button 1 is currently pressed within the button's area.

'clearClick'
     Resets a previous clicked state as returned by the 'haveClick'
     method, above.

'text'
     Returns a 'String' with the button's text.  If the text is
     displayed on several lines, the method concatenates the lines with
     a space character '' '' between them.

Resources
---------

The resources that 'X11ButtonPane : new' defines by default are stored
in the 'resources' instance variable, an 'AssociativeArray' that is
declared in 'X11Pane' class.  For a description, see the 'resources'
instance variable documentation.  *Note PaneResources::.

'backgroundColor'
     A 'String' that contains the color used to draw the button's
     background.  This includes the actual subwindow that receives the
     button's events from the display server.  The resources' default
     value is 'gray'.

     If you want the button's background to match its parent window, add
     a statement like the following _before_ attaching the button to its
     parent window with the 'attachTo' method (assuming in this example
     that the parent window's background is also 'blue').


          myButton resources replaceAt "backgroundColor", "blue";


     When the program creates the actual X subwindow (again, by calling
     the 'attachTo' method), the Ctalk libraries then check for a
     resource or instance variable named either, 'background' or
     'backgroundColor' and uses its value to set the X subwindow's
     background color.

'borderColor'
     A 'String' that contains the name of the color used to draw the
     label's borders.  The default value is 'black'.

'borderWidth'

     An 'Integer' that contains the width of the visible border in
     pixels.  Its default value is '1'.  To draw buttons without
     borders, programs can set this resource to '0'.

'foregroundColor'
     A 'String' that defines the color used for the button's drawable
     face.  Its default color is 'gray'.

'font'
     A 'String' that contains the Fontconfig descriptor of the button's
     default font.  Its default value is 'sans serif-12'.  The button's
     label inherits the descriptor as its default font when attaching
     the button (and its 'X11LabelPane' label) to its parent window with
     the 'attachTo' method.

     To change the label's font, include a statement like the one in the
     example, _after_ the button has been fully initialized by the
     'attachTo' method.


          myButton label resources replaceAt "ftFont", "URW Gothic L-10";


     The font, 'URW Gothic L,' is a Type 1 font included in the
     Ghostscript 'gsfonts' package.

     Note that the older, 'ftFont' key has been changed to, 'font', so
     it's consitent with other classes' resources.  The class still uses
     the older 'ftfont' resource key if a program uses it.

'highlightForegroundColor'
     A 'String' that contains the color used to fill the button's face
     when the pointer is over the button.  Its default value is
     'gray90'.

     If you want buttons to display a thicker border and bold font for
     highlighting, you can include a set of statements like the
     following in the program, _after_ the program attaches the button
     to its parent pane.


          myButton label resources replaceAt "highlightForegroundColor",
            (myButton resources at "foregroundColor");
          myButton label resources replaceAt "highlightBorderWidth", 2;


     To cause the button's text to be emphasized when the button is
     highlighted, add a line like this one.


          myButton label resources replaceAt "highlightTextBold", true;


     This is only effective if the font library supports boldfacing
     (i.e., mainly Freetype and Type 1 fonts).

     In these cases, the label subpane doesn't automatically inherit
     these values, so it's necessary to use the label's declaration,
     'myButton label,' directly.

'highlightBorderColor'
     A 'String' that defines the color to use when drawing a highlighted
     border.  The default is 'black'.

'highlightBorderWidth'
     An 'Integer' that defines the border width in pixels when the
     button is highlighted.  The default value is '1'.  (That is, the
     button doesn't use a heavier border for emphasis by default.)

     The 'label' subpane inherits this value when the 'attachTo' method
     constructs the button pane.

'highlightHPenColor'
'highlightVPenColor'
'shadowPenColor'
     These are 'String' objects that define the colors for the
     highlighted and shadowed button edges when drawing a beveled
     button.

'textColor'
     A 'String' that contains the color used to draw the button's text.
     This value is inherited by the button's label widget.  The
     'textColor' resources' default value is 'black'.

Instance Variables
------------------

'bevelEdges'
     A 'Boolean' that causes the widget to display beveled edges if
     true.

'bevelWidth'
     An 'Integer' that defines the width of the button's bevelled edges
     in pixels.

'borderColor'
     A 'String' that contains the name of the button's border color when
     drawing a non-beveled button.

'borderMargin'
     An 'Integer' that defines the distance between the border and the
     pane's edge in pixels, when drawing a non-beveled button.

'borderWidth'
'borderHighlighWidth'
     'Integer' values that determine the width a non-beveled button when
     it is clicked on and in its non-highlighted state.

'clicked'
     A 'Boolean' that is true when the pointer's Button 1 is pressed
     while over the widget, and false otherwise.

'highlightHPen'
'highlightVPen'
'shadowPen'
     'Pen' objects that defines the color of the edges' bevels when
     drawing a beveled widget.

'hover'
     A 'Boolean' that is true if the pointer is over the button's
     window, false otherwise.  Normally, this causes the button to draw
     its face using highlighted colors, fonts, and borders.

'label'
     A 'X11LabelPane' object that contains a button's text and provides
     the methods to draw on the button's surface.  *Note X11LabelPane::.

'radius'
     If greater than zero ('0'), this 'Integer' defines the radius in
     pixels of the curves displayed when the button is drawn with
     rounded corners.

Instance Methods
----------------

'attachTo (Object PARENTPANE, String GEOMETRY)'
'attachTo (Object PARENTPANE)'
'attachTo (Object PARENTPANE, Integer XORG, Integer YORG)'
'attachTo (Object PARENTPANE, Integer XORG, Integer YORG, Integer XSIZE, Integer YSIZE)'
     Attaches the receiver to the parentPane named by PARENTPANE, with
     the placement and size given by 'geometry'.  The parent pane should
     generally be a 'X11PaneDispatcher' which directs X events to the
     correct subpane.

     The positioning of subwindows within the parent window is
     controlled by the arguments to the 'attachTo' methods; in
     particular, these methods accept a geometry specification, as an
     argument, which has the following format.

     If only PARENTPANE is given as an argument, the child pane occupies
     the entire width and height of the parent pane.

     If the program has initialized the Xft Freetype libraries, this
     method also fills in the pane object's 'ftFontVar' instance
     variable with the selected font, which is normally a system-defined
     standard font during app initialization.


          width[%]xheight[%]+x[%]+y[%]


     If a dimension does not contain a percent ('%') sign, the
     dimensions are in pixels.  With a percent sign, the dimensions are
     a fractional percentage of the parent pane's width or height, or a
     horizontal or vertical distance that places the subwindow's upper
     left-hand corner that distance from the parent window's upper
     left-hand corner.

'clearClick (void)'
     Resets a button's clicked state as returned by 'haveClick' to
     false.

'clearClick (configureFonts'
     A convenience method that localizes the button's label font for
     more uses, especially with composite widgets like dialog boxes.
     This method set's the label subpane's font to the button's 'font'
     resource.

'draw (void)'
     Draws the button and its label on the pane's buffer so the widget
     can be displayed with the refresh method.

     If the program has saved a font specification to the widget's
     'ftFontVar' instance variable, then this method also selects the
     font before drawing the widget.  If you want a button to display a
     different font than the surronding window, this is the way to
     declare and save a font specification.


          /* The button inherits the ftFont method from X11Pane class. */

          button ftFont "DejaVu Sans", FTFONT_ROMAN, FTFONT_MEDIUM, DEFAULT_DPI, 10.0;
          button ftFontVar saveSelectedFont;


     The 'X11FreeTypeFont' section describes the parameters that the
     'X11FreeTypeFont' class uses when selecting fonts.  *Note
     X11FreeTypeFont::.

'haveClicked (void)'
     Returns a 'Boolean' true or false depending on whether the button
     has been clicked previously.  In that case, the program should call
     the 'clearClick' method to detect further button clicks.

'isClicked (void)'
     Returns a 'Boolean' value of true or false depending on whether the
     pointer's button 1 is currently pressed within the button.

'new (String NEWOBJECTNAME)'
     The 'X11ButtonPane' constructor.  Creates a 'X11ButtonPane' object
     with the classes' instance variables, and initialized the object's
     event handlers and 'Pen' objects for drawing a beveled button.

'subPaneExpose (Object SUBPANE, InputEvent EVENT)'
'subPaneButtonPress (Object SUBPANE, InputEvent EVENT)'
'subPaneEnter (Object SUBPANE, InputEvent EVENT)'
'subPaneLeave (Object SUBPANE, InputEvent EVENT)'
'subPaneResize (Object SUBPANE, InputEvent EVENT)'
     The class's handlers for events generated by the X server.

'subPaneFocusIn (void)'
'subPaneFocusOut (void)'
     Handlers for focus changes generated by the application.  These do
     not respond to X events and don't require any arguments.  These
     methods are designed to be called by methods like
     'X11PaneDispatcher : shiftFocus' (e.g., in response to a <Tab>
     keypress).

'text (void)'
     Returns a 'String' with the button's text.  If the text is
     displayed on multiple lines, this method concatenates the lines
     with a space character (' ') between them.


File: ctalk.info,  Node: X11CheckBoxPane,  Next: X11LabelPane,  Prev: X11ButtonPane,  Up: Classes

'X11CheckBoxPane' Class
-----------------------

A single 'X11CheckBoxPane' object draws a checkable box on the main
window.  The class has methods for initialization, drawing, changing the
box's clicked/unclicked state, and the instance data for retrieving the
state.

Here is an example program that displays a 'X11CheckBoxPane' object.


/*
 *  X11CheckBoxPane demo.
 */	

/* 
 *  To display bevels, uncomment the following line. 
 */
/* #define BEVEL */

/* 
 * To draw a checkbox with rounded corners, uncomment the following
 * lines and set FRAME_RADIUS and FILL_RADIUS to non-zero values.  The
 * checkboxes use different radius' for the frame and the filled
 * interior of a checked checkbox because most radius are a
 * significant percent of the boxes' sides, which can make the frame
 * look like a rectangle with rounded corners, and also make the fill
 * rectangle look like an oval, if the shapes use the same radius.
 */
/* #define RADIUS */
/* #define FRAME_RADIUS 0 */
/* #define FILL_RADIUS 0 */

/* 
 * To change the width, height, and internal margin of the
 * check box, edit these #defines.  The measurements are in
 * pixels.
 */
#define CHECKBOX_WIDTH   15
#define CHECKBOX_HEIGHT  15
#define CHECKBOX_MARGIN  1
#define CHECKBOX_BORDER  1

#include <ctalk/ctalkdefs.h>

int main (int argv, char **argc) @{
  X11Pane new xPane;
  X11PaneDispatcher new xTopLevelPane;
  X11CheckBoxPane new xCheckBoxPane;
  X11LabelPane new label;
  X11CanvasPane new canvas;
  InputEvent new e;
  Exception new ex;
  Pen new arrowPen;

  xPane ftFontVar initFontLib;

  xPane initialize 0, 0, 300, 300, "Checkbox Demo";
  xPane inputStream eventMask = BUTTONPRESS|BUTTONRELEASE|WINDELETE|EXPOSE;
  xTopLevelPane attachTo xPane;

  /* Note that the geometry string in the, "attachTo," call below
     contains only the X,Y origin of the check box.  In this case, the
     size of the check box is taken from the object's resources, which
     we can adjust any time before, "attachTo," sizes the actual
     drawing surfaces. */
  xCheckBoxPane resources replaceAt "width", CHECKBOX_WIDTH;
  xCheckBoxPane resources replaceAt "height", CHECKBOX_HEIGHT;
  xCheckBoxPane resources replaceAt "margin", CHECKBOX_MARGIN;
  xCheckBoxPane resources replaceAt "borderWidth", CHECKBOX_BORDER;
#ifdef RADIUS
  xCheckBoxPane resources replaceAt "frameRadius", FRAME_RADIUS;
  xCheckBoxPane resources replaceAt "fillRadius", FILL_RADIUS;
#endif  

  label ftFontVar selectFontFromFontConfig "URW Gothic L-12";
  label ftFontVar saveSelectedFont;
  label justify = LABEL_LEFT;
  label text "Please Click";
  label resources replaceAt "borderWidth", 0;
  
  canvas attachTo xTopLevelPane, "280x280+10+10";
  xCheckBoxPane attachTo xTopLevelPane, "+20%+40%";
  label attachTo xTopLevelPane, "160x40+35%+50";

#ifdef BEVEL
  xCheckBoxPane resources replaceAt "bevel", true;
#endif

  xPane map;
  xPane raiseWindow;

  xPane openEventStream;

  xPane setWMTitle "Checkbox Demo";
  canvas background "white";
  label draw;
  xCheckBoxPane draw;
  arrowPen width = 1;
  arrowPen colorName = "black";
  
  while (TRUE) @{
    xPane inputStream queueInput;
    if (xPane inputStream eventPending) @{
      e become xPane inputStream inputQueue unshift;
      xPane subPaneNotify e;  /* Call the classes' event handlers. */
      if (ex pending)
	ex handle;
      
      switch (e eventClass value)
     	@{
	case BUTTONPRESS:
	  if (e eventData == xCheckBoxPane xWindowID) @{
	    if (xCheckBoxPane clicked) @{
	      printf ("clicked\n");
	    @} else @{
	      printf ("unclicked\n");
	    @}
	  @}
	  break;
	case EXPOSE:
	  label draw;
	  canvas paneBuffer drawRectangle 10, 10, 260, 260, false,
	    1, "black", 0;
	  canvas paneBuffer drawLine 110, 45, 70, 100, arrowPen;
	  canvas paneBuffer drawLine 70, 100, 70, 90, arrowPen;
	  canvas paneBuffer drawLine 70, 100, 81, 97, arrowPen;
	  canvas refresh;
	  break;
	case WINDELETE:
      	  xPane deleteAndClose;
     	  exit (0);
     	  break;
     	default:
     	  break;
     	@}
    @}
  @}
@}


Retrieving a 'X11CheckBox' Object's State
-----------------------------------------

The 'X11CheckBoxPane' class declares the 'checked' instance variable,
which is either true or false depending on when and how many times a
user has clicked on the checkbox.  Successive clicks change the
'checked' instance variable's state from false to true and back again.
The 'draw' method draws the checkbox filled or empty depending on the
state of the 'checked' instance variable.

Here is the portion of the program above that retrieves the checkbox's
state.  The check box object is named 'xCheckBoxPane'.  The condition,
'if (e eventData == xCheckBoxPane xWindowID)' insures that the program
uses only pointer clicks that fall within 'xCheckBoxPane's' boundaries.


     if (e eventData == xCheckBoxPane xWindowID) {
       if (xCheckBoxPane clicked) {
         printf ("clicked\n");
       } else {
         printf ("unclicked\n");
       }
     }


Resources
---------

'backgroundColor'
     A 'String' that contains the color name of the checkbox's
     background.  The default is 'white'.

'bevel'
     A 'Boolean' that determines whether to draw beveled edges on the
     checkbox's interior.  The default is 'false'.

'borderWidth'
     An 'Integer' that specifies the width in pixels of the checkbox's
     border.  The default is 1px.

'clickColor'
     A 'String' that contains the color name of the checkbox's border
     and interior when checked.  The default is 'darkslategray'.

'fillRadius'
'frameRadius'
     These are 'Integer' objects which, if nonzero, cause the checkbox
     to be drawn with rounded corners.  There is a separate dimension
     for the margin and the checkbox interior because the radius
     comprises a significant amount of a checkbox's size, so the margin
     might appear like a rectangle with rounded corners, while the
     interior might look like a circle or oval, if the shapes use the
     same corner radius.

'darkShadowColor'
'lightShadowColor'
     The names of the colors of the light and dark shadows that the
     checkbox displays inside its border if the 'bevel' resource is
     true.

'height'
'width'
     These are 'Integer' values that contain the width and height of the
     checkbox, in pixels.  Their default value, '15px', is set when the
     checkbox object is created, and may be changed before the checkbox
     is attached to its parent pane.  If the checkbox's 'attachTo'
     method is given a geometry that also contains a width and height,
     then this latest dimension setting determines the checkbox's size
     when displayed.

'margin'
     The distance in pixels between the inner edge of the border and the
     edge of the check in a filled checkbox.  The default is 1px.

Instance Variables
------------------

'clicked'
     A 'Boolean' that changes between true and false every time the
     check box is clicked.  The variable's value also determines whether
     the checkbox's interior is filled.

Instance Methods
----------------

'attachTo (Object PARENTPANE, String GEOMETRY)'
     Attaches the receiver 'X11CheckBoxPane' to its PARENTPANE using the
     dimensions given by GEOMETRY.  The method also creates the drawing
     surfaces with the correct dimensions.

     The GEOMETRY argument may optionally omit the checkbox's width and
     height, which causes the method to use the width and height given
     by the checkbox object's resources.  For example, if the program
     contains an expression like the following:


          xCheckBoxPane attachTo xTopLevelPane, "+25%+25%";


     Then the method will create the checkbox with the dimensions preset
     by the object's 'width' and 'height' resources.  If the checkbox's
     dimensions are determined in this manner, a program my change the
     checkbox's size any time before the 'attachTo' method is called.
     However, if the program contains a statement like the following,


          xCheckBoxPane attachTo xTopLevelPane, "20x20+25%+25%";


     Then the program uses the '20x20' size given as the argument, which
     is the most recent dimension that the program has defined..

'draw (void)'
     This method draws the checkbox.  It uses the CLICKED instance
     variable state to determine whether to draw a filled checkbox, as
     well as the classes' resources that have been set in the object to
     determine check checkbox's style; i.e., the checkbox's size,
     whether its edges are beveled or rounded, and the checkbox's color.

'new (String PANENAME)'
     The 'X11CheckBoxPane' constructor.  Creates a new 'X11CheckBox'
     with the name given by PANENAME, and makes it available to the
     method that contains the statement, or to the entire program if the
     new 'X11CheckBoxPane' is declared in a global scope.  The method
     also initializes the event handlers and resources that are defined
     in the class.

'onClick (Object SUBPANE, InputEvent EVENT)'
     This method receives a 'BUTTONPRESS' event from the display system,
     and toggles the receiver checkbox's 'clicked' instance variable
     between true and false.  The method changes the 'clicked' state
     only in response to 'BUTTONPRESS' events; a corresponding
     'BUTTONRELEASE' event is ignored.


File: ctalk.info,  Node: X11LabelPane,  Next: X11ListPane,  Prev: X11CheckBoxPane,  Up: Classes

'X11LabelPane' Class
--------------------

'X11LabelPane' objects display text in graphical windows.  The class
provides instance variables and methods that control the label's font,
border, justification, whether the label is highlighted when the pointer
is over it, and formatting of single and multiple line labels.

Formatting label text for multiple line labels, as well as controlling
the text's justification, is described in the subsections below.

Here is a simple example program that displays a X11LabelPane widget.


     #include <ctalk/ctalkdefs.h>

     #define FTFONTS    /* Comment this line out to use X fonts. */
     #define MULTILINE  /* Comment out to display a single line label. */
     #define ROUNDED    /* Comment out to draw borders with straight edges. */

     int main (int argv, char **argc) {
       X11Pane new xPane;
       X11PaneDispatcher new xTopLevelPane;
       X11LabelPane new xLabelPane;
       InputEvent new e;
       Exception new ex;

     #ifdef FTFONTS
       xPane ftFontVar initFontLib;
       xLabelPane resources replaceAt "ftFont", "DejaVu Sans-12:bold";
       xLabelPane selectFont;
     #endif

       xLabelPane resources replaceAt "backgroundColor", "white";

       xPane initialize 0, 0, 300, 300;
       xPane inputStream eventMask =
         WINDELETE|EXPOSE|ENTERWINDOWNOTIFY|LEAVEWINDOWNOTIFY;
       xTopLevelPane attachTo xPane;
       xLabelPane attachTo xTopLevelPane, "150x150+c+50";
       xPane map;
       xPane raiseWindow;

       xPane openEventStream;

     #ifndef FTFONTS
       xLabelPane font "-*-helvetica-medium-r-*-*-*-120-*-*-*-*-*-*";
     #endif

     #ifdef MULTILINE
       xLabelPane multiLine "Labels\ncan occupy\nmultiple\nlines.";
     #else
       xLabelPane text "A Label";
     #endif

     #ifdef ROUNDED
       xLabelPane radius = 10;
     #endif

       xLabelPane draw;

       while (TRUE) {
         xPane inputStream queueInput;
         if (xPane inputStream eventPending) {
           e become xPane inputStream inputQueue unshift;
           xPane subPaneNotify e;  /* Call the classes' event handlers. */
           if (ex pending)
     	ex handle;

           switch (e eventClass value)
          	{
          	case WINDELETE:
           	  xPane deleteAndClose;
          	  exit (0);
          	  break;
          	default:
          	  break;
          	}
         }
       }
     }


Multiple Line Labels
--------------------

If the label's text contains embedded newline '\n' characters, and the
text is defined using the 'multiLine' method, below, then the text is
display on multiple lines, with the breaks appearing where the newline
characters appear in the text.  The text is displayed centered
vertically, and justified as described in the next section.

For single line labels, use the 'text' method with a 'String' argument
to fit on one line.

Justification
-------------

The 'X11LabelPane' widget contains a simple layout engine that can
center label text, or justify it against the right or left margins.

The text's justification is determined by the setting of the
'justification' instance variable, which can have one of three values,
which are defined by the following macros:


     LABEL_LEFT
     LABEL_RIGHT
     LABEL_CENTER


These macros are defined in the 'ctalk/ctalkdefs.h' include file.  To
use them, add the line


     #include <ctalk/ctalkdefs.h>


to the beginning of the source module.

The widget calculates the right and left margins as the following:


     (aLabel margin) + (aLabel highlightBorderWidth) + (aLabel padding)


The highlighted border width is included regardless of whether the
border actually is drawn or the label is hightlighted, so text alignment
remains constant if a program draws and then obscures the border, or
when the pointer passes over the label.

Resources
---------

The resources that 'X11LabelPane : new' defines by default are stored in
the 'resources' instance variable, an 'AssociativeArray' that is
declared in 'X11Pane' class.  For a description, see the 'resources'
instance variable documentation.  *Note PaneResources::.

'boldFont'
     The font that the label uses for highlighting text by printing in
     bold type.

'font'
'ftFont'
     A 'String' that contains the text font's Fontconfig font
     descriptor.  The default is 'sans serif-12'.

     Note that the class still checks for the 'ftFont' resource for
     compatibility with previous versions, but the class now uses the
     'font' resource to make int consistent with other classes.

     For more information about Fontconfig descriptors, refer to the
     'X11FreeTypeFont' class.  *Note X11FreeTypeFont::.

'backgroundColor'
     A 'String' that contains the pane's background color.  This is the
     color of the pane's X subwindow, so it is generally useful to set
     this to the color of the surrounding window, if you want the label
     to blend in with its surrounding drawing area.

'borderColor'
     A 'String' that contains the name of the pane's border color.  The
     default is 'black'

     An 'Integer' that contains the line width the pane's border.  The
     default is '1'.

'foregroundColor'
     A 'String' that contains the name of the color that fills the
     pane's visible area.  The default is 'white'.

'grayedColor'
     The color of the text and border when the pane is grayed.  The
     default is 'gray'.

'highlightBorderColor'
     The color of the border when the pane is highlighted.  The default
     is 'black'.

'highlightBorderWidth'
     The width of the border when the pane is highlighted the default is
     '2'.

'highlightForegroundColor'
     A 'String' that contains the color name of the pane's visible area
     when it the pane is in a highlighted state, which is generally when
     the pointer is over the pane's window area.  The default is
     'orange'.

'highlightTextBold'
     A 'Boolean' that causes the label to display its text in a bold
     font when the label is highlighted, if the font library supports
     it.  The default is 'false'.

'highlightTextColor'
     A 'String' that contains the text color when the pane is in a
     highlighted state, generally when the pointer is over the pane.
     The default is 'black'.

'textColor'
     A 'String' that contains the text color when the pane is not
     highlighted.  The default is 'black'.

'xFont'
     A 'String' that contains the text fonts X Logical Font Descriptor.
     Refer to 'xfontsel(1)' and 'xlsfonts(1)' for information about
     XLFD's.  The default is 'fixed'.

Instance Variables
------------------

'boldFont'
     A 'X11FreeTypeFont' object that the label uses to highlight text by
     printing it in boldfaced text.

'border'
     A 'Boolean' that controls whether the label displays a border.  The
     default is 'true'.

'borderColor'
     A 'String' that contains the name of the border's color if the
     label displays a border.  The default is 'black'.

'borderWidth'
     An 'Integer' that defines the width of the border in pixels when
     the widget is not highlighted.  The default is '2'.

'grayed'
     A 'Boolean' that determines whether to draw the widget in a grayed,
     or inactive, state.  The state has no other effect for a
     'X11LabelPane' object.  It can indicate the state of other controls
     in the window.  The default is 'false'.

'grayedColor'
     A 'String' that contains the name of the color to draw the widget
     when it is grayed.  The default is is 'gray'.

'haveMultiLine'
     A 'Boolean' that indicates whether the widget's text is defined
     using the 'multiLine' method, and indicates that the widget should
     format the label's text to span multiple lines.

'highlightBackgroundColor'
     A 'String' that contains the color to draw a highlighted label's
     background.

'highlightBorderColor'
     A 'String' that contain's the name of a highlighed border's color.
     The default is 'black'.

'highlightBorderWidth'
     An 'Integer' that determines the width in pixels of the label's
     border when the widget is highlighed.  The default is two pixels.

'highlightTextColor'
     A 'String' that contains the name of the text color when the widget
     is drawn highlighted.  The default is 'black'.

'initialized'
     A 'Boolean' that indicates that the widget has initialized its
     instance variable states from the resource values.  Normally, a
     class does this in an 'attachTo' method, but this class uses the
     superclasses' attachTo methods, so the class uses this to perform
     the initialization on the first call to the 'draw' method.

'justify'
     An 'Integer' that determines whether to draw the label's text
     centered horizontally, or justified on the right or left margins.

     This variable recognizes three values, which are #defines in the
     'ctalk/ctalkdefs.h' include file.  The definitions are:


          LABEL_LEFT
          LABEL_CENTER
          LABEL_RIGHT


     To use these macros, add the statement


          #include <ctalk/ctalkdefs.h>


     near the top of the source module.

'leading'
     An 'Integer' that defines the space between lines of a multi-line
     label.  This variable only affects text drawn using scalable fonts
     of the Freetype library.  X11 bitmap fonts contain the leading in
     the character glyphs.

'lineHeight'
     An 'Integer' that contains the label's font height + the leading.

'margin'
     An 'Integer' that defines the distance in pixels between the border
     and the edges of the 'X11LabelPane' object.

'padding'
     An 'Integer' that defines the minimum distance in pixels between
     the inner edge of the border and the pane object's text.

'parHeight'
     For multi-line labels, an 'Integer' that contains the height of all
     of the lines of text.  For single-line labels, the 'lineHeight' and
     'parHeight' are the same.

'radius'
     An 'Integer' that describes the radius to round the corners of the
     border with.  If the value is '0' (the default), then draw borders
     with straight edges.

'textColor'
     A 'String' that defines the name of the text color when the widget
     is not highlighted.  The default is 'black'.

'textLine'
     A 'String' that contains the label's text if the text is to appear
     on a single line.  The default is an empty string.

'textLines'
     An 'Array' that contains a multi-line widget's text, as set using
     the 'multiLine' method.

Instance Methods
----------------

'draw (void)'
'drawButtonLayout (void)'
     Draws the text of the label, and updates the visible label on the
     display.  The instance variables in this class and the text font's
     class allow programs to adjust how the text is laid out.

     The 'drawButtonLayout' method is similar, but it uses a different
     algorithm that is more suited to laying out text on button labels.

     If the widget has saved a font specification to its 'ftFontVar'
     instance variable, then this method also selects the font before
     drawing the label.  If you want a label to have a different font
     than the rest of the window, this is how to declare and save a font
     specification.


          /* The label inherits the ftFont method from X11Pane class. */

          label ftFont "DejaVu Sans", FTFONT_ROMAN, FTFONT_MEDIUM, DEFAULT_DPI, 10.0;
          label ftFontVar saveSelectedFont;


     The 'X11FreeTypeFont' section describes the parameters that the
     'X11FreeTypeFont' class uses when selecting fonts.  *Note
     X11FreeTypeFont::.

'new'
     Creates a new 'X11LabelPane' object, initializes the object's
     instance variables and event handlers, and sets the pane's default
     foreground and background colors.

'selectFontOld (void)'
     This method was formerly named 'selectFont,' although it has been
     superceded by 'X11CanvasPane : selectFont'.

'subPaneExpose (Object SUBPANE, InputEvent EVENT)'
     The widget's Expose event handler.  When the widget receives an
     Expose event, this method redraws the widget.

'subPaneEnter (Object SUBPANE, InputEvent EVENT)'
'subPaneLeave (Object SUBPANE, InputEvent EVENT)'
     The widget's EnterNotify and LeaveNotify event handlers.  These
     methods set the 'subPane's' 'highlight' instance variable to true
     or false (if the widget is configured to accept input focus), then
     calls the 'draw' method to redraw the label.

'subPaneResize (Object SUBPANE, InputEvent EVENT)'
     Handles resize events received from the display server.

'font (String FONTDESC)'
     Sets the X11 font to use for the label's text.  When drawing using
     Freetype scalable fonts, the widget uses the 'ftFont' method from
     'X11CanvasPane'.

'text (String LABELTEXT)'
     Sets the text of a single-line label.

'text (String LABELTEXT)'
     Sets the receiver's 'textLine' instance variable for single-line
     labels.

'multiText (String LABELTEXT)'
     Divides the text given as the argument into lines where newline
     characters '\n' appear in the text, and sets the elements of the
     receiver's 'textLine' instance variable to one line for each array
     element.  Also sets the 'haveMultiLine' instance variable to
     'true'.


File: ctalk.info,  Node: X11ListPane,  Next: X11MessageBoxPane,  Prev: X11LabelPane,  Up: Classes

'X11ListlPane' Class
--------------------

The 'X11ListPane' class displays a scrolling list of items.  Clicking
the left pointer buttons selects an item, which is available to the
program for as long as the 'X11ListPane' object is available.

The list may be larger than the pane can display at one time, and the
list may be scrolled using the scrollbar on the left edge of the pane,
or the <up> and <down> arrow keys, or the <C-p> and <C-n> keys.

The X11ListPane class also supports scroll wheels on pointing devices
that are equipped with them.

Here is a program that displays a 'X11ListPane' object, and prints the
selected item on the terminal when the program exits.

Clicking on an item using the left mouse button (or the single button on
pointing devices that have only one button) selects that item.  Clicking
on the item again de-selects the item, or if a different item is
clicked, then that item is selected.

If the user presses the 'Shift' key while clicking on an item, it is
selected in addition to any items that have already been selected.

Pressing the 'Ctrl' key while clicking selects every item in a range
between the first selected item in the list and the last selected item.


     /* listpane.ca, a X11ListPane demonstration. -*-c-*- */

     #define N_ITEMS 30

     #include <ctalk/ctalkdefs.h>

     int main (int argv, char **argc) {
       X11Pane new xPane;
       X11PaneDispatcher new dispatcher;
       X11ListPane new listPane;
       X11LabelPane new label;
       X11ButtonPane new button;
       InputEvent new e;
       Integer new nEvents;
       Integer new verbose;
       Integer new i;
       X11Cursor new cursor;
       String new itemText, itemN;
       List new itemTextOut, itemNOut;

       xPane ftFontVar initFontLib;
       listPane selectFont;
       label selectFont;

       xPane resources atPut "backgroundColor", "blue";
       label resources replaceAt "backgroundColor", "blue";
       label resources replaceAt "foregroundColor", "blue";
       label resources replaceAt "highlightForegroundColor", "blue";
       label resources replaceAt "textColor", "white";
       label resources replaceAt "highlightTextColor", "white";
       label border = false;

       xPane inputStream eventMask = EXPOSE|ENTERWINDOWNOTIFY|LEAVEWINDOWNOTIFY| \
         KEYPRESS|KEYRELEASE|WINDELETE|BUTTONPRESS|BUTTONRELEASE|MOTIONNOTIFY| \
         SELECTIONCLEAR|SELECTIONREQUEST;
       xPane initialize 300, 400;
       dispatcher attachTo xPane;
       label attachTo dispatcher, "100x70+10+30%";
       button attachTo dispatcher, "60x45+50%+-75";
       listPane attachTo dispatcher, "-15x-90+100+24";

       for (i = 1; i < N_ITEMS; ++i) {
         listPane add "item " + i asString;
       }

       xPane map;
       xPane raiseWindow;

       xPane openEventStream;

       xPane setWMTitle "X11TextListPane Demo";
       label multiLine "Select\nan\nItem";
       button label text "Done";

       listPane draw;
       listPane refresh;

       while (TRUE) {
         xPane inputStream queueInput;
         if (xPane inputStream eventPending) {
           e become xPane inputStream inputQueue unshift;

           xPane subPaneNotify e;

           switch (e eventClass value)
             {
             case WINDELETE:
               xPane deleteAndClose;
               exit (0);
               break;
             default:
               if (button haveClick) {
                 button clearClick;
                 xPane deleteAndClose;
     	    if (listPane nItemsSelected > 1) {
     	      i = 0;
     	      listPane selectedItems itemTextOut;
     	      listPane selectedItemsN itemNOut;
     	      itemNOut map {
     		itemN = self;
     		/* This is a convenient way to retrieve
     		   the i'th item in the itemTextOut list. */
     		itemText = *(itemTextOut + i);
     		printf ("%d: %s\n", itemN, itemText);
     		++i;
     	      }
     	    } else {
     	      printf ("%d: %s\n",
     		      listPane selectedItemN,
     		      listPane selectedItemText);
     	    }
                 exit (0);
               }
             break;
             }
         }
       }
     }


Retrieving Selected Items
-------------------------

The method 'nItemsSelected' returns the number of list items that are
currently selected.  If only one item is selected, a program use the
'selectedItemN' and 'selectedItem' methods to retrieve the selected
item's position in the list, and its text.  This example shows how to
print the list's selection when only one item is selected.


     if (myListPane nItemsSelected == 1) {
        printf ("%d: %s.\n", myListPane selectedItemN,
          myListPane selectedItemText);
     }


If there are multiple items selected (i.e., 'nItemsSelected' returns an
'Integer' greater than 1), a program can retrieve and display all of the
results the 'selectedItems' and 'selectedItemsN' methods, and display
all of the results using an expression like this (although this example
doesn't print both sets of results at once).


     List new itemTextOut, itemNOut;

     ...

     if (myListPane nItemsSelected > 1) {
        myListPane selectedItems itemTextOut;
        myListPane selectedItemsN itemNOut;
        itemNOut map {
          printf ("%d\n", self)
        }
        itemTextOut map {
          printf ("%s\n", self)
        }
     }


Resources
---------

'borderColor'
     A 'String' that contains the named color of the pane's border.  The
     default is 'gray'.

'borderWidth'
     An 'Integer' that defines the width in pixels of the pane's border
     The default is '2' pixels.

'font'
     A 'String' that contains the Fontconfig descriptor of the font used
     to display the list items.  The default is 'sans serif-12'.

'keyScrollIncrement'
     The distance in pixels the list should scroll up or down when the
     user scrolls the list.  The default is 4 pixels.

'leftMargin'
     An 'Integer' that defines the width in pixels of between the left
     edge of pane's list area and the left margin of the item text.  The
     default is 4 pixels.

'scrollBorderColor'
     A 'String' that contains the color for the edges of the scroll
     channel.  The default is 'darkgray'.

'scrollBorderWidth'
     An 'Integer' that contains the width in pixels of the scroll
     channel's border.  The default is 1 pixel.

'selectColor'
     A 'String' that contains the background color of selected items.
     The default is 'lightblue'.

'selectStyle'
     An 'Integer' that defines whether a select bar extends to the right
     edge of an item's text, or to the right margin of the pane.  The
     class recognizes the #defines 'LIST_SELECT_PANE' and
     'LIST_SELECT_ITEM', which are defined in 'ctalkdefs.h'.  The
     default is 'LIST_SELECT_PANE', so to change it to only highlight an
     item's text, a program should contain the line,


          myListPane resources replaceAt "selectStyle", LIST_SELECT_ITEM;


'textColor'
     A 'String' that contains the color of the list text.  The default
     is 'black'.

'thumbColor'
     A 'String' that defines the color of the scroll bar's thumb.  The
     default is 'darkgray'.

'thumbMargin'
     An 'Integer' that defines the distance in pixels between the thumb
     and its channel.  The default is 2 pixels.

'vAlignHint'
     An 'Integer' that helps display items vertically centered in their
     layout boxes.  While X11ListPane objects generally can approximate
     how font renderers align text within their layout boxes, fonts and
     even different library versions may vary this.  Increasing this
     number shifts the item's text downward within the box when it is
     displayed.  Smaller numbers (including negative numbers) shift the
     text upward.  The default is 2px.

Instance Variables
------------------

'borderPen'
     A 'Pen' object that contains the color and width of the border.
     Its values are defined by the 'borderColor' and 'borderWidth'
     resources.

'buttonState'
     An 'Integer' that records whether any of the pointer buttons are
     pressed.  The possible values may be any combination of the
     following definitions, or none ('0').


          BUTTON1MASK     (1 << 0)
          BUTTON2MASK     (1 << 1)
          BUTTON3MASK     (1 << 2)


'items'
     A 'List' that contains the pane's list items.  Each item uses an
     'ItemBox' object to store its information.  The definition of the
     'ItemBox' class (which is also defined in the 'X11ListPane' class
     library) is:


          String class ItemBox;

          ItemBox instanceVariable org Point 0;
          ItemBox instanceVariable ext Point 0;
          ItemBox instanceVariable size Point 0;


'scrollBorderPen'
     A 'Pen' object that contains the width and the color of the scroll
     channel's borders.  Its values are set by the 'scrollBorderColor'
     and 'scrollBorderWidth' resources.

'selectionPen'
     A 'Pen' object that defines the color used to fill list selections.
     Its value is set by the 'selectColor' resources.  The pen's width
     is not used.

'scrollWidth'
     An 'Integer' that defines the width in pixels of the scroll bar.
     It is initialized from the value of the 'scrollWidth' resource when
     the 'X11ListPane' object is attached to its parent window by the
     'attachTo' method.  The default is 10 pixels.

'scrollWidth'
     An 'Integer' that records whether a <Shift> or <Ctrl> key is
     currently being pressed.  The state is used when selecting multiple
     items, and may be either or both of the following, or none.


          shiftStateShift     (1 << 0)
          shiftStateCtrl      (1 << 1)


'thumbExt'
'thumbOrg'
     These are 'Integers' that define the position and height of the
     scroll thumb in pixels.  The value of 'thumbExt' is calculated from
     the percentage of the list contents that are visible in the window
     at any one time.  The value of 'thumbOrg' records the vertical
     position of the thumb where the user moved it using the pointer.

'viewStartY'
     An 'Integer' that contains the distance from the top edge of the
     first list item (which is stored in the item's 'org' instance
     variable) to the top of the portion of the list that is visible in
     the pane's window.

'visiblePercent'
     A 'Float' that contains the fraction of the list that the window
     can display at any one time.

Instance Methods
----------------

'add (String ITEMTEXT)'
     Addes a list item using ITEMTEXT as its contents.  New items are
     added sequentially to the end of the item list.  The method also
     calculates the item's width and height in pixels, and the position
     of the top and bottom edges relative to the top edge of the
     zero'eth item in the list.  Each item is stored in the pane's
     'items' list using an 'ItemBox' object, which stores each item's
     dimensions as well as the item's contents.  The 'ItemBox' class is
     defined in the 'X11ListPane' class library.

'attachTo (Object PARENTPANE, String GEOMSPECT)'
     Attaches the 'X11ListPane' object to PARENTPANE, with the
     dimensions given by GEOMSPECT.  Also initializes the object's
     drawing surfaces and the actual window within the parent window.

     The GEOMSPEC argument defines the width, height and position of the
     pane within the parent window.  For a description of its contents,
     refer to the 'X11PaneDispatcher' class *Note X11PaneDispatcher::.

'calcThumb (void)'
     Calculates the height of the scroll thumb as a proportion of the
     percentage of the list contents that can be displayed on the pane
     at any one time, and stores the value in the pane's 'thumbExt'
     instance variable (which is itself a 'Point' object, so a program
     would retrieve the thumb's height like this).


          thumbHeight = myListPane thumbExt y;


'draw (void)'
     This method draws the the pane's scroll frame and borders, and
     calls the 'drawItemList' and 'drawThumb' methods to display the
     list contents.

'drawItemList (void)'
     This method is called by the 'draw' method to display the visible
     items on the pane's window.

'drawThumb (void)'
     Another method that is called by the 'draw' method, this method
     draws the scroll thumb within the scroll bar.

'moveThumb (Integer N)'
     Move the scroll thumb by N pixels upward (if N is negative) or
     downward (if N is positive).

'new (String PANENAME)'
     The 'X11ListPane' constructor.  This method creates a 'X11ListPane'
     object with the name given by PANENAME, and initializes the
     object's resources and event handlers.

'nItemsSelected (void)'
     Returns an 'Integer' with the number of items that are currently
     selected.

'onClick (Object SUBPANE, InputEvent EVENT)'
'onEnter (Object SUBPANE, InputEvent EVENT)'
'onExpose (Object SUBPANE, InputEvent EVENT)'
'onKey (Object SUBPANE, InputEvent EVENT)'
'onLeave (Object SUBPANE, InputEvent EVENT)'
'onMotion (Object SUBPANE, InputEvent EVENT)'
'onResize (Object SUBPANE, InputEvent EVENT)'
     These are the 'X11ListPane' object's event handlers, which receive
     events from the display server.  They are initialized by the 'new'
     method.

'selectedItemN (void)'
     This method returns an 'Integer' with the index of the selected
     item.

     The indexes are numbered from zero, which is the index of the first
     item.

     If no item is selected, this method returns '-1'.

'selectedItems (List ITEMSOUT)'
     Pushes a 'String' object with the text of each currently selected
     item onto the ITEMSOUT list.

'selectedItemsN (List ITEMSOUT)'
     Pushes an 'Integer' with the numerical position of each selected
     item onto ITEMSOUT.  The indexes start with 0 reprsenting the first
     item, 1 representing the second item, and so on.

'selectedItemText (void)'
     Returns a 'String' with the text of the selected item.  If no item
     is selected, the method returns and empty 'String'.

'selectFont (void)'
     Selects the font to display the list items, and saves the font
     parameters in the object's 'ftFontVar' instance variable, which is
     inherited from 'X11Pane' class.


File: ctalk.info,  Node: X11MessageBoxPane,  Next: X11PopupMenu,  Prev: X11ListPane,  Up: Classes

'X11MessageBoxPane' Class
-------------------------

A 'X11MessageBoxPane' object displays a popup window that contains a
text message and a button that closes the window.

The button's text is displayed by a 'X11LabelPane' object, and the
button is a 'X11ButtonObject'.  Generally, 'X11MessageBoxPane' objects
override any input to the program that opened them, so they contain
their own event loop, in the 'show' method.

Here is an example of a program that creates its own 'X11MessageBoxPane'
object, and then opens it when the user clicks on the main window's
button.


     /* messagebox.ca - X11MessageBox Demonstration -*-c-*- */

     #include <ctalk/ctalkdefs.h>

     /* See the X11FreeTypeFont section of the the Ctalk reference. */
     #define FTFONT_BOLD   200
     #define FTFONT_MEDIUM 100

     int main (void) {
       X11Pane new mainWindow;
       X11PaneDispatcher new dispatcher;
       X11ButtonPane new button;
       X11LabelPane new label;
       X11MessageBoxPane new messageBox;
       InputEvent new e;

       label textColor = "white";
       label canFocus = false;
       label borderWidth = 0;

       label ftFontVar initFontLib;
       label ftFontVar notifyLevel XFT_NOTIFY_NONE;

       mainWindow backgroundColor = "blue";
       label resources replaceAt "backgroundColor", "blue";
       button resources replaceAt "backgroundColor", "blue";
       messageBox resources replaceAt "backgroundColor", "blue";

       mainWindow initialize 255, 200;
       mainWindow inputStream eventMask =
         EXPOSE|ENTERWINDOWNOTIFY|LEAVEWINDOWNOTIFY|BUTTONPRESS|BUTTONRELEASE|KEYPRESS|KEYRELEASE|WINDELETE|MOVENOTIFY;

       dispatcher attachTo mainWindow;
       button attachTo dispatcher, "125x75+c+100";
       label attachTo dispatcher, "177x80+34+15";
       messageBox attachTo dispatcher, "300x200";

       mainWindow map;
       mainWindow raiseWindow;

       mainWindow openEventStream;

       mainWindow setWMTitle "X11MessageBoxPane Demo";


       label multiLine "X11MessageBoxPane\nDemo";
       label resources replaceAt "textColor", "lightgray";
       label resources replaceAt "foregroundColor", "blue";
       label resources replaceAt "borderColor", "blue";

       button label multiLine "Open\nMessageBox";

       button label resources replaceAt "highlightForegroundColor", "gray80";

       /* Icon IDs, like ICON_INFO, are defined in ctalkdefs.h. */
       messageBox resources replaceAt "iconID", ICON_INFO;

       /* The program uses the "replaceAt" method because the key/value
          entry for "backgroundColor" the X11MessageBoxPane : new method
          has alread created an entry for backgroundColor. */
       messageBox resources replaceAt "backgroundColor", "blue";
       messageBox resources replaceAt "foregroundColor", "blue";
       messageBox resources replaceAt "messageText",
         	       "Hello, messageBox!\nYour message text here.";

       while (TRUE) {
         mainWindow inputStream queueInput;
         if (mainWindow inputStream eventPending) {
           e become mainWindow inputStream inputQueue unshift;

           mainWindow subPaneNotify e;

           switch (e eventClass value)
     	{
     	case EXPOSE:
     	  button subPaneExpose (button, e);
     	  label subPaneExpose (label, e);
     	  break;
     	case BUTTONRELEASE:
     	  messageBox showManaged button;
     	  break;
     	case WINDELETE:
      	  mainWindow deleteAndClose;
     	  exit (0);
     	  break;
     	}
         } else {
           usleep (1000);
         }
       }

     }


Resources
---------

'background'
     The window's background color, and the background color of the
     message label and the close button.  The value is a 'String' that
     contains a X11 named color.  The default is 'gray'.  For a list of
     X11 color names, see 'showrgb(1)'.

'buttonText'
     A 'String' that contains the text that appears in the button.  The
     default is 'Ok'.

'foregroundColor'
     A 'String' with the name of the color that the messagebox window is
     filled with.  The default is 'gray'.

'geometry'
     A 'String' that contains the message window's size, and,
     optionally, its position.  The value is set to the dimensions that
     are given as arguments to the 'attachTo' method.

'iconID'
     An 'Integer' that contains the identifier to the icon to be
     displayed.  Ctalk defines the following constants for icons in
     'ctalkdefs.h' and in the graphics libraries.


          ICON_NONE
          ICON_CAUTION
          ICON_INFO
          ICON_QUESTION
          ICON_STOP


     The default is 'ICON_NONE', which causes no icon to be displayed.
     Any other constant causes an icon to be displayed to the left of
     the message text.  The widget adjusts the size and position of the
     text automatically to provide space for the icon.

'messageColor'
     A 'String' that contains the color of the message text.  The
     default is 'black'.  The message box sets the label's 'textColor'
     resource to this value.

'messageFont'
     A 'String' that contains the Fontconfig font descriptor.  The
     default is 'sans serif-12'.  The pane uses this value to set the
     label's 'fcFont' resource.

'messageText'
     A 'String' that contains the text of the message to be displayed.
     The default is 'Sample message text.'.

'pad'
     An 'Integer' that contains the space in pixels betwween the button
     and label widgets, and between each widget and the edge of the
     window.  The default is 10 pixels.

'titleText'
     A 'String' that contains the message window's title text.  The
     default is 'Message'.

Instance Variables
------------------

'button'
     A 'X11ButtonPane' object that closes the window when clicked.  The
     button's default text is, 'Ok'.  Programs can change the text with
     a statement like the following, which changes the button's text to,
     'Close'.


          myMessageBox resources atPut "buttonText", "Close";


'initialized'
     A 'Boolean' that is 'true' if the pane has already been
     initialized.  When a message box is closed, it is not deleted - it
     is simply unmapped from the display.  This variable is set to true
     so that the message box is initialized only once.

'label'
     A 'X11LabelPane' that displays the message box's text.  As
     configured, the label is the same color as the main message box
     window, and uses no borders.  The label's text is controlled by the
     resource, 'messageText'.  To set the message text, use a statement
     like the following.


          myMessageBox resources atPut "messageText", "Today Is\nJanuary 3rd";


     The class draws the label using multiline formatting, so if you
     want the text to appear on multiple lines, include the sequence
     '\n' in the text (that's a backslash and the character, 'n', not a
     literal newline).

'keyState'
     An 'Integer' which records whether the <Tab> or <Enter> keyboard
     shortcuts have been pressed.  Pressing <Tab> highlights the pane's
     button, and pressing <Enter> withdraws the pane's window from the
     display, and the 'show' method returns to the program that opened
     the message box.

'mainWindowPtr'
     A 'Symbol' that contains a pointer to the main window.

Instance Methods
----------------

'attachTo (Object PARENTPANE, String GEOMETRY)'
     Sets the message box's dimensions and creates the object's buffers
     and main window.  Unlike other 'X11Pane' subclasses, this method
     does not immediately attach the message box's object to its parent
     pane, so the message box isn't displayed until the program invokes
     the 'show' or 'showManaged' method.

'draw (void)'
     Draws the label and button subpanes in the message box's buffers
     and the buffers of the button and label subpanes.  After calling
     this method, the 'refresh' method makes the changes visible.

'fill (String COLORNAME)'
     A convenience method that fills the pane window with the color
     given as the argument.

'initWidgets (void)'
     Initializes the message box's button and label subpanes when the
     pane's window is first opened.  When constructed this method sets
     the 'initialized' instance variable to 'true', so when the message
     box appears again, this method is a no-op.

'new (String NEWPANENAME)'
     The X11MessageBoxPane constructor.

'refresh (void)'
     After the method DRAW renders the main window and the label and the
     button subwindow's contents on the pane objects' buffers, this
     method updates the visible window with the contents of the buffers.

'show (void)'
     This method displays the message box, waits for events from the
     display system, and closes the message box when its button is
     clicked, then returns to the calling program.

'show (X11ButtonPane BUTTONPANE)'
     This method is similar to the 'show' method, but it takes as its
     argument the pane object from the main window that caused the
     message window to open.

     This method sets the main window's button to be unclicked and then
     redrawn.

     This method manages 'X11ButtonPane' objects specifically, but it
     can be subclassed to manage any pane class object.

'subPaneButton (Object SUBPANE, InputEvent EVENT)'
     This is the event handler for button press and button release
     events from the display hardware.  When a button is clicked on, the
     message box draws the button in its clicked state.  When the button
     is released, the pane draws the button unclicked, then unmaps the
     message box window from the display, and returns to the main
     program.

'subPaneExpose (Object SUBPANE, InputEvent EVENT)'
     Handles drawing the message box when the program receives an Expose
     event from the display.  This method calls the message box's 'draw'
     and 'refresh' methods.

'withdraw (void)'
     Unmaps the message box's window from the display after the pane
     object receives a button release event while processing the 'show'
     method.  When the 'show' or 'showManaged' method receives the
     button release event, this method is called to remove the pane's
     window from the display, and the 'show' or 'showManaged' method
     returns to the main program.


File: ctalk.info,  Node: X11PopupMenu,  Next: X11ScrollBarPane,  Prev: X11MessageBoxPane,  Up: Classes

'X11PopupMenu' Class
--------------------

A 'X11PopupMenu' object displays a basic menu at the point where the
user has pressed a mouse button in a program window.

At this time the class is still very basic - it doesn't support menu
decorations like titles or separators, nor does it support submenus.

This example program demonstrates how a program might use a basic
'X11PopupMenu' object.  It also contains examples of simple helper
methods that are called when a user clicks on a menu item.


     /* popupmenu.ca - X11PopupMenu Demonstration -*-c-*- */

     #include <ctalk/ctalkdefs.h>

     /* See the X11FreeTypeFont section of the the Ctalk reference. */
     #define FTFONT_BOLD   200
     #define FTFONT_MEDIUM 100

     /*
      *  Objects that are targets of menu items
      *  need to be within the scope of the popup's
      *  methods.  The simplest way to do this is to
      *  make them global.
      */
     X11MessageBoxPane new aboutBox;
     X11MessageBoxPane new msgBox;
     X11YesNoBoxPane new yesNoBox;
     X11TextEntryBox new textEntryBox;
     X11FileSelectDialog new fileBox;

     X11MessageBoxPane instanceMethod aboutBoxConf (void) {
       self resources replaceAt "backgroundColor", "darkblue";
       self resources replaceAt "foregroundColor", "darkblue";
       self resources replaceAt "messageColor", "white";
       self resources replaceAt "messageText",
         "X11PopupMenu Demo\nCtalk Version: 0.67";
       self resources replaceAt "iconID", ICON_INFO;

     }

     X11FileSelectDialog instanceMethod fileSelectConf (void) {
       self resources replaceAt "backgroundColor", "blue";
       self resources replaceAt "foregroundColor", "blue";
       self resources replaceAt "messageColor", "white";
       self resources replaceAt "messageText",
         "Directory:\n";
     }

     /*
        This is initialized internally when we create the app's
        window.
     */
     extern Atom wm_delete_window;

     X11PopupMenu instanceMethod clientExit (X11Pane parentPane) {
       "This is a typical handler to exit an app from a menu entry.
       It simulates a user selecting a close window option on the
       window's title bar. It still needs an independent connection to
       the display server, however."
       XEvent e;
       Display *d_l;
       if ((d_l = XOpenDisplay (getenv ("DISPLAY"))) != NULL) {
         e.type = ClientMessage;
         e.xclient.serial = 0l;
         e.xclient.send_event = true;
         e.xclient.display = d_l;
         e.xclient.window = parentPane xWindowID;
         e.xclient.format = 32;
         e.xclient.data.l[0] = wm_delete_window;
         XSendEvent (d_l, parentPane xWindowID, true, 0l, &e);
         XFlush (d_l);
         XCloseDisplay (d_l);
       }
     }

     int main (void) {
       X11Pane new mainWin;
       X11PaneDispatcher new dispatcher;
       X11LabelPane new heading, subHeading;
       X11PopupMenu new mainMenu, dialogMenu;
       InputEvent new e;
       XEvent ev_ret;
       Display *display;

       /*
        *  To Add a Submenu -
        *  1. In the entry that pops up the submenu, which is
        *     "Dialog Boxes>" here, add a '>' to the end of the
        *     label, which marks the entry as a submenu launcher.
        *     The '>" is displayed in the menu's right margin
        *     where the item appears.
        *  2. The submenu launcher's expression needs to be the
        *     name that you want the submenu referred to as -
        *     here, that's "dialogMenu."
        *  3. Add the submenu to the parents menu's "subMenus"
        *     AssociativeArray, again using the name that you
        *     want to identify the submenu by - again, that's
        *     "dialogMenu" in this example.
        *
        */
       dialogMenu add "X11FileSelectDialog...", "fileBox show";
       dialogMenu add "X11MessageBoxPane...", "msgBox show";
       dialogMenu add "X11TextEntryBox...", "textEntryBox show";
       dialogMenu add "X11YesNoBoxPane...", "yesNoBox show";

       mainMenu add "Dialog Widget Classes>", "dialogMenu";
       mainMenu add "About...", "aboutBox show";
       mainMenu add "Exit", "self clientExit parentPane";
       mainMenu subMenus atPut "dialogMenu", dialogMenu;

       heading canFocus = false;
       heading resources replaceAt "borderWidth", 0;
       subHeading canFocus = false;
       subHeading resources replaceAt "borderWidth", 0;

       heading ftFontVar notifyLevel XFT_NOTIFY_NONE;

       heading ftFontVar initFontLib;

       aboutBox aboutBoxConf;
       fileBox fileSelectConf;

       mainWin backgroundColor = "blue";
       heading resources replaceAt "backgroundColor", "blue";
       subHeading resources replaceAt "backgroundColor", "blue";

       mainWin initialize 255, 200;
       /*
        * Select which X events we want to handle.
        */
       mainWin inputStream eventMask =
         EXPOSE|ENTERWINDOWNOTIFY \
         |LEAVEWINDOWNOTIFY|BUTTONPRESS \
         |BUTTONRELEASE|KEYPRESS|KEYRELEASE \
         |MOVENOTIFY|WINDELETE \
         |WMFOCUSCHANGENOTIFY;

       dispatcher attachTo mainWin;
       heading attachTo dispatcher, "177x60+c+25";
       subHeading attachTo dispatcher, "190x60+c+75";

       /* The dialogs, which are launched by the menu, still need
          to be attached to the menu's parent window, even if it's
          only to set their dimensions similar to the main window's
          dimensions. */
       aboutBox attachTo dispatcher, "300x200";
       fileBox attachTo dispatcher, "250x350";
       msgBox attachTo dispatcher, "250x350";
       textEntryBox attachTo dispatcher, "350x250";
       yesNoBox attachTo dispatcher, "250x350";

       mainWin map;
       mainWin raiseWindow;

       mainWin openEventStream;

       mainWin setWMTitle "X11PopupMenu Demo";

       heading multiLine "X11PopupMenu\nDemo";
       heading resources replaceAt "textColor", "lightgray";
       heading resources replaceAt "foregroundColor", "blue";

       subHeading resources replaceAt "ftFont", "DejaVu Sans-8";
       subHeading resources replaceAt foregroundColor, "blue";
       subHeading resources replaceAt textColor, "lightgray";
       subHeading multiLine "Click anywhere\nto display the menu.";

       while (TRUE) {
         mainWin inputStream queueInput;
         if (mainWin inputStream eventPending) {
           e become mainWin inputStream inputQueue unshift;

           mainWin subPaneNotify e;

           switch (e eventClass value)
     	{
     	case EXPOSE:
     	  heading subPaneExpose (heading, e);
     	  subHeading subPaneExpose (subHeading, e);
     	  break;
     	case BUTTONPRESS:
     	  mainMenu popup mainWin, e xEventData5, e xEventData6;
     	  display = mainMenu displayPtr;
     	  while (XCheckTypedEvent (display, ButtonPress, &ev_ret))
     	    ;
     	  break;
     	case WINDELETE:
      	  mainWin deleteAndClose;
     	  exit (0);
     	  break;
     	}
         } else {
           usleep (1000);
         }
       }

     }


Constructing Menus
------------------

The structure of method items is simple: each item contains the text of
the label that is visible to the user, and also the text of the Ctalk
expression that the class will execute when the user selects the item.
The 'add' method, which is used to add the items, also calculates the
entry's geometry within the menu.

Here is the part of the demo program above that adds items to the menu.


     mainMenu add "Browse Files...", "fileBox show";
     mainMenu add "About...", "aboutBox show";
     mainMenu add "Exit", "self clientExit parentPane";


In addition, the X11PopupMenu class provides these parameters that can
be used in the expressions that the menu class calls.


     parentPane     # The main window object that the menu is popped
                    # up over.
     itemName       # A String object that contains the item's visible
                    # text.
     exprText       # A String that contains the text of the menu item's
                    # expression.
     itemIndex      # An Integer that contains the ordinal position of
                    # the menu item; the topmost item's index is 0, and
                    # the index of the bottom item is <number_of_items> - 1.


The labels are actually parameters of the 'X11PopupMenu : execItem'
method, and expressions can use them verbatim.  There's more information
in the 'execItem' method's documentation.

Submenus
--------

A menu needs only to refer to its submenus by the name of the submenu.
Adding a '>' to the end of the menu item's label designates the item as
a submenu launcher, and the '>' character is drawn in the menu's right
margin.

The submenu is referred to by a key which is written to the parent
menu's 'subMenus' 'AssociativeArray' object.  The key is a string and
may be any convenient name.

The example program shows the expressions used to create a submenu, its
launcher, and how to store it in a parent menu's 'subMenu's' associative
array.

Resources
---------

'backgroundColor'
     The name of the color used as the menu's background.

'bottomMargin'
     The vertical distance between the bottom menu item's text and the
     bottom of the menu.

'cursorHPad'
     The number of pixels between the start of a menu item's text and
     the left edge of the menu's selection bar.

'font'
     The Fontconfig descriptor of the font used to display the menu's
     text.

'gadgetRMargin'
     The distance in pixels between a gadget to the right of a menu
     entry's text, and the right edge of the menu.

'gadgetSpace'
     The distance between the right edge of the longest menu item's
     text, and a gadget on the right of the menu.

'hlColor'
     The name of the background color used to highlight menu entries.

'hlTextColor'
     The text color of highlighted items.

'hMargins'
     The distance in pixels between the edge of the menu and the left
     edge of the text, and between the right edge of the longest menu
     item's text and the right edge of the menu.

'itemSpace'
     The vertical distance in pixels between menu items.

'textColor'
     The name of the color used to display non-highlighted text.

'topMargin'
     The distance in pixels between the top of the menu and the first
     menu item.

Instance Variables
------------------

'bgPixel'
'hlPixel'
'hlTextPixel'
     The X pixel values of the menu's background color, and highlighted
     background and text colors.

'gadgetSpace'
     The distance between the right edge of the longest menu entry's
     text and any decorations on the right side of the menu.

'itemHeight'
'textHeight'
     The height in pixels of a menu item's text, and the total height of
     each item.

'items'
     A 'AssociativeArray' that maintains the list of menu entries.

Instance Methods
----------------

'add (String MENUTEXT, String EXPRESSION)'
     Add an item to the receiver menu.  The MENUTEXT argument contains
     the text that will appear in the menu entry, and the EXPRESSION
     argument is the Ctalk expression that the program executes when the
     user selects the item.

'draw (void)'
     Draw the menu items, the highlight bar, and any decorations on the
     side of the menu.

'execItem (X11Pane PARENTPANE, String ITEMNAME, String EXPRTEXT, Integer ITEMINDEX)'
     Executes the selected menu item's expression.  The method makes
     avaiable parameters that contain information about the item.  The
     parameters, which expressions can use verbatim, are listed here.


          parentPane     # The main window object that the menu is popped
                         # up over.
          itemName       # A String object that contains the item's visible
                         # text.
          exprText       # A String that contains the text of the menu item's
                         # expression.
          itemIndex      # An Integer that contains the ordinal position of
                         # the menu item; the topmost item's index is 0, and
                         # the index of the bottom item is <number_of_items> - 1.


'new (String OBJECTNAME)'
     The 'X11PopupMenu' constructor.  Creates a 'X11PopupMenu' object
     and its instance variables, and initializes the object's resources
     and event handlers.

'subMenuGadget (Integer BASELINE Boolean HILIGHT)'
     Draws submenu indicator to the right of a menu entry.

'popup (X11Pane PARENTPANE, Integer DISPLAYX, Integer DISPLAYY)'
     Display the menu at the pointer's position, relative to the
     upper-right corner of the display.

     This method also withdraws the menu when the user selects an item,
     and whenever the pointer moves outside of the menu or the window
     defined in PARENTPANE.


File: ctalk.info,  Node: X11ScrollBarPane,  Next: X11TextEntryPane,  Prev: X11PopupMenu,  Up: Classes

'X11ScrollBarPane' Class
------------------------

A 'X11ScrollBarPane' object draws a basic scroll bar and allows the user
to move the scroll thumb by clicking and dragging.

Applications can set and read the scroll thumb's size and position via
the object's instance variables.  In particular, the 'thumbHeight'
instance variable sets the vertical size of the scroll thumb, and the
'thumbDimensions' method sets the coordinates and height of the thumb
when sliding it to a new position.

The scroll bar's 'frame' and 'thumb' instance variables are both
'Rectangle' objects.  Applications can use the 'Rectangle' class's
methods, like 'dimension,' to set the scroll position, and can read the
position using the 'Rectangle' object's instance variables.  *Note
Rectangle::.

Here is an example program that demonstrates the basic steps needed to
draw a scroll bar.


     int main (int argv, char **argc) {
       Integer new xWindowSize;
       Integer new yWindowSize;
       X11Pane new xPane;
       X11PaneDispatcher new xTopLevelPane;
       X11ScrollBarPane new xScrollBarPane;
       X11CanvasPane new xCanvasPane;
       InputEvent new e;
       Exception new ex;
       Application new scrollDemo;
       String new pctstr;
       Integer new strWidth;

       scrollDemo enableExceptionTrace;
       scrollDemo installExitHandlerBasic;
       scrollDemo installAbortHandlerBasic;

       xWindowSize = 400;
       yWindowSize = 400;

       xPane ftFontVar initFontLib;
       xPane ftFont "DejaVu Sans", 0, 0, 0, 48.0;

       xPane initialize xWindowSize, yWindowSize;
       xPane inputStream eventMask = WINDELETE|EXPOSE|BUTTONPRESS|BUTTONRELEASE|MOTIONNOTIFY;
       xTopLevelPane attachTo xPane;
       xScrollBarPane attachTo xTopLevelPane, "20x100%+0+0";
       xCanvasPane attachTo xTopLevelPane, "380x100%+20+0";

       xPane map;
       xPane raiseWindow;

       xPane openEventStream;

       xScrollBarPane background "lightblue";
       xScrollBarPane refresh;

       xCanvasPane background "navy";
       xCanvasPane foreground "navy";
       xPane ftFontVar namedX11Color "white";
       xCanvasPane clear;
       pctstr printOn "%0.2f%%", xScrollBarPane percent * 100.0;
       strWidth = xPane ftFontVar textWidth pctstr;
       xCanvasPane putStrXY (380 / 2) - (strWidth / 2), (400 / 2), pctstr;
       xCanvasPane refresh;

       while (TRUE) {

         xPane inputStream queueInput;
         if (xPane inputStream eventPending) {
           e become xPane inputStream inputQueue unshift;

           if (ex pending)
       	ex handle;

           xPane subPaneNotify e;

           switch (e eventClass value)
      	{
     	case EXPOSE:
     	  xCanvasPane paneBuffer clear;
     	  pctstr printOn "%0.2f%%", xScrollBarPane percent * 100;
     	  strWidth = xPane ftFontVar textWidth pctstr;
     	  xCanvasPane putStrXY (380 / 2) - (strWidth / 2), (400 / 2), pctstr;
     	  xCanvasPane refresh;
     	  break;
      	case WINDELETE:
       	  xPane deleteAndClose;
      	  exit (0);
      	  break;
       	default:
     	  xCanvasPane paneBuffer clear;
     	  pctstr printOn "%0.2f%%", xScrollBarPane percent * 100;
     	  strWidth = xPane ftFontVar textWidth pctstr;
     	  xCanvasPane putStrXY (380 / 2) - (strWidth / 2), (400 / 2), pctstr;
     	  xCanvasPane refresh;
       	  break;
      	}
         }
       }
     }


Instance Variables
..................

'arrowCursor'
     A 'X11Cursor' object that contains the resource ID of the widget's
     arrow cursor.  *Note X11Cursor::.

'bevel'
     A 'Boolean' that determines whether the scroll thumb is drawn as a
     beveled widget.

'dragging'
     A 'Boolean' object that is True while the right mouse button is
     clicked while over the scroll thumb.  *Note Boolean::.

'frame'
     A 'Rectangle' object that contains coordinates of the scroll bar
     frame.  *Note Rectangle::.

'frameWidthVar'
     An 'Integer' that contains the width of the scrollbar's visible
     frame in pixels.

'framePen'
     A 'Pen' object that sets the line color and width of the scroll bar
     frame.  *Note Pen::.

'grabCursor'
     A 'X11Cursor' object that contains the resource ID of the widget's
     grab cursor.  *Note X11Cursor::.

'lastY'
     An 'Integer' object that contains the previous PointerMotion
     event's y coordinate while dragging.  *Note Integer::.

'margin'
     An 'Integer' that defines the distance in pixels between the pane's
     edge and the outer edge of the scrollbar frame.

'mouseOver'
     A 'Boolean' that is true if the pointer is over the scrollbar
     frame, false otherwise.

'padding'
     An 'Integer' that defines the distance in pixels between the inner
     edge of the scrollbar frame and the thumb.

'thumb'
     A 'Rectangle' object that contains coordinates of the scroll thumb.
     *Note Rectangle::.

'thumbBackgrondColor'
     A 'String' that contains the name of the X11 color used to draw the
     thumb.

'thumbErasePen'
     A 'Pen' object that sets the color and line width of the scroll
     thumb background when animating the thumb.  *Note Pen::.

'thumbHeight'
     An 'Integer' that sets the height of the scroll thumb.  *Note
     Integer::.

'thumbPen'
     A 'Pen' object that sets the color and line width of the scroll
     thumb.  *Note Pen::.

'thumbPix'
     A 'X11Bitmap' that contains the thumb's beveled image, if the pane
     is drawn with 'bevel' set to 'true'.

Instance Methods
................

'attachTo (Object PARENTPANE)'
     Attaches the 'X11ScrollBarPane' object to its parent pane, which is
     usually a 'X11PaneDispatcher' object.  Also sizes the pane and its
     buffers to fit within the visible window, and sets the dimensions
     of the scrollbar's visible frame and thumb.

'background (String COLORNAME)'
     Sets the pane's background color to COLORNAME, and also sets the
     color to use when performing scrollbar animations.

'drawThumb (void)'
'eraseThumb (void)'
     These methods animate the thumb so that it tracks the pointer's
     position within the scrollbar.

'frameWidth (Integer LINEWIDTH)'
     Calculates the scrollbar frame's dimensions within the pane's
     margins for the line width in pixels given as the argument.

'new (String PANENAME)'
     Creates a new 'X11ScrollBarPane' object, initializes the pane's
     event handlers, and sets the default colors of the pane's elements.

'percent (void)'
     Returns a 'Float' with the position of the thumb's top edge in the
     usable trough of the scrollbar, as a percentage between 0.0 and
     1.0.

     The usable area of the trough is defined as the distance that the
     top edge of the scrollbar thumb can travel within the scrollbar's
     margins; i.e,


          usableTrough = aScrollBar size y -
                            ((aScrollBar margin * 2) +
                             (aScrollBar frameWidthVar * 2) +
                             (aScrollBar padding * 2) +
                             (aScrollBar thumbHeight));


'pointIsInThumb (Integer X, Integer, Y)'
     This method returns a 'Boolean' value of true if the point X,Y is
     within the scroll bar thumb.

'subPaneDestroy (Object SUBPANE, InputEvent EVENT'
'subPaneExpose (Object SUBPANE, InputEvent EVENT'
'subPanePointerInput (Object SUBPANE, InputEvent EVENT'
'subPanePointerMotion (Object SUBPANE, InputEvent EVENT'
'subPaneEnterNotify (Object SUBPANE, InputEvent EVENT'
'subPaneLeaveNotify (Object SUBPANE, InputEvent EVENT'
     The 'X11ScrollBarPane' object's event handlers for DESTROY, EXPOSE,
     BUTTONPRESS/BUTTONRELEASE, MOTIONNOTIFY, ENTERWINDOWNOTIFY, and
     LEAVEWINDOWNOTIFY X Window System events.

'thumbDimensions (Integer Y, Integer HEIGHT)'
     Calculates the position and size thumb's rectangle within the pane
     using the vertical Y position and the thumb's HEIGHT.

'thumbPercent (Float PCT)'
     Calculates the thumb's height as a percent of the trough's vertical
     distance.  The argument, PCT, is a 'Float' between 0.0 and 1.0.

     Note that, in order to make these calculations and update the thumb
     height in the pane's viewing area, the scrollbar must already be
     attached to its parent pane, and the program needs to be receiving
     X events.  So this method should only be used after a call to, for
     example, X11Pane : openEventStream.


File: ctalk.info,  Node: X11TextEntryPane,  Next: X11YesNoBoxPane,  Prev: X11ScrollBarPane,  Up: Classes

'X11TextEntryPane' Class
------------------------

A 'X11TextEntryPane' object displays a basic, single line text entry
box.  Users can enter text when the pointer is over the entry box, and
the application can retrieve the text that the user enters as the
contents of the 'X11TextEntryPane : entryText' method.

Editing is performed using the pointer's left button or cursor motion
keys to position the cursor.  Users may insert text at that point, or
delete characters using the <Backspace> and <Delete> keys.  The class
also supports cursor motion using Emacs-compatible editing keys.


     Action            Keys
     ------            ----
     Character Left    Left Arrow,  <Ctrl-B>
     Character Right   Right Arrow, <Ctrl-F>
     Start of Text     Home,        <Ctrl-A>
     End of Text       End,         <Ctrl-E>
     Delete Right      Del,         <Ctrl-D>
     Delete Left       <Backspace>
     Delete Selection  <Backspace> (If Selecting Text)


In addition, 'X11TextEntryPane' objects support cutting and pasting of
entry text using the X primary selection.  The class uses the standard
pointer buttons to select text and to paste text selected by other X
client programs.


     Action                           Pointer Buttons
     ------                           ---------------
     Set Insertion Point              Button 1 (Left Button) Press and
                                      Release

     Paste Selected Text At Cursor    Button 2 (Center Button, or Both
                                      Left and Right Buttons) Press and
                                      Release

     Select Text to Place on the      Button 1 (Left Button) Press + Drag
     X selection                      Pointer Across Text


Here is an example of an 'X11TextEntryPane' object's use.


     /* entrypane.ca, a X11TextEntryPane demonstration. -*-c-*- */

     /* Uncomment if you want the entry box to echo dots. */
     /* #define DOTS */

     #include <ctalk/ctalkdefs.h>

     int main (int argv, char **argc) {
       X11Pane new xPane;
       X11PaneDispatcher new dispatcher;
       X11TextEntryPane new entry;
       X11LabelPane new label;
       X11ButtonPane new button;
       InputEvent new e;
       Integer new nEvents;
       Integer new verbose;
       X11Cursor new cursor;

       xPane ftFontVar initFontLib;
       xPane resources atPut "backgroundColor", "blue";
       label resources replaceAt "backgroundColor", "blue";
       label resources replaceAt "foregroundColor", "blue";
       label resources replaceAt "highlightForegroundColor", "blue";
       label resources replaceAt "textColor", "white";
       label resources replaceAt "highlightTextColor", "white";
       label border = false;

     #ifdef DOTS
       entry dots = true;
     #endif

       xPane inputStream eventMask = EXPOSE|ENTERWINDOWNOTIFY|LEAVEWINDOWNOTIFY| \
         KEYPRESS|KEYRELEASE|WINDELETE|BUTTONPRESS|BUTTONRELEASE|MOTIONNOTIFY| \
          SELECTIONCLEAR|SELECTIONREQUEST;
        xPane initialize 300, 185;
       dispatcher attachTo xPane;
       label attachTo dispatcher, "100x80+10+10";
       button attachTo dispatcher, "70x55+c+100";
       entry attachTo dispatcher, "140x32+120+32";

       xPane map;
       xPane raiseWindow;

       xPane openEventStream;

       xPane setWMTitle "X11TextEntryPane Demo";
       label multiLine "Enter your\ntext:";
       button label text "Done";

       while (TRUE) {
         xPane inputStream queueInput;
         if (xPane inputStream eventPending) {
           e become xPane inputStream inputQueue unshift;

           xPane subPaneNotify e;

           switch (e eventClass value)
             {
             case EXPOSE:
               entry refresh;
               break;
             case WINDELETE:
               xPane deleteAndClose;
               exit (0);
               break;
             default:
               if (button haveClick) {
                 button clearClick;
                 xPane deleteAndClose;
                 printf ("You entered: %s\n", entry entryText);
                 exit (0);
               }
             break;
             }
         }
       }
     }


Echoing Dots
------------

Normally a 'X11TextEntryPane' object displays characters as you type
them.  However, you can set the 'dots' instance variable to 'true' to
cause the pane to display dots instead, like this.


     entry dots = true;


Resources
---------

For information about how to set and retrieve resources, refer to the
'X11Pane' section *Note PaneResources::.

'backgroundColor'
     The background color of the entry pane's window.  The default is
     'white'.

'borderColor'
     The color of the entry pane's border.  The default is 'gray'.

'borderWidth'
     The width in pixels of the pane's border when the pointer is not
     above it.  The default is 1 pixels.

'cursorAdvanceHint'
     The distance in pixels between the last character and the cursor
     when the point is positioned at the end of the buffer for appending
     text.  The default is 2 pixels when built and run with MacOS, 4
     pixels for Linux and other systems.

'font'
     A 'String' that contains the display font's descriptor.  In order
     to maintain alignment between the character display and insertion
     point, the display font be monospaced.

     The default font for MacOS is 'Bitstream Vera Sans
     Mono-14:weight=medium;slant=roman'.  The default font for Linux and
     other systems is 'DejaVu Sans Mono-12:weight=medium;slant=roman'.

'hoverBorderWidth'
     The width in pixels of the pane's border when the pointer is over
     it and the pane's window has the input focus.  The default is 4
     pixels.

'hPad'
'vPad'
     The distance in pixels between the edges of the text and the edge
     to the window, including the width of the border.  The default is 4
     pixels.

'spacingHint'
     The distance in pixels that the pane adjusts the displayed text's
     horizontal spacing.  The default is -1 for MacOs and 0 for Linux
     and other systems.

'selectionColor'
     A 'String' that contains the background color of selected text.
     The default is 'orange'.

'textColor'
     The color that the pane uses to display text.  The default is
     'black'.

Instance Variables
------------------

'baselineY'
     An 'Integer' that contains the vertical location of the text's
     baseline in the entry window, in pixels.

'button'
     An 'Integer' that records the state of the pointer buttons when the
     program receives a BUTTONPRESS or BUTTONRELEASE event.

'center'
     A 'Boolean' that helps determine how a part of the text is
     displayed if the text is too large to fit within the pane.

'clipX'
     An 'Integer' that contains the leftmost character that is displayed
     when the text is scrolled leftward.

'chars'
     A 'List' that contains the entry pane's text.  Each member of the
     list is a 'CharCell', a class used exclusively by
     'X11TextEntryPane' objects, which contains both the character and
     information about its dimensions and placement within the window.

'cursor'
     A 'X11Cursor' object that contains a text editing cursor which is
     displayed when the pointer is over the pane and it has the keyboard
     input focus.

'cursorX'
     An 'Integer' that contains the character index of the cursor and
     insertion point within the text.

'dots'
     A 'Boolean', which, if set by a program, causes the entry pane to
     echo dots instead of the typed characters.  In order to display
     dots, the calling program should contain a statement like this.


          entry dots = true;


'hover'
     A 'Boolean' object that is true when the pointer is over the pane
     and the pane has the keyboard input focus.

'paneWidthChars'
     The width of the pane as measured in the number of characters that
     can be displayed at one time using the current font.  The pane uses
     the 'paneWidth' variable's value to help determine which section of
     the text to display when the entire text is too wide to fit within
     the pane's window.

'point'
     An 'Integer' that determines where each character that the user
     types is inserted into the buffer's text.  If 'point' is equal to
     the size of the 'chars' list, then the pane appends the characters
     to the end of the text.

'selecting'
     A 'Boolean' that is true if the user is in the process of selecting
     text; that is, when the pointer's left button is depressed and the
     pointer is dragged across the text.

'sEnd'
'sStart'
     These are 'Integer', which, if non-zero contain the start and end
     indexes of selected text within the entry pane's buffer.

'shiftState'
     An 'Integer' that records whether a 'Shift', 'Control', or 'Caps
     Lock' key is being pressed while typing.

'spacingHint'
     An 'Integer' that contains the value of the 'spacingHint' resource.

Instance Methods
----------------

'attachTo (X11Pane PARENTPANE, String GEOMETRY)'
     Attaches the entry pane to PARENTPANE using the dimensions and
     placement given by GEOMETRY.  For information about how to specify
     a pane's geometry, refer to the 'X11PaneDispatcher' class *Note
     X11PaneDispatcher::.

'calclulateSpaceAppend (void)'
     This method defers calculating the width of a space that the user
     appends to the text until a following character is added.

'charCellAt (Integer charIndex)'
     Returns the 'CharCell' object for the 'charIndex' position in the
     text.  (I.e., the _nth_ element of the 'chars' instance variable's
     list).

'charIndex (Integer clickX, Integer CLICKY)'
     Returns an 'Integer' with the index of the character displayed at
     CLICKX,CLICKY.

'clearSelection (void)'
     Clears the selection in response to events from the user or from
     another X client application requesting the selection ownership.

'deleteAt (Integer CHARINDEX)'
     Deletes the character at CHARINDEX and returns the element, which
     is a 'CharCell' object.  'CharCell' objects are a class that
     'X11TextEntryPane' class uses to store each character, as well as
     its dimensions and placement within the window.

'deleteForward (Integer CHARINDEX)'
     This deletes the character at the insertion point and is called
     when the user presses the 'Delete' or 'Ctrl-D' key.

'draw (void)'
     Draws the pane's border, its text contents after determining how
     far left to scroll the text, and calls 'drawCursor' to draw the
     insertion cursor.  The drawing occurs on the pane's 'paneBuffer'
     instance variable, which is a 'X11Bitmap' object.  To make the the
     pane's contents visible in the application's window, use the
     'refresh' method.

'drawCursor (void)'
     Draws the pane's editing cursor at the text insertion point.

'drawSelection (void)'
     If any text is selected, highlight the text using the color defined
     by the 'selectionColor' resource.

'entryText (void)'
     Returns the text contents of the entry pane as a 'String' object.

'inputWidth (Integer STARTIDX)'
     Returns an 'Integer' that contains the width in pixels of the input
     text starting at character STARTIDX.  This method determines how
     far leftward text should be scrolled to keep the insertion point
     and its surrounding text visible in the pane's window.

'insertAt (Integer CHARINDEX)'
     Inserts a 'CharCell' object at CHARINDEX in the entry object's
     'chars' list.

'new (String PANENAME)'
     The 'X11TextEntryPane' constructor.  Initializes resources to their
     default values and the event handler instance variables to the
     classes' event handlers.  These instance variables are declared in
     'X11PaneDispatcher' class *Note X11PaneDispatcher::.

'reflow (void)'
     Recalculates the character placement in the entry object's 'chars'
     list.  This method should be used after any operation that inserts
     or deletes text in the middle of the CHARS list.

'refresh (void)'
     Displays the contents of the pane's drawing surfaces on the
     program's visible window.

'selectionToText (String TEXTOUT)'
     Sets its argument, a 'String' object, to the currently selected
     text as a 'string'.

'subPaneButtonPress (Object SUBPANEOBJECT, InputEvent EVENT)'
'subPaneEnter (Object SUBPANEOBJECT, InputEvent EVENT)'
'subPaneExpose (Object SUBPANEOBJECT, InputEvent EVENT)'
'subPaneLeave (Object SUBPANEOBJECT, InputEvent EVENT)'
'subPaneKbd (Object SUBPANEOBJECT, InputEvent EVENT)'
'subPanePointerMotion (Object SUBPANEOBJECT, InputEvent EVENT)'
'subPaneSelectionClear (Object SUBPANEOBJECT, InputEvent EVENT)'
     Handler methods for different types of X 'InputEvent' objects.  For
     more information about the handlers and event types, refer to the
     'X11PaneDispatcher' class.  *Note X11PaneDispatcher::.


File: ctalk.info,  Node: X11YesNoBoxPane,  Next: X11TextEntryBox,  Prev: X11TextEntryPane,  Up: Classes

'X11YesNoBoxPane' Class
-----------------------

A 'X11YesNoBoxPane' object displays a window with a text message,
optionally an icon, and two buttons, which are normally labelled 'Yes'
and 'No'.

Clicking on one of the buttons closes the window and returns an
identifier of the selected button as an 'Integer'.  The object also
stores the text of the selected button's label.

Also, pressing the 'Tab' key switches focus between buttons.  Pressing
'Enter' activates the button with the focus, also causing the window to
close.

Here is an example program.


     /* yesnobox.ca - X11YesNoBoxPane Demonstration -*-c-*- */

     #include <ctalk/ctalkdefs.h>

     int main (void) {
       X11Pane new mainWindow;
       X11PaneDispatcher new dispatcher;
       X11ButtonPane new button;
       X11LabelPane new label;
       X11YesNoBoxPane new yesnoBox;
       InputEvent new e;

       label textColor = "white";
       label canFocus = false;
       label borderWidth = 0;

       label ftFontVar initFontLib;
       label ftFontVar notifyLevel XFT_NOTIFY_NONE;

       mainWindow backgroundColor = "blue";
       label resources replaceAt "backgroundColor", "blue";
       button resources replaceAt "backgroundColor", "blue";
       yesnoBox resources replaceAt "backgroundColor", "blue";

       mainWindow initialize 255, 200;
       mainWindow inputStream eventMask =
         EXPOSE|ENTERWINDOWNOTIFY|LEAVEWINDOWNOTIFY|BUTTONPRESS|BUTTONRELEASE|KEYPRESS|KEYRELEASE|WINDELETE|MOVENOTIFY;

       dispatcher attachTo mainWindow;
       label attachTo dispatcher, "177x80+c+15";
       button attachTo dispatcher, "110x90+c+90";
       yesnoBox attachTo dispatcher, "300x200";

       mainWindow map;
       mainWindow raiseWindow;

       mainWindow openEventStream;

       mainWindow setWMTitle "X11YesNoBoxPane Demo";

       label multiLine "X11YesNoBoxPane\nDemo";
       label resources replaceAt "textColor", "lightgray";
       label resources replaceAt "foregroundColor", "blue";
       label resources replaceAt "borderColor", "blue";

       button label multiLine "Open\nYes/No\nDialog";

       button label resources replaceAt "highlightForegroundColor", "gray80";

       /* The program uses the "replaceAt" method because the key/value
          entry for "backgroundColor" the X11MessageBoxPane : new method
          has alread created an entry for backgroundColor. */
       yesnoBox resources replaceAt "backgroundColor", "blue";
       yesnoBox resources replaceAt "foregroundColor", "blue";
       yesnoBox resources replaceAt "messageColor", "white";
       yesnoBox resources replaceAt "messageText",
         	       "Hello, yesnoBox!\nYour message text here.";

       button draw;
       button refresh;
       label draw;
       label refresh;

       while (TRUE) {
         mainWindow inputStream queueInput;
         if (mainWindow inputStream eventPending) {
           e become mainWindow inputStream inputQueue unshift;

           mainWindow subPaneNotify e;

           switch (e eventClass value)
     	{
     	case EXPOSE:
     	  button subPaneExpose (button, e);
     	  label subPaneExpose (label, e);
     	  break;
     	case BUTTONRELEASE:
     	  yesnoBox showManaged button;
     	  printf ("returnVal: %d: %s\n", yesnoBox returnVal,
     		  yesnoBox returnText);
     	  break;
     	case WINDELETE:
      	  mainWindow deleteAndClose;
     	  exit (0);
     	  break;
     	}
         } else {
           usleep (1000);
         }
       }

     }


Return Values
-------------

Normally, after initializing the 'X11YesNoBoxPane' object, a program
calls either the 'show' or 'showManaged' method, which displays the
object's window.  After clicking on one of the buttons, or after either
the calling program or the user otherwise closes the window, the method
withdraws the window, and returns an 'Integer' value that contains one
of the following definitions.


     YESNO_NONE
     YESNO_LBUTTON
     YESNO_RBUTTON


These constants are defined in 'ctalkdefs.h', so the calling program
should contain the following statement.


     #include <ctalk/ctalkdefs.h>


This value is also contained in the 'X11YesNoBox' object's 'returnVal'
instance variable.  In addition, the text of the selected button is
contained in the object's 'returnText' label.

In the example above, this is how the program displays the user's
selection.


     yesnoBox showManaged button;
     printf ("returnVal: %d: %s\n", yesnoBox returnVal,
             yesnoBox returnText);


If the user or the calling program close the object's window by some
other method, then the value of 'returnText' is an empty string.

Resources
---------

The resources that 'X11YesNoBoxPane : new' defines by default are stored
in the 'resources' instance variable, an 'AssociativeArray' that is
declared in 'X11Pane' class.  For a description, see the 'resources'
instance variable documentation.  *Note PaneResources::.

'backgroundColor'
     A 'String' that contains the color used to draw the window
     background.  This includes the actual subwindow that receives the
     button's events from the display server.  The resources' default
     value is 'gray'.

'foregroundColor'
     A 'String' with the name of the color that the messagebox window is
     filled with.  The default is 'gray'.

'geometry'
     A 'String' that contains the message window's size, and,
     optionally, its position.  The value is set to the dimensions that
     are given as arguments to the 'attachTo' method.

'iconID'
     An 'Integer' that contains the identifier to the icon to be
     displayed.  Ctalk defines the following constants for icons in
     'ctalkdefs.h' and in the graphics libraries.


          ICON_NONE
          ICON_CAUTION
          ICON_INFO
          ICON_QUESTION
          ICON_STOP


     The default is 'ICON_QUESTION', which causes a question mark icon
     to be displayed.  The widget adjusts the size and position of the
     text automatically to provide space for the icon.

'leftButtonText'
'rightButtonText'
     These are 'Strings' that contain the text that appears in the left
     and right-hand buttons.  The default is 'Yes' and 'No'.

'messageColor'
     A 'String' that contains the color of the message text.  The
     default is 'black'.  The message box sets the label's 'textColor'
     resource to this value.

'messageFont'
     A 'String' that contains the Fontconfig font descriptor.  The
     default is 'sans serif-12'.  The pane uses this value to set the
     label's 'fcFont' resource.

'messageText'
     A 'String' that contains the text of the message to be displayed.
     The default is 'Sample message text.'.

'pad'
     An 'Integer' that contains the space in pixels betwween the button
     and label widgets, and between each widget and the edge of the
     window.  The default is 10 pixels.

'titleText'
     A 'String' that contains the message window's title text.  The
     default is 'Message'.

Instance Variables
------------------

'lbutton'
'rbutton'
     The 'X11ButtonPane' objects that close the window when either is
     clicked.  The buttons' default text are, 'Yes' and 'No'.  Programs
     can change the text with a statement like the following.


          myYesNoBox resources atPut "leftButtonText", "All Right";
          myYesNoBox resources atPut "rightButtonText", "No Way!";


'initialized'
     A 'Boolean' that is 'true' if the pane has already been
     initialized.  When a message box is closed, it is not deleted - it
     is simply unmapped from the display.  This variable is set to true
     so that the message box is initialized only once.

'label'
     A 'X11LabelPane' that displays the message box's text.  As
     configured, the label is the same color as the main message box
     window, and uses no borders.  The label's text is controlled by the
     resource, 'messageText'.  To set the message text, use a statement
     like the following.


          myYesNoBox resources atPut "messageText", "Today Is\nJanuary 3rd.\nOkay?";


     The class draws the label using multiline formatting, so if you
     want the text to appear on multiple lines, include the sequence
     '\n' in the text (that's a backslash and the character, 'n', not a
     literal newline).

'mainWindowPtr'
     A 'Symbol' that contains a pointer to the main window.

'returnText'
     A 'String' that contains the text of the button that was clicked to
     withdraw the window.  If the window was closed by some other
     method, then 'returnText' contains an empty string.

'returnVal'
     When the 'X11YesNoBoxPane' obect's window is closed, either by
     clicking on one of the buttons, or by otherwise closing the window,
     this 'Integer' that contains one of the following values.


          YESNO_NONE
          YESNO_LBUTTON
          YESNO_RBUTTON


     The value of 'returnVal' is also used as the 'show' and
     'showManaged' methods' return value.

Instance Methods
----------------

'attachTo (Object PARENTPANE, String GEOMETRY)'
     Sets the yes/no box's dimensions and creates the object's buffers
     and main window.  Unlike other 'X11Pane' subclasses, this method
     does not immediately attach the yes/no box's object to its parent
     pane, so the yes/no box isn't displayed until the program invokes
     the 'show' or 'showManaged' method.

'draw (void)'
     Draws the label and button subpanes in the yes/no box's buffers and
     the buffers of the button and label subpanes.  After calling this
     method, the 'refresh' method makes the changes visible.

'fill (String COLORNAME)'
     A convenience method that fills the pane window with the color
     given as the argument.

'initWidgets (void)'
     Initializes the yes/no box's button and label subpanes when the
     pane's window is first opened.  When constructed this method sets
     the 'initialized' instance variable to 'true', so when the yes/no
     box appears again, this method is a no-op.

'new (String NEWPANENAME)'
     The X11YesNoBoxPane constructor.

'refresh (void)'
     After the method DRAW renders the main window and the label and the
     button subwindow's contents on the pane objects' buffers, this
     method updates the visible window with the contents of the buffers.

'show (void)'
     This method displays the yes/no box, waits for events from the
     display system, and closes the yes/no box when its button is
     clicked, then returns to the calling program.

'show (X11ButtonPane BUTTONPANE)'
     This method is similar to the 'show' method, but it takes as its
     argument the pane object from the main window that caused the
     yes/no window to open.

     This method sets the main window's button to be unclicked and then
     redrawn.

     This method manages 'X11ButtonPane' objects specifically, but it
     can be subclassed to manage any pane class object.

'subPaneButton (Object SUBPANE, InputEvent EVENT)'
     This is the event handler for button press and button release
     events from the display hardware.  When a button is clicked on, the
     yes/no box draws the button in its clicked state.  When the button
     is released, the pane draws the button unclicked, then unmaps the
     yes/no box window from the display, and returns to the main
     program.

'subPaneExpose (Object SUBPANE, InputEvent EVENT)'
     Handles drawing the yes/no box when the program receives an Expose
     event from the display.  This method calls the yes/no box's 'draw'
     and 'refresh' methods.

'withdraw (void)'
     Unmaps the yes/no box's window from the display after the pane
     object receives a button release event while processing the 'show'
     method.  When the 'show' or 'showManaged' method receives the
     button release event, this method is called to remove the pane's
     window from the display, and the 'show' or 'showManaged' method
     returns to the main program.


File: ctalk.info,  Node: X11TextEntryBox,  Next: X11ListBox,  Prev: X11YesNoBoxPane,  Up: Classes

'X11TextEntryBox' Class
-----------------------

A 'X11TextEntryBox' object pops up a dialog window that contains a
'X11TextEntryPane' object, where the user can enter text.  The contents
of the text entry persist if the dialog window is re-opened, and the
contents are available to the calling program, as is the text of the
button and return code that indicates how the user closed the dialog
box.

Here is an example program that demonstrates a 'X11TextEntryBox's' use.


     /* entrybox.ca, a X11TextEntryBox demonstration. -*-c-*- */

     #include <ctalk/ctalkdefs.h>

     int main (void) {
       X11Pane new mainWindow;
       X11PaneDispatcher new dispatcher;
       X11ButtonPane new button;
       X11LabelPane new label;
       X11TextEntryBox new textEntryBox;
       InputEvent new e;

       label textColor = "white";
       label canFocus = false;
       label borderWidth = 0;

       label ftFontVar initFontLib;
       label ftFontVar notifyLevel XFT_NOTIFY_NONE;

       mainWindow backgroundColor = "blue";
       label resources replaceAt "backgroundColor", "blue";
       button resources replaceAt "backgroundColor", "blue";
       textEntryBox resources replaceAt "backgroundColor", "blue";

       mainWindow initialize 255, 200;
       mainWindow inputStream eventMask =
         EXPOSE|ENTERWINDOWNOTIFY|LEAVEWINDOWNOTIFY|BUTTONPRESS|BUTTONRELEASE|KEYPRESS|KEYRELEASE|WINDELETE|MOVENOTIFY;

       dispatcher attachTo mainWindow;
       button attachTo dispatcher, "110x90+c+95";
       label attachTo dispatcher, "177x80+c+15";
       textEntryBox attachTo dispatcher, "300x200";

       mainWindow map;
       mainWindow raiseWindow;

       mainWindow openEventStream;

       mainWindow setWMTitle "X11TextEntryBox Demo";

       label multiLine "X11TextEntryBox\nDemo";
       label resources replaceAt "textColor", "lightgray";
       label resources replaceAt "foregroundColor", "blue";
       label resources replaceAt "borderColor", "blue";

       button label multiLine "Open\nText Entry\nDialog";

       button label resources replaceAt "highlightForegroundColor", "gray80";

       /* The program uses the "replaceAt" method because the key/value
          entry for "backgroundColor" the X11MessageBoxPane : new method
          has alread created an entry for backgroundColor. */
       textEntryBox resources replaceAt "backgroundColor", "blue";
       textEntryBox resources replaceAt "foregroundColor", "blue";
       textEntryBox resources replaceAt "messageColor", "white";
       textEntryBox resources replaceAt "messageText",
         	       "Hello, textEntryBox!\nYour message text here.";

       button draw;
       button refresh;
       label draw;
       label refresh;

       while (TRUE) {
         mainWindow inputStream queueInput;
         if (mainWindow inputStream eventPending) {
           e become mainWindow inputStream inputQueue unshift;

           mainWindow subPaneNotify e;

           switch (e eventClass value)
     	{
     	case EXPOSE:
     	  button subPaneExpose (button, e);
     	  label subPaneExpose (label, e);
     	  break;
     	case BUTTONRELEASE:
     	  textEntryBox showManaged button;
     	  printf ("returnVal: %d: %s: %s\n", textEntryBox returnVal,
     		  textEntryBox returnText, textEntryBox entryContents);
     	  break;
     	case WINDELETE:
      	  mainWindow deleteAndClose;
     	  exit (0);
     	  break;
     	}
         } else {
           usleep (1000);
         }
       }

     }


Resources
---------

'X11TextEntryBox' objects do not define resources of their own.
Instead, it uses the resources defined by the classes of its components:

'X11YesNoBoxPane *Note X11YesNoBoxPane::.'
'X11LabelPane *Note X11LabelPane::.'
'X11ButtonPane *Note X11ButtonPane::.'
'X11TextEntryPane *Note X11TextEntryPane::.'

The top-level window's resources are defined by the 'X11YesNoBox'
superclass.  Each of the component subpanes is defined by an instance
variable.  This allows each of the subpanes to be managed individually.

'lbutton'
     Defined by the 'X11ButtonPane' class.  *Note X11ButtonPane::.
'rbutton'
     Defined by the 'X11ButtonPane' class.  *Note X11ButtonPane::.
'label'
     Defined by the 'X11LabelPane' class.  *Note X11LabelPane::.
'icon'
     Defined by the 'X11Bitmap' class.  *Note X11Bitmap::.
'entryPane'
     Defined by the 'X11TextEntryPane' class.  *Note X11TextEntryPane::.

For example, to change the background color of selected text in the
entrybox subwindow, a program would contain a statement like this one.


     myEntryBox entryPane resources replaceAt "selectionColor", "lightblue";


Occasionally, the subpane's class defines its own resources that it
propagates to its own subpanes.  For example, to change the text that
appears on the buttons:


     myEntryBox resources replaceAt "leftButtonText", "Dismiss";
     myEntryBox resources replaceAt "rightButtonText", "Accept";


It's necessary to use the 'Collection : replaceAt' method, because each
subpane's default resources has already been created when the subpane is
constructed (generally, this is done by each classes' 'new' method).

Instance Variables
------------------

'dots'
     A 'Boolean' that causes the entryPane to echo dots instead of the
     text that the user typed.

'entryContents'
     A 'String' that contains the text contents of the entry window.
     This variable is updated whenever the contents of the 'entryPane'
     object are modified.

'entryPane'
     The 'X11TextEntryPane' object that is constructed when the 'show'
     method is first called, and is updated and displayed via the 'show'
     method's event loop.

Instance Methods
----------------

'draw (void'
     Draws the main pane and each subpane's controls on each subpane's
     buffer, as well as the main pane's icon, if any.

'initWidgets (void)'
     Constructs the subpanes when the entrybox window is first
     constructed and mapped to the display.  The method sets the
     'initialized' instance variable (defined in 'X11YesNoBoxPane'
     class) to true, so the pane is only constructed once if it is
     withdrawn from the display and then remapped.

'new (String PANENAME)'
     The 'X11TextEntryBox' constructor.  This method calls the
     constructor of its superclass, 'X11YesNoBoxPane', which defines the
     resources that this class uses as well.  However, this constructor
     defines the event handlers it needs, in order to make the events
     available to the 'entryPane' subpane when necessary.

'show (Object SUBPANE, InputEvent EVENT)'
     This method constructs the 'X11TextEntryBox' object when it is
     first called, and then on the first and each following call, maps
     the entry box to the display, waits for and dispatches events from
     the display server, and withdraws the window from the display when
     the user clicks on a button or on the window's close menu.

'subPaneEnter (Object SUBPANE, InputEvent EVENT)'
'subPaneLeave (Object SUBPANE, InputEvent EVENT)'
     Event handlers for enter and leave events, which are generated when
     the pointer is over one of the subpanes.


File: ctalk.info,  Node: X11ListBox,  Next: X11FileSelectDialog,  Prev: X11TextEntryBox,  Up: Classes

'X11ListBox' Class
------------------

A 'X11ListBox' object pops up a dialog window that contains a label, a
listbox, and "Cancel" and "Ok" buttons.

After the listbox has first appeared and all of its subpanes have been
initialized, a program can access any of the items selected in the
listbox's list via the 'listPane' instance variable.

A 'X11ListBox' dialog supports multiple selections.  Pressing <Shift>
while clicking on a list item adds that item to list's selections.
Pressing <Ctrl> while clicking on an item selects all of the items in a
range between the first selected item and the last selected item of the
list.

Component Widgets
-----------------

A 'X11ListBox' consists of component widgets from the 'X11LabelPane',
'X11ListPane', and 'X11ButtonPane' class.

The objects for each component are declared as instance variables,
which, except for the list subpane itself, are inherited from the
'X11YesNoBoxPane' superclass.  *Note X11YesNoBoxPane::.


     Component Instance       Class                 Inherited
          Variable                                    From
     ------------------       -----               --------------
     listPane                 X11ListPane         --
     lButton                  X11ButtonPane       X11YesNoBoxPane
     rButton                  X11ButtonPane       X11YesNoBoxPane
     label                    X11LabelPane        X11YesNoBoxPane


More information about the resources, instance variables, and methods
that each component uses is contained in each of the component classes'
individual sections: *Note X11ListPane::, *Note X11ButtonPane::, and
*Note X11LabelPane::

Here is an example program that shows how to display a 'X11ListBox' and
retrieve the selected list items.


     /* listbox.ca, a X11ListBox demonstration. -*-c-*- */

     #include <ctalk/ctalkdefs.h>

     #define N_ITEMS 30

     int main (void) {
       X11Pane new mainWindow;
       X11PaneDispatcher new dispatcher;
       X11ButtonPane new button;
       X11LabelPane new label;
       X11ListBox new listBox;
       InputEvent new e;
       Integer new i;
       List new itemTextOut, itemNOut;
       String new itemText, itemN;

       label textColor = "white";
       label canFocus = false;
       label borderWidth = 0;

       label ftFontVar initFontLib;
       label ftFontVar notifyLevel XFT_NOTIFY_NONE;

       mainWindow backgroundColor = "blue";
       label resources replaceAt "backgroundColor", "blue";
       button resources replaceAt "backgroundColor", "blue";
       listBox resources replaceAt "backgroundColor", "blue";

       mainWindow initialize 255, 200;
       mainWindow inputStream eventMask =
         EXPOSE|ENTERWINDOWNOTIFY|LEAVEWINDOWNOTIFY|BUTTONPRESS|BUTTONRELEASE|KEYPRESS|KEYRELEASE|WINDELETE|MOVENOTIFY|MOTIONNOTIFY;

       dispatcher attachTo mainWindow;
       label attachTo dispatcher, "177x80+c+15";
       button attachTo dispatcher, "110x85+c+100";
       listBox attachTo dispatcher, "300x400";

       mainWindow map;
       mainWindow raiseWindow;

       mainWindow openEventStream;

       mainWindow setWMTitle "X11ListBox Demo";

       label multiLine "X11ListBox\nDemo";
       label resources replaceAt "textColor", "lightgray";
       label resources replaceAt "foregroundColor", "blue";
       label resources replaceAt "borderColor", "blue";

       button label multiLine "Open\nListBox\nDialog";

       button label resources replaceAt "highlightForegroundColor", "gray80";

       /* The program uses the "replaceAt" method because the key/value
          entry for "backgroundColor" the X11MessageBoxPane : new method
          has alread created an entry for backgroundColor. */
       listBox resources replaceAt "backgroundColor", "blue";
       listBox resources replaceAt "foregroundColor", "blue";
       listBox resources replaceAt "messageColor", "white";
       listBox resources replaceAt "messageText",
         	       "Hello, listBox!\nPlease select an item.";

       for (i = 1; i < N_ITEMS; ++i) {
         listBox items push "item " + i asString;
       }

       button draw;
       button refresh;
       label draw;
       label refresh;

       while (TRUE) {
         mainWindow inputStream queueInput;
         if (mainWindow inputStream eventPending) {
           e become mainWindow inputStream inputQueue unshift;

           mainWindow subPaneNotify e;

           switch (e eventClass value)
     	{
     	case EXPOSE:
     	  button subPaneExpose (button, e);
     	  label subPaneExpose (label, e);
     	  break;
     	case BUTTONRELEASE:
     	  listBox showManaged button;
     	  if (listBox listPane nItemsSelected > 1) {
     	    i = 0;
     	    listBox listPane selectedItems itemTextOut;
     	    listBox listPane selectedItemsN itemNOut;
     	    itemNOut map {
     	      itemN = self;
     	      /* This is a convenient way to retrieve
     		 the i'th item in the itemTextOut list. */
     	      itemText = *(itemTextOut + i);
     	      printf ("%d: %s\n", itemN, itemText);
     	      ++i;
     	    }
     	  } else {
     	    printf ("%d: %s\n",
     		    listBox listPane selectedItemN,
     		    listBox listPane selectedItemText);
     	  }
     	  break;
     	case WINDELETE:
      	  mainWindow deleteAndClose;
     	  exit (0);
     	  break;
     	}
         } else {
           usleep (1000);
         }
       }

     }


Retrieving List Selections
--------------------------

There are several methods that provide information about which item or
list items are currently selected.  Generally, if a user has selected
more than one item, then the results would be in the form of a list,
instead of an 'Integer' index of a selection or a 'String' containing
the selection's contents.

The method, 'nItemsSelected', returns an 'Integer' with the number of
items that are currently selected.  Programs can use this to determine
which method to use to retrieve the list selections.

Depending on whether a user has selected a single item or multiple
items, a program can use the 'selectedItemN' or 'selectedItemsN' methods
to retrieve selection indexes, and the 'selectedItemText' or
'selectedItems' methods to retrieve the text of the selected item or
items.

The example program above uses this method to print either a single
selected item or multiple selections.


     if (listBox listPane nItemsSelected > 1) {
       i = 0;
       listBox listPane selectedItems itemTextOut;
       listBox listPane selectedItemsN itemNOut;
       itemNOut map {
         itemN = self;
         /* This is a convenient way to retrieve
            the i'th item in the itemTextOut list. */
         itemText = *(itemTextOut + i);
         printf ("%d: %s\n", itemN, itemText);
         ++i;
       }
     } else {
       printf ("%d: %s\n",
               listBox listPane selectedItemN,
               listBox listPane selectedItemText);
     }


Resources
---------

'listFont'
     A 'String' that contains the name of the font that the
     'X11ListPane' subwidget uses to display the list items.  The
     default is 'sans-serif-12'.

Instance Variables
------------------

'items'
     A 'List' that contains all of the items to be added to the list
     when the dialog is first popped up.  Because the dialog box doesn't
     construct itself and the list subpane until it first appears, this
     is a convenient way for programs to define the items that will
     initially appear in the list before the the dialog first appears.

     After the dialog first appears, the list items may be modified by
     using the list pane's 'add' method.  For example:


          myListDialog listPane add "Extra List Item 1";


'listPane'
     A 'X11ListPane' object that defines the list subpane.  It is
     initialized when the dialog is first popped up.  After that,
     programs can use any of the methods, resources, and instance
     variables that are defined in 'X11ListPane' class to alter or
     retrieve the list's items or the user's selections *Note
     X11ListPane::.

Instance Methods
----------------

'draw (void)'
     This calls the indivdual subpane's 'draw' and 'refresh' methods in
     order to update the dialog's contents on the display.

'initWidgets (void)'
     Called when the dialog first appears, this initializes each of the
     component widget objects.

'new (String PANENAME'
     The 'X11ListBox' constructor.  Creates the dialog object with the
     name given as the argument, and initializes the dialog's event
     handlers and resources.

'show (String PANENAME'
     Displays the dialog window, also calling 'initWidgets' if the
     dialog is being displayed for the first time.

'subPaneEnter (Object SUBPANE, InputEvent EVENT)'
'subPaneLeave (Object SUBPANE, InputEvent EVENT)'
     Event handlers for highlighting the dialog's label or buttons when
     the pointer is over them.


File: ctalk.info,  Node: X11FileSelectDialog,  Next: X11TextPane,  Prev: X11ListBox,  Up: Classes

'X11FileSelectDialog' Class
---------------------------

A 'X11FileSelectDialog' object displays a dialog box with a list of
files in the current directory, a preselected target directory, or a
subdirectory that a user selects from the current directory's entries.

The class uses a 'X11ListPane' object to display and manage the file
list, so the 'X11FileSelectDialog' supports the same scrolling and
selection operations as basic list pane.  *Note X11ListPane::.

Additionally, 'X11FileSelectDialog' panes require a double click when
changing directories.  This behavior is controlled by the dialog's
'chDirDoubleClick' instance variable.  If this variable is set to
'false', then the dialog changes directories with a single click.

The class allows users to select multiple entries by holding either the
<Shift> or <Ctrl> keys while selecting items.  The class provides a
number of methods to retrieve the number of items that the user selects,
the items' text, and text for a new file that the user enters, if any.
These methods are described below.  *Note
Retrieving-Selection-Information::.

The 'X11FileSelectDialog' class can also display a text entry box (from
'X11TextEntryPane' class) where users can enter new file names.

Here is an example program that pops up a 'X11FileSelectDialog' window.


     /* -*-c-*- */

     /*
      *   fileselectbox.ca, a X11FileSelectDialog demonstration.
      *
      *     To build:
      *
      *       ctcc -x fileselectbox.ca -o fileselectbox
      *
      *     You can optionally buidl the dialog with a X11TextEntryPane
      *     so you can enter filenames by typing.  For a full description
      *     of the X11FileSelectDialog class, refer to the Ctalk Language
      *     Reference.
      */

     /*
      *  Uncomment the following #define if you want to build the dialog
      *  with a X11TextEntryPane for creating new file paths.
      */
     /* #define FILENAME_ENTRY_BOX */

     #include <ctalk/ctalkdefs.h>

     int main (void) {
       X11Pane new mainWindow;
       X11PaneDispatcher new dispatcher;
       X11ButtonPane new button;
       X11LabelPane new label;
       X11FileSelectDialog new fileSelect;
       InputEvent new e;
       Integer new i;
       List new itemTextOut, itemNOut;
       String new itemText, itemN;

       label textColor = "white";
       label canFocus = false;
       label borderWidth = 0;

       label ftFontVar initFontLib;
       label ftFontVar notifyLevel XFT_NOTIFY_NONE;

       mainWindow backgroundColor = "blue";
       label resources replaceAt "backgroundColor", "blue";
       button resources replaceAt "backgroundColor", "blue";
       fileSelect resources replaceAt "backgroundColor", "blue";

       mainWindow initialize 255, 245;
       mainWindow inputStream eventMask =
         EXPOSE|ENTERWINDOWNOTIFY|LEAVEWINDOWNOTIFY|BUTTONPRESS|BUTTONRELEASE|KEYPRESS|KEYRELEASE|WINDELETE|MOVENOTIFY|MOTIONNOTIFY;

       dispatcher attachTo mainWindow;
       label attachTo dispatcher, "177x60+c+35";
       button attachTo dispatcher, "110x105+c+100";
       fileSelect attachTo dispatcher, "300x400";

       mainWindow map;
       mainWindow raiseWindow;

       mainWindow openEventStream;

     #ifdef FILENAME_ENTRY_BOX
       fileSelect resources replaceAt "useEntryBox", TRUE;
     #endif

       mainWindow setWMTitle "X11FileSelectDialog Demo";

       label multiLine "X11FileSelectDialog\nDemo";
       label resources replaceAt "textColor", "lightgray";
       label resources replaceAt "foregroundColor", "blue";
       label resources replaceAt "borderColor", "blue";

       button label multiLine "Open\nFile Select\nDialog";

       button label resources replaceAt "highlightForegroundColor", "gray80";

       /* The program uses the "replaceAt" method because the key/value
          entry for "backgroundColor" the X11MessageBoxPane : new method
          has alread created an entry for backgroundColor. */
       fileSelect resources replaceAt "backgroundColor", "blue";
       fileSelect resources replaceAt "foregroundColor", "blue";
       fileSelect resources replaceAt "messageColor", "white";
       fileSelect resources replaceAt "messageText",
         	       "Directory:\n";

       button draw;
       button refresh;
       label draw;
       label refresh;

       while (TRUE) {
         mainWindow inputStream queueInput;
         if (mainWindow inputStream eventPending) {
           e become mainWindow inputStream inputQueue unshift;

           mainWindow subPaneNotify e;

           switch (e eventClass value)
     	{
     	case EXPOSE:
     	  button subPaneExpose (button, e);
     	  label subPaneExpose (label, e);
     	  break;
     	case BUTTONRELEASE:
     	  fileSelect showManaged button;
     	  if (fileSelect buttonClick == FILESELECT_LBUTTON) {
     	    printf ("\"%s,\" clicked.\n", fileSelect buttonText);
     	    /*
     	       The button's click should be cleared, because in this
     	       program, the dialog can be re-opened here (i.e., not
     	       reinstantiated with the "new" method).

     	       The, "buttonText," method is equivalent, in this clause,
     	       to, "fileSelect lbutton text."

     	       The FILESELECT_LBUTTON #define and the other button
     	       definitions, are in ctalkdefs.h.
     	    */
     	    fileSelect lbutton clearClick;
     	  } else if (fileSelect entryLength > 0) {
     	    printf ("%s\n", fileSelect pathEntry);
     	  } else if (fileSelect nItemsSelected > 1) {
     	    i = 0;
     	    fileSelect selectedItems itemTextOut;
     	    fileSelect selectedItemsN itemNOut;
     	    itemNOut map {
     	      itemN = self;
     	      /* This is a convenient way to retrieve
     		 the i'th item in the itemTextOut list. */
     	      itemText = *(itemTextOut + i);
     	      printf ("%d: %s\n", itemN, itemText);
     	      ++i;
     	    }
     	  } else {
     	    printf ("%d: %s\n",
     		    fileSelect selectedItemN,
     		    fileSelect selectedItemText);
     	  }
     	  fileSelect rbutton clearClick;
     	  break;
     	case WINDELETE:
      	  mainWindow deleteAndClose;
     	  exit (0);
     	  break;
     	}
         } else {
           usleep (1000);
         }
       }

     }


Retrieving Selection Information
--------------------------------

The type and number of entries that a 'X11FileSelectDialog' can return
can differ depending on whether a user selects a single directory entry,
multiple directory entries, or enters a new file name.

When returning directory entries, the class returns each entry as a
concatenation of the current directory plus the entry name; for example,
if the current directory is '/home/bill' and the user has selected the
file 'message.txt', the dialog returns the 'String',
'/home/bill/message.txt'.

In addition, the dialog can provide information about whether the user
has clicked the left or right buttons, which are labeled, by default,
'Cancel' and 'Ok'.

Generally, when a program displays the file select dialog, the program
waits until the dialog box returns, that is, when the user presses
either the 'Cancel' or 'Ok' buttons.  On most desktops, the user can
also close the dialog using the desktop's close window menu item.  In
this case, the dialog can return a value indicating that the dialog has
returned without the user making a selection or cancelling the
selection.  These values and the method to retrieve them are described
below.

Here is the section of code from the example above (without the
comments) that retrieves and displays the user's selection or
selections.  The file select dialog is defined in the
'X11FileSelectDialog' object, 'fileSelect'.


     if (fileSelect buttonClick == FILESELECT_LBUTTON) {
       printf ("\"%s,\" clicked.\n", fileSelect buttonText);
       fileSelect lbutton clearClick;
     } else if (fileSelect entryLength > 0) {
       printf ("%s\n", fileSelect pathEntry);
     } else if (fileSelect nItemsSelected > 1) {
       i = 0;
       fileSelect selectedItems itemTextOut;
       fileSelect selectedItemsN itemNOut;
       itemNOut map {
         itemN = self;
         itemText = *(itemTextOut + i);
         printf ("%d: %s\n", itemN, itemText);
         ++i;
       }
     } else {
       printf ("%d: %s\n",
               fileSelect selectedItemN,
               fileSelect selectedItemText);
     }
     fileSelect rbutton clearClick;


First, the application checks whether the user clicked the 'Cancel'
button with the expresion:


     if (fileSelect buttonClick == FILESELECT_LBUTTON)


In this class, 'buttonClick' is a convenience method that checks each of
the dialog's buttons.  It can return the following values.


     FILESELECT_LBUTTON
     FILESELECT_RBUTTON
     FILESELECT_BUTTON_NONE


These values are defined in the 'ctalkdefs.h' include file, which
programs can include with a statement like this:


     #include <ctalkdefs.h>


near the start of the file.

Assuming that the user has pressed the 'Ok' button, the program next
checks if the user has entered a new file name, with the statement:


     } else if (fileSelect entryLength > 0) {


The 'entryLength' method returns '-1' if the dialog doesn't display an
entry box, '0' if no text is entered, or the length of the text.  If the
user has entered text, then the program can retrieve it with the
'pathEntry' method, which retrieves and prints the entry with this line.


     printf ("%s\n", fileSelect pathEntry);



Once again, the dialog returns a 'String' that is the concatenation of
the current directory and the filename that the user entered.  To
retrieve the entry box's text alone, programs can use the 'textEntry'
method instead of 'pathEntry'.

Finally, the program checks how many items the user selected from the
directory entries.  The program does this with the 'nItemsSelected'
method.


     } else if (fileSelect nItemsSelected > 1) {


If 'nItemsSelected' returns an 'Integer' greater than one, the program
can retrieve all of the entries as a list, with the 'selectedItems'
method, and their position in the list with the 'selectedItemsN' method.


     fileSelect selectedItems itemTextOut;
     fileSelect selectedItemsN itemNOut;


These methods take one argument, a 'List' object, here 'itemTextOut' and
'itemNOut', to which the method adds either the list item text or
ordinal position of each selected directory entry.

In the case where the user has selected only a single directory entry
(i.e., 'nItemsSelected' returns '1'), the program can use the
'selectedItemN' and 'selectedItemText' methods, as in this statement,
which prints the information about a single entry.


     printf ("%d: %s\n",
             fileSelect selectedItemN,
             fileSelect selectedItemText);


Resources
---------

Further information about modifying resource entries is given in the
'resources' instance variable section.  *Note PaneResources::.

The dialog's subpanes use their own resources, but this class defines a
few shortcuts that the subpanes inherit: 'backgroundColor',
'foregroundColor', 'messageColor', and 'messageText'.

'backgroundColor'
     Defines the color of the window background.  The default is 'gray'.

'foregroundColor'
     The fill color of the subpanes.  The default is 'gray'.

'listROPx'
'listRWPx'
     The distance in pixels between the bottom of the file list and the
     bottom of the window, in pixels.  The values determine,
     respectively whether to display the dialog's buttons directly
     beneath the list, or to display a text entry box between the file
     list and the buttons.

'messageColor'
     The color used by the directory path label.  The default is
     'black'.

'messageText'
     The text of the path label's heading.  The default is
     'Directory:\n'.

'pad'
     The amount of space in pixels between the dialog window's edges and
     the component subpane's boundaries.  The default is '0'.

'useEntryBox'
     A boolean value that determines whether the dialog box displays a
     text entry box.  The default is 'false'.

Instance Variables
------------------

In addition to the instance variables defined in superclasses (like
'lbutton, rbutton,' and 'label', which are defined in 'X11YesNoBoxPane'
class; 'entryPane', defined in 'X11TextEntryBox'; and 'listPane', which
is defined in 'X11ListBox' class), the 'X11FileSelectDialog' class
defines the following instance variables.

'chDirDoubleClick'
     A 'Boolean' that, if 'true', requires a double mouse click to
     change directories.  If this variable is false, then the dialog
     changes directories with a single click.

'dirPattern'
     A 'String' that contains the file glob of the directory that the
     dialog displays initially.  The default is '.' (i.e., the current
     directory).

'dotFiles'
     If true, include hidden files (i.e., files whose names begin with
     '.') in the directory listing.

'targetPath'
     A 'String' that contains the fully qualified path of the directory
     that is being displayed.  The dialog object fills in the value
     whenever it compiles a new list of directory contents.

'useEntryBox'
     A 'Boolean' that determines whether the dialog should display an
     entry box or check for text entry operations.  The default is
     'false'.

'waitCursor'
     A 'X11Cursor' item that defines the wait mouse pointer that the
     dialog can display when building directory lists.

Instance Methods
----------------

'buttonClick (void)'
     Returns an 'Integer' with one of the following values.


          FILESELECT_LBUTTON
          FILESELECT_RBUTTON
          FILESELECT_BUTTON_NONE


     These values are defined in 'ctalkdefs.h'.  Programs can include
     the statement:


          #include <ctalkdefs.h>


     near the start of the file.

'buttonText (void)'
     Returns a 'String' that contains the text of the button that the
     user has clicked, or NULL if no button has been clicked.

     To reset the button, programs should use the 'clearClick' method,
     which is defined in 'X11ButtonPane' class; for example:


          myDialog lbutton clearClick;

          _... or ..._

          myDialog rbutton clearClick;


'chDir (ItemBox ITEM)'
     Changes the working directory of the dialog (and the program that
     opens it) to the directory whose name is contained in 'item'.  If
     'item' contains '..', the the new directory is the parent directory
     of the current directory.

'draw (void)'
     Redraws the dialog's label, list and button subpanes.  Redrawing of
     the text entry pane, if it is displayed, is handled separately.

'entryLength (void)'
     Returns the length of the text entered in the dialog's entry box,
     or '-1' if the dialog does not display a text entry box.

'getExpandedDir (String DIRPATTERN)'
     Retrieves the contents of the directory named in DIRPATTERN, which
     the method qualifies and stores in the 'targetPath' instance
     variable.

     The method then constructs a sorted list of the directory's
     contents, which it stores in 'listPane's items' instance variable.
     In order to use these items directly, programs could use an
     expression similar to this one.


          myFileDialog listPane items


'initWidgets (void)'
     Creates the subpane objects and adds them to the dialog's window
     when the dialog is first opened.  Sets the 'initialized' instance
     variable (defined in 'X11YesNoBoxPane') to 'true'.

'makeItem (String ITEMTEXT)'
     Creates an 'ItemBox' object (which is defined in 'X11ListPane'
     class), with the text of the object, the item's boundaries and
     position in pixels.

'new (String PANENAME)'
     The 'X11FileSelectDialog' constructor.  The argument, a 'String',
     is the name of the new dialog object.

     Note: The 'X11FileSelectDialog' class adds the 'fileMode' instance
     variable to 'ItemBox' class, so it's necessary to make sure that
     the 'ItemBox' class, which is defined in 'X11ListPane'.  In
     'X11FileSelectDialog' class, the 'X11ListPane' class should be
     loaded automatically when the 'listPane' instance variable is
     created.

'onExpose (Object SUBPANE, InputEvent EVENT)'
'onListClick (Object SUBPANE, InputEvent EVENT)'
'onResize (Object SUBPANE, InputEvent EVENT)'
'subPaneButton (Object SUBPANE, InputEvent EVENT)'
     The 'X11FileSelectDialog's' event handlers.  If the dialog handles
     events similarly to the operations in superclasses, then Ctalk uses
     event handlers defined in 'X11FileSelectDialog's' superclasses.

'nItemsSelected (void)'
     Returns an 'Integer' with the number of list entries that are
     currently selected.

'pathEntry (void)'
     If the dialog displays a text entry box, and the user has entered
     the name of a new file in it, returns the fully qualified path of
     the entry (i.e., the current directory path plus the name of text
     entry).  If the dialog does not display an entry box, or the entry
     box contains no text, the method returns an empty string.

'refresh (void)'
     Updates the dialog window with the contents of the dialog's
     subpanes.

'selectedItems (List SELECTEITEMSOUT)'
     Stores the text of each item that the user has selected in
     SELECTEDITEMSOUT.

'selectedItemN (void)'
     If the user has selected a single directory entry, returns the
     ordinal position of the item (counting from 0) as an 'Integer'.

'selectedItemsN (List SELECTEITEMSOUT)'
     Stores the ordinal position of enach item, counting from zero ('0')
     that the user has selected in SELECTEDITEMSOUT.  Each of the
     elements in in SELECTEDITEMSOUT is an 'Integer' object.

'selectedItemText (void)'
     If the user has selected a single directory entry, returns the text
     of that item as a 'String'.

'show (void)'
     The main dialog box loop.  This creates the dialog's subpanes and
     attaches them to the main dialog window.  If the dialog has already
     been popped up, maps the dialog on the display.  Contains the event
     loop.  When the dialog is closed, the method returns to the calling
     program.

'textEntry (void)'
     If the dialog displays a text entry box, and the user has entered a
     file name in it, returns a 'String' that contains the text of the
     entry.  If the dialog does not display an entry box, or if the
     entry box does not contain any text, returns and empty string.

'updateLabel (String QUALPATH)'
     Updates the dialog's label with the name of the directory that is
     being displayed in QUALPATH.


File: ctalk.info,  Node: X11TextPane,  Next: X11TextEditorPane,  Prev: X11FileSelectDialog,  Up: Classes

'X11TextPane' Class
-------------------

'X11TextPane' objects display text within a X window.  The class defines
methods to display text when opening or resizing a window, and scrolling
through the text.

The Ctalk distribution's, 'demos,' subdirectory contains several example
applications of 'X11TextPane' objects.

Viewing Text
............

With a 'X11TextPane' window open, the class provides the following
keyboard commands.


     Key(s)                 Action
     ------                 ------
     j, Control-N, <Up>     Scroll the text down by one line.
     k, Control-P, <Down>   Scroll the text up by one line.
     Control-V              Scroll the text down one screenful.
     Control-T              Scroll the text up one screenful.
     Control-Q              Go to the start of the text.
     Control-Z              Go to the end of the text.
     Escape, Control-C      Close the window and exit the program.


Adding and Formatting Text
..........................

To display text, the class provides the methods 'addText', 'putStr', and
'printOn'.

The 'addText' method wraps long lines to fit within the window's viewing
area, and recognizes newline characters as hard line breaks and inserts
soft line breaks where necessary.  The methods 'putStr' and 'printOn'
can display shorter items of text at specific X,Y positions.

For word wrapped text, each member of the 'textList' instance variable
(described below) is a 'TextBox' object, which is an iternal class that
is used exclusively by '__ctalkWrapText' library function and the
'displayText' method.

The class supports both X bitmapped fonts and the X11FreeTypeFont
outline font libraries.  Applications enable outline font support by
calling the 'X11FreeTypeFont' method 'initFontLib' at the start of the
program.

In addition, the class supports different typefaces and simple line
formatting with a small set of HTML-like formatting tags.

     Tag(s)                Action
     ------                ------
     <b>, </b>             Start/end boldface type.
     <i>, </i>             Start/end italic (or oblique) type.
     <center>, </center>   Start/end a centered line of text.


Instance Variables
------------------

'leading'
     An 'Integer' that contains the extra space between lines, in
     pixels.  Its value depends on the font that the program uses.  The
     dimensions of Xlib bitmap fonts seems to provide enough space
     without adding any extra space.  Outline fonts, however, seem to
     need this.  The default is 2 (pixels), which the program can set
     whenever it selects a font.  Currently, this variable has no effect
     with Xlib fonts, though.

'lineHeight'
     An 'Integer' that contains the height of a line in pixels.  Its
     value is set when the program selects a font.  The default is 12
     pixels, which is the value used whenever a program doesn't specify
     any fonts.  The total lineHeight is the height of the tallest
     character ascent + the longest character descent, and optionally,
     any leading, either added by the font designer or the X11TextPane
     object.  Refer to the 'font' method, below.

'scrollHeight'
     An 'Integer' that contains the number of lines that the text moves
     when scrolling by one screenful.  Its value is


          textPaneObject scrollHeight = textPaneObject viewHeight -
                                          textPaneObject scrollMargin


'scrollMargin'
     An 'Integer' that contains the number of lines to overlap when
     scrolling by pagefuls.  Its default value is 3.

'text'
     A 'String' that contains the unformmated text to be displayed in
     the window.  Formatting raw text for display is done by the
     'addText' method, below.

'textList'
     This 'List' object contains the output of the word wrapping
     routines.  Each item of the 'List' is a 'TextBox' object, an
     internal class that stores information about each word of the text.

'textLines'
     An 'Integer' that contains the number of lines of text after it is
     formatted.

'viewStartLine'
     An 'Integer' that contains the number of the first text line that
     is visible in the window.

'requestClose'
     A 'Boolean' that indicates whether the 'X11TextPane' object has
     requested to be closed, normally in response to an Escape or
     Control-C keypress.

'viewXOffset'
     An 'Integer' that contains the left margin of the text when
     displayed in the window.

'viewHeight'
'viewWidth'
     'Integer' objects that contain the width and height of viewable
     area, in characters.  These are normally determined by the font
     that the program selects, and after the program calculates the line
     height (refer to the 'font' method, below).  The 'X11TextPane'
     class adjusts for variable width fonts and faces whenever necessary
     (and possible, in some cases).

     If the program has selected a font, the 'X11TextPane' class
     calculates the width and height of the viewing area like this.


          self viewHeight = self size y / self lineHeight;
          self viewWidth = self size x / self fontVar maxWidth;


     If the program doesn't select any fonts, the class uses 14 pixels
     as the height of each character and 12 pixels as the character
     width.

Instance Methods
................

'addText (Object TEXT)'
     Adds the argument's text to the receiver pane's 'text' instance
     variable, then word-wraps the entire text into the 'textList'
     instance variable.

'attachTo (Object PARENTPANE)'
     Attaches the 'X11TextPane' object to its parent pane.  The parent
     pane should always be a 'X11PaneDispatcher' object.

'cursorPos (Integer X, Integer Y)'
     Set the pane's cursor to the coordinates given as arguments.

'background (String COLORNAME)'
     Set the background color of the text pane.  See the note for
     'X11Bitmap' class's 'background' method.  *Note X11Bitmap::.

'clear (void)'
     Clear the pane to the background color.

'displayText (void)'
     Update the pane's text.  The pane's window is updated at the next
     'refresh' message (see below).

'faceRegular (void)'
'faceBold (void)'
'faceItalic (void)'
'faceBoldItalic (void)'
     Selects the typeface of the currently selected font.  The font
     should be selected by a previous call to the 'font' method (below).
     The 'font' call gathers information about the type variations if
     the typeface is available.

'font (String FONT_DESCRIPTOR)'
     Loads the bitmap font named by FONT_DESCRIPTOR and the bold,
     italic, and bold italic typefaces if they are available, and makes
     the font named by the argument the currently selected the receiver
     Pane's currently selected font.

     If a program uses outline fonts, it has more freedom to decide when
     to select the fonts, because the font libraries operate
     independently of the program's connection to the GUI. *Note
     X11FreeTypeFont::.

     Programs that use Xlib bitmap fonts, however, need to wait until
     the connection to the GUI is opened, with a call to
     'openEventStream' (class 'X11Pane').  *Note X11Pane::.

     Here's a code snippet from 'X11TextPane' class.


            X11FreeTypeFont new ftFont;
            Integer new ftMaxCharWidth;

            self fontDescStr = fontDesc;
            self fontVar getFontInfo fontDesc;
            (X11Bitmap *)self paneBuffer font fontDesc;

            if (ftFont libIsInitialized) {
              self lineHeight = ftFont textHeight "ghyl";
              self lineHeight += self leading;
              ftMaxCharWidth = ftFont textWidth "M";
              self viewWidth = self size x / ftMaxCharWidth;
            } else {
              /* Note that we don't add the leading to the lineHeight here */
              self lineHeight = self fontVar height;
              self viewWidth = self size x / self fontVar maxWidth;
            }
            self viewHeight = self size y / self lineHeight;


'foreground (String COLORNAME)'
     Set the forground color of the text pane.  See the note for
     'X11Bitmap' class's 'foreground' method.  *Note X11Bitmap::.

'gotoXY (Integer X, Integer Y)'
     Set the pane's cursor to the coordinates given as arguments.  The
     coordinates are the number of horizontal and vertical pixels from
     the pane's top-left corner.

     This method is a synonym for 'cursorPos', above.

'new (String PANENAME)'
     Creates a 'X11TextPane' object and initializes the pane's event
     handlers and other instance data.

     If the argument list contains more than one name, create
     'X11TextPane' objects with the names given by the arguments.

'printOn (char *FMT, ...)'
     Print the argument, which is a 'printf(3)' style format string with
     arguments for the format conversion specifiers, in the pane's
     buffer at the position given by the pane's software cursor.  To
     update the visible window with the pane buffer's contents, call the
     'refresh' method (below), after calling this function.

'putChar (Character C)'
     Write a character in the pane's window at the pane's cursor
     position.

'putStr (String S)'
     Write a string in the pane's window at the pane's cursor position.

'refresh (void)'
     Update the text displayed in the pane's window.

'subPaneDestroy (Object SUBPANEREFERENCE, InputEvent EVENT)'
     The class's destructor method.  This method deletes only the data
     associated with the pane object's window, not the pane object
     itself, which is treated like any other object.

'subPaneExpose (Object SUBPANEREFERENCE, InputEvent EVENT)'
     The class's 'EXPOSE' event handler.  Refreshes the main window from
     the pane's text buffer.

'subPaneKbdInput (Object SUBPANEREFERENCE, InputEvent EVENT)'
     The handler for 'KEYPRESS' and 'KEYRELEASE' events from the window
     system.

'subPaneResize (Object SUBPANEREFERENCE, InputEvent EVENT)'
     The handler for 'RESIZENOTIFY' events from the window system.


File: ctalk.info,  Node: X11TextEditorPane,  Next: Symbol,  Prev: X11TextPane,  Up: Classes

'X11TextEditorPane' Class
-------------------------

Objects of 'X11TextEditorPane' class create a X window which displays
text, and editing commands to perform basic text editing operations.

There is an example text editor program that demonstrates a
'X11TextEditorPane' object's use at the end of this section.

Editing Commands
................

The set of editing commands that a 'X11TextEditorPane' object uses is
given here, along with their key bindings.  You can bind them to
different keys by modifying the 'handleKbdInput' method.

     Right, Ctrl-F       Next character
     Left, Ctrl-B        Previous character
     Up, Ctrl-P          Previous line
     Down, Ctrl-N        Next line
     PgDn, Ctrl-V        Next page
     PgUp, Ctrl-T        Previous page
     Home, Ctrl-A        Start of line
     End, Ctrl-E         End of line
     Ctrl-Q              Start of text
     Ctrl-Z              End of text
     Ctrl-D              Delete character under cursor

     Alt-V               Paste text from the clipboard at the insertion point.
     Alt-C               Copy the selected text to the clipboard.
     Alt-X               Delete selected text and save the text on the clipboard.

     Backspace           Delete previous character.  If selecting text, delete
                         the selection.
     Del                 Delete the character under the cursor, or the
                         previous character if at the end of the text.
                         If there is selected text, delete the selection.
     Esc                 Close the window and exit the program.

     Mouse-1             Move the insertion point cursor to the click.
                         Click and drag the pointer to select text.
     Mouse-2             Paste text of the X selection at the insertion point.


Cutting and Pasting Text with the X Selection
.............................................

'X11TextEditorPane' objects can copy text selections to the X primary
selection, and paste selected text from other X programs into the
program's text.

To select text to be pasted into another application, press the left
pointer button and drag the pointer across the text that you want to
select.  The text should be highlighted with the color defined in the
'selectionBackgroundColor' instance variable.

Then, switch to the window that you want to paste the text into, and
press the center pointer button at the point where you want to insert
the text (or press the left and right buttons simultaneously on machines
with two buttons).

Conversely, to paste text into the 'X11TextEditorPane' object's
contents, select the text in the other application's window, then switch
to the 'X11TextEditorPane' object's window, and press the center pointer
button at the point where you want the text inserted.

If the program has text selected and another program tries to place its
contents in the X primary selection, the class will allow the selection
ownership to change to the other program.  Any text that was selected in
the 'X11TextEditor' pane's window will no longer be selected.

In general, X programs aren't required to send their to the display's X
selection buffers.  Many programs only use selected contents internally,
and may require another command to send the content to the X display's
primary selection buffer.  'X11TextEditorPane' objects maintain the
contents of its selection buffer continuously when selecting, but they
only send the contents to the X display's primary selection when another
program requests it.

Cutting and Pasting Text with the X Clipboard
.............................................

'X11TextEditorPane' objects also provide generic support for copying and
pasting text using the X clipboard.

Many graphical environments provide their own clipboard implementation,
and 'X11TextEditorPane' class doesn't yet support them.  For vanilla
clipboard implementations, however, selecting text for the clipboard is
similar to the the X selection's process: press the left pointer button
and drag the pointer across the text that you want to select.  The text
should be highlighted with the color defined by the
'selectionBackgroundColor' instance variable.

However, the clipboard operations' are performed entirely with
keystrokes, and the key bindings are customizable, even though most text
oriented applications use a standard set of key definitions for working
with the clipboard:


     Alt-X         Cut the selected text and save it on the clipboard.
     Alt-C         Copy the selected text to the clipboard, without deleting it.
     Alt-V         Paste the text from the clipboard at the point where the
                   user clicks.


Fonts
.....

The demonstration program, 'demos/x11/ctedit.ca', provides options to
change the default font and point size.  The X11 utility programs
'xfontsel(1)' and 'fc-list(1)' can display the X bitmap fonts and the
Xft library's scalable fonts that are available on the machine,
respectively.

Programs configure X fonts within the window's graphics context, using
the instance variable 'fontVar', which is inherited from 'X11Pane'
class.

FreeTypeFonts need to be configured separately from the X window, but
the parent 'X11Pane' object also defines the 'ftFontVar' instance
variable, so the program can configure outline fonts before entering its
event loop.

If a program is to be configurable for different machines, it should
check which of the font libraries are present on the system, and which
of the 'fontVar' or 'ftFontVar' instance variables the program has
configured in the program's initialization.

The 'X11TextEditorPane' class uses monospaced fonts exclusively.  If a
program requests a proportionally spaced font, the pane's libraries
won't maintain alignment between the displayed text and editing
operations.

The sections, 'X11FreeTypeFont' and 'X11Font' contain more information
about how to select fonts.  *Note X11FreeTypeFont::, *Note X11Font::.

Instance Variables
..................

'bufLength'
     An 'Integer' that records the size of the object's text buffer.
     The class adjusts the buffer's size automatically if necessary.

'button'
     An 'Integer' that records the state of the mouse buttons, i.e.,
     whether they are pressed or not.  The values that the the variable
     might contain are composed of these definitions.


          #define BUTTON1MASK  (1 << 0)
          #define BUTTON2MASK  (1 << 1)
          #define BUTTON3MASK  (1 << 2)


'foregroundColor'
     A 'String' that contains the window's foreground color.  The
     variable is included here to facilitate drawing the cursor in
     reverse video.  The 'backgroundColor' instance variable is declared
     in 'X11Pane' class.  *Note X11Pane::.

     An 'Integer' that defines the right margin in character columns.
     Setting this to zero '0' sets the line width limit to the line
     length, so the line width in character columns is calculated as:


          lineWidth = (window_width_px - left_margin_px - right_margin_px) /
                         character_width_px;


'rightMargin'
     The distance in pixels from the right edge of the window, leftward
     to the right-hand limit of each line's length.

'point'
     An 'Integer' that contains the current position in the text where
     editing occurs.

'selectionBackgroundColor'
     A 'String' that contains the background color of selected text.
     The foreground color is the same as normal text.

'sStart'
'sEnd'
'selecting'
     The 'Integer' variables 'sStart' and 'sEnd' record the beginning
     and end of selected text as character indexes into the text.  The
     'Boolean' variable 'selecting' is true while the pointer is being
     dragged across text while Button 1 is pressed.

'shiftState'
     An 'Integer' that records whether the Shift of Control keys are
     currently pressed.

'textLength'
     An 'Integer' that records the length of the object's text.

Instance Methods
................

'attachTo (Object PARENT_PANE)'
     Attach a 'X11TextEditorPane' object to its parent pane, which is
     typically a 'X11PaneDispatcher' object.  This method initializes
     the size of the pane's window and buffers to the parent pane's
     dimensions, and positions the pane at the upper left-hand origin of
     the main window.

'background (String COLORNAME)'
'foreground (String COLORNAME)'
     Sets the foreground and backgrounds color of the pane's window and
     buffers.

'clearSelection (void)'
     Sets the 'sStart' and 'sEnd' instance variables to '0', cancelling
     text selection.

'defaultFormat (void)'
     Sets the document-wide margins and text text colors.  If the pane
     is using an 'X11FreeTypeFont' object to render text, the font needs
     to be configured before calling this method.  *Note
     X11FreeTypeFont::.

'displayText (void)'
     Displays the text and editing cursor.  Programs should call this
     method as soon as possible after the program starts the X event
     loop (which it does by calling the 'X11TerminalStream :
     openEventStream' method), and after every editing operation.

'gotoChar (Integer N)'
     Sets the 'point' instance variable to the N'th character in the
     text.  If N is greater than the length of the text, sets 'point' to
     the end of the text.

'new (String PANENAME)'
     Initializes the 'X11TextEditorPane' object's event handlers, and
     calls constructors in the 'X11TextEditorPane's' superclasses to
     perform addition initialization.  The method 'attachTo', declared
     in 'X11TextPane' class, performs the actual dimensioning of the
     pane and its buffers.  *Note X11TextPane::.

'subPaneKbdInput (X11TextEditorPane SUBPANE, InputEvent EVENT)'
     Handles Keypress and KeyRelease events from the X server.  It's
     possible to reconfigure the editing commands by modifying this
     method.

     The method works in conjuction with the Ctalk library's editing
     functions to translate alphanumeric and punctuation characters with
     the correct shift and control state, and to transmit special keys
     like arrow keys and Home/End keys untranslated.

'subPaneButtonPress (X11TextEditorPane SUBPANE, InputEvent EVENT)'
     The handler for button press and button release events.  This
     method sets the value of the 'button' instance variable, in
     addition to performing other tasks.

'subPaneMotionNotify (X11TextEditorPane SUBPANE, InputEvent EVENT)'
     The handler method for pointer motion events.

'subPaneResize (X11TextEditorPane SUBPANE, InputEvent EVENT)'
     Handles resizing the 'X11TextEditor' pane's dimensions in response
     to a window resize event.  This method is a no-op in the current
     release.

'subPaneSelectionClear (X11TextEditorPane SUBPANE, InputEvent EVENT)'
     Updates the program's state after receiving a a SelectionClear
     event.  Normally this occurs when another program requests the X
     primary selection.  The method updates this program's state so that
     it is no longer selecting, and redraws the text.

Example Text Editing Program
............................

     /*
       ctedit.ca - Basic text editor using X11TextEditorPane class.

       Usage:

         ctedit [<options>] <filename>

       Typing, "ctedit -h" displays a list of options.

       Pressing Esc or selecting "Close" from the window menu
       exits the program and saves the edited text.

       If <filename> exists, ctedit renames the previous version
       of the file to <filename>.bak.  If <filename> doesn't
       exist, ctedit creates a new file.

       The editing commands are set in the X11TextEditorPane :
       handleKbdInput method.  They are:

          Right, Ctrl-F       Next character
          Left, Ctrl-B        Previous character
          Up, Ctrl-P          Previous line
          Down, Ctrl-N        Next line
          PgDn, Ctrl-V        Next page
          PgUp, Ctrl-T        Previous page
          Home, Ctrl-A        Start of line
          End, Ctrl-E         End of line
          Ctrl-Q              Start of text
          Ctrl-Z              End of text
          Ctrl-D              Delete character under cursor
          Backspace           Delete previous character
          Del                 At the end of the text, delete the
                              previous character.  Otherwise delete
                              the character under the cursor.
          Esc                 Close the window, save the edited text,
                              and exit the program.
      */

     #define WIN_WIDTH 500
     #define WIN_HEIGHT 340
     #define WIN_X 25
     #define WIN_Y 30
     #define FIXED_FONT "fixed"
     #define DEFAULT_BG "white"
     #define DEFAULT_FG "black"
     #define DEFAULT_FT_FONT "DejaVu Sans Mono"
     #define DEFAULT_FT_PTSIZE 12.0

     Application new ctEdit;
     String new geomString;
     String new infileName;
     String new xFontName;
     String new ftFontName;
     Float new ftFontSize;
     String new bgColor;
     String new fgColor;

     Boolean new createFile;

     Boolean new useFtFonts;
     X11FreeTypeFont new ftFont;
     Boolean new useXFont;

     void exit_help () {
       printf ("usage: ctedit [-h] | [-g <geom>] [-fg <color>] "
     	  "[-bg <color>] [-fn <font> ] <filename>\n");
       printf ("-bg <color>    Set the window background to <color>.\n");
       printf ("-fg <color>    Display the text using <color>.\n");
       printf ("-fn <font>     Use the X <font> to display the text. See xfontsel(1).\n");
       printf ("-ft <font>     Use the FreeType <font> to display the text. See\n");
       printf ("               X11FreeTypeFont class.\n");
       printf ("-g  <geom>     Set the window geometry to <geom>. See XParseGeometry (3).\n");
       printf ("-h             Print this message and exit.\n");
       printf ("-xfonts        Use X bitmap fonts, even if outline fonts are available.\n");
       exit (1);
     }

     /* UNIX-compatible line ending. */
     #define LF 10

     X11TextEditorPane instanceMethod writeOutput (String infileName) {
       "Create a backup of the previous version of the file, if any,
        and check that the text ends with a UNIX-standard newline
        (ASCII 10) character."
       WriteFileStream new writeFile;
       Character new c;

       c = self text at (self text length - 1);
       if (c != LF) {
         self text += "\n";
       }

       if (!createFile)
         writeFile renameFile infileName, infileName + ".bak";
       writeFile openOn infileName;
       writeFile writeStream (self text);
       writeFile closeStream;

     }

     Application instanceMethod commandLineOptions (void) {
       Integer new i, nParams;
       String new param;


       nParams = self cmdLineArgs size;
       for (i = 1; i < nParams; i++) {

         param = self cmdLineArgs at i;

         if (param  == "-g") {
           ++i;
           geomString = self cmdLineArgs at i;
           continue;
         }
         if (param == "-fn") {
           ++i;
           xFontName = self cmdLineArgs at i;
           continue;
         }
         if (param == "-bg") {
           ++i;
           bgColor = self cmdLineArgs at i;
           continue;
         }
         if (param == "-fg") {
           ++i;
           fgColor = self cmdLineArgs at i;
           continue;
         }
         if (param == "-ft") {
           ++i;
           ftFontName = self cmdLineArgs at i;
           continue;
         }
         if (param == "-xfonts") {
           useXFont = True;
           continue;
         }
         if (param == "-pt") {
           ++i;
           ftFontSize = (self cmdLineArgs at i) asFloat;
           continue;
         }
         if (param == "-h" || param == "--help" || param == "--h" ||
     	param at 0 == '-') {
           exit_help ();
         }

         infileName = param;

       }

     }

     Application instanceMethod winDimensions (void) {
       if (geomString length > 0) {
         self parseX11Geometry geomString;
         if (self winWidth == 0) {
           self winWidth = WIN_WIDTH;
         }
         if (self winHeight == 0) {
           self winHeight = WIN_HEIGHT;
         }
         if (self winXOrg == 0) {
           self winXOrg = WIN_X;
         }
         if (self winYOrg == 0) {
           self winYOrg = WIN_Y;
         }
       } else {
         self winWidth = WIN_WIDTH;
         self winHeight = WIN_HEIGHT;
         self winXOrg = WIN_X;
         self winYOrg = WIN_Y;
       }
     }

     Application instanceMethod findFtFonts (void) {

       if (useFtFonts && !useXFont) {
         ftFont initFontLib;
         ftFont selectFont ftFontName, 0, 80, 72, ftFontSize;
       }

     }

     int main (int argc, char **argv) {
       X11Pane new xPane;
       X11PaneDispatcher new xTopLevelPane;
       X11TextEditorPane new xEditorPane;
       InputEvent new e;
       Exception new ex;
       X11Cursor new watchCursor;
       ReadFileStream new readFile;
       String new winTitle;

       geomString = "";
       xFontName = FIXED_FONT;
       bgColor = DEFAULT_BG;
       fgColor = DEFAULT_FG;
       infileName = "";
       useFtFonts = True;
       useXFont = False;
       ftFontSize = DEFAULT_FT_PTSIZE;
       ftFontName = DEFAULT_FT_FONT;

       ctEdit parseArgs argc, argv;
       ctEdit commandLineOptions;
       ctEdit winDimensions;

       if (ftFont version < 10) {
         useFtFonts = false;
       } else {
         ctEdit findFtFonts;
       }


       if (infileName length == 0) {
         exit_help ();
       }

       if (!readFile exists infileName) {
         createFile = true;
         winTitle = infileName + "   (New file)";
       } else {
         readFile openOn infileName;
         xEditorPane text = readFile readAll;
         readFile closeStream;
         winTitle = infileName;
         createFile = false;
       }

       xPane initialize ctEdit winXOrg, ctEdit winYOrg,
         ctEdit winWidth, ctEdit winHeight, ctEdit geomFlags, winTitle;

       xTopLevelPane attachTo xPane;
       xEditorPane attachTo xTopLevelPane;
       xPane map;
       xPane raiseWindow;
       watchCursor watch;

       xPane openEventStream;

       /* This sets the maximum line width to the width of the window. */
       xEditorPane lineWidth = 0;

       if (!useFtFonts || useXFont) {
         xEditorPane foreground fgColor;
         xEditorPane font xFontName;
         xEditorPane defaultFormat;
       } else {
         xEditorPane defaultFormatFT ftFont;
       }

       xEditorPane background bgColor;
       xEditorPane clear;

       xPane defaultCursor;

       while (TRUE) {
         xPane inputStream queueInput;
         if (xPane inputStream eventPending) {
           e become xPane inputStream inputQueue unshift;
           xPane subPaneNotify e;
           if (ex pending)
      	ex handle;
           switch (e eventClass value)
     	{
     	  /*
     	   *  Handle both types of events in case the window
     	   *  manager doesn't distinguish between them.
     	   */
     	case MOVENOTIFY:
     	  break;
     	case RESIZENOTIFY:
     	  break;
     	case EXPOSE:
     	  xEditorPane displayText;
     	  break;
     	case WINDELETE:
     	  xEditorPane writeOutput infileName;
      	  xPane deleteAndClose;
     	  exit (0);
     	  break;
     	default:
     	  break;
     	}
         } else {
           if (xEditorPane requestClose) {
     	xEditorPane writeOutput infileName;
     	xPane deleteAndClose;
     	exit (0);
           }
         }
       }
     }


File: ctalk.info,  Node: Symbol,  Next: Key,  Prev: X11TextEditorPane,  Up: Classes

'Symbol' Class
--------------

'Symbol' class objects represent memory locations.  They can refer to
objects, C variables, buffers, I/O ports, and other data located in
memory.

As an alternative, if you receive an 'Unimplemented C type' warning, you
can store various types of C data in 'Symbol' objects.  *Note Objects in
Function Arguments::.

A unary '*' operator behaves similarly to the C operator.  That is, it
refers to the value of the 'Symbol' object, not the object itself.  The
following example might make this clearer.


     int main () {

       Symbol new sym1;
       Symbol new sym2;
       Symbol new sym3;
       Integer new i;

       i = 2;

       sym3 = sym1;   /* Save the original value of sym1. */

       sym1 = i;
       printf ("%d\n", sym1);

       *sym2 = i;
       printf ("%d\n", *sym2);

       sym1 = sym3;  /* Restore sym1 to the original object. */

       i = 4;

       *sym1 = i;

       printf ("%d\n", *sym1);
     }


Instance Variables
------------------

'value'
     The value of a 'Symbol' is a hexadecimal memory address.

Instance Methods
................

'* (void)'
     The '*'.  A shortcut for the 'getValue' method, below.

'= (void *V)'
     Assign a reference to the argument as the value of the receiver.
     If V is also a 'Symbol' object, simply copy the reference.  This
     method is a synonym for 'symbolReference', below.  If you want to
     use multiple levels of object references and dereferences, see the
     'addressOf' method in 'Object' class *Note Object::, and the
     'deref' method, below.

'asAddrString (void)'
     Returns a 'String' object with the formatted hexadecimal address of
     the object pointed to by the receiver.

'asString (void)'
     Returns the receiver's value as a 'String' object with the value of
     the 'char' string that the 'Symbol' receiver object points to.  The
     result object has the same name as the receiver and the class of
     'String'.

'basicObject (char *NAME, char *CLASSNAME, char *SUPERCLASSNAME, char *VALUE_EXPR)'
     Create a basic object and make the receiver's value point to it.
     The new object has the scope 'LOCAL_VAR|VAR_REF_OBJECT' and a
     reference count of 1.

     Referencing the object with a 'Symbol' makes it easy to create
     objects and then assign them to C variables in the calling method
     or function.  For example,


            Symbol new s;
            OBJECT *int_object;

            s basicObject "new_int", "Integer", "Magnitude", "10";

            int_object = s getValue;

            printf ("%d\n", int_object value);


'deref (void)'
     Return the object referred to by the receiver.  This method is
     functionally equivalent to the C '*' operator.

'getValue (void)'
     Return the object that the receiver's value (previously set by '='
     or 'symbolReference') refers to.  If the address doesn't refer to
     an object, returns the receiver and generates an exception, which
     the program can handle in whatever manner is necessary.  In some
     cases, the internals of Ctalk's object-to-C routines can also
     generate an warning message.

     Note that when assigning a non-object data address to a C variable
     like a 'void *', Ctalk allows both of these expressions:


           void *myVoidPtr;

           myVoidPtr = mySymbol;

           myVoidPtr = *mySymbol;   /* Generates an exception. */


'name (void)'
     Return a new 'String' object containing the receiver's name.

'removeValue (void)'
     Remove the reference to the target object from the receiver.
     Delete the target object if there are no further references to it.

'symbolReference (void *V)'
     Return a new 'String' object containing the receiver's name.

