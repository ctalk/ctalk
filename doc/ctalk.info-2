This is ctalk.info, produced by makeinfo version 6.5 from ctalk.texi.

INFO-DIR-SECTION Ctalk
START-INFO-DIR-ENTRY
* ctalk: (ctalk).	The Ctalk language reference manual.
END-INFO-DIR-ENTRY

This file documents Ctalk version 0.0.65.

Copyright (C) 2007-2015 Robert Kiesling

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the section entitled, "GNU
Free Documentation License."


File: ctalk.info,  Node: ANSITextBoxPane,  Next: ANSITextEntryPane,  Prev: ANSIScrollPane,  Up: Classes

'ANSITextBoxPane' Class
-----------------------

An 'ANSITextBoxPane' object displays a text-mode dialog box with an
application's text in the window, and a "Dismiss" button at the bottom
of the display area.  Like other widgets that are subclasses of
'ANSIWidgetPane,' you can close the window by pressing 'Esc' or 'Enter',
and you can scroll through the text with the terminal's up and down
arrow keys, the 'vi' keys 'j' and 'k', and the 'emacs' keys 'C-n' and
'C-p'.

Here is a brief example of how to open and display text in an
'ANSITextBoxPane' object.
     int main () {
       ANSITextBoxPane new textBox;

       textBox resize 75, 30;

       textBox appendLine "Hello, world!";
       textBox appendLine "This is another line of text.";
       textBox appendLine "More text to follow.";

       textBox show 1, 1;

       textBox cleanup;
     }

Instance Variables
------------------

'dismissButton'
     An 'ANSIButtonPane' object that displays a "Dismiss" button at the
     bottom of the pane's display area.
'text'
     A 'List' object that contains the text to be displayed in the pane,
     one line per list element.
'viewStartLine'
     An 'Integer' object that indicates the topmost line of text to be
     displayed in the pane.
'viewHeight'
     An 'Integer' that contains the height of the pane's text display
     area.  The text display area is the width and height of the pane,
     not including a window border if any, and not including the bottom
     five lines of the pane, which is used to display the
     'dismissButton' widget.
'viewWidth'
     An 'Integer' that contains the width of the viewable text area.  As
     mentioned above, the 'viewWidth' dimension is the width of the pane
     minus the window borders, if any.
'viewXOffSet'
     An 'Integer' that contains the starting column of each line within
     the window.

Instance Methods
................

'appendLine (String TEXT)'
     Append a line to the widget's 'text' (class 'List') instance
     variable.  The text will be visible after the next 'refresh'
     message.

'cleanup (Integer LINENUMBER)'
     Delete the extra buffers that the receiver uses for screen data.
     The normal object cleanup routines delete the receiver pane itself.

'clearLine (Integer LINENUMBER)'
     Erase the line LINENUMBER in the pane's view area.

'handleInput (void)'
     Wait for the user's input from the keyboard and redisplay or
     withdraw the receiver widget depending on which key the user
     presses.

'new (String PANENAME)'
     Constructs a new 'ANSITextBoxPane' object.  The object's dimensions
     are 40 columns wide by 20 rows high, with a "Dismiss" button at the
     bottom of the window, and with a border and shadow.

     If more that one name is given in the argument list, construct new
     'ANSITextBoxPane' objects with the labels' names.

'refresh (void)'
     Redraws the receiver object and any text to be displayed in the
     pane's visible area.

'resize (Integer XSIZE, Integer YSIZE)'
     Resize the pane to the dimensions XSIZE, YSIZE.

'show (Integer XORIGIN, Integer YORIGIN)'
     Pop up the pane's window at the terminal coordinates XORIGIN,
     YORIGIN, and wait for the user's input.


File: ctalk.info,  Node: ANSITextEntryPane,  Next: ANSIYesNoBoxPane,  Prev: ANSITextBoxPane,  Up: Classes

'ANSITextEntryPane' Class
-------------------------

A 'ANSITextEntryPane' object prompts the user for text input and returns
the input to the application program.  Like other subclasses of
'ANSIWidgetPane', this class uses the methods of that class or
re-implements them as necessary.  *Note ANSIWidgetPane::.

The widget can be displayed independently; that is, it can be popped up
on its own, as in this example.
     int main () {
       ANSITextEntryPane new textEntry;
       String new inputText;

       textEntry withPrompt "Please enter some text: ";
       inputText = textEntry show 10, 10;
       printf ("\nYou typed: %s\n", inputText);
       textEntry cleanup;
     }
To pop up an 'ANSITextEntryPane' over another pane, the program must
also configure and define the widget's parent pane.
     int main () {
       ANSITerminalPane new mainPane;
       ANSITextEntryPane new textEntry;
       String new inputText;

       mainPane initialize 1, 1, 80, 24;
       mainPane refresh;

       mainPane gotoXY 29, 10;
       mainPane printOn "Parent Pane";
       mainPane gotoXY 25, 11;
       mainPane printOn "Please press [Enter].";
       mainPane refresh;

       getchar ();  /* Actual apps should use getCh, etc. */

       textEntry parent mainPane;
       textEntry withPrompt "Please enter some text: ";
       inputText = textEntry show 10, 10;
       mainPane refresh;

       printf ("\nYou typed: %s\n", inputText);

       getchar ();

       textEntry cleanup;
       mainPane cleanup;
     }

Instance Variables
------------------

'promptText'
     The text of the entry pane's prompt.  The default is an empty
     'String' object.

'inputBuffer'
     A 'String' object that contains the user's input.

'inputLength'
     The width in characters of the text entry.  The default is 20.

Instance Methods
................

'handleInput (void)'
     Process 'InputEvent' objects from the receiver's 'paneStream' input
     handle.

'inputWidth (Integer WIDTH)'
     Set the width, in characters, of the input entry box.  The default
     is 20.

'new (String PANENAME)'
     Creates a new 'ANSITextEntryPane' object.  Also uses the
     'withShadow' and 'withBorder' messages from 'ANSITerminalPane'
     class, and the 'openInputQueue' message from 'ANSITerminalStream'
     class.

     If more that one argument is given in the argument list, create new
     'ANSITextEntryPane' objects with the arguments' names.

'show (int X_ORIGIN, int Y_ORIGIN)'
     Display the receiver pane and return input from the user.

'withdraw'
     Remove the receiver widget from the display.  If the widget is
     drawn over another pane object, unmap the receiver from the parent
     pane.  If the receiver is displayed independently, clear the
     display before returning.

'withPrompt (String PROMPTTEXT)'
     Set the receiver's prompt to PROMPTTEXT.


File: ctalk.info,  Node: ANSIYesNoBoxPane,  Next: X11Pane,  Prev: ANSITextEntryPane,  Up: Classes

'ANSIYesNoBoxPane' Class
------------------------

An 'ANSIYesNoBoxPane' object presents the user with a dialog that
contains a text message and waits for the user's 'Yes' or 'No' response.

Here is an example of opening an 'ANSIYesNoBoxPane' object using
standard input and output (e.g., when displaying the pane on a xterm).
     int main () {
       ANSIYesNoBoxPane new messageBox;
       String new answer;

       messageBox withText "Do you want to quit?";
       answer = messageBox show 10, 10;
       messageBox cleanup;
       printf ("You answered, \"%s\"\n", answer);
     }

Here is an example of opening an 'ANSIYesNoBoxPane' object in a serial
terminal (for a Linux serial device).  For other systems, change the
'/dev/ttyS1' argument to the device node that connects to the serial
terminal.  It's necessary to adjust the arguments to 'setTty' to match
the terminal's settings.

     int main () {
       ANSIYesNoBoxPane new messageBox;
       String new answer;

       messageBox paneStream openOn "/dev/ttyS1";  /* Linux serial device. */
       messageBox paneStream setTty 9600, 1, 'n', 8;

       messageBox noBorder;  /* Not all terminals support line drawing characters. */

       messageBox withText "Are you sure you want to quit?";
       answer = messageBox show 10, 10;
       messageBox cleanup;
       printf ("You answered, \"%s\"\n", answer);
     }

As with any dialog widget, pressing 'Esc' or 'Return' closes the
'ANSIYesNoBoxPane' object.  The 'Tab' key selects between the "Yes" and
"No" buttons, as do the 'Y' and 'N' keys,

Instance Variables
------------------

'button1'
     The 'ANSIButtonPane' widget that controls the 'Yes' response.
'button2'
     The 'ANSIButtonPane' widget that controls the 'No' response.
     ('ANSIYesNoBoxPane' class)
'messageText'
     A 'String' object that contains the text displayed in the pane.

Instance Methods
................

'cleanup (void)'
     Delete the widget's data before exiting.

'getFocusWidgetText (void)'
     Return the text associated with the button that has the input
     focus.

'handleInput (void)'
     Wait for the user's input and return the response from the widget.

'new (NEWPANENAME'
     Create a new 'ANSIYesNoBox' object with the name given as an
     argument.  If the argument list contains more than one name, create
     'ANSIYesNoBoxPane' objects for each argument.


          ANSIYesNoBoxPane new yesnobox1, yesnobox2;


'nextFocus (void)'
     Set the input focus to the next button widget.

'noBorder (void)'
'withBorder (void)'
     Set or unset the border for the main pane and the button labels.
     These methods are equivalent to the following expressions.


            /* To display borders. */
            yesnoBox border = 1;
            yesnoBox button1 border = 1;
            yesnoBox button2 border = 1;

            /* To hide the borders. */
            yesnoBox border = 0;
            yesnoBox button1 border = 0;
            yesnoBox button2 border = 0;


     Note that not all terninals support line drawing characters.

'noBorder (void)'
'withBorder (void)'
     Set or unset the shadow for the main pane and the buttons.  The
     methods are a shortcut for these statements.


            /* To display shadows. */
            yesnoBox shadow = 1;
            yesnoBox button1 shadow = 1;
            yesnoBox button2 shadow = 1;

            /* To hide the shadows. */
            yesnoBox shadow = 0;
            yesnoBox button1 shadow = 0;
            yesnoBox button2 shadow = 0;


'show (int X_ORIGIN, int Y_ORIGIN)'
     Display the 'ANSIYesNoBoxPane' object at X_ORIGIN, Y_ORIGIN.  If
     displayed over another pane, the origin is relative to the parent
     pane's origin.  If displayed independently, the origin is relative
     the the upper left-hand corner of the terminal.

'withText (char *TEXT)'
     Defines the text that is to appear within the pane.  This method
     adjust's the pane's size to fit the text.


File: ctalk.info,  Node: X11Pane,  Next: GLXCanvasPane,  Prev: ANSIYesNoBoxPane,  Up: Classes

'X11Pane' Class
---------------

The 'X11Pane' class provides the basic methods and instance variables
for creating and displaying a window on a X display.

The 'X11Pane' class does not, itself, provide methods for moving,
resizing, or handling input or changing focus.

The 'X11TerminalStream' class handles X input events.  The 'X11Pane'
constructor 'new' also creates a 'X11TerminalStream' object in the
'X11Pane's' 'inputStream' instance variable.  There is a short example
program in the 'X11TerminalStream' section.  *Note X11TerminalStream::.

This class uses the default visual or a X window without buffering, so
applications need to be careful to handle InputEvents correctly, or
graphics drawing may result in flicker, depending how the window manager
handles X Window System events.  See the 'Ctalk Tutorial' for
information about how to use 'InputEvent' objects in applications.

However, 'X11Pane' class provides the address of the window's graphics
context in the 'xGC' instance variable, so applications that use this
class for graphical displays can create and use their own visuals if
necessary.

Instance Variables
------------------

'backgroundColor'
     A 'String' object that contains the name of the window's background
     color.  The value is the background color of the window,
     independent of the background color of any buffers used by
     subpanes.  Normally this value is set by the 'background' method,
     described below.

'borderWidth'
     An 'Integer' object that contains the window's border width in
     pixels.  The default is 1 pixel.

'container'
     A 'Symbol' that refers to a pane's container (i.e., parent) Pane
     object.  For top-level 'X11Pane' objects this value should be
     'NULL'.

'depth'
     An 'Integer' that contains the default depth of the display screen.
     Ctalk sets this value when creating the window of a 'X11Pane'
     object or an instance of one of 'X11Pane's' subclasses.  Normally
     applications should not need to change this value.

'displayPtr'
     A 'Symbol' that holds the pointer to the display connection; i.e.,
     the 'Display *' returned by 'XOpenDisplay(3)'.  Most windows use
     the display connection opened when the main window is created.
     Dialogs, which create their own main windows, open their own
     connection to the display.

     When using subpanes, it's convenient to set the subpane's
     'displayPtr' variable to the value of the main window pane's value.
     This is generally done in the 'attachTo' methods, with a line that
     looks something like this.


          self displayPtr = self mainWindow displayPtr;


'fontVar'
     A 'X11Font' object that contains information about the Window or
     Pane's current font.

'fontDesc'
     A 'String' that contains a X Logical Font Descriptor for the font
     to be used by the window.  If the value is '(null)', the window
     uses the system's fixed font.

'ftFontVar'
     An 'X11FreeTypeFont' object that contains the pane's current font,
     if the 'X11TextEditorPane' object uses outline fonts.

     If, on the other hand, the pane uses X11 bitmap fonts, the Pane
     uses the 'fontVar' instance variable.  Which requires no additional
     initialization.

     To determine whether a machine has outline fonts available, a
     program could use a set of statements like this in its
     initialization.


          Boolean new useXFonts;
          X11Pane new myPane;

          ...

          if (myPane ftFontVar version >= 10) {
            myPane ftFontVar initFontLib;
            useXFonts = false;
          } else {
            useXFonts = true;
          }


'inputStream'
     A 'X11TerminalStream' object that provides 'InputEvent' objects to
     the application.  *Note X11TerminalStream::.

'xGC'
     A 'Symbol' that contains the address of the window's graphics
     context.  The 'X11Pane' class does not, at this time, provide
     methods or instance data for drawables, so the application needs to
     implement its own drawable for each window.

'xWindowID'
     An 'Integer' that contains the window's id that a program can use
     with X library functions.

Class Variables
---------------

'xColormap'
     An 'Integer' that contains the resource ID of the default color
     map.
'xDisplay'
     An 'Integer' object that contains the address of the X display
     pointer.  Like many X resources that are opaque types, it is
     formatted as an integer, rather than as a pointer, to avoid
     confusing it with 'OBJECT *' values.  An 'Integer' that indicates
     whether the 'X11Pane' class has been initialized.

Instance Methods
................

'attachTo (Object PARENTPANE)'
     Attach the receiver to PARENTPANE.  The value of PARENTPANE's
     SUBWIDGET instance variable is the receiver.

'background (String COLOR_NAME)'
     Sets the background color of the pane object's window.  For
     buffered Panes, programs need to set the background color of that
     Pane independently.  This method also has the effect of clearing
     the window.

'clearRectangle (int X, int Y, int WIDTH, int HEIGHT)'
     Clear the area of the receiver's window with the dimensions given
     as the arguments.

'clearWindow (void)'
     Clear the receiver's window.  This method clears only the main
     window and does not affect any image buffers associated with the
     pane object.  To also clear the pane object's image buffers, use
     'clearRectangle', above.

'defaultCursor (void)'
     Restore the window's default cursor, which is normally the cursor
     of the parent window.

'deleteAndClose (void)'
     Delete the receiver window and close the display.

'displayHeight (void)'
     Returns an 'Integer' with the display's height in pixels.

'displayWidth (void)'
     Returns an 'Integer' with the display's width in pixels.

'faceRegular (void)'
'faceBold (void)'
'faceItalic (void)'
'faceBoldItalic (void)'
     These methods select which 'X11FreeTypeFont' typeface a pane should
     use.  These methods need the program to initialize the Xft
     libraries (with the 'initFontLib' method in 'X11FreeTypeFont'
     class), and the pane has established a connection to the X server
     (with the 'openEventStream' method).

'font (String FONT_DESC)'
     Set the X font used for drawing on the window.  This font can be
     set independently of the fonts used by subpanes.  *Note
     X11TextPane::, and *Note X11Bitmap::.

     Because the Ctalk libraries use shared memory to manage font
     information, it is generally necessary to call this method after
     the 'openEventStream' method, for the program to calculate the
     character spacing of multiple typefaces correctly.

'ftFont (String FAMILY, Integer SLANT,'
     'Integer' WEIGHT 'Integer' DPI, 'Float' POINTSIZE) Selects an
     outline font for use by the 'X11Pane' object.  The method selects
     the font, and fills in the 'ftFontVar' instance variable with the
     font's information.  Programs should first determine if FreeType
     fonts are available on the system, by using the 'X11FreeTypeFont'
     method 'version' first, as in this example.


          Boolean new useXFonts;
          X11Pane new myPane;

          ...

          if (myPane ftFontVar version >= 10) {
            myPane ftFontVar initFontLib;
            useXFonts = false;
          } else {
            useXFonts = true;
          }

          ...

          /* Selects the font DejaVu Sans Mono, regular slant, normal weight,
             72 dpi, 12 points. */
          myPane ftFont "DejaVu Sans Mono", 0, 80, 72, 12.0;


     The 'X11FreeTypeFont' class also provides methods that use Xft and
     X11 font descriptors to select fonts.  *Note X11FreeTypeFont::.

'initialize (int WIDTH, int HEIGHT)'
'initialize (int X, int Y, int WIDTH, int HEIGHT)'
     Create the window and its graphics context with the width and
     height given as the arguments.  This method also opens a connection
     to the X server if necessary.  This method uses the window system
     to set the window's initial position.

     Create the window and its graphics context with the dimensions
     given as the arguments.  This method also opens the connection to
     the X server if necessary.

     This method is here for older programs, or programs that set the
     window position directly.  Otherwise, use the form of 'initialize',
     below, that takes the window's geometry flags as an argument, and
     only set the window's position if the user provides one on the
     command line and the program retrieves it with 'parseX11Geometry'.

     Even more simply, a program can set X_ORG and Y_ORG to zero, and
     let the window system handle any positioning.  Or use the form of
     'initialize' that uses only the WIDTH and HEIGHT arguments.

'initialize (int X, int Y, int WIDTH, int HEIGHT, int GEOM_FLAGS)'
     Create the window and its graphics context with the dimensions
     given as the arguments.  Like the other forms of 'initialize', this
     method also opens the connection to the X server if necessary.

     The GEOM_FLAGS argument provides placement hints for the window's
     initial position.  It has the format provided by the
     'parseX11Geometry' method in 'Application' class.  *Note
     parseX11Geometry::.

     The X and Y parameters can also be given directly if the program
     sets the window position itself.  If these arguments are zero, then
     the window manager or the user supplied window geometry determine
     the window placement.

'initialize (int X, int Y, int WIDTH, int HEIGHT, int GEOM_FLAGS, char *WIN_TITLE)'
     This method is similar to the five-argument form of 'initialize',
     and additionally sets the window's title using the contents of the
     string WIN_TITLE.

'isTopLevel (void)'
     Return 'TRUE' if the receiver's container pane is 'NULL'.

'mainWindow (void)'
     Returns the 'X11Pane' object that manages a program's main window.
     The method retrieves the main window object by following the
     references of each subpane's 'container' instance variable.  If the
     top-level pane object is not a 'X11Pane', the method prints a
     warning.

'map (void)'
     Map the receiver window onto the X display.

'openEventStream (void)'
     Open the window's input stream, a 'X11TerminalStream' object.  The
     'X11TerminalStream' section of the manual describes X input event
     handling.  *Note X11TerminalStream::.

'putStrXY (Integer XORG, Integer YORG, String STR)'
     Draw the string on the receiver's drawable surface at XORG, YORG,
     using the selected font.

'putStrXY (Integer XORG, Integer YORG, String STR)'
     Draw the string on the receiver's drawable surface at XORG, YORG.
     Currently this method is the same as 'putStrXY,' above.

'raiseWindow (void)'
     Display the receiver window above other windows on the X display.
     Note that the method's name was changed from 'raise' to avoid
     warnings when including the C 'raise(3)' function.

'setResources (String RESOURCENAME, String RESOURCECLASS)'
     Set the resource name and class of the main window.  Normally the
     resource name is the name of the application, which may vary from
     the window title.  The resource class should be used to identify
     the window for X resources.

     A program can call this method either before or after connecting to
     the server with the 'openEventStream' method.  Generally, if the
     resources affect the appearance of decorations provided by the
     system, like the window frame or icon, the window needs to be
     remapped for the changes to be visible, but this may vary with the
     application and the type of window manager.

'setWMTitle (char *TITLE)'
     Set the window's title.  Because setting a X window's title
     requires communication between the window and the display server,
     this method requires that the window is first mapped and raised
     (with the 'map' and 'raiseWindow' methods, above), and has a
     connection to the display server (which is done with the
     'openEventStream' method, also above).

     In other words, when setting a window's title for the first time,
     this method works best when used just before processing any other
     events.

'subPaneNotify (InputEvent EVENT)'
     Called by applications that need to invoke sub-pane handlers in
     response to window events.  For examples of its usage, refer to the
     section for 'X11CanvasPane', *Note X11CanvasPane::, and other
     'X11Pane' subclasses.

'useCursor (Cursor CURSOR_OBJECT)'
     Display the X11 cursor defined by CURSOR_OBJECT, a 'X11Cursor'
     object, in the receiver's window.  To create cursors, *Note
     X11Cursor::.

'useXRender (Boolean B)'
     If B is true, draw graphics using the X Render extension if it is
     available.  If B is false, use Xlib for graphics drawing.  The
     default is to draw using the X Render extension if it is available.

'usingXRender (void)'
     Returns a 'Boolean' value of True if the program is using the X
     Render extension for drawing, False otherwise.


File: ctalk.info,  Node: GLXCanvasPane,  Next: X11PaneDispatcher,  Prev: X11Pane,  Up: Classes

'GLXCanvasPane' Class
---------------------

The 'GLXCanvasPane' class displays 3 dimensional graphics drawn with
OpenGL in a X window.  The class requires that the display server
supports GLX visuals, which is the case with most modern X server
installations.

The class includes instance variables that select GLX visual properties,
methods that create and display the window, and provides a simple API
for the window's application program.

There is an example program that displays a 'GLXCanvasPane' window at
the end of this section.  *Note GLXExampleProgram::.

GLXCanvasPane Applications
--------------------------

The 'GLXCanvasPane' class provides a simple application framework that
is compatible with OpenGL's single threading model.  The framework
consists of a number of callback methods and a 'run' method, that are
configured when the program starts.

The methods that install callbacks are:


     onButtonPress
     onIdle
     onKeyPress
     onExpose
     onPointerMotion
     onResize
     onTimerTick
     onAnimation


There is a complete description of each of these methods in the section,
'Instance Methods.'

Typically, a program installs its callback methods and initializes the
OpenGL system, and then calls the method 'run' to begin the program's
event loop.  The example program given at the end of this section
follows this process.  The program's initialization and startup, which
is contained in 'main ()', is shown here.


     int main () {
       GLXCanvasPane new pane;

       pane initialize (1, 150, 500, 500);
       pane title "GLXCanvasPane Demonstration";
       pane map;
       pane raiseWindow;

       pane onKeyPress "myKeyPressMethod";
       pane onExpose "myExposeMethod";
       pane onTimerTick "myTimerTickHandler";
       pane onResize "myResizeMethod";

       pane initGL;

       pane run;

     }


Selecting GLX Visuals
---------------------

The 'GLXCanvasPane' class selects visuals based on the values of many of
the instance variables.  These instance variables correspond with the
attributes recognized by the 'glXChooseVisual(3)' library call.

The instance variables' default settings select a double buffered,
TrueColor or DirectColor visual, with 24 color bits per pixel, and a
stencil buffer with 8 bit planes, which is supported by many common GLX
servers.  The equivalent C code for these attributes, formatted as an
argument for 'glXChooseVisual(3)', would be:


     static GLint att[] = {GLX_RGBA, GLX_DEPTH_SIZE, 24, GLX_STENCIL_SIZE, 8,
                           GLX_DOUBLEBUFFER, None};


These attributes also correspond to the available attributes output by a
program like 'glxinfo(1)'.  Refer to the 'glXChooseVisual(3)' and
'glxinfo(1)' manual pages for more information

Drawing with X Fonts
--------------------

The 'GLXCanvasPane' class defines three methods, 'useXFont', 'drawText',
'drawTextW', and 'freeXFont' that facilitate drawing text with X fonts.

Typically, a program calls 'useXFont' with the name of the X font when
it initializes OpenGL (that is, after first creating the window and
mapping the GLX context to the display), then using 'drawText' to draw
the text in the program's drawing routine.  Finally, the program calls
'freeXFont' to release the font data before exiting, or when changing
fonts if the program uses multiple fonts for drawing.


     myPane useXFont "fixed";    /* Call during OpenGL initialization. */
                                 /* The argument, "fixed," is the name */
                                 /* of the font to be used.            */

     ...

                                 /* Called from within the program's   */
                                 /* drawing routine.                   */
     myPane drawText "Text to appear in the window";


     ...

     myPane freeXFont;           /* Called during program cleanup or   */
                                 /* before calling useXFont again to   */
                                 /* draw text in a different font.     */


The Ctalk distribution contains an example program in the 'demos/glx'
subdirectory, 'xfont.ca' that demonstrates this drawing method.

Drawing with FreeType Fonts
---------------------------

The methods to draw text using the freetype libraries are similar to
those that render X bitmap fonts.  The Freetype libaries support text
rendering using Freetype, Truetype, and Postscript Type1 fonts.

The main differences are that, because of the way the fonts are rendered
on the screen, their measurements are given in the coordinates of the
current viewing and transformation matrices.

In addition, when loading a font using 'useFTFont', the method uses the
path name of the font file, not an identifier.  This is the only
interface that the Freetype libraries use.  To use the system's font
caching, refer to *Note X11FreeTypeFont::.

There is a demo program that renders Freetype fonts in the 'demos/glx'
subdirectory of the Ctalk source package, 'ftfont.ca'.

Display Synchronization
-----------------------

On OpenGL releases that support synchronization, 'GLXCanvasPane'
applications can synchronize buffer swapping with the video display's
refresh rate.  'GLXCanvasPane' class provides the methods
'syncSwap,refreshRate,' and 'frameRate' which allow programs to adjust
buffer swapping to match the video refresh rate.  The demonstration
program, 'demos/glx/glxchaser.ca' provides an example of how to use
these methods.

To find out which GLX extensions the display server supports, the
'extensions' method, below, returns the extensions as a 'String' object.

Currently, video syncronization support is limited to MESA releases that
provide the 'GLX_MESA_swap_control' and 'GLX_OML_sync_control'
extensions.

Instance Variables
..................

'animationHandler'
     Defines the callback method that is called 24 times a second to
     perform animation.

'buttonPressHandler'
     A 'Method' object that defines the callback method that is executed
     when a mouse button is pressed.

'buttonState'
     An 'Integer' that records whether a mouse button is currently
     pressed.  The class defines macro constants to record the states,
     and you can include these definitions in your programs to interpret
     the value of 'buttonState'.


          #define buttonStateButton1 (1 << 0)
          #define buttonStateButton2 (1 << 1)
          #define buttonStateButton3 (1 << 2)
          #define buttonStateButton4 (1 << 3)
          #define buttonStateButton5 (1 << 4)


     So to check if the mouse button 1 is pressed, the program could
     contain an expression like the following.


          if (myPane buttonState & buttonStateButton1) {
             printf ("Button 1 pressed.\n");
          }


'colormap'
     An 'Integer' that contains the X resource ID of the default
     colormap of the current display and screen.

'displayPtr'
     A 'Symbol' that contains the address of the X server's display
     handle as provided to the application.  The 'displayPtr' instance
     variable is filled in by the 'initialize' methods.

'exposeHandler'
     Defines the method that is called each time the program's window
     receives an Expose event from the display.  This handler is
     essential to displaying the window in coordination with other
     display events.  If this variable is not initialized, then the
     'run' method calls the 'swapBuffers' method.

'glxContextPtr'
     A 'Symbol' that contains the address of the 'GLXContext' that is
     current for the 'GLXCanvasPane's' window.  This variable is
     normally filled in by the 'map' method.

'idleHandler'
     A 'Method' that contains the callback that the program executes
     when not processing events from the display.

'keyPressHandler'
     A 'Method' that handles the KeyPress events that the display sends
     to the program's window.  This variable should be set during
     program initialization using the 'onKeyPress' method before the
     program starts the 'run' method.

'pointerMotionHandler'
     A 'Method' that is called whenever the window receives a
     MotionNotify event.

'resizeHandler'
     A 'Method' that is called whenever the window receives a
     ConfigureNotify event.  The variable should be set using the
     'onResize' method before the program starts the 'run' method.

'shiftState'
     An 'Integer' that records whether the any of the Shift, Control, or
     Alt keys is currently pressed.  The class defines macro constants
     to record the states, and you should also include the definitions
     in your program if it needs to monitor the state of the modifier
     keys.


          #define shiftStateShift (1 << 0)
          #define shiftStateCtrl  (1 << 1)
          #define shiftStateAlt   (1 << 2)


     So, for example, to test whether a Control key is pressed, you can
     use an expression like the following.


          if (myPane shiftState & shiftStateCtrl)
             printf ("Control key pressed.\n");


'timerMSec'
     An 'Integer' that defines the time in milliseconds between
     'onTimerTick' handler calls.  The default is 1 millisecond.

'timerTickHandler'
     A 'Method' that defines the callback that is executed when the
     classes' interval timer reaches 0.

'visualAuxBuffers'
     An 'Integer' that, in combination with 'visualSetAuxBuffers',
     defines the minimum number of auxiliary buffers that the selected
     visual must have.

'visualBufferSize'
     An 'Integer' that defines the desired color index buffer size.  The
     instance variable 'visualSetBufferSize' must also be set to true.

'visualDepthSize'
     An 'Integer' that contains the size of the visual's depth buffer.
     The 'visualSetDepthSize' instance variable must also be true for
     this value to take effect.

'visualDoubleBuffer'
     A 'Boolean' that selects a double-buffered GLX visual if true, or a
     single-buffered visual if false.

'visualInfoPtr'
     A 'Symbol' that contains the address of a X visual selected when
     the pane's window is created, which normally happens when a program
     calls one of the 'initialize' methods described below.

'visualRedSize'
'visualGreenSize'
'visualBlueSize'
'visualAlphaSize'
     'Integer' values that, if greater than zero, try to select thea
     largest buffer for that color channel of at least the specified
     size.  If one of the values is zero, then 'glXChooseVisual(3)'
     tries to select the smallest available buffer for that color
     channel.

'visualRedAccumSize'
'visualGreenAccumSize'
'visualBlueAccumSize'
'visualAlphaAccumSize'
     'Integer' values that, if greater than zero, try to select thea
     largest accumulator buffer for that color channel of at least the
     specified size.  If one of the values is zero, then
     'glXChooseVisual(3)' tries to select a visual with no accumulator
     buffer for that color channel.

'visualRGBA'
     A 'Boolean' that selects a TrueColor or DirectColor visual if true,
     or a PseudoColor or StaticColor visual if false.  Also, the
     'visualSetBufferSize' and 'visualBufferSize' instance variables are
     ignored when this variable is true.

'visualStencilPlanes'
     An 'Integer' the selects the number of stencil bitplanes if greater
     than zero.  If zero, then a visual with no stencil buffer is
     selected if possible.

'visualStereo'
     A 'Boolean' value that selects a stereo visual if true.

'xLineHeight'
     An 'Integer' that contains the line height in pixels of a font that
     has been selected by the 'useXFont' method.  This variable is read
     only.

'xMaxCharWidth'
     An 'Integer' that contains the maximum width in pixels of a
     character for a X font that has been selected by 'useXFont'.  This
     value is read only.

Instance Methods
................

'alpha (Float ALPHA)'
     Sets the alpha channel (opacity) when rendering outline fonts.
     Values should be between 0.0 (transparent) and 1.0 (opaque).  The
     Ctalk library's default value is 1.0.  Calling this method also
     sets the value of the receiver pane's 'ftFontVar fgAlpha' instance
     variable.

'deleteAndClose (void)'
     Releases the receiver pane's GLX context and deletes the X11
     window, and shuts down the application's X11 input client.

'displayHeigth (void)'
'displayWidth (void)'
     These methods return an 'Integer' with the display height and width
     in pixels, respectively.

'drawFmtText (Float XORG, Float YORG, String FMT, ...)'
     Draws the text given by FMT and its arguments at the matrix
     position given by XORG,YORG.

'drawFmtTextFT (Float XORG, Float YORG, String FMT, ...)'
     Display the string given by FMT and its arguments at the matrix
     coordinates XORG, YORG in the currently selected Freetype font.
     This call, like all calls that render text, should be preceded by a
     call to 'useFTFont'.

'drawFmtTextW (Integer XORG, Integer YORG, String FMT, ...)'
     Draws the formatted text of FMT and its arguments at the pixel
     position given by XORG, YORG.  OpenGL uses the lower left-hand
     corner of the window as the origin for pixel coordinates.

'drawText (Float XORG, Float YORG, String TEXT)'
'drawText (Float XORG, Float YORG, Float RED, Float GREEN, Float BLUE, String TEXT)'
     Draws TEXT at the matrix position given by XORG,YORG.

     The program must have registered a X font for drawing with a
     previous call to the 'useXFont' method.

     If the RED, GREEN, and BLUE arguments are given, the method draws
     the text in that color.  Otherwise, the method (via OpenGL) draws
     the text using the last OpenGL color setting.

'drawTextFT (Float XORG, Float YORG, String TEXT)'
'drawTextFT (Float XORG, Float YORG, Float RED, Float GREEN, Float BLUE, Float ALPHA, String TEXT)'
     Draws the string given by TEXT at the matrix coordinates XORG,
     YORG.

     The RED, GREEN, BLUE, and ALPHA arguments, if used, should be
     between the values of 0.0 and 1.0, so they can be passed along to
     the OpenGL API directly, and also to set the receiver's 'ftFontVar'
     instance variable (a 'X11FreeTypeFont' values for its instance
     variables: 'fgRed, fgGreen, fgBlue,' and 'fgAlpha' *Note
     X11FreeTypeFont::.

'drawTextW (Float XORG, Float YORG, String TEXT)'
'drawTextW (Float XORG, Float YORG, Float RED, Float GREEN, Float BLUE, String TEXT)'
     Draws TEXT using the window's XORG,YORG pixel as the origin.

     If the RED, GREEN, and BLUE arguments are given, the method draws
     the text in that color.  Otherwise, the method (via OpenGL) draws
     the text using the last OpenGL color setting.

     This method allows text to be positioned relative to the window's
     pixels, which avoids the need for programs to translate a matrix
     position into a pixel position manually.  This allows a program to
     position text more easily when it is necessary to measure spaces
     using the dimensions of the text and font that are being displayed.

     The coordinates' origin (0,0) is at the lower left-hand corner of
     the window, and the pixel coordinates increase as the position
     moves toward the top and right of the window.

     The GL function 'glWindowPos2i', which this method uses internally,
     is an extension in many GL implementations.  Ctalk checks for the
     function when building the Ctalk libraries.  If 'glWindowPos2i' is
     not present in the machine's GL libraries, then programs that try
     to use these methods display an error message on the terminal and
     exit.

'extensions (void)'
     Returns the supported GLX extensions from the display server as a
     'String' object.

'frameRate (void)'
     Returns the rate that the program updates the display, in frames
     per second.  The algorithm that calculates the frame rate measures
     frames over a five-second interval.

'freeFTFont (void)'
     Releases the Freetype font in use.

'freeXFont (VOID)'
     Frees the font data that was allocated by a previous call to
     'useXFont'.  Programs should call this method when cleaning up
     before program exit, or when switching fonts by a subsequent call
     to 'useXFont'.

'initialize (Integer X, Integer Y, Integer WIDTH, Integer HEIGHT, Integer GEOMFLAGS)'
'initialize (Integer X, Integer Y, Integer WIDTH, Integer HEIGHT)'
'initialize (Integer WIDTH, Integer HEIGHT'
     Creates the receiver pane's window and configures the window for
     display.  The 'initialize' method also fills in the receiver's
     'visualInfoPtr' instance variable with a pointer the X visual info
     structure specified by the receiver, which is provided by the
     receiver's instance variables.

     With two arguments, the method initializes the receiver window with
     the width and height given as arguments.

     With four arguments, the method initializes the receiver window
     with the window's x and y origin and the width and height given as
     arguments.

     With five arguments, the GEOM_FLAGS argument provides placement
     hints for the window's initial position.  It has the format
     provided by the 'parseX11Geometry' method in 'Application' class.
     *Note parseX11Geometry::.

     When used, the X and Y parameters can be given directly if the
     program sets the window position itself.  If these arguments are
     zero, then the window manager or the user supplied window geometry
     determines the window placement.

'hasExtension (String EXTENSIONNAME)'
     Returns a 'Boolean' value of true if the system's OpenGL library
     supports the GLX extension EXTENSIONNAME, false otherwise.

'map (void)'
     Maps the 'GLXCanvasPane's' window to the display, and internally
     creates a 'GLXContext' for the window, and makes the 'GLXContext'
     current.

     This method fills in the receiver's 'glxContextPtr' instance
     method.

'namedColorFT (String COLORNAME, Float REDOUT, Float GREENOUT, Float BLUEOUT)'
     Return the GLX compatible color values for COLORNAME; i.e., the
     red, green, and blue values are 'Floats' between 0.0 and 1.0.  The
     COLORNAME argument can be any of the colors supported by the X11
     display server.  Refer to 'showrgb(1)' for a list of colors.

'onAnimation (String ANIMATIONHANDLERNAME)'
     Installs the callback method that the program calls 24 times a
     second.  The method needs to have the prototype:


          GLXCanvasPane instanceMethod <methodName> (void);


'onButtonPress (String BUTTONPRESSHANDLERNAME)'
     Installs the callback method that handles ButtonPress events from
     the display.  The callback method needs to have this prototype.


          GLXCanvasPane instanceMethod <methodName> (Integer winX, Integer winY,
                                                     Integer screenX, Integer screenY,
                                                     Integer buttonState,
                                                     Integer eventTime);


     The parameters WINX and WINY give the position of the pointer
     relative to the window's origin.  The parameters SCREENX and
     SCREENY give the pointer's position relative to the upper left-hand
     corner of the root window.

     Note this does not generally mean that the program can receive
     events when a button is pressed outside of the program's window.
     This depends on how the desktop GUI interprets button presses; with
     many desktop programs, the program doesn't receive events when a
     button is clicked outside of the program's window.

     The BUTTONSTATE parameter's value records which buttons are pressed
     at the time of the event.  Note that many systems interpret a
     multiple button click (a "chord") as a unique button.  For example,
     pressing the left and right buttons of a two-button mouse at the
     same time results in a buttonState that indicates button 2 is
     pressed, not that button 1 and button 3 are pressed simultaneously.

     The TIME parameter is the time that the event occurred, so programs
     can interpret a series of ButtonPress events as multiple mouse
     clicks if necessary.

     To install a buttonPress callback method, the program needs to
     include an expression like this one in its initialization code.


          myGLXPane onButtonPress "myButtonPressHandler";


'onExpose (String EXPOSEHANDLERNAME)'
     Installs the callback method to handle Expose events received from
     the display.  The callback method should have the following
     prototype.


          GLXCanvasPane instanceMethod <methodName> (Integer nEvents);


     To install the callback method, the program's initialization should
     contain an expression like this one.


          myPane onExpose "myExposeHandler";


     The parameter NEVENTS contains the number of Expose events that the
     window is waiting to receive.  This allows programs to execute the
     handler's statements once per group of Expose events; that is, when
     NEVENTS reaches 0.

     This handler is important because it updates the window in
     coordination with other display events.  If a callback method is
     not installed, then the 'run' method calls the 'swapBuffers'
     method.

'onIdle (String CALLBACKMETHODNAME)'
     Installs a callback method that the program executes when it is not
     processing events from the display.

     The callback method has the prototype:


          GLXCanvasPane instanceMethod <idleHandler> (void);


     To install the handler, the program's initialization needs to
     contain an expression like this.


          myPane onIdle "myIdleCallback";


'onKeyPress (String CALLBACKMETHODNAME)'
     Configures the receiver's 'keyPressHandler' instance variable to
     refer to the application's actual KeyPress handler method, which is
     called when the program's window receives a KeyPress event from the
     display.

     The actual callback method has the prototype:


          GLXCanvasPane instanceMethod <methodName> (Integer xKeySym,
                                                     Integer keyCode,
                                                     Integer shiftState);

     This example shows a simple KeyPress handler that closes the window
     and exits the program when the 'Escape' key is pressed.


          /* This definition comes from the machine's X11/keysymdef.h file. */
          #define XK_Escape 0xff1b

          GLXCanvasPane instanceMethod myKeyPressMethod (Integer xKeySym,
          					       Integer keyCode,
          					       Integer shiftState) {
            if (xKeySym == XK_Escape) {
              self deleteAndClose;
              exit (0);
            }
          }



     The first parameter is the X Window System symbol for the key,
     which is specific to the machine's keyboard configuration.  The
     complete set of X key symbols is located in the machine's
     'X11/keysymdef.h' file.

     The second parameter is the ASCII value of alphanumeric keys and
     punctuation keys.  In the case of alphabetic characters, the value
     is the same whether the keypress is shifted or unshifted.  That
     means that pressing 'A' and 'a' both result in the 'keyCode'
     argument having the value 97.

     The third parameter, shiftState, indicates whether a modifier key
     is currently being pressed.  The parameter is the receiver's
     'shiftState' instance variable.  The variable's description
     describes how to interpret its value.

     Then, during the program's initialization the program's code should
     include an expression like the following.


          myProgram onKeyPress "myKeyPressMethod";


     There is a more detailed description of how to configure callback
     methods in section that discusses 'Method' class.  *Note
     CallbackSetup::.

'onPointerMotion (String CALLBACKMETHODNAME)'
     Installs the callback method that handles pointer motion events
     from the display.  The callback method must have the prototype:


          GLXCanvasPane instanceMethod <methodName> (Integer winX,
                                                     Integer winY,
                                                     Integer screenX,
                                                     Integer screenY);


     The program's initialization should contain an expression like this
     one:


          myPane onPointerMotion "myPointerMotionMethod";


'onResize (String CALLBACKMETHODNAME)'
     Installs the callback method that handles resize notifications from
     the display.  The callback method needs to have the prototype:


          GLXCanvasPane instanceMethod <methodName> (Integer width,
                                                     Integer height);


     The program's initialization code should contain an expression like
     this one.


          myPane onResize "myResizeMethod";


'onTimerTick (String CALLBACKMETHODNAME)'
     Installs the callback method to be executed when the classes'
     interval timer reaches zero.  The callback method needs to have the
     following prototype.


          GLXCanvasPane instanceMethod <methodName> (void);


     The interval in milliseconds between the callback method's
     execution is set in the 'timerMSec' instance variable,

'pixelHeightFT (Integer PXHEIGHT)'
     Set the pixel height of the selected font to the argument.  The
     default height for rendering fonts with the Freetype libraries is
     18 pixels.

'refreshRate (void)'
     Returns a 'Float' with the display's refresh rate.  If the
     machine's OpenGL does not support reporting the refresh rate,
     returns -1.

'run (void)'
     Runs the event loop that receives X events from the display server,
     and sends them to the callback methods that are configured for the
     application.

     Without any callback methods defined, the 'run' method handles only
     'Expose' events (by calling 'swapBuffers'), and 'ClientMessage'
     events, which check for the 'WM_DELETE_WINDOW' Atom and if present,
     delete the pane's window and GLX context, and exit the program.

'swapBuffers (void)'
     Swaps the pane window's offscreen rendering buffer with the
     window's visible buffer.

'syncSwap (Integer INTERVAL)'
     If INTERVAL > 0, sets the swap interval to 1/INTERVAL, which
     enables swap synchronization with the display's vertical refresh
     rate if the machine's OpenGL installation supports the
     'GLX_MESA_swap_control' extension.

     An INTERVAL value of 0 disables swap synchronization.

     Returns 0 on sucess, or -1 if the extension is not supported.

'textWidth (String TEXT)'
     Returns an 'Integer' with the width of TEXT in pixels in the
     currently selected X font.  If no font is selected, the method
     returns '-1'.

'textWidthFT (String TEXT)'
     Returns a 'Float' with the width of TEXT in matrix coordinates for
     the currently selected Freetype font.

'title (String TITLE_STRING)'
     Set's the window's title.  This method should be called as soon as
     possible after the program calls the 'initialize' method.

'useFTFont (String FONTFILENAME)'
     Load a TrueType, FreeType or Type 1 font.  Also initializes the
     font and GLEW libraries if needed.

     The method uses the font's file name as its argument.  To use a
     system's font aliasing and lookup, refer to *Note
     X11FreeTypeFont::.

'useXFont (String FONTNAME)'
     Register a X font for use with drawing text in the receiver pane.
     The argument, FONTNAME, is th X Logical Font Descriptor of a X font
     that is available on the system - refer to 'xlsfonts(1)' or
     'xfontsel(1)' for more information.

     This method should be called during OpenGL initialization (that is,
     after the 'GLXCanvasPane' object has been created and the GLX
     context established).

'xpmToTexture (Symbol XPMDATA, Integer WIDTHOUT, Integer HEIGHTOUT, Symbol TEXELDATAOUT)'
'xpmToTexture (Symbol XPMDATA, Integer ALPHA Integer WIDTHOUT, Integer HEIGHTOUT, Symbol TEXELDATAOUT)'

     Translates a XPM pixmap into an OpenGL texture.  The argument
     XPM_DATA is the pixmap's 'char *pixmap_name[]' declaration.  If no
     ALPHA argument is given, then '1.0' is used to create an opaque
     texture.

     Alpha values can range from 0 (completely transparent) - 0xffff
     (completely opaque), although in practice, the alpha channel's
     effect might not be apparent, because OpenGL has its own set of
     functions that perform texture blending.

     The method sets the arguments WIDTH_OUT, HEIGHT_OUT, and
     TEXEL_DATA_OUT with the height, width and data of the texture.

     Mesa OpenGL textures, used with Linux systems, internally have the
     format GL_RGBA and the data type GL_UNSIGNED_INT_8_8_8_8, so you
     can create a 2D texture from a pixmap with statements like these.


          Integer new xpmWidth;
          Integer new xpmHeight;
          Symbol new texData;

          /*
           *  Note that the xpm_data argument should not normally need a
           *  translation from C.
           */
          myGLUTApp xpmToTexture xpm_data, xpmWidth, xpmHeight, texData;
          glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, xpmWidth, xpmHeight, 0,
                        GL_RGBA, GL_UNSIGNED_INT_8_8_8_8, texData);


     Apple OpenGL implementations use a different internal format, so a
     program would create the equivalent texture like this.


          Integer new xpmWidth;
          Integer new xpmHeight;
          Symbol new texData;

          myGLUTApp xpmToTexture xpm_data, xpmWidth, xpmHeight, texData;
          glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, xpmWidth, xpmHeight, 0,
                        GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, texData);


     The 'xpmToTexture' method does not do any setup of the OpenGL
     texture environment.  For basic textures, OpenGL works better with
     textures that have a geometry that is an even multiple of 2; e.g.,
     128x128 or 256x256 pixels.

     Individual applications can add parameters for interpolation,
     blending, mipmap creation, and material rendering based on the
     program's requirements, though.

     The Ctalk library only stores the data for one texture at a time,
     so if a program uses multiple textures, it should save the texture
     data to a separate 'Symbol', in orderq to avoid regenerating the
     texture each time it's used.  Many OpenGL implementations also
     provide API functions for texture caching.

     For an example of how to draw with textures, refer to the
     'glxtexture.ca' program in the Ctalk distribution's 'demos/glx'
     subdirectory.

Sample GLXCanvasPane Application
--------------------------------


     #include <X11/Xlib.h>
     #include <GL/glx.h>

     #define DEFAULT_WIDTH 500
     #define DEFAULT_HEIGHT 500

     float face1[3][3] = {{0.0f, 2.0f, 0.0f},
     		     {-2.0f, -2.0f, 2.0f},
     		     {2.0f, -2.0f, 2.0f}};
     float face2[3][3] = {{0.0f, 2.0f, 0.0f},
     		     {2.0f, -2.0f, 2.0f},
     		     {2.0f, -2.0f, -2.0f}};
     float face3[3][3] = {{0.0f, 2.0f, 0.0f},
     		     {2.0f, -2.0f, -2.0f},
     		     {-2.0f, -2.0f, -2.0f}};
     float face4[3][3] = {{0.0f, 2.0f, 0.0f},
     		     {-2.0f, -2.0f, -2.0f},
     		     {-2.0f, -2.0f, 2.0f}};

     float base[4][3] = {{2.0f, -2.0f, 2.0f},
     		    {2.0f, -2.0f, -2.0f},
     		    {-2.0f, -2.0f, -2.0f},
     		    {-2.0f, -2.0f, 2.0f}};

     float angle = 20.0;

     GLXCanvasPane instanceMethod draw (void) {
       glEnable (GL_NORMALIZE);
       glEnable(GL_DEPTH_TEST);
       glClearColor(0.0, 0.0, 0.0, 1.0);
       glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
       glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
       glLineWidth (1.0f);

       glLoadIdentity ();
       glColor4f (1.0f, 1.0f, 1.0f, 1.0f);

       glRotatef (angle, 0.0f, 1.0f, 0.0f);
       glRotatef (10.0f, 0.0f, 0.0f, 1.0f);

       glBegin (GL_TRIANGLES);
       glColor3f (1.0f, 0.0f, 0.0f);
       glVertex3fv (face1[0]);
       glColor3f (0.0f, 1.0f, 0.0f);
       glVertex3fv (face1[1]);
       glColor3f (0.0f, 0.0f, 1.0f);
       glVertex3fv (face1[2]);

       glColor3f (1.0f, 0.0f, 0.0f);
       glVertex3fv (face2[0]);
       glColor3f (0.0f, 1.0f, 0.0f);
       glVertex3fv (face2[1]);
       glColor3f (0.0f, 0.0f, 1.0f);
       glVertex3fv (face2[2]);

       glColor3f (1.0f, 0.0f, 0.0f);
       glVertex3fv (face3[0]);
       glColor3f (0.0f, 1.0f, 0.0f);
       glVertex3fv (face3[1]);
       glColor3f (0.0f, 0.0f, 1.0f);
       glVertex3fv (face3[2]);

       glColor3f (1.0f, 0.0f, 0.0f);
       glVertex3fv (face4[0]);
       glColor3f (0.0f, 1.0f, 0.0f);
       glVertex3fv (face4[1]);
       glColor3f (0.0f, 0.0f, 1.0f);
       glVertex3fv (face4[2]);
       glEnd ();

       glBegin (GL_QUADS);

       glColor3f (1.0f, 0.0f, 0.0f);
       glVertex3fv (base[0]);
       glColor3f (0.0f, 1.0f, 0.0f);
       glVertex3fv (base[1]);
       glColor3f (0.0f, 0.0f, 1.0f);
       glVertex3fv (base[2]);
       glColor3f (1.0f, 0.0f, 1.0f);
       glVertex3fv (base[3]);

       glEnd ();

       glRotatef (20.0, 0.0f, 0.0f, 1.0f);
       glRotatef (angle, 0.0f, 1.0f, 0.0f);

       self swapBuffers;
     }

     GLXCanvasPane instanceMethod initGL (void) {
       glViewport (0, 0, DEFAULT_WIDTH, DEFAULT_HEIGHT);
       glClearColor(0.0, 0.0, 0.0, 1.0);
       glLineWidth (1.0);
       glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
       glEnable (GL_LINE_SMOOTH);
       glHint (GL_LINE_SMOOTH_HINT, GL_DONT_CARE);
       glMatrixMode (GL_PROJECTION);
       glLoadIdentity ();
       if (DEFAULT_WIDTH <= DEFAULT_HEIGHT) {
         glOrtho (-5.0, 5.0,
     	     -5.0 * ((float)DEFAULT_HEIGHT / (float)DEFAULT_WIDTH),
     	     5.0 * ((float)DEFAULT_HEIGHT / (float)DEFAULT_WIDTH),
     	     -5.0, 5.0);
       } else {
         glOrtho (-5.0, 5.0,
     	     -5.0 * ((float)DEFAULT_WIDTH / (float)DEFAULT_HEIGHT),
     	     5.0 * ((float)DEFAULT_WIDTH / (float)DEFAULT_HEIGHT),
     	     -5.0, 5.0);
       }
       glMatrixMode (GL_MODELVIEW);
       glLoadIdentity ();
     }

     GLXCanvasPane instanceMethod myTimerTickHandler (void) {
       angle += 1.0;
       self draw;
     }

     /* This definition comes from the machine's X11/keysymdef.h file. */
     #define XK_Escape 0xff1b

     GLXCanvasPane instanceMethod myKeyPressMethod (Integer xKeySym,
     					       Integer keyCode,
     					       Integer shiftState) {
       if (xKeySym == XK_Escape) {
         self deleteAndClose;
         exit (0);
       }
     }

     GLXCanvasPane instanceMethod myExposeMethod (Integer nEvents) {
       if (nEvents == 0)
         self draw;
     }

     GLXCanvasPane instanceMethod myResizeMethod (Integer width,
     					     Integer height) {
       float ar;

       glViewport (0, 0, width, height);
       glMatrixMode (GL_PROJECTION);
       glLoadIdentity ();
       if (width <= height)
         ar = (float)height / (float)width;
       else
         ar = (float)width / (float)height;
       glOrtho (-5.0, 5.0, -5.0 * ar, 5.0 * ar, -5.0, 5.0);
       glMatrixMode (GL_MODELVIEW);
       glLoadIdentity ();
     }

     int main () {
       GLXCanvasPane new pane;

       pane initialize (1, 150, 500, 500);
       pane title "GLXCanvasPane Demonstration";
       pane map;
       pane raiseWindow;

       pane onKeyPress "myKeyPressMethod";
       pane onExpose "myExposeMethod";
       pane onTimerTick "myTimerTickHandler";
       pane onResize "myResizeMethod";

       pane initGL;

       pane run;

     }



File: ctalk.info,  Node: X11PaneDispatcher,  Next: X11CanvasPane,  Prev: GLXCanvasPane,  Up: Classes

'X11PaneDispatcher' Class
-------------------------

'X11PaneDispatcher' objects manage events from the system's display,
control posititioning and rendering of subpanes within the main pane,
and help communicate events between the main window's pane and the
subwindows' panes.

The positioning of subwindows within the parent window is controlled by
the arguments to the 'attachTo' methods; in particular, these methods
accept a geometry specification, as an argument, which has the following
format.


     width[%]xheight[%]+x[%]+y[%]


If a dimension does not contain a percent ('%') sign, the dimensions are
in pixels.  With a percent sign, the dimensions are a fractional
percentage of the parent pane's width or height.

The 'X11PaneDispatcher' method 'new' creates a X window, although the
window of the 'X11PaneDispatcher' itself is not normally visible, the
window is provided for subclass panes whose windows will appear within
the main 'X11Pane' window.

Subclasses can reimplement default methods like 'new' and the event
handler methods if necessary.  It is also possible for subclasses to
implement event handlers with other method messages than those given
here.  The 'X11PaneDispatcher' object can use these subclasses' methods
if they are available.

Subclasses, however, should use the 'setMethodHandler' method, described
below, to register these callback methods.

Handler Classes
...............

The following event handlers and the default names of the callback
method that handles the event, are available to 'X11PaneDispatcher'
objects and its subclasses.  Handler methods need to take as arguments a
reference to a subpane object, and the 'InputEvent' object from the
system.  *Note X11TerminalStream::.

     Handler Class  Event Class    Description                     Default Handler Method
     "resize"       RESIZENOTIFY   Called when the user            subPaneResize
                                   resizes a window.

     "move"         MOVENOTIFY     Called when a user              subPaneMove
                                   moves a window.
                                   Depending on the
                                   window manager, an
                                   application might also
                                   need to make sure the
                                   window is resized
                                   correctly.

     "expose"       EXPOSE         Called whenever the display     subPaneExpose
                                   server generates exposes a
                                   window due when raised,
                                   uncovered, resized, or other
                                   change.

     "kbdinput"     KEYPRESS       Called when the user presses    subPaneKbdInput
                    KEYRELEASE     a key and the application's
                                   window has the focus.

     "pointerinput" BUTTONPRESS    Called when a mouse button      subPanePointerInput
                    BUTTONRELEASE  is pressed or released.

     "pointermotion" MOTIONNOTIFY  Called whe the pointer is       subPanePointerMotion
                                   moved.

     "selectionrequest"
                  SELECTIONREQUEST Received when another program   subPaneSelectionRequest
                                   requests the X selection.
                                   This callback is here mainly
                                   for completeness; presently, X
                                   selection events are handled
                                   internally, and only with the
                                   library functions used by
                                   X11TextEditorPane objects.

     "selectionclear"
                    SELECTIONCLEAR Received when another program
                                   requests the X selection. Currently,
                                   on library functions used by
                                   X11TextEditorPane objects use this
                                   internally but applications can use this
                                   event to update their status if
                                   necessary.
     "wmfocuschange" WMFOCUSCHANGENOTIFY
                                   Received from the window manager when the
                                   pointer enters or leaves a window, or when
                                   the window manager raises a window.  The
                                   xEventData1 instance variable contains the
                                   type of X event, either FocusIn or FocusOut.

     "enternotify" ENTERWINDOWNOTIFY
                                   Received when the pointer enters a
                                   window from another window.

     "leavenotify" LEAVEWINDOWNOTIFY
                                   Received when the pointer leaves a
                                   window.

     "focusin"     FOCUSIN         Received when the application signals
     "focusout"    FOCUSOUT        a change of widget focus; for example,
                                   when the user presses the <Tab>
                                   key.

     "destroy"      WINDELETE      Called when the user closes the
                                   application window.


Handler Methods
...............

A handler typically takes as its arguments a reference to a subpane, and
the event.  Although the subpane reference parameter can be declared as
an 'Object', it is in actual use a 'Symbol' object, with the reference
defined by the 'attachTo' method.  The handler should be able to pass
the event along to any subpanes of the receiver pane if necessary, by
checking whether subpanes implement their own handlers.  Here, for
example, is the 'X11PaneDispatcher' class's 'subPaneResize' method.


     X11PaneDispatcher instanceMethod subPaneResize (Object __subPane,
     					      InputEvent __event) {
       "Dispatch an Resize event to the subpanes of the
        receiver pane."
       X11Pane new containerPane;
       self size x = __event xEventData3;
       self size y = __event xEventData4;
       containerPane = *self container;
       XResizeWindow (containerPane xDisplay, containerPane xWindowID,
     		 self size x, self size y);
       if (__subPane isInstanceMethod "subPaneResize") {
         __subPane methodObjectMessage __subPane handleResize, __subPane,
           __event;
       }
       return NULL;
     }


The internals of the subpane API are likely to change and be expanded in
future releases.  Using the methods described here and in other sections
should help insure that applications are compatible with future Ctalk
releases.

Instance Variables
..................

'canFocus'
     A 'Boolean' that determines whether the widget is highlighed when
     the pointer passes over it, or the application sets the focus; for
     example, by pressing the <Tab> key.

     If this variable is true, which is the default, then the class
     should also declare event handlers for focus in and focus out
     events.  Otherwise, the program prints a warning each time the
     'shiftFocus' method, described below, calls a 'NULL' 'Method'
     object.

'handleDestroy'
     A 'Method' that provides the default handler to delete a subpane
     window and its data.

'handleEnterNotify'
'handleLeaveNotify'
     Handlers for events that are generated when a pointer crosses from
     one window to another.

'handleFocusIn'
'handleFocusOut'
     Handles highlighting or un-highlighting a widget when receiving a
     FOCUSIN or FOCUSOUT event from the application; for example, when
     the user presses the <Tab> key.

'handleKbdInput'
     A 'Method' that provides the default handler for subpanes to handle
     keyboard input.

'handleMove'
     A 'Method' that provides the default handler for moving subpane
     windows.

'handlePointerInput'
     A 'Method' that provides the default handler for pointer input
     (mainly ButtonPress) events.

'handlePointerMotion'
     A 'Method' that provides the default handler for pointer motion
     events.

'handleResize'
     A 'Method' that provides the default handler for resizing subpane
     windows within the main window.

'handleSelectionClear'
     A 'Method' that provides the default handler for SelectionClear
     events.

'handleSelectionRequest'
     A 'Method' that provides the default handler for SelectionRequest
     events.  Currently, this callback is here for completeness; X
     selection events are handled internally, and only in the library
     functions used by 'X11TextEditorPane' objects.

'handleWMFocusChange'
     The method that handles the events received from the desktop's
     window manager when it changes the window focus in response to a
     pointer motion or click; or when the window manager raises a
     window.

'hasFocus'
     An 'Integer' that is true if the current subpane has the input
     focus.  For programs with only a single widget class, this variable
     is not used.

'highlight'
     A 'Boolean' that indicates whether the widget is displayed
     highlighted.

'modalWin'
     When a dialog window is popped up over the main window, this holds
     the window ID of the popup.  The 'handleSubPaneEvent' method uses
     this to determine how the application's main window should respond
     to X events; generally it keeps the dialog window above the main
     window until the dialog window is withdrawn.  When their is no
     window popped up over the main window, the value of 'modalWin' is
     zero ('0').

'tabFocus'
     A 'Boolean' that determines, if true (which is the default),
     whether the 'handleSubPaneEvent' method intercepts the <Tab> key in
     order to shift the input focus when it is pressed.  If 'tabFocus'
     is true, the subpane's class must implement methods to handle the
     'focusin' and 'focusout' events that shifting focus with the
     keyboard implements, or the program will display warning messages
     when it can't find the methods.

Instance Methods
................

'attachTo (Object PARENTPANE)'
'attachTo (Object PARENTPANE, String GEOMETRY)'
     Attach the receiver to its parent pane, typically a 'X11Pane' or
     'X11PaneDispatcher'.  Also creates a X window, although
     'X11PaneDispatcher' windows themselves are not normally visible.

     When the subwindow is attached to the parent window, the Ctalk
     library creates the pane object's window and graphics context, and
     clears the window to the background color of the pane object's
     'backgroundColor' instance variable; for example, with an
     expression like this:


          myCanvasPane backgroundColor = "blue";


     Otherwise, the method clears the subpane's window to black.

     The GEOMETRY argument, if present, defines the size and placement
     of the subpane's window within the parent window.  A geometry
     specification has the form:


          width[%]xheight[%]+x[%]+y[%]


     The dimensions are in pixels, unless a percent sign ('%') follows a
     dimension.  In that case, the dimension is a fractional percentage
     of the parent pane's width or height.  The 'String' may contain a
     combination of absolute and relative dimensions.

'handleSubPaneEvent (InputEvent EVENT)'
     Handle an input event from the window system.  Typically the parent
     pane's 'inputStream' provides the event.  *Note
     X11TerminalStream::.

     This method also checks keypresses for the <Tab> key, and calls the
     'shiftFocus' method in order to shift focus between a window's
     subpanes when the user presses <Tab>.

'new (DISPATCHERNAME)'
     Create a new 'X11PaneDispatcher' object.  Initializes the instance
     variables to the default subpane event handlers and the container
     mode to 'full'.  If the argument list contains more than one label,
     created new 'X11PaneDispatcher' objects with the names of each
     label.

'setMethodHandler (String HANDLERTYPE, Method HANDLERMETHOD)'
     Set the pane's handler for HANDLERTYPE to HANDLERMETHOD.  Currently
     supported handler types are: 'resize'.

'shiftFocus (void)'
     When the user presses <Tab>, 'handleSubPaneEvent' calls this
     method, which highlights a window's subpanes in succession, if the
     subpanes can take the input focus.

     Refer to the 'canFocus' instance variable, and the handlers for
     focus in and focus out events.  These event handlers are called by
     the program, and are not the same as the 'handleWMFocusChange'
     handler, which is called when the window focus changes on the
     desktop.

'clearFocus (void'
     Called before shifting the focus highlight to a new pane to insure
     that only one pane indicates that it should receive focus,
     including the synthetic focus that is assigned when shifting focus
     using the <Tab> key.

'subPaneDestroy (Object SUBPANEREF, InputEvent DESTROYEVENT)'
     The default handler for 'WINDELETE' events.  Like the other method
     handlers, SUBPANEREF is typically a 'Symbol' object.  The
     'X11TerminalStream' section describes these events.  *Note
     X11TerminalStream::.

'subPaneGeometry'
     A 'String' that stores a subpane's geometry specification, if any.
     For an explanation of geometry string's format, refer to the
     'attachTo' method, below.

'subPaneKbdInput (Object SUBPANEREF, InputEvent KBDINPUTEVENT)'
     The default handler for 'KEYPRESS' and 'KEYRELEASE' events.  Like
     the other method handlers, SUBPANEREF is typically a 'Symbol'
     object.  The 'X11TerminalStream' section describes these events.
     *Note X11TerminalStream::.

'subPaneMove (Object SUBPANEREF, InputEvent MOVENOTIFYEVENT)'
     The default event handler for 'MOVENOTIFY' events from the system's
     GUI. Like the other method handlers, SUBPANEREF is typically a
     'Symbol' object.  The 'X11TerminalStream' section describes these
     events.  *Note X11TerminalStream::.

     With some window managers, a 'subPaneMove' method might also need
     to handle 'RESIZENOTIFY' events.

'subPanePointerMotion (Object SUBPANEREF, InputEvent EVENT)'
'subPanePointerInput (Object SUBPANEREF, InputEvent EVENT)'
     The default handlers for 'MOTIONNOTIFY', and 'BUTTONPRESS' and
     'BUTTONRELEASE' events.  Like the other method handlers, SUBPANEREF
     is typically a 'Symbol' object.  The 'X11TerminalStream' section
     describes these events.  *Note X11TerminalStream::.

'subPaneResize (Object SUBPANEREF, InputEvent RESIZENOTIFYEVENT)'
     The default resize handler for subpane windows.  Typically
     SUBPANEREF is a 'Symbol' object that contains a reference to the
     subpane object.  The RESIZEEVENT argument is typically a
     'RESIZENOTIFY' event from the system's GUI. *Note
     X11TerminalStream::.


File: ctalk.info,  Node: X11CanvasPane,  Next: X11ButtonPane,  Prev: X11PaneDispatcher,  Up: Classes

'X11CanvasPane' Class
---------------------

The 'X11CanvasPane' class provides the instance variables and methods
for basic X window graphics operations like drawing points, lines, and
rectangles.  The width and color of shapes is controlled by the 'pen'
instance variable.

Here is brief drawing program that uses a 'X11CanvasPane' object.
Clicking on the pane's window draws a dot at that point.  If the program
is given the argument '-v', the program displays the X events it
receives from the display.

     int main (int argv, char **argc) {
       X11Pane new xPane;
       X11PaneDispatcher new xTopLevelPane;
       X11CanvasPane new xCanvasPane;
       InputEvent new e;
       Integer new nEvents;
       Integer new verbose;
       Exception new ex;
       String new text;
       Application new paneApp;

       paneApp enableExceptionTrace;
       paneApp installExitHandlerBasic;

       xPane initialize 0, 0, 200, 100;
       xPane inputStream eventMask =
         WINDELETE|BUTTONPRESS|BUTTONRELEASE|MOVENOTIFY|EXPOSE;
       xTopLevelPane attachTo xPane;
       xCanvasPane attachTo xTopLevelPane;
       xPane map;
       xPane raiseWindow;

       xPane openEventStream;

       xCanvasPane clear;
       xCanvasPane background "blue";
       xCanvasPane pen width = 5;
       xCanvasPane pen colorName = "white";

       xCanvasPane refresh;

       verbose = FALSE;
       if (argc == 2) {
         if (!strcmp (argv[1], "-v")) {
           verbose = TRUE;
         }
       }

       WriteFileStream classInit;

       while (TRUE) {
         xPane inputStream queueInput;
         if (xPane inputStream eventPending) {
           e become xPane inputStream inputQueue unshift;
           xPane subPaneNotify e;  /* Call the classes' event handlers. */
           if (ex pending)
      	ex handle;

           switch (e eventClass value)
     	{
     	  /*
     	   *  Handle both types of events in case the window
     	   *  manager doesn't distinguish between them.
     	   */
     	case MOVENOTIFY:
     	  if (verbose) {
     	    stdoutStream printOn "MOVENOTIFY\t%d\t%d\t%d\t%d\n",
     	      e xEventData1,
     	      e xEventData2,
     	      e xEventData3,
     	      e xEventData4;
     	    stdoutStream printOn "Window\t\t%d\t%d\t%d\t%d\n",
     	      xPane origin x,
     	      xPane origin y,
     	      xPane size x,
     	      xPane size y;
     	  }
     	  break;
     	case RESIZENOTIFY:
     	  if (verbose) {
     	    stdoutStream printOn "RESIZENOTIFY\t%d\t%d\t%d\t%d\n",
     	      e xEventData1,
     	      e xEventData2,
     	      e xEventData3,
     	      e xEventData4;
     	    stdoutStream printOn "Window\t\t%d\t%d\t%d\t%d\n",
     	      xPane origin x,
     	      xPane origin y,
     	      xPane size x,
     	      xPane size y;
     	  }
     	  break;
     	case EXPOSE:
     	  if (verbose) {
     	    stdoutStream printOn "Expose\t\t%d\t%d\t%d\t%d\t%d\n",
     	      e xEventData1,
     	      e xEventData2,
     	      e xEventData3,
     	      e xEventData4,
     	      e xEventData5;
     	  }
     	  break;
     	case BUTTONPRESS:
     	  xCanvasPane drawPoint e xEventData1, e xEventData2;
     	  if (verbose) {
     	    stdoutStream printOn "ButtonPress\t\t%d\t%d\t%d\t%d\t%d\n",
     	      e xEventData1,
     	      e xEventData2,
     	      e xEventData3,
     	      e xEventData4,
     	      e xEventData5;
     	  }
     	  xCanvasPane refresh;
     	  break;
     	case BUTTONRELEASE:
     	  if (verbose) {
     	    stdoutStream printOn "ButtonRelease\t\t%d\t%d\t%d\t%d\t%d\n",
     	      e xEventData1,
     	      e xEventData2,
     	      e xEventData3,
     	      e xEventData4,
     	      e xEventData5;
     	  }
     	  break;
     	case WINDELETE:
      	  xPane deleteAndClose;
     	  exit (0);
     	  break;
     	default:
     	  break;
     	}
         }
       }
     }



Instance Variables
------------------

'dragStart'
     A 'Point' object that records the beginning of a canvas motion
     operation within a window or view port.

'moveCursor'
     The 'X11Cursor' displayed when moving the 'X11CanvasPane' object
     within a window or view port.

'pen'
     A 'Pen' object that contains the width in pixels and color of lines
     and points drawn on the pane's window.

'regions'
     An 'AssociativeArray' that contains the rectangular regions defined
     by the 'defineRegion' method, below.

'viewHeight'
     An 'Integer' that contains the height of the pane's window and
     buffers in pixels.

'viewWidth'
     An 'Integer' that contains the height of the pane's window and
     buffers in pixels.

'viewXOrg'
     The X coordinate of the upper right-hand corner of a canvas'
     visible rectangle within a window or view port.

'viewYOrg'
     The Y coordinate of the upper right-hand corner of a canvas'
     visible rectangle within a window or view port.

Instance Methods
................

'attachTo (Object PARENT_PANE)'
'attachTo (Object PARENT_PANE, String GEOMETRY)'
'attachTo (Object PARENT_PANE, Integer XORG, Integer YORG)'
'attachTo (Object PARENT_PANE, Integer XORG, Integer YORG, Integer XSIZE, Integer YSIZE)'
     Attach a 'X11CanvasPane' object to its parent pane, which is
     typically a 'X11PaneDispatcher' object.  With one argument, this
     method initializes the size of the pane's window and buffers to the
     parent pane's dimensions, and positions the pane at the upper
     left-hand origin of the main window.

     If two arguments are present, the second is a 'String' with the
     geometry specifcation for the subpane.  Subpane geometry strings
     have the form:


          width[%]xheight[%]+x[%]+y[%]


     The dimensions are in pixels, unless a percent sign ('%') follows a
     dimension.  In that case, the dimension is a fractional percentage
     of the parent pane's width or height.  The 'String' may contain a
     combination of absolute and relative dimensions.

     With three arguments, the method positions the pane at XORG,YORG
     within the parent pane, which usually is relative to the upper left
     hand origin of the window.

     With five arguments, the method positions the pane at XORG,YORG
     within the parent pane, with the width and height XSIZE,YSIZE.

'background (String COLOR)'
     Set the background of the pane to COLOR.  You need to update the
     pane using, for example, 'clearRectangle', for the new background
     to be visible.  See the note for 'X11Bitmap' class's 'background'
     method.  *Note X11Bitmap::.

'clear (void)'
     Clear the pane to the background color.

'clearRectangle (Intger XORG, Integer YORG, Integer XSIZE, Integer YSIZE)'
     Clear the pane's image to the window background in a rectangle
     bounded by the method's arguments, and update the top-level pane's
     window.

'copy (X11Bitmap SRC_BITMAP, Integer SRC_X_ORT, Integer SRC_Y_ORG, Integer SRC_WIDTH, Integer SRC_HEIGHT, Integer DEST_X_ORG, Integer DEST_Y_ORG)'
     Copies the contents of SRC_BITMAP to the receiver's drawing
     surface.  The source dimensions are determined by SRC_X_ORG,
     SRC_Y_ORG, SRC_WIDTH, and SRC_HEIGHT.  The method draws the source
     bitmap's contents with the source's upper left-hand corner at
     DEST_X_ORG, DEST_Y_ORG.

     The 'X11Bitmap's' parent drawable must be the receiver's drawable
     surface, and the color depths of the source and destination must
     match.

     The process is similar to the 'refresh' method, below, so programs
     do not need to call both 'copy' and 'refresh' for the same
     operation.

     This slightly abbreviated example program is included in the Ctalk
     package at test/expect/examples-x11/canvas-copy.c as well as the
     XPM graphic, but almost any XPM should work as well.

          #include "coffee-cup.xpm"

          /*
             Set these to the width and height of your pixmap,
             and edit the pixmapFromData expression below to
             the xpm's declaration name.
          */
          #define XPM_WIDTH 127
          #define XPM_HEIGHT 141

          X11CanvasPane instanceMethod drawXPMs (X11Bitmap xpmBitmap) {
            Integer new i;

            for (i = 0; i < 5; i++) {
              self copy xpmBitmap, 0, 0, XPM_WIDTH, XPM_HEIGHT, (i* 40), (i * 40);
            }

            self refresh;
          }

          int main () {
            X11Pane new xPane;
            InputEvent new e;
            X11PaneDispatcher new xTopLevelPane;
            X11CanvasPane new xCanvasPane;
            Application new paneApp;
            X11Bitmap new srcBitmap;

            paneApp enableExceptionTrace;
            paneApp installExitHandlerBasic;

            xPane initialize 10, 10, 300, 300;
            xTopLevelPane attachTo xPane;
            xCanvasPane attachTo xTopLevelPane;

            srcBitmap create xCanvasPane xWindowID, XPM_WIDTH, XPM_HEIGHT,
              xCanvasPane depth;

            xPane map;
            xPane raiseWindow;
            xPane openEventStream;

            xCanvasPane background "white";

            srcBitmap pixmapFromData (0, 0, coffee_cup);

            xCanvasPane drawXPMs srcBitmap;

            while (TRUE) {
              xPane inputStream queueInput;
              if (xPane inputStream eventPending) {
                e become xPane inputStream inputQueue unshift;
                /* We don't have to use, "xPane subPaneNotify e" here, because
                   the program doesn't need to handle any X events for the
                   graphics classes. */
                switch (e eventClass value)
                  {
                  case WINDELETE:
                    xPane deleteAndClose;
                    exit (0);
                    break;
                  case EXPOSE:
                  case RESIZENOTIFY:
          	  xCanvasPane drawXPMs srcBitmap;
                    break;
                  default:
                    break;
                  }
              }
              usleep (100000);
            }
          }


     _Note:_ The 'copy' method retrieves the 'paneBuffer' instance
     variable.  If you use an expresion like the following, then the
     program calls the 'X11Bitmap : copy' method instead.  *Note
     X11Bitmap::.


            myRcvrPane paneBuffer copy ...


'defineRegion (String REGIONNAME, Integer XORG, Integer YORG, Integer XSIZE, Integer YSIZE)'
     Define a rectangular region with name REGIONNAME with the upper
     left-hand corner at XORG, YORG relative to the upper left-hand
     corner of the canvas.  The region has the width XSIZE and height
     YSIZE.  When handling input events, the window system clips the
     region to the canvas' viewable area.

'drawCircle (Circle ACIRCLE, Integer FILLED, String BGCOLOR)'
'drawCircle (Circle ACIRCLE, Pen APEN, Integer FILLED, String BGCOLOR)'
     Draw the circle defined by ACIRCLE in the receiver's paneBuffer.
     If FILLED is true, draws a filled circle.  If the APEN argument is
     given, draws the circle with the color and the line width defined
     by the 'Pen', and fills the interior of the circle with BGCOLOR.

     For an example program, refer to the 'Circle' section of this
     manual.  *Note Circle::.

'drawPoint (Intger X, Integer Y)'
     Draw a dot on the pane's window at the x and y coordinates given by
     the arguments.

'drawLine (Line ALINE)'
'drawLine (Line ALINE, Pen APEN)'
'drawLine (Intger STARTX, Integer STARTY, Integer ENDX, Integer ENDY)'
'drawLine (Intger STARTX, Integer STARTY, Integer ENDX, Integer ENDY, pen APEN)'
     With one argument, a 'Line' object, draws the line using the
     receiver's 'Pen' instance variable.  With two arguments, draws the
     'Line' object with the color and line width given by APEN.

     If given the line's endpoints as arguments, the method draws a line
     on the pane's window from the point given by the STARTX and STARTY
     arguments to the point given by the ENDX and ENDY arguments, with
     the color and the line width given by the receiver's 'Pen' object.

'drawLine (Intger XORG, Integer YORG, Integer XSIZE, Integer YSIZE)'
     Draw a filled rectangle on the pane's window with the upper-left
     hand corner at the point given by the XORG and YORG arguments, with
     the width XSIZE and the height YSIZE.  If a 'Pen' argument isn't
     given, uses the line width and color defined by the receiver's
     'pen' instance variable; otherwise uses the line width and color
     defined by the 'Pen' argument.

'drawRoundedRectangle (Intger XORG, Integer YORG, Integer XSIZE, Integer YSIZE, Integer RADIUS)'
     Similar to 'drawFilledRectangle', but this method takes an extra
     argument, the radius of the corner arcs that round the rendered
     rectangle's corners.

'drawRectangle (Intger XORG, Integer YORG, Integer XSIZE, Integer YSIZE)'
     Draw the borders of a rectangle on the pane's window with the
     upper-left hand corner at the point given by the XORG and YORG
     arguments, with the width XSIZE and the height YSIZE.

'drawRoundedRectangle (Intger XORG, Integer YORG, Integer XSIZE, Integer YSIZE, Integer RADIUS)'
     This method is similar to 'drawRectangle', except that it takes an
     extra argument, RADIUS, which specifies the radius of the arcs that
     form the rectangle's corners.

'directCopy (X11Bitmap SRC_BITMAP, Integer SRC_X_ORT, Integer SRC_Y_ORG, Integer SRC_WIDTH, Integer SRC_HEIGHT, Integer DEST_X_ORG, Integer DEST_Y_ORG)'
     Similar to the 'copy' method, above, except 'directCopy' copies the
     'X11Bitmap' object given as its argument directly to the window.
     This might be quicker, and doesn't require that the program call
     'refresh' (below) to update the window contents, but this method
     may also cause flickering when the window is updated.

'foreground (String COLOR)'
     Set the background of the pane to COLOR.  See the note for
     'X11Bitmap' class's 'background' method.  *Note X11Bitmap::.

'new (String PANE_NAME)'
     Create a new 'X11CanvasPane' instance and initialize its event
     handlers.

     If the argument list contains more than one label, create a new
     'X11CanvasPane' object with the names given by the arguments; for
     example,


          X11CanvasPane new pane1, pane2, pane3;


'pixmapFromData (int X_ORG, int Y_ORG, char *XPM_DATA[])'
     Draw the X pixmap defined by XPM_DATA with the upper left corner at
     X_ORG,Y_ORG on the receiver's pane.

     The XPM_DATA argument is the name of the array declared at the
     start of a 'xpm' file's data array.

'refresh (void)'
     Redraw the pane on the main window.

'refreshReframe (void)'
     Redraw the pane on the main window.  If the user has moved the pane
     by clicking and dragging on it, then reposition the pane within the
     window.

'putStrXY (Integer XORG, Integer YORG String TEXT)'
'putStrXY (Integer XORG, Integer YORG String TEXT, String FONT_DESC)'
'putStrXY (Integer XORG, Integer YORG String TEXT, String FONT_DESC, String COLOR_NAME))'
     Write TEXT on the receiver pane's drawing surface (usually a
     X11Bitmap) at position XORG,YORG.  *Note X11Bitmap::.

     If the fourth argument is FONT_DESC, the method draws the text
     using that font.  If a COLOR_NAME argument is also given, draws the
     text using that color.

'subPaneDestroy (Object SUBPANEREF, InputEvent EVENT)'
     Deletes the pane's window and its data when the user closes the
     pane's window.

'subPaneExpose (Object SUBPANEREF, InputEvent EVENT)'
     Redraws the pane's window whenever it is mapped or displayed after
     being covered by another window.

'subPanePointerInput (Object SUBPANEREF, InputEvent EVENT)'
     Default handler for mouse ButtonPress and ButtonRelease events.
     This method is a no-op here, but it can be re-implemented if
     necessary by subclasses.  The application receives pointer events,
     like all other events, via the top-level window's 'inputStream' (a
     'X11TerminalStream' object).

'subPaneResize (Object SUBPANEREF, InputEvent EVENT)'
     The handler for Resize events from the X display.  Resizes the
     pane's X window and adjusts the pane's dimensions.


File: ctalk.info,  Node: X11ButtonPane,  Next: X11LabelPane,  Prev: X11CanvasPane,  Up: Classes

'X11ButtonPane' Class
---------------------

The 'X11ButtonPane' class defines instance variables and methods that
draw buttons on X windows.  The buttons' appearance is defined by the
values in the instance variables, and they may be used to define the
format of customized buttons and labels.

The definitions of the 'X11ButtonPane's' instance variables' define the
parameters for basic buttons with beveled and non-beveled edges, and the
buttons' text is contained in a 'X11LabelPane' object, which defines the
appreance of a button's text.

Here is a brief example program.


     /* buttons.ca - X11ButtonPane Demonstration */

     #include <ctalk/ctalkdefs.h>

     /* Uncomment this #define to use X bitmap fonts. */
     /* #define XFONTS */

     /* Also, uncomment this to draw a multiline label. */
     /* #define MULTILINE */

     /* Define CORNER_RADIUS > 0 for rounded corners (non-beveled, too).
        The value is the radius of the corner arcs. */
     #define CORNER_RADIUS 0

     /* See the X11FreeTypeFont section of the the Ctalk reference. */
     #define FTFONT_BOLD   200
     #define FTFONT_MEDIUM 100

     int main (void) {
       X11Pane new mainWindow;
       X11PaneDispatcher new dispatcher;
       X11ButtonPane new lbutton;
       X11ButtonPane new rbutton;
       X11LabelPane new label;
       InputEvent new e;

       mainWindow backgroundColor = "blue";
       lbutton backgroundColor = "blue";
       rbutton backgroundColor = "blue";
       label backgroundColor = "blue";
       label textColor = "white";
       label canFocus = false;
       label borderWidth = 0;

       mainWindow initialize 255, 200;
       mainWindow inputStream eventMask =
         EXPOSE|ENTERWINDOWNOTIFY|LEAVEWINDOWNOTIFY|BUTTONPRESS|BUTTONRELEASE|KEYPRESS|KEYRELEASE;
       dispatcher attachTo mainWindow;
       lbutton attachTo dispatcher, "90x50+25+100";
       rbutton attachTo dispatcher, "90x50+135+100";
       label attachTo dispatcher, "147x80+44+15";

       mainWindow map;
       mainWindow raiseWindow;

       mainWindow openEventStream;

       mainWindow setWMTitle "X11ButtonPane Demo";

     #ifndef XFONTS
       /*
        * This is the recommended way to set up fonts for each widget.
        */
       label ftFontVar initFontLib;
       label ftFont "DejaVu Sans", 0, FTFONT_BOLD, 0, 12.0;
       label ftFontVar saveSelectedFont;
       lbutton ftFont "DejaVu Sans", 0, FTFONT_MEDIUM, 0, 10.0;
       lbutton ftFontVar saveSelectedFont;
       rbutton ftFont "DejaVu Sans", 0, FTFONT_MEDIUM, 0, 10.0;
       rbutton ftFontVar saveSelectedFont;
     #else
       lbutton label font "fixed";
     #endif

       label multiLine "X11ButtonPane\nDemo";

     #ifndef MULTILINE
       lbutton label text "Left";
       rbutton label text "Right";
     #else
       lbutton label multiLine "Click\nHere";
       rbutton label multiLine "Click\nHere, Too";
     #endif

     #if CORNER_RADIUS > 0
       lbutton bevelEdges = false;
       lbutton radius = CORNER_RADIUS;
       lbutton label radius = CORNER_RADIUS;
       rbutton bevelEdges = false;
       rbutton radius = CORNER_RADIUS;
       rbutton label radius = CORNER_RADIUS;
     #endif

       lbutton label highlightBackgroundColor = "gray90";
       rbutton label highlightBackgroundColor = "gray90";

       lbutton label highlightTextColor = "gray";
       rbutton label highlightTextColor = "gray";

       lbutton draw;
       lbutton refresh;
       rbutton draw;
       rbutton refresh;
       label draw;
       label refresh;

       while (TRUE) {
         mainWindow inputStream queueInput;
         if (mainWindow inputStream eventPending) {
           e become mainWindow inputStream inputQueue unshift;

           mainWindow subPaneNotify e;

           switch (e eventClass value)
     	{
     	case EXPOSE:
     	  lbutton subPaneExpose (lbutton, e);
     	  rbutton subPaneExpose (rbutton, e);
     	  label subPaneExpose (label, e);
     	  break;
     	default:
     	  if (lbutton haveClick) {
     	    printf ("left button!\n");
     	    lbutton clearClick;
     	  } else if (rbutton haveClick) {
     	    printf ("right button!\n");
     	    rbutton clearClick;
     	  }
     	  break;
     	}
         } else {
           usleep (1000);
         }
       }

     }


Retrieving Button States
........................

The 'X11ButtonPane' class provides several methods to retrieve the state
of a button object.

'haveClick'
     Returns true or false depending on whether the button has been
     clicked recently.  This means that programs do not need to
     constantly monitor a button's state.  If 'haveClick' returns true,
     then the click state can be cleared with the 'clearClick' method
     (below).

'isClicked'
     This method returns true or false depending on whether the
     pointer's button 1 is currently pressed within the button's area.

'clearClick'
     Resets a previous clicked state as returned by the 'haveClick'
     method, above.

'text'
     Returns a 'String' with the button's text.  If the text is
     displayed on several lines, the method concatenates the lines with
     a space character '' '' between them.

Instance Variables
..................

'bevelEdges'
     A 'Boolean' that causes the widget to display beveled edges if
     true.

'bevelWidth'
     An 'Integer' that defines the width of the button's bevelled edges
     in pixels.

'borderColor'
     A 'String' that contains the name of the button's border color when
     drawing a non-beveled button.

'borderMargin'
     An 'Integer' that defines the distance between the border and the
     pane's edge in pixels, when drawing a non-beveled button.

'borderWidth'
'borderHighlighWidth'
     'Integer' values that determine the width a non-beveled button when
     it is clicked on and in its non-highlighted state.

'clicked'
     A 'Boolean' that is true when the pointer's Button 1 is pressed
     while over the widget, and false otherwise.

'highlightHPen'
'highlightVPen'
'shadowPen'
     'Pen' objects that defines the color of the edges' bevels when
     drawing a beveled widget.

'label'
     A 'X11LabelPane' object that contains a button's text and provides
     the methods to draw on the button's surface.  *Note X11LabelPane::.

'radius'
     If greater than zero ('0'), this 'Integer' defines the radius in
     pixels of the curves displayed when the button is drawn with
     rounded corners.

Instance Methods
................

'attachTo (Object PARENTPANE, String GEOMETRY)'
     Attaches the receiver to the parentPane named by PARENTPANE, with
     the placement and size given by 'geometry'.  The parent pane should
     generally be a 'X11PaneDispatcher' which directs X events to the
     correct subpane.

     The positioning of subwindows within the parent window is
     controlled by the arguments to the 'attachTo' methods; in
     particular, these methods accept a geometry specification, as an
     argument, which has the following format.


          width[%]xheight[%]+x[%]+y[%]


     If a dimension does not contain a percent ('%') sign, the
     dimensions are in pixels.  With a percent sign, the dimensions are
     a fractional percentage of the parent pane's width or height, or a
     horizontal or vertical distance that places the subwindow's upper
     left-hand corner that distance from the parent window's upper
     left-hand corner.

'clearClick (void)'
     Resets a button's clicked state as returned by 'haveClick' to
     false.

'draw (void)'
     Draws the button and its label on the pane's buffer so the widget
     can be displayed with the refresh method.

     If the program has saved a font specification to the widget's
     'ftFontVar' instance variable, then this method also selects the
     font before drawing the widget.  If you want a button to display a
     different font than the surronding window, this is the way to
     declare and save a font specification.


          /* The button inherits the ftFont method from X11Pane class. */

          button ftFont "DejaVu Sans", FTFONT_ROMAN, FTFONT_MEDIUM, DEFAULT_DPI, 10.0;
          button ftFontVar saveSelectedFont;


     The 'X11FreeTypeFont' section describes the parameters that the
     'X11FreeTypeFont' class uses when selecting fonts.  *Note
     X11FreeTypeFont::.

'haveClicked (void)'
     Returns a 'Boolean' true or false depending on whether the button
     has been clicked previously.  In that case, the program should call
     the 'clearClick' method to detect further button clicks.

'isClicked (void)'
     Returns a 'Boolean' value of true or false depending on whether the
     pointer's button 1 is currently pressed within the button.

'new (String NEWOBJECTNAME)'
     The 'X11ButtonPane' constructor.  Creates a 'X11ButtonPane' object
     with the classes' instance variables, and initialized the object's
     event handlers and 'Pen' objects for drawing a beveled button.

'subPaneExpose (Object SUBPANE, InputEvent EVENT)'
'subPaneButtonPress (Object SUBPANE, InputEvent EVENT)'
'subPaneEnter (Object SUBPANE, InputEvent EVENT)'
'subPaneLeave (Object SUBPANE, InputEvent EVENT)'
     The class's handlers for events generated by the X server.

'subPaneFocusIn (void)'
'subPaneFocusOut (void)'
     Handlers for focus changes generated by the application.  These do
     not respond to X events and don't require any arguments.  These
     methods are designed to be called by methods like
     'X11PaneDispatcher : shiftFocus' (e.g., in response to a <Tab>
     keypress).

'text (void)'
     Returns a 'String' with the button's text.  If the text is
     displayed on multiple lines, this method concatenates the lines
     with a space character (' ') between them.


File: ctalk.info,  Node: X11LabelPane,  Next: X11ScrollBarPane,  Prev: X11ButtonPane,  Up: Classes

'X11LabelPane' Class
--------------------

'X11LabelPane' objects display text in graphical windows.  The class
provides instance variables and methods that control the label's font,
border, justification, whether the label is highlighted when the pointer
is over it, and formatting of single and multiple line labels.

Formatting label text for multiple line labels, as well as controlling
the text's justification, is described in the subsections below.

Here is a simple example program that displays a X11LabelPane widget.


     #include <ctalk/ctalkdefs.h>

     #define FTFONTS    /* Comment this line out to use X fonts. */
     #define MULTILINE  /* Comment out to display a single line label. */
     #define ROUNDED    /* Comment out to draw borders with straight edges. */

     int main (int argv, char **argc) {
       X11Pane new xPane;
       X11PaneDispatcher new xTopLevelPane;
       X11CanvasPane new xCanvasPane;
       X11LabelPane new xLabelPane;
       InputEvent new e;
       Integer new verbose;
       Exception new ex;

     #ifdef FTFONTS
       xPane ftFontVar initFontLib;
     #endif

       xPane initialize 0, 0, 300, 300;
       xPane inputStream eventMask =
         WINDELETE|EXPOSE|ENTERWINDOWNOTIFY|LEAVEWINDOWNOTIFY;
       xTopLevelPane attachTo xPane;
       xLabelPane attachTo xTopLevelPane, "100x100+25+50";
       xPane map;
       xPane raiseWindow;

       xPane openEventStream;

     #ifdef FTFONTS
       xLabelPane ftFont "DejaVu Sans", 0, 0, 72, 11.0;
     #else
       xLabelPane font "-*-helvetica-medium-r-*-*-*-80-*-*-*-*-*-*";
     #endif
       xLabelPane textColor = "navyblue";

     #ifdef MULTILINE
       xLabelPane multiLine "Labels\ncan occupy\nmultiple\nlines.";
     #else
       xLabelPane text "A Label";
     #endif

     #ifdef ROUNDED
       xLabelPane radius = 10;
     #endif

       xLabelPane draw;

       while (TRUE) {
         xPane inputStream queueInput;
         if (xPane inputStream eventPending) {
           e become xPane inputStream inputQueue unshift;
           xPane subPaneNotify e;  /* Call the classes' event handlers. */
           if (ex pending)
     	ex handle;

           switch (e eventClass value)
          	{
          	case WINDELETE:
           	  xPane deleteAndClose;
          	  exit (0);
          	  break;
          	default:
          	  break;
          	}
         }
       }
     }



Multiple Line Labels
....................

If the label's text contains embedded newline '\n' characters, and the
text is defined using the 'multiLine' method, below, then the text is
display on multiple lines, with the breaks appearing where the newline
characters appear in the text.  The text is displayed centered
vertically, and justified as described in the next section.

For single line labels, use the 'text' method with a 'String' argument
to fit on one line.

Justification
.............

The 'X11LabelPane' widget contains a simple layout engine that can
center label text, or justify it against the right or left margins.

The text's justification is determined by the setting of the
'justification' instance variable, which can have one of three values,
which are defined by the following macros:


     LABEL_LEFT
     LABEL_RIGHT
     LABEL_CENTER


These macros are defined in the 'ctalk/ctalkdefs.h' include file.  To
use them, add the line


     #include <ctalk/ctalkdefs.h>


to the beginning of the source module.

The widget calculates the right and left margins as the following:


     (aLabel margin) + (aLabel highlightBorderWidth) + (aLabel padding)


The highlighted border width is included regardless of whether the
border actually is drawn or the label is hightlighted, so text alignment
remains constant if a program draws and then obscures the border, or
when the pointer passes over the label.

Instance Variables
..................

'border'
     A 'Boolean' that controls whether the label displays a border.  The
     default is 'true'.

'borderColor'
     A 'String' that contains the name of the border's color if the
     label displays a border.  The default is 'black'.

'borderWidth'
     An 'Integer' that defines the width of the border in pixels when
     the widget is not highlighted.  The default is '2'.

'grayed'
     A 'Boolean' that determines whether to draw the widget in a grayed,
     or inactive, state.  The state has no other effect for a
     'X11LabelPane' object.  It can indicate the state of other controls
     in the window.  The default is 'false'.

'grayedColor'
     A 'String' that contains the name of the color to draw the widget
     when it is grayed.  The default is is 'gray'.

'haveMultiLine'
     A 'Boolean' that indicates whether the widget's text is defined
     using the 'multiLine' method, and indicates that the widget should
     format the label's text to span multiple lines.

'highlightBackgroundColor'
     A 'String' that contains the color to draw a highlighted label's
     background.

'highlightBorderColor'
     A 'String' that contain's the name of a highlighed border's color.
     The default is 'black'.

'highlightBorderWidth'
     An 'Integer' that determines the width in pixels of the label's
     border when the widget is highlighed.  The default is two pixels.

'highlightTextBold'
     A 'Boolean' that indicates whether the widget should draw a
     highlighted widget's text using a bold typeface.  The default is
     'false'.

     This variable has no effect when using X11 bitmap fonts.

'highlightTextColor'
     A 'String' that contains the name of the text color when the widget
     is drawn highlighted.  The default is 'black'.

'justify'
     An 'Integer' that determines whether to draw the label's text
     centered horizontally, or justified on the right or left margins.

     This variable recognizes three values, which are #defines in the
     'ctalk/ctalkdefs.h' include file.  The definitions are:


          LABEL_LEFT
          LABEL_CENTER
          LABEL_RIGHT


     To use these macros, add the statement


          #include <ctalk/ctalkdefs.h>


     near the top of the source module.

'leading'
     An 'Integer' that defines the space between lines of a multi-line
     label.  This variable only affects text drawn using scalable fonts
     of the Freetype library.  X11 bitmap fonts contain the leading in
     the character glyphs.

'margin'
     An 'Integer' that defines the distance in pixels between the border
     and the edges of the 'X11LabelPane' object.

'padding'
     An 'Integer' that defines the minimum distance in pixels between
     the inner edge of the border and the pane object's text.

'radius'
     An 'Integer' that describes the radius to round the corners of the
     border with.  If the value is '0' (the default), then draw borders
     with straight edges.

'textColor'
     A 'String' that defines the name of the text color when the widget
     is not highlighted.  The default is 'black'.

'textLine'
     A 'String' that contains the label's text if the text is to appear
     on a single line.  The default is an empty string.

'textLines'
     An 'Array' that contains a multi-line widget's text, as set using
     the 'multiLine' method.

1 Instance Methods
..................

'draw (void)'
'drawButtonLayout (void)'
     Draws the text of the label, and updates the visible label on the
     display.  The instance variables in this class and the text font's
     class allow programs to adjust how the text is laid out.

     The 'drawButtonLayout' method is similar, but it uses a different
     algorithm that is more suited to laying out text on button labels.

     If the widget has saved a font specification to its 'ftFontVar'
     instance variable, then this method also selects the font before
     drawing the label.  If you want a label to have a different font
     than the rest of the window, this is how to declare and save a font
     specification.


          /* The label inherits the ftFont method from X11Pane class. */

          label ftFont "DejaVu Sans", FTFONT_ROMAN, FTFONT_MEDIUM, DEFAULT_DPI, 10.0;
          label ftFontVar saveSelectedFont;


     The 'X11FreeTypeFont' section describes the parameters that the
     'X11FreeTypeFont' class uses when selecting fonts.  *Note
     X11FreeTypeFont::.

'new'
     Creates a new 'X11LabelPane' object, initializes the object's
     instance variables and event handlers, and sets the pane's default
     foreground and background colors.

'subPaneExpose (Object SUBPANE, InputEvent EVENT)'
     The widget's Expose event handler.  When the widget receives an
     Expose event, this method redraws the widget.

'subPaneEnter (Object SUBPANE, InputEvent EVENT)'
'subPaneLeave (Object SUBPANE, InputEvent EVENT)'
     The widget's EnterNotify and LeaveNotify event handlers.  These
     methods set the 'subPane's' 'highlight' instance variable to true
     or false (if the widget is configured to accept input focus), then
     calls the 'draw' method to redraw the label.

'font (String FONTDESC)'
     Sets the X11 font to use for the label's text.  When drawing using
     Freetype scalable fonts, the widget uses the 'ftFont' method from
     'X11CanvasPane'.

'text (String LABELTEXT)'
     Sets the text of a single-line label.

'text (String LABELTEXT)'
     Sets the receiver's 'textLine' instance variable for single-line
     labels.

'multiText (String LABELTEXT)'
     Divides the text given as the argument into lines where newline
     characters '\n' appear in the text, and sets the elements of the
     receiver's 'textLine' instance variable to one line for each array
     element.  Also sets the 'haveMultiLine' instance variable to
     'true'.


File: ctalk.info,  Node: X11ScrollBarPane,  Next: X11TextPane,  Prev: X11LabelPane,  Up: Classes

'X11ScrollBarPane' Class
------------------------

A 'X11ScrollBarPane' object draws a basic scroll bar and allows the user
to move the scroll thumb by clicking and dragging.

Applications can set and read the scroll thumb's size and position via
the object's instance variables.  In particular, the 'thumbHeight'
instance variable sets the vertical size of the scroll thumb, and the
'thumbDimensions' method sets the coordinates and height of the thumb
when sliding it to a new position.

The scroll bar's 'frame' and 'thumb' instance variables are both
'Rectangle' objects.  Applications can use the 'Rectangle' class's
methods, like 'dimension,' to set the scroll position, and can read the
position using the 'Rectangle' object's instance variables.  *Note
Rectangle::.

Here is an example program that demonstrates the basic steps needed to
draw a scroll bar.


     int main (int argv, char **argc) {
       Integer new xWindowSize;
       Integer new yWindowSize;
       X11Pane new xPane;
       X11PaneDispatcher new xTopLevelPane;
       X11ScrollBarPane new xScrollBarPane;
       X11CanvasPane new xCanvasPane;
       InputEvent new e;
       Exception new ex;
       Application new scrollDemo;
       String new pctstr;
       Integer new strWidth;

       scrollDemo enableExceptionTrace;
       scrollDemo installExitHandlerBasic;
       scrollDemo installAbortHandlerBasic;

       xWindowSize = 400;
       yWindowSize = 400;

       xPane ftFontVar initFontLib;
       xPane ftFont "DejaVu Sans", 0, 0, 0, 48.0;

       xPane initialize xWindowSize, yWindowSize;
       xPane inputStream eventMask = WINDELETE|EXPOSE|BUTTONPRESS|BUTTONRELEASE|MOTIONNOTIFY;
       xTopLevelPane attachTo xPane;
       xScrollBarPane attachTo xTopLevelPane, "20x100%+0+0";
       xCanvasPane attachTo xTopLevelPane, "380x100%+20+0";

       xPane map;
       xPane raiseWindow;

       xPane openEventStream;

       xScrollBarPane background "lightblue";
       xScrollBarPane refresh;

       xCanvasPane background "navy";
       xCanvasPane foreground "navy";
       xPane ftFontVar namedX11Color "white";
       xCanvasPane clear;
       pctstr printOn "%0.2f%%", xScrollBarPane percent * 100.0;
       strWidth = xPane ftFontVar textWidth pctstr;
       xCanvasPane putStrXY (380 / 2) - (strWidth / 2), (400 / 2), pctstr;
       xCanvasPane refresh;

       while (TRUE) {

         xPane inputStream queueInput;
         if (xPane inputStream eventPending) {
           e become xPane inputStream inputQueue unshift;

           if (ex pending)
       	ex handle;

           xPane subPaneNotify e;

           switch (e eventClass value)
      	{
     	case EXPOSE:
     	  xCanvasPane paneBuffer clear;
     	  pctstr printOn "%0.2f%%", xScrollBarPane percent * 100;
     	  strWidth = xPane ftFontVar textWidth pctstr;
     	  xCanvasPane putStrXY (380 / 2) - (strWidth / 2), (400 / 2), pctstr;
     	  xCanvasPane refresh;
     	  break;
      	case WINDELETE:
       	  xPane deleteAndClose;
      	  exit (0);
      	  break;
       	default:
     	  xCanvasPane paneBuffer clear;
     	  pctstr printOn "%0.2f%%", xScrollBarPane percent * 100;
     	  strWidth = xPane ftFontVar textWidth pctstr;
     	  xCanvasPane putStrXY (380 / 2) - (strWidth / 2), (400 / 2), pctstr;
     	  xCanvasPane refresh;
       	  break;
      	}
         }
       }
     }


Instance Variables
..................

'arrowCursor'
     A 'X11Cursor' object that contains the resource ID of the widget's
     arrow cursor.  *Note X11Cursor::.

'bevel'
     A 'Boolean' that determines whether the scroll thumb is drawn as a
     beveled widget.

'dragging'
     A 'Boolean' object that is True while the right mouse button is
     clicked while over the scroll thumb.  *Note Boolean::.

'frame'
     A 'Rectangle' object that contains coordinates of the scroll bar
     frame.  *Note Rectangle::.

'frameWidthVar'
     An 'Integer' that contains the width of the scrollbar's visible
     frame in pixels.

'framePen'
     A 'Pen' object that sets the line color and width of the scroll bar
     frame.  *Note Pen::.

'grabCursor'
     A 'X11Cursor' object that contains the resource ID of the widget's
     grab cursor.  *Note X11Cursor::.

'lastY'
     An 'Integer' object that contains the previous PointerMotion
     event's y coordinate while dragging.  *Note Integer::.

'margin'
     An 'Integer' that defines the distance in pixels between the pane's
     edge and the outer edge of the scrollbar frame.

'mouseOver'
     A 'Boolean' that is true if the pointer is over the scrollbar
     frame, false otherwise.

'padding'
     An 'Integer' that defines the distance in pixels between the inner
     edge of the scrollbar frame and the thumb.

'thumb'
     A 'Rectangle' object that contains coordinates of the scroll thumb.
     *Note Rectangle::.

'thumbBackgrondColor'
     A 'String' that contains the name of the X11 color used to draw the
     thumb.

'thumbErasePen'
     A 'Pen' object that sets the color and line width of the scroll
     thumb background when animating the thumb.  *Note Pen::.

'thumbHeight'
     An 'Integer' that sets the height of the scroll thumb.  *Note
     Integer::.

'thumbPen'
     A 'Pen' object that sets the color and line width of the scroll
     thumb.  *Note Pen::.

'thumbPix'
     A 'X11Bitmap' that contains the thumb's beveled image, if the pane
     is drawn with 'bevel' set to 'true'.

Instance Methods
................

'attachTo (Object PARENTPANE)'
     Attaches the 'X11ScrollBarPane' object to its parent pane, which is
     usually a 'X11PaneDispatcher' object.  Also sizes the pane and its
     buffers to fit within the visible window, and sets the dimensions
     of the scrollbar's visible frame and thumb.

'background (String COLORNAME)'
     Sets the pane's background color to COLORNAME, and also sets the
     color to use when performing scrollbar animations.

'drawThumb (void)'
'eraseThumb (void)'
     These methods animate the thumb so that it tracks the pointer's
     position within the scrollbar.

'frameWidth (Integer LINEWIDTH)'
     Calculates the scrollbar frame's dimensions within the pane's
     margins for the line width in pixels given as the argument.

'new (String PANENAME)'
     Creates a new 'X11ScrollBarPane' object, initializes the pane's
     event handlers, and sets the default colors of the pane's elements.

'percent (void)'
     Returns a 'Float' with the position of the thumb's top edge in the
     usable trough of the scrollbar, as a percentage between 0.0 and
     1.0.

     The usable area of the trough is defined as the distance that the
     top edge of the scrollbar thumb can travel within the scrollbar's
     margins; i.e,


          usableTrough = aScrollBar size y -
                            ((aScrollBar margin * 2) +
                             (aScrollBar frameWidthVar * 2) +
                             (aScrollBar padding * 2) +
                             (aScrollBar thumbHeight));


'pointIsInThumb (Integer X, Integer, Y)'
     This method returns a 'Boolean' value of true if the point X,Y is
     within the scroll bar thumb.

'subPaneDestroy (Object SUBPANE, InputEvent EVENT'
'subPaneExpose (Object SUBPANE, InputEvent EVENT'
'subPanePointerInput (Object SUBPANE, InputEvent EVENT'
'subPanePointerMotion (Object SUBPANE, InputEvent EVENT'
'subPaneEnterNotify (Object SUBPANE, InputEvent EVENT'
'subPaneLeaveNotify (Object SUBPANE, InputEvent EVENT'
     The 'X11ScrollBarPane' object's event handlers for DESTROY, EXPOSE,
     BUTTONPRESS/BUTTONRELEASE, MOTIONNOTIFY, ENTERWINDOWNOTIFY, and
     LEAVEWINDOWNOTIFY X Window System events.

'thumbDimensions (Integer Y, Integer HEIGHT)'
     Calculates the position and size thumb's rectangle within the pane
     using the vertical Y position and the thumb's HEIGHT.

'thumbPercent (Float PCT)'
     Calculates the thumb's height as a percent of the trough's vertical
     distance.  The argument, PCT, is a 'Float' between 0.0 and 1.0.

     Note that, in order to make these calculations and update the thumb
     height in the pane's viewing area, the scrollbar must already be
     attached to its parent pane, and the program needs to be receiving
     X events.  So this method should only be used after a call to, for
     example, X11Pane : openEventStream.


File: ctalk.info,  Node: X11TextPane,  Next: X11TextEditorPane,  Prev: X11ScrollBarPane,  Up: Classes

'X11TextPane' Class
-------------------

'X11TextPane' objects display text within a X window.  The class defines
methods to display text when opening or resizing a window, and scrolling
through the text.

The Ctalk distribution's, 'demos,' subdirectory contains several example
applications of 'X11TextPane' objects.

Viewing Text
............

With a 'X11TextPane' window open, the class provides the following
keyboard commands.


     Key(s)                 Action
     ------                 ------
     j, Control-N, <Up>     Scroll the text down by one line.
     k, Control-P, <Down>   Scroll the text up by one line.
     Control-V              Scroll the text down one screenful.
     Control-T              Scroll the text up one screenful.
     Control-Q              Go to the start of the text.
     Control-Z              Go to the end of the text.
     Escape, Control-C      Close the window and exit the program.


Adding and Formatting Text
..........................

To display text, the class provides the methods 'addText', 'putStr', and
'printOn'.

The 'addText' method wraps long lines to fit within the window's viewing
area, and recognizes newline characters as hard line breaks and inserts
soft line breaks where necessary.  The methods 'putStr' and 'printOn'
can display shorter items of text at specific X,Y positions.

For word wrapped text, each member of the 'textList' instance variable
(described below) is a 'TextBox' object, which is an iternal class that
is used exclusively by '__ctalkWrapText' library function and the
'displayText' method.

The class supports both X bitmapped fonts and the X11FreeTypeFont
outline font libraries.  Applications enable outline font support by
calling the 'X11FreeTypeFont' method 'initFontLib' at the start of the
program.

In addition, the class supports different typefaces and simple line
formatting with a small set of HTML-like formatting tags.

     Tag(s)                Action
     ------                ------
     <b>, </b>             Start/end boldface type.
     <i>, </i>             Start/end italic (or oblique) type.
     <center>, </center>   Start/end a centered line of text.


Instance Variables
------------------

'leading'
     An 'Integer' that contains the extra space between lines, in
     pixels.  Its value depends on the font that the program uses.  The
     dimensions of Xlib bitmap fonts seems to provide enough space
     without adding any extra space.  Outline fonts, however, seem to
     need this.  The default is 2 (pixels), which the program can set
     whenever it selects a font.  Currently, this variable has no effect
     with Xlib fonts, though.

'lineHeight'
     An 'Integer' that contains the height of a line in pixels.  Its
     value is set when the program selects a font.  The default is 12
     pixels, which is the value used whenever a program doesn't specify
     any fonts.  The total lineHeight is the height of the tallest
     character ascent + the longest character descent, and optionally,
     any leading, either added by the font designer or the X11TextPane
     object.  Refer to the 'font' method, below.

'scrollHeight'
     An 'Integer' that contains the number of lines that the text moves
     when scrolling by one screenful.  Its value is


          textPaneObject scrollHeight = textPaneObject viewHeight -
                                          textPaneObject scrollMargin


'scrollMargin'
     An 'Integer' that contains the number of lines to overlap when
     scrolling by pagefuls.  Its default value is 3.

'text'
     A 'String' that contains the unformmated text to be displayed in
     the window.  Formatting raw text for display is done by the
     'addText' method, below.

'textList'
     This 'List' object contains the output of the word wrapping
     routines.  Each item of the 'List' is a 'TextBox' object, an
     internal class that stores information about each word of the text.

'textLines'
     An 'Integer' that contains the number of lines of text after it is
     formatted.

'viewStartLine'
     An 'Integer' that contains the number of the first text line that
     is visible in the window.

'requestClose'
     A 'Boolean' that indicates whether the 'X11TextPane' object has
     requested to be closed, normally in response to an Escape or
     Control-C keypress.

'viewXOffset'
     An 'Integer' that contains the left margin of the text when
     displayed in the window.

'viewHeight'
'viewWidth'
     'Integer' objects that contain the width and height of viewable
     area, in characters.  These are normally determined by the font
     that the program selects, and after the program calculates the line
     height (refer to the 'font' method, below).  The 'X11TextPane'
     class adjusts for variable width fonts and faces whenever necessary
     (and possible, in some cases).

     If the program has selected a font, the 'X11TextPane' class
     calculates the width and height of the viewing area like this.


          self viewHeight = self size y / self lineHeight;
          self viewWidth = self size x / self fontVar maxWidth;


     If the program doesn't select any fonts, the class uses 14 pixels
     as the height of each character and 12 pixels as the character
     width.

Instance Methods
................

'addText (Object TEXT)'
     Adds the argument's text to the receiver pane's 'text' instance
     variable, then word-wraps the entire text into the 'textList'
     instance variable.

'attachTo (Object PARENTPANE)'
     Attaches the 'X11TextPane' object to its parent pane.  The parent
     pane should always be a 'X11PaneDispatcher' object.

'cursorPos (Integer X, Integer Y)'
     Set the pane's cursor to the coordinates given as arguments.

'background (String COLORNAME)'
     Set the background color of the text pane.  See the note for
     'X11Bitmap' class's 'background' method.  *Note X11Bitmap::.

'clear (void)'
     Clear the pane to the background color.

'displayText (void)'
     Update the pane's text.  The pane's window is updated at the next
     'refresh' message (see below).

'faceRegular (void)'
'faceBold (void)'
'faceItalic (void)'
'faceBoldItalic (void)'
     Selects the typeface of the currently selected font.  The font
     should be selected by a previous call to the 'font' method (below).
     The 'font' call gathers information about the type variations if
     the typeface is available.

'font (String FONT_DESCRIPTOR)'
     Loads the bitmap font named by FONT_DESCRIPTOR and the bold,
     italic, and bold italic typefaces if they are available, and makes
     the font named by the argument the currently selected the receiver
     Pane's currently selected font.

     If a program uses outline fonts, it has more freedom to decide when
     to select the fonts, because the font libraries operate
     independently of the program's connection to the GUI. *Note
     X11FreeTypeFont::.

     Programs that use Xlib bitmap fonts, however, need to wait until
     the connection to the GUI is opened, with a call to
     'openEventStream' (class 'X11Pane').  *Note X11Pane::.

     Here's a code snippet from 'X11TextPane' class.


            X11FreeTypeFont new ftFont;
            Integer new ftMaxCharWidth;

            self fontDescStr = fontDesc;
            self fontVar getFontInfo fontDesc;
            (X11Bitmap *)self paneBuffer font fontDesc;

            if (ftFont libIsInitialized) {
              self lineHeight = ftFont textHeight "ghyl";
              self lineHeight += self leading;
              ftMaxCharWidth = ftFont textWidth "M";
              self viewWidth = self size x / ftMaxCharWidth;
            } else {
              /* Note that we don't add the leading to the lineHeight here */
              self lineHeight = self fontVar height;
              self viewWidth = self size x / self fontVar maxWidth;
            }
            self viewHeight = self size y / self lineHeight;


'foreground (String COLORNAME)'
     Set the forground color of the text pane.  See the note for
     'X11Bitmap' class's 'foreground' method.  *Note X11Bitmap::.

'gotoXY (Integer X, Integer Y)'
     Set the pane's cursor to the coordinates given as arguments.  The
     coordinates are the number of horizontal and vertical pixels from
     the pane's top-left corner.

     This method is a synonym for 'cursorPos', above.

'new (String PANENAME)'
     Creates a 'X11TextPane' object and initializes the pane's event
     handlers and other instance data.

     If the argument list contains more than one name, create
     'X11TextPane' objects with the names given by the arguments.

'printOn (char *FMT, ...)'
     Print the argument, which is a 'printf(3)' style format string with
     arguments for the format conversion specifiers, in the pane's
     buffer at the position given by the pane's software cursor.  To
     update the visible window with the pane buffer's contents, call the
     'refresh' method (below), after calling this function.

'putChar (Character C)'
     Write a character in the pane's window at the pane's cursor
     position.

'putStr (String S)'
     Write a string in the pane's window at the pane's cursor position.

'refresh (void)'
     Update the text displayed in the pane's window.

'subPaneDestroy (Object SUBPANEREFERENCE, InputEvent EVENT)'
     The class's destructor method.  This method deletes only the data
     associated with the pane object's window, not the pane object
     itself, which is treated like any other object.

'subPaneExpose (Object SUBPANEREFERENCE, InputEvent EVENT)'
     The class's 'EXPOSE' event handler.  Refreshes the main window from
     the pane's text buffer.

'subPaneKbdInput (Object SUBPANEREFERENCE, InputEvent EVENT)'
     The handler for 'KEYPRESS' and 'KEYRELEASE' events from the window
     system.

'subPaneResize (Object SUBPANEREFERENCE, InputEvent EVENT)'
     The handler for 'RESIZENOTIFY' events from the window system.


File: ctalk.info,  Node: X11TextEditorPane,  Next: Symbol,  Prev: X11TextPane,  Up: Classes

'X11TextEditorPane' Class
-------------------------

Objects of 'X11TextEditorPane' class create a X window which displays
text, and editing commands to perform basic text editing operations.

There is an example program that demonstrates a 'X11TextEditorPane'
object's use in a text editor program at the end of this section.

Editing Commands
................

The set of editing commands that a 'X11TextEditorPane' object uses is
given here, along with their key bindings.  You can bind them to
different keys by modifying the 'handleKbdInput' method.

     Right, Ctrl-F       Next character
     Left, Ctrl-B        Previous character
     Up, Ctrl-P          Previous line
     Down, Ctrl-N        Next line
     PgDn, Ctrl-V        Next page
     PgUp, Ctrl-T        Previous page
     Home, Ctrl-A        Start of line
     End, Ctrl-E         End of line
     Ctrl-Q              Start of text
     Ctrl-Z              End of text
     Ctrl-D              Delete character under cursor
     Backspace           Delete previous character.  If selecting text, delete
                         the selection.
     Del                 Delete the character under the cursor, or the
                         previous character if at the end of the text.
                         If there is selected text, delete the selection.
     Esc                 Close the window and exit the program.

     Mouse-1             Move the insertion point cursor to the click.
                         Click and drag the pointer to select text.
     Mouse-2             Paste text of the X selection at the insertion point.


Cutting and Pasting Text
........................

'X11TextEditorPane' objects can copy text selections to the X primary
selection, and paste selected text from other X programs into the
program's text.

To select text to be pasted into another application, press the left
pointer button and drag the pointer across the text that you want to
select.  The text should be highlighted with the color defined in the
'selectionBackgroundColor' instance variable.

Then, switch to the window that you want to paste the text into, and
press the center pointer button at the point where you want to insert
the text (or press the left and right buttons simultaneously on machines
with two buttons).

Conversely, to paste text into the 'X11TextEditorPane' object's
contents, select the text in the other application's window, then switch
to the 'X11TextEditorPane' object's window, and press the center pointer
button at the point where you want the text inserted.

If the program has text selected and another program tries to place its
contents in the X primary selection, the class will allow the selection
ownership to change to the other program.  Any text that was selected in
the 'X11TextEditor' pane's window will no longer be selected.

In general, X programs aren't required to send their to the display's X
selection buffers.  Many programs only use selected contents internally,
and may require another command to send the content to the X display's
primary selection buffer.  'X11TextEditorPane' objects maintain the
contents of its selection buffer continuously when selecting, but they
only send the contents to the X display's primary selection when another
program requests it.

Fonts
.....

The demonstration program, 'demos/x11/ctedit.ca', provides options to
change the default font and point size.  The X11 utility programs
'xfontsel(1)' and 'fc-list(1)' can display the X bitmap fonts and the
Xft library's scalable fonts that are available on the machine,
respectively.

Programs configure X fonts within the window's graphics context, using
the instance variable 'fontVar', which is inherited from 'X11Pane'
class.

FreeTypeFonts need to be configured separately from the X window, but
the parent 'X11Pane' object also defines the 'ftFontVar' instance
variable, so the program can configure outline fonts before entering its
event loop.

If a program is to be configurable for different machines, it should
check which of the font libraries are present on the system, and which
of the 'fontVar' or 'ftFontVar' instance variables the program has
configured in the program's initialization.

The 'X11TextEditorPane' class uses monospaced fonts exclusively.  If a
program requests a proportionally spaced font, the pane's libraries
won't maintain alignment between the displayed text and editing
operations.

The sections, 'X11FreeTypeFont' and 'X11Font' contain more information
about how to select fonts.  *Note X11FreeTypeFont::, *Note X11Font::.

Instance Variables
..................

'bufLength'
     An 'Integer' that records the size of the object's text buffer.
     The class adjusts the buffer's size automatically if necessary.

'button'
     An 'Integer' that records the state of the mouse buttons, i.e.,
     whether they are pressed or not.  The values that the the variable
     might contain are composed of these definitions.


          #define BUTTON1MASK  (1 << 0)
          #define BUTTON2MASK  (1 << 1)
          #define BUTTON3MASK  (1 << 2)


'foregroundColor'
     A 'String' that contains the window's foreground color.  The
     variable is included here to facilitate drawing the cursor in
     reverse video.  The 'backgroundColor' instance variable is declared
     in 'X11Pane' class.  *Note X11Pane::.

     An 'Integer' that defines the right margin in character columns.
     Setting this to zero '0' sets the line width limit to the line
     length, so the line width in character columns is calculated as:


          lineWidth = (window_width_px - left_margin_px - right_margin_px) /
                         character_width_px;


'rightMargin'
     The distance in pixels from the right edge of the window, leftward
     to the right-hand limit of each line's length.

'point'
     An 'Integer' that contains the current position in the text where
     editing occurs.

'selectionBackgroundColor'
     A 'String' that contains the background color of selected text.
     The foreground color is the same as normal text.

'sStart'
'sEnd'
'selecting'
     The 'Integer' variables 'sStart' and 'sEnd' record the beginning
     and end of selected text as character indexes into the text.  The
     'Boolean' variable 'selecting' is true while the pointer is being
     dragged across text while Button 1 is pressed.

'shiftState'
     An 'Integer' that records whether the Shift of Control keys are
     currently pressed.

'textLength'
     An 'Integer' that records the length of the object's text.

Instance Methods
................

'attachTo (Object PARENT_PANE)'
     Attach a 'X11TextEditorPane' object to its parent pane, which is
     typically a 'X11PaneDispatcher' object.  This method initializes
     the size of the pane's window and buffers to the parent pane's
     dimensions, and positions the pane at the upper left-hand origin of
     the main window.

'background (String COLORNAME)'
'foreground (String COLORNAME)'
     Sets the foreground and backgrounds color of the pane's window and
     buffers.

'clearSelection (void)'
     Sets the 'sStart' and 'sEnd' instance variables to '0', cancelling
     text selection.

'defaultFormat (void)'
     Sets the document-wide margins and text text colors.  If the pane
     is using an 'X11FreeTypeFont' object to render text, the font needs
     to be configured before calling this method.  *Note
     X11FreeTypeFont::.

'displayText (void)'
     Displays the text and editing cursor.  Programs should call this
     method as soon as possible after the program starts the X event
     loop (which it does by calling the 'X11TerminalStream :
     openEventStream' method), and after every editing operation.

'gotoChar (Integer N)'
     Sets the 'point' instance variable to the N'th character in the
     text.  If N is greater than the length of the text, sets 'point' to
     the end of the text.

'new (String PANENAME)'
     Initializes the 'X11TextEditorPane' object's event handlers, and
     calls constructors in the 'X11TextEditorPane's' superclasses to
     perform addition initialization.  The method 'attachTo', declared
     in 'X11TextPane' class, performs the actual dimensioning of the
     pane and its buffers.  *Note X11TextPane::.

'subPaneKbdInput (X11TextEditorPane SUBPANE, InputEvent EVENT)'
     Handles Keypress and KeyRelease events from the X server.  It's
     possible to reconfigure the editing commands by modifying this
     method.

     The method works in conjuction with the Ctalk library's editing
     functions to translate alphanumeric and punctuation characters with
     the correct shift and control state, and to transmit special keys
     like arrow keys and Home/End keys untranslated.

'subPaneButtonPress (X11TextEditorPane SUBPANE, InputEvent EVENT)'
     The handler for button press and button release events.  This
     method sets the value of the 'button' instance variable, in
     addition to performing other tasks.

'subPaneMotionNotify (X11TextEditorPane SUBPANE, InputEvent EVENT)'
     The handler method for pointer motion events.

'subPaneResize (X11TextEditorPane SUBPANE, InputEvent EVENT)'
     Handles resizing the 'X11TextEditor' pane's dimensions in response
     to a window resize event.  This method is a no-op in the current
     release.

'subPaneSelectionClear (X11TextEditorPane SUBPANE, InputEvent EVENT)'
     Updates the program's state after receiving a a SelectionClear
     event.  Normally this occurs when another program requests the X
     primary selection.  The method updates this program's state so that
     it is no longer selecting, and redraws the text.

Example Text Editing Program
............................

     /*
       ctedit.ca - Basic text editor using X11TextEditorPane class.

       Usage:

         ctedit [<options>] <filename>

       Typing, "ctedit -h" displays a list of options.

       Pressing Esc or selecting "Close" from the window menu
       exits the program and saves the edited text.

       If <filename> exists, ctedit renames the previous version
       of the file to <filename>.bak.  If <filename> doesn't
       exist, ctedit creates a new file.

       The editing commands are set in the X11TextEditorPane :
       handleKbdInput method.  They are:

          Right, Ctrl-F       Next character
          Left, Ctrl-B        Previous character
          Up, Ctrl-P          Previous line
          Down, Ctrl-N        Next line
          PgDn, Ctrl-V        Next page
          PgUp, Ctrl-T        Previous page
          Home, Ctrl-A        Start of line
          End, Ctrl-E         End of line
          Ctrl-Q              Start of text
          Ctrl-Z              End of text
          Ctrl-D              Delete character under cursor
          Backspace           Delete previous character
          Del                 At the end of the text, delete the
                              previous character.  Otherwise delete
                              the character under the cursor.
          Esc                 Close the window, save the edited text,
                              and exit the program.
      */

     #define WIN_WIDTH 500
     #define WIN_HEIGHT 340
     #define WIN_X 25
     #define WIN_Y 30
     #define FIXED_FONT "fixed"
     #define DEFAULT_BG "white"
     #define DEFAULT_FG "black"
     #define DEFAULT_FT_FONT "DejaVu Sans Mono"
     #define DEFAULT_FT_PTSIZE 12.0

     Application new ctEdit;
     String new geomString;
     String new infileName;
     String new xFontName;
     String new ftFontName;
     Float new ftFontSize;
     String new bgColor;
     String new fgColor;

     Boolean new createFile;

     Boolean new useFtFonts;
     X11FreeTypeFont new ftFont;
     Boolean new useXFont;

     void exit_help () {
       printf ("usage: ctedit [-h] | [-g <geom>] [-fg <color>] "
     	  "[-bg <color>] [-fn <font> ] <filename>\n");
       printf ("-bg <color>    Set the window background to <color>.\n");
       printf ("-fg <color>    Display the text using <color>.\n");
       printf ("-fn <font>     Use the X <font> to display the text. See xfontsel(1).\n");
       printf ("-ft <font>     Use the FreeType <font> to display the text. See\n");
       printf ("               X11FreeTypeFont class.\n");
       printf ("-g  <geom>     Set the window geometry to <geom>. See XParseGeometry (3).\n");
       printf ("-h             Print this message and exit.\n");
       printf ("-xfonts        Use X bitmap fonts, even if outline fonts are available.\n");
       exit (1);
     }

     /* UNIX-compatible line ending. */
     #define LF 10

     X11TextEditorPane instanceMethod writeOutput (String infileName) {
       "Create a backup of the previous version of the file, if any,
        and check that the text ends with a UNIX-standard newline
        (ASCII 10) character."
       WriteFileStream new writeFile;
       Character new c;

       c = self text at (self text length - 1);
       if (c != LF) {
         self text += "\n";
       }

       if (!createFile)
         writeFile renameFile infileName, infileName + ".bak";
       writeFile openOn infileName;
       writeFile writeStream (self text);
       writeFile closeStream;

     }

     Application instanceMethod commandLineOptions (void) {
       Integer new i, nParams;
       String new param;


       nParams = self cmdLineArgs size;
       for (i = 1; i < nParams; i++) {

         param = self cmdLineArgs at i;

         if (param  == "-g") {
           ++i;
           geomString = self cmdLineArgs at i;
           continue;
         }
         if (param == "-fn") {
           ++i;
           xFontName = self cmdLineArgs at i;
           continue;
         }
         if (param == "-bg") {
           ++i;
           bgColor = self cmdLineArgs at i;
           continue;
         }
         if (param == "-fg") {
           ++i;
           fgColor = self cmdLineArgs at i;
           continue;
         }
         if (param == "-ft") {
           ++i;
           ftFontName = self cmdLineArgs at i;
           continue;
         }
         if (param == "-xfonts") {
           useXFont = True;
           continue;
         }
         if (param == "-pt") {
           ++i;
           ftFontSize = (self cmdLineArgs at i) asFloat;
           continue;
         }
         if (param == "-h" || param == "--help" || param == "--h" ||
     	param at 0 == '-') {
           exit_help ();
         }

         infileName = param;

       }

     }

     Application instanceMethod winDimensions (void) {
       if (geomString length > 0) {
         self parseX11Geometry geomString;
         if (self winWidth == 0) {
           self winWidth = WIN_WIDTH;
         }
         if (self winHeight == 0) {
           self winHeight = WIN_HEIGHT;
         }
         if (self winXOrg == 0) {
           self winXOrg = WIN_X;
         }
         if (self winYOrg == 0) {
           self winYOrg = WIN_Y;
         }
       } else {
         self winWidth = WIN_WIDTH;
         self winHeight = WIN_HEIGHT;
         self winXOrg = WIN_X;
         self winYOrg = WIN_Y;
       }
     }

     Application instanceMethod findFtFonts (void) {

       if (useFtFonts && !useXFont) {
         ftFont initFontLib;
         ftFont selectFont ftFontName, 0, 80, 72, ftFontSize;
         ftFont namedX11Color fgColor;
       }

     }

     int main (int argc, char **argv) {
       X11Pane new xPane;
       X11PaneDispatcher new xTopLevelPane;
       X11TextEditorPane new xEditorPane;
       InputEvent new e;
       Exception new ex;
       X11Cursor new watchCursor;
       ReadFileStream new readFile;
       String new winTitle;

       geomString = "";
       xFontName = FIXED_FONT;
       bgColor = DEFAULT_BG;
       fgColor = DEFAULT_FG;
       infileName = "";
       useFtFonts = True;
       useXFont = False;
       ftFontSize = DEFAULT_FT_PTSIZE;
       ftFontName = DEFAULT_FT_FONT;

       ctEdit parseArgs argc, argv;
       ctEdit commandLineOptions;
       ctEdit winDimensions;

       if (ftFont version < 10) {
         useFtFonts = false;
       } else {
         ctEdit findFtFonts;
       }


       if (infileName length == 0) {
         exit_help ();
       }

       if (!readFile exists infileName) {
         createFile = true;
         winTitle = infileName + "   (New file)";
       } else {
         readFile openOn infileName;
         xEditorPane text = readFile readAll;
         readFile closeStream;
         winTitle = infileName;
         createFile = false;
       }

       xPane initialize ctEdit winXOrg, ctEdit winYOrg,
         ctEdit winWidth, ctEdit winHeight, ctEdit geomFlags, winTitle;

       xTopLevelPane attachTo xPane;
       xEditorPane attachTo xTopLevelPane;
       xPane map;
       xPane raiseWindow;
       watchCursor watch;

       xPane openEventStream;

       /* This sets the maximum line width to the width of the window. */
       xEditorPane lineWidth = 0;

       if (!useFtFonts || useXFont) {
         xEditorPane foreground fgColor;
         xEditorPane font xFontName;
         xEditorPane defaultFormat;
       } else {
         xEditorPane defaultFormatFT ftFont;
       }

       xEditorPane background bgColor;
       xEditorPane clear;

       xPane defaultCursor;

       while (TRUE) {
         xPane inputStream queueInput;
         if (xPane inputStream eventPending) {
           e become xPane inputStream inputQueue unshift;
           xPane subPaneNotify e;
           if (ex pending)
      	ex handle;
           switch (e eventClass value)
     	{
     	  /*
     	   *  Handle both types of events in case the window
     	   *  manager doesn't distinguish between them.
     	   */
     	case MOVENOTIFY:
     	  break;
     	case RESIZENOTIFY:
     	  break;
     	case EXPOSE:
     	  xEditorPane displayText;
     	  break;
     	case WINDELETE:
     	  xEditorPane writeOutput infileName;
      	  xPane deleteAndClose;
     	  exit (0);
     	  break;
     	default:
     	  break;
     	}
         } else {
           if (xEditorPane requestClose) {
     	xEditorPane writeOutput infileName;
     	xPane deleteAndClose;
     	exit (0);
           }
         }
       }
     }


File: ctalk.info,  Node: Symbol,  Next: Key,  Prev: X11TextEditorPane,  Up: Classes

'Symbol' Class
--------------

'Symbol' class objects represent memory locations.  They can refer to
objects, C variables, buffers, I/O ports, and other data located in
memory.

As an alternative, if you receive an 'Unimplemented C type' warning, you
can store various types of C data in 'Symbol' objects.  *Note Objects in
Function Arguments::.

A unary '*' operator behaves similarly to the C operator.  That is, it
refers to the value of the 'Symbol' object, not the object itself.  The
following example might make this clearer.


     int main () {

       Symbol new sym1;
       Symbol new sym2;
       Symbol new sym3;
       Integer new i;

       i = 2;

       sym3 = sym1;   /* Save the original value of sym1. */

       sym1 = i;
       printf ("%d\n", sym1);

       *sym2 = i;
       printf ("%d\n", *sym2);

       sym1 = sym3;  /* Restore sym1 to the original object. */

       i = 4;

       *sym1 = i;

       printf ("%d\n", *sym1);
     }


Instance Variables
------------------

'value'
     The value of a 'Symbol' is a hexadecimal memory address.

Instance Methods
................

'* (void)'
     The '*'.  A shortcut for the 'getValue' method, below.

'= (void *V)'
     Assign a reference to the argument as the value of the receiver.
     If V is also a 'Symbol' object, simply copy the reference.  This
     method is a synonym for 'symbolReference', below.  If you want to
     use multiple levels of object references and dereferences, see the
     'addressOf' method in 'Object' class *Note Object::, and the
     'deref' method, below.

'asAddrString (void)'
     Returns a 'String' object with the formatted hexadecimal address of
     the object pointed to by the receiver.

'asString (void)'
     Returns the receiver's value as a 'String' object with the value of
     the 'char' string that the 'Symbol' receiver object points to.  The
     result object has the same name as the receiver and the class of
     'String'.

'basicObject (char *NAME, char *CLASSNAME, char *SUPERCLASSNAME, char *VALUE_EXPR)'
     Create a basic object and make the receiver's value point to it.
     The new object has the scope 'LOCAL_VAR|VAR_REF_OBJECT' and a
     reference count of 1.

     Referencing the object with a 'Symbol' makes it easy to create
     objects and then assign them to C variables in the calling method
     or function.  For example,


            Symbol new s;
            OBJECT *int_object;

            s basicObject "new_int", "Integer", "Magnitude", "10";

            int_object = s getValue;

            printf ("%d\n", int_object value);


'deref (void)'
     Return the object referred to by the receiver.  This method is
     functionally equivalent to the C '*' operator.

'getValue (void)'
     Return the object that the receiver's value (previously set by '='
     or 'symbolReference') refers to.  If the address doesn't refer to
     an object, returns the receiver and generates an exception, which
     the program can handle in whatever manner is necessary.  In some
     cases, the internals of Ctalk's object-to-C routines can also
     generate an warning message.

     Note that when assigning a non-object data address to a C variable
     like a 'void *', Ctalk allows both of these expressions:


           void *myVoidPtr;

           myVoidPtr = mySymbol;

           myVoidPtr = *mySymbol;   /* Generates an exception. */


'name (void)'
     Return a new 'String' object containing the receiver's name.

'removeValue (void)'
     Remove the reference to the target object from the receiver.
     Delete the target object if there are no further references to it.

'symbolReference (void *V)'
     Return a new 'String' object containing the receiver's name.


File: ctalk.info,  Node: Key,  Next: Vector,  Prev: Symbol,  Up: Classes

'Key' Class
-----------

Objects of class 'Key' are key-value pairs.  Other classes and programs
can use 'Key' objects' names when looking up objects.  The value of a
key object is a reference to the value object.

Many of the 'Collection' subclasses are composed entirely of 'Key'
objects, which act as the "glue" that maintains references to the the
actual contents of the collection.  *Note Collection::.

Programs can also manipulate 'Key' objects independently.  Most of the
math operators that work with collections actually work with 'Key'
objects.  So it's important to add the attribute
OBJECT_IS_MEMBER_OF_PARENT_COLLECTION to a 'Key' object when building
collections.  This tells Ctalk that the 'Key' object can be used
independently, as well as part of its parent collection.  *Note
Attributes::.

Here's a program that manipulates the 'Key' objects of a collection
(here, an 'AssociativeArray') directly.  *Note AssociativeArray::.


     int main (int argc, char **argv) {

       AssociativeArray new a;
       Key new k;

       a atPut "key1", "value1";
       a atPut "key2", "value2";
       a atPut "key3", "value3";
       a atPut "key4", "value4";

       k = *a;

       while (++k)
         printf ("%s --> %s\n", k name, *k);

     }


Instance Variables
------------------

'value'
     The value is the formatted representation of a hexadecimal pointer
     to a memory address.

Instance Methods
................

'+ (Integer N)'
     Increments the receiver by N.  For a 'Key' object, this sets the
     receiver to the NTH successive element in a collection.  The
     increments are numbered with '1' pointing to the first member of
     the collection, and so on.  If there are no more elements, the
     receiver's value is NULL. For an example, refer to '-', below.

'++'
     Increments the receiver to point to the next 'Key' in a collection.
     If the receiver is already the last item item in the collection,
     the value of the receiver after it is incremented is NULL. This
     method works as both a prefix and postfix method, and increments
     the receiver either before or after it is referenced, respectively.

     Here is an example of how to iterate over an 'AssociativeArray'
     using '++'.


            AssociativeArray new a;
            Key new k;

            a atPut "key1", "value1";
            a atPut "key2", "value2";
            a atPut "key3", "value3";
            a atPut "key4", "value4";

            k = *a;

            while (++k)
              printf ("%s --> %s\n", k name, *k);


'- (Integer N)'
     Decrements the receiver by N.  For a 'Key' object, this sets the
     receiver to the NTH previous element of the collection that the
     receiver is a member of.  Here is a brief example


          int main () {

            AssociativeArray new a;
            Key new k;

            a atPut "1", "value1";
            a atPut "2", "value2";
            a atPut "3", "value3";
            a atPut "4", "value4";

            k = *a;
            printf ("%s --> %s\n", k name, *k);
            k = k + 3;
            printf ("%s --> %s\n", k name, *k);
            k = k - 1;
            printf ("%s --> %s\n", k name, *k);
          }


     Running this program produces the following output.


          1 --> value1
          4 --> value4
          3 --> value3


'--'
     Decrements the receiver to point to the previous 'Key' in a
     collection.  If the receiver is the first item in the collection,
     the value of the receiver after it is decremented is NULL. Like
     '++', this method works as both a prefix and postfix method, and
     decrements the receiver either before or after it is referenced,
     respectively.

'='
     If the receiver refers to an object reference (that is, preceded by
     a '*' operator), sets the value of the receiver to the address of
     the argument.  Otherwise, sets the receiver to refer to the
     argument.

'getKeyObject (void)'
     Return the receiver.

'setName (char *KEY_NAME)'
     Set the receiver's name to the argument, a 'String' object.

     _Note:_ In some cases, the object's name is the only way that Ctalk
     can refer to it.  In that case, the program needs to maintain an
     alias to the object, like an 'OBJECT *,' so that it can refer to
     the object later.  In the following example, the program can refer
     to 'keyObject' by using 'key_alias_ptr,' regardless of the object's
     name.
          Key new keyObject;
          OBJECT *key_alias_ptr;
          ...
          key_alias_ptr = KeyObject setName keyNameString;

'ulink (void)'
     Detach the receiver object from its parent collection.  The method
     also removes the OBJECT_IS_MEMBER_OF_PARENT_COLLECTION attribute
     from the receiver.


File: ctalk.info,  Node: Vector,  Prev: Key,  Up: Classes

'Vector' Class
--------------

Objects of 'Vector' class refer to blocks of memory of arbitrary length.
The memory area that the 'Vector' object points to may contain any data,
including NULL bytes.

Whenever a program or method assigns a 'Vector' object a new area of
memory, the program or method also sets the 'Vector' object's 'length'
instance variable; for example, the method 'readVec' (class
'ReadFileStream') records the memory area's size in the 'length'
instance variable after it has read a chunk of data from a disk file.
*Note ReadFileStream::.

Here's an example program that writes a copy of a JPEG image file.


     int main () {
       ReadFileStream new readF;
       WriteFileStream new writeF;
       FileStream new f;
       Vector new vec;
       LongInteger new size;

       readF openOn "original.jpeg";
       readF statStream;
       size = readF streamSize;

       vec = readF readVec size;

       writeF openOn "copy.jpeg";
       writeF writeVec vec;

       writeF closeStream ;
       readF closeStream;
     }


Instance Variables
..................

'length'
     An 'Integer' that contains the size in bytes of the memory area
     that the 'Vector' object points to.

Instance Methods
................

'+ (Vector V)'
     Return a 'Vector' object that is the concatenation of the receiver
     and the argument.

'+= (Vector V)'
     Concatenate the receiver with the vector given as the argument.

'asString (void)'
     Returns the value of the receiver as a 'String' object terminated
     with a NUL byte to the value of the receiver's 'length' instance
     variable.  Does not check for NULs or non-printing characters in
     the value, so the returned 'String' may still be truncated to less
     than the receiver's length.

'basicNew (char *NAME, char *VALUE, int VALUE_LENGTH'
'basicNew (char *NAME, char *CLASSNAME, char *SUPERCLASSNAME, char *VALUE, int VALUE_LENGTH)'
     Create a new 'Vector' object with the name, contents, length, and,
     optionally, class name and superclass name given as the arguments.

     For the five-argument form of 'basicNew', the class should be
     'Vector' and the superclassname should be 'Symbol', unless the
     program has subclassed 'Vector'.

     In the three-argument form, the receiver must be a member of
     'Vector' class or its subclasses, in which case the method takes
     the class and superclass from the receiver, as in this example.


          myBuf = Vector basicNew "memorybuf", memory_buf_ptr, memory_buf_length;


     The VALUE argument may be any memory address that points to data of
     arbitrary size, and may contain any data, including NULL bytes.

     The VALUE_LENGTH argument supplies the length of the memory segment
     in bytes, which the returned 'Vector' object stores in its 'length'
     instance variable.

     Most of the internal work of setting the values and attributes of
     the returned object, and registering the memory area, is performed
     by '__ctalkSetObjectValueAddr', which each of these methods call.
     *Note ctalkSetObjectValueAddr::.

     It's also necessary that these methods take care of other
     initialization tasks which are necessary for all classes of
     objects.  They're described in general in the description of
     'basicNew' ('Object' class).  *Note ObjectbasicNew::.

'contains (String PATTERN)'
'contains (String PATTERN, Integer start_offset)'
     With one argument, returns an 'Integer' with the byte offset of the
     first occurence of PATTERN in the receiver, starting from the
     beginning of the receiver's value, or -1 if the pattern is not
     found.

     If a second argument is given, it contains the 'Integer' offset
     into the buffer where the method begins its search.  That allows
     programs to find multiple matches of the same pattern in the
     receiver's value.


File: ctalk.info,  Node: Methods,  Next: C,  Prev: Classes,  Up: Top

Methods
=======

The following sections outline some of the programming features that
Ctalk methods implement.  The 'Ctalk Tutorial' provides step-by-step
instructions on how to write some common method types.

Declaring a method is similar to declaring a C function, but the
declaration syntax adds some additional features.

   * The declaration specifies the class that the method belongs to.
   * The statement allows the method to be identified by an alias, so
     the method can overload operators.  Classes can implement
     overloaded methods in other ways, too.  *Note Overloading::.

To declare an instance method, use the 'instanceMethod' keyword, as in
the following example.

     String instanceMethod = set_value (char *s) {

      ... method statements

     }

This example declares an instance method, '=', which is recognized by
objects that belong to the class 'String' and its subclasses.  The '='
in the declaration overloads C's '=' operator, so that, instead of
assigning a value to a C variable, the method sets the value of its
receiver.

In this example, the receiver is an instance of class 'String.'

     newObject = "Hello, World!";

If the variable reference immediately preceding '=' refers to a C
variable, then '=' behaves as the C operator, '=.'

Ctalk can use most C operators as methods, with the exception of
parentheses and prefix operators.  Receivers always precede the method
message.

For example, the 'Integer' methods 'invert' and 'bitComp' perform the
same operations as the C prefix operators '!' and '~.'
     int i;              /* C variable. */
     Integer new myInt;  /* Ctalk object. */

     i = 0;
     myInt = 0;

     /* These two statements are equivalent. */
     printf ("%d", !i);
     printf ("%d", myInt invert).

     /* And so are these two statements. */
     printf ("%d", ~i);
     printf ("%d", myInt bitComp);

Declaring Methods
-----------------

The declaration syntax for instance methods is:

     CLASSNAME 'instanceMethod' [ALIAS] FUNCNAME (ARGS) { METHOD BODY }

and for class methods:

     CLASSNAME 'classMethod' [ALIAS] FUNCNAME (ARGS) { METHOD BODY }

If ALIAS is omitted, Ctalk refers to the method by FUNCNAME.

In the example at the beginning of this section, if '=' were omitted, a
program could refer to the method by the message, 'set_value.'

With the exception of the primitive methods 'class', 'new',
'classMethod', and 'instanceMethod', Ctalk declares methods in its class
library, or in the program input.  *Note Classes::.

Method Parameters
-----------------

You can use Ctalk class objects to declare method parameters, but you
can also declare parameters using C data types, in order to prevent
class libraries from being loaded recursively.  This is necessary in
many of the basic classes.

Regardless of how you declare method parameters, when the method's
message is sent to an object, Ctalk translates C language arguments into
class objects.

For example, these two declarations are equivalent.
     Integer instanceMethod + add (int i) {
     ...
     }

     Integer instanceMethod + add (Integer i) {
     ...
     }

Ctalk does not use objects in C function arguments, so if you need to
use objects as parameters, you must write a method instead of a C
function.

* Menu:

* Method API::            The method application programming interface.
* Self and super::        How to refer to receivers and superclass methods.
* Class initialization::  How to set class variables at run time.
* Translating::           C to objects and back again.
* C Macros::              Macros that provide convenient shortcuts.
* Prefixes::              Methods can also overload C unary operators.
* Required classes::      Preloading classes that you will need.
* Scoping::               An object can have many scopes.
* Templates::             Method wrappers for C-language tasks.
* Return values::         How to return objects of various classes.
* Variable arguments::    Calling C library functions with variable arguments.
* Overloading::           How Ctalk works with multiple method definitions.
* Variable method arguments::
                          Ctalk allows flexible argument lists.
* Method functions::      Methods that are called as C functions.
* Errors::                Exception and error handling.
* Cautions::              Precautions for using objects with C variables.
* Method keywords::       Ctalk keywords that apply to methods.
* Documentation::         Describing methods, classes, and variables
                          in publicly visible comments.
* Ctalk library::         Library function reference.


File: ctalk.info,  Node: Method API,  Next: Self and super,  Up: Methods

Method Application Programming Interface
----------------------------------------

This section describes the C functions and macros that methods use to
interface with the Ctalk run time libraries and with each other.

At this point, the method API is still developing, and relies heavily on
C library functions.

This example shows method '+' of class 'Integer', which adds two Integer
objects, creates an object for the result, and returns the result.

     Integer instanceMethod + add (int i) {

       OBJECT *op1, *op2;

       op1 = self value;
       op2 = i value;

       methodReturnInteger(atoi(op1->__o_value) + atoi(op2->__o_value))
     }

The keyword 'self' refers to the receiver of the method.  *Note Self and
super::.

The variables 'op1' and 'op2' are the 'value' instance variables of the
receiver and the argument.  Ctalk has a method, 'value' (class
'Object'), which returns the 'value' instance variable, but you can also
refer to instance variables by sending an instance variable's name as a
message to an object.

Internally, the receiver, arguments, and return value of a method are
all 'OBJECT *'.  When you use C functions with objects, you use the
members of an OBJECT type, a 'struct.' (*Note OBJECT typedef::.)  If you
declare an object as a C 'OBJECT *,' then the method uses it like any
other C 'struct *.'

All methods return an 'OBJECT *' as the result.  The macro
'methodReturnInteger' defines the object that the method returns.  *Note
Return values::.

The 'add' method is in 'classes/Integer'.  The file 'include/object.h'
contains the declaration of the 'OBJECT' type.


File: ctalk.info,  Node: Self and super,  Next: Class initialization,  Prev: Method API,  Up: Methods

'self' and 'super'
------------------

The keywords 'self' and 'super' refer to the method's receiver object
and a method in a superclass of the receiver's class, respectively.

Refer to the method '+' (class 'Integer') from the previous section.  If
you call '+' with the statement below, 'self' in the '+' method would
refer to 'i.'

     j = i + 2;

The 'super' keyword refers to a method in one of the superclasses of the
receiver.  It is commonly used in constructors.

For example, if a class implements its own 'new' method that performs
additional initialization for instances of a class, it can also call
'new' implemented by a superclass.

This constructor from the 'ReadFileStream' method, 'new', also calls
'new' from class 'Object.'

     ReadFileStream instanceMethod new (char *name) {

       ReadFileStream super new name;

       __ctalkInstanceVarsFromClassObject (name);

       ReadFileStream classInit;

       return name;
     }

The first statement, 'ReadFileStream super new name,' calls 'new' from
class 'Object' before performing its own initialization.


File: ctalk.info,  Node: Class initialization,  Next: Prefixes,  Prev: Self and super,  Up: Methods

Class Initialization
--------------------

Some classes that have class variables require initialization when the
program is run.  For example, class 'ReadFileStream' needs to have its
class variable 'stdinStream' set to the application's 'stdin' file
stream before the program can read from standard input.

Classes that require initialization need to define a method,
'classInit', which is called by a constructor when the first object is
created.  An example is the 'ReadFileStream' method 'new' from the
previous section.

Here is the 'classInit' method for class 'ReadFileStream'.

     ReadFileStream classMethod classInit (void) {

       OBJECT *classObject,
         *stdinStreamVar,
         *classInitVar;
       char buf[MAXLABEL];

       if (self classInitDone)
         return NULL;

       classObject = __ctalkGetClass ("ReadFileStream");
       stdinStreamVar = __ctalkGetClassVariable ("stdinStream", TRUE);

       sprintf (buf, "%p", _IO_stdin);
       __ctalkSetObjectValueVar (stdinStreamVar, buf);

       __ctalkInstanceVarsFromClassObject (stdinStreamVar);
       stdinStream statStream;

       classInitVar =
         __ctalkCreateObjectInit ("classInitDone", classObject -> __o_name,
     				classObject -> __o_superclassname,
     				classObject -> scope, "1");
       __ctalkAddInstanceVariable (classObject, "classInitDone", classInitVar);

       return NULL;
     }

A 'classInit' method needs to be called only once.  The method checks
the 'classInitDone' instance variable to determine the method has
already performed the initialization that the class needs.


File: ctalk.info,  Node: Prefixes,  Next: Translating,  Prev: Class initialization,  Up: Methods

Overloading C Unary Operators
-----------------------------

Methods can also overload C unary operators like '*', '&', '!', '~', and
'sizeof'.  For most unary operators, if the class defines a method to
overload the operator, then Ctalk uses the method; otherwise, it treats
the operator as a normal C operator.

Methods that overload unary operators contain the '__prefix__' attribute
in their declaration.  This simplifies method writing considerably,
because that allows a class to define two different method '*' methods,
for example, one a unary dereference operator, the other a
multiplication operator.

In the method's declaration, use the '__prefix__' attribute in place of
paramter declarations, as in this example.
     String instanceMethod * deref_prefix (__prefix__) {
     ... Method statements here ...
     }

When Ctalk encounters a 'sizeof' operator, it checks whether the
argument is a Ctalk object, or a C variable or type cast expression.  If
the argument is a C variable or type cast expression, then Ctalk uses
the C 'sizeof' operator.  Otherwise, it uses the 'sizeof' method
('Object' class).  This method's implementation is simple: it treats a
Ctalk object as an 'OBJECT *', and returns the size in bytes of a
pointer on the system.  On 32-bit systems, the 'sizeof' method always
returns 4.  However, you can overload the 'sizeof' operator in your own
classes if necessary.

You need to take care when using unary operators in complex statements,
due to the precedence of Ctalk's method messages.  In the following
highly experimental example, you would need to use parentheses to
specify the order of evaluation, because the expression needs the result
of '(*s) asString' to be a 'String' also.
     String new s;
     String new sFirstChar;
     Character new c;
     Integer new i;
     s = "Hello, ";
     sFirstChar = (*s) asString;
Ctalk also provides postfix equivalents for many of these operators,
like 'deref' (class 'Symbol') and 'invert' ('Character,' 'Integer,' and
'LongInteger' classes).

Ctalk can overload these operators even if the class defines a method
that uses the operator with an argument.  For example, the pointer ('*')
and unary minus ('-') operators can have different methods than the
methods that perform multiplication and subtraction.

The subject of method overloading is discussed further in its own
section.  *Note Overloading::.


File: ctalk.info,  Node: Translating,  Next: C Macros,  Prev: Prefixes,  Up: Methods

Translating C Variables into Object Values
------------------------------------------

The 'OBJECT' C data type that Ctalk uses internally stores objects'
values as C 'char *''s.  *Note OBJECT typedef::.

To store numeric values, you must format them as character strings,
using, for example, 'sprintf'.  In many cases, however, Ctalk performs
this translation automatically.

'Integer' objects can also translate values with 'atoi(3)' or
'__ctalkDecimalIntegerToASCII'. Other scalar data types have
corresponding functions that translate numbers to character strings.

If for some reason you need to translate an object to its C type or back
again, the Ctalk library provides the following functions.

'__ctalkToCArrayElement (OBJECT *O)'
     Translate the value of an 'Integer,' 'Character,' 'String,' or
     'LongInteger' array element to a 'void *' that points to its
     corresponding C data type.

'__ctalkToCCharPtr (OBJECT *O, int KEEP)'
     Translate the value of a 'String' object into a C 'char *.' If KEEP
     is 'FALSE', delete O.

'__ctalkToCIntArrayElement (OBJECT *O)'
     Translate the value of an 'Integer' array element to an 'int.'

'__ctalkToCInteger (OBJECT *O, int KEEP_OBJECT)'
     Translate the value of an 'Integer' to an 'int.' If KEEP_OBJECT is
     'FALSE,' then delete the object.

'__ctalkToCInteger (OBJECT *O, int KEEP_OBJECT)'
     Translate the value of an 'Integer' to a 'long int.' If KEEP_OBJECT
     is 'FALSE,' then delete the object.

'__ctalk_to_c_char_ptr (OBJECT *O)'
     Translate the value of a 'String' object into a C 'char *.' Note:
     This function is being phased out.  Use '__ctalkToCCharPtr ()',
     above, instead.

'__ctalk_to_c_double (OBJECT *O)'
     Translate the value of a 'Float' object into a C 'double.'

'__ctalk_to_c_int (OBJECT *O)'
     Translate the value of an 'Integer' object into a C 'int.'

'__ctalk_to_c_longlong (OBJECT *OBJ, int KEEP)'
     Translate the value of a 'LongInteger' object into a C 'long long
     int.' If KEEP is non-zero, does not delete OBJ, or, in compound
     expressions that need to interface with C variables, (like complex
     if-statement conditionals), whether to delete the library's
     internal C variable registrations.

     Formats the arguments of the second-most calling method and prints
     them on the receiver.  This function is meant to be used within a
     method that is called by another method.  One method that uses this
     function is 'String : vPrintOn'.  Refer to 'String : vPrintOn' for
     an example of this function's use.  *Note vPrintOn--class String::

'__ctalkCBoolToObj (bool B)'
     Create a 'Boolean' object with the boolean (either true or false)
     value of the argument.

'__ctalkCCharPtrToObj (char *S)'
     Create a 'String' object with the value S.

'__ctalkClassLibraryPath (void)'
     Return a 'char *' containing the directories that Ctalk searches
     for class libraries.  When compiling programs Ctalk searches first
     for directories given as arguments to the '-I' option, then
     directories given by the 'CLASSLIBDIRS' environment variable, then
     the standard class library directory which is defined when Ctalk is
     built.  In addition, for each directory, if a subdirectory named
     'ctalk' exists, then Ctalk searches that subdirectory also.

     The standard library directory defaults to
     '/usr/local/include/ctalk', although if you define a different
     '--prefix' when building and installing Ctalk, the class libraries
     will be located in PREFIX'/include/ctalk'.

     If it is necessary to look up class libraries at run time, Ctalk
     first searches the directories listed by the 'CLASSLIBDIRS'
     environment variable, then the default class library directory
     mentioned above.

'__ctalkClassSearchPath (void)'
     A synonym for '__ctalkClassLibraryPath()', above.

'__ctalkCDoubleToObj (double F)'
     Create a 'Float' object with the value F.

'__ctalkCIntToObj (int I)'
     Create an 'Integer' object with the value I.

'__ctalkCLongLongToObj (long long int L)'
     Create a 'LongInteger' object with the value L.

'__ctalkCSymbolToObj (unsigned int LABEL)'
     Create a 'Symbol' object with the value that is the address of
     LABEL.  This is used for expressions where a function name appears
     by itself, for example.  In that case, the result is a 'Symbol'
     object with the address of the function.

The functions that create objects give the objects the scope of the
function call, either global or local.

_Note:_ In future versions of Ctalk, the names of these functions are
likely to change.


File: ctalk.info,  Node: C Macros,  Next: Required classes,  Prev: Translating,  Up: Methods

C Macros
--------

Ctalk also provides many macros that help standardize the Ctalk-to-C
conventions.  They're defined in the 'ctalkdefs.h' include file.  To use
them, include 'ctalkdefs.h' in a source file or class library.


     #include <ctalk/ctalkdefs.h>


Some of the macro definitions in 'ctalkdefs.h' are described here.

'ARG'
     With a numeric argument, retrieves the n'th method or template
     argument from the stack; i.e., 'ARG(0)' refers to the first
     argument on the stack, 'ARG(1)' retrieves the second argument, and
     so on.

'CLASSNAME'
     Returns an object's classname.

     _Note:_ You should use this macro in new code.  While typing
     '__o_classname' directly with an 'OBJECT *' should work for a
     while, it's going to be phased out.

     Using __o_classname with an object and the '->' method is still
     okay, though.  For example:


            OBJECT *myObjRef;
            String new myString;

            /* The use of __o_classname as struct member is going away... */
            myObjRef -> __o_classname;
            /* Instead, write this. */
            myObjRef -> CLASSNAME;

            /* These are still okay, because -> is a method, not the C operator. */
            myString -> __o_classname;
            self -> __o_classname;

            /* The same is true for the SUPERCLASSNAME definition. */

            SUPERCLASSNAME(myObjRef);

            self -> SUPERCLASSNAME;
            myString ->  SUPERCLASSNAME;

'FILEEOF'
     Writes an fEOF to the 'char *' buffer given as its argument.

'FMT_0XHEX'
     When used with a function like 'sprintf ()', formats a pointer into
     its string representation.  For example:


          char buf[64];
          OBJECT *my_object_ptr;

          ....   /* Do stuff. */

          sprintf (buf, FMT_0XHEX(my_object_ptr));


     However, this macro is not very portable and using functions that
     use stdargs (e.g., printf, scanf, etc.)  can be cumbersome.
     Library functions like '__ctalkGenericPtrFromStr ()' *Note
     ctalkGenericPtrFromStr::, and '__ctalkFilePtrFromStr ()' *Note
     ctalkFilePtrFromStr::, might be faster and more reliable.

'IS_OBJECT'
     Returns True or False if its argument, a C pointer, refers to a
     valid object.

'IS_VALUE_INSTANCE_VAR'
     Returns True or False if its argument, a C pointer, refers to the
     value instance variable of an object.

'MEMADDR'
     Casts its operand to a 'void **', which is what Ctalk's internal
     function '__xfree ()' uses when freeing memory.  Normally you
     should use __ctalkFree () to free memory, but the MEMADDR macro is
     here in case you want to call __xfree () directly.  Refer to the
     entry for __ctalkFree () for details.  *Note ctalkFree::.

'STR_0XHEX_TO_PTR'
     Does the converse of 'FMT_0XHEX;' it converts the string
     representation of a pointer into an actual pointer, when used with
     a function like 'sscanf ()'.  For example:


          OBJECT *my_object;
          OBJECT *my_object_ptr;

          sscanf (my_object -> __o_value, STR_0XHEX_TO_PTR(my_object_ptr));


     Again, using stdargs functions can be cumbersome and not very
     portable.  In many cases, '__ctalkObjValPtr ()' accomplishes the
     same thing.  *Note ctalkObjValPtr::.

'SUPERCLASSNAME'
     Returns an object's superclass name.  This macro should be used
     only with OBJECT *'s, as it is rather extensive and written in C.
     Returns an empty string if the object doesn't have a superclass.
     *Note CLASSNAMEMacro::, above.

'__LIST_HEAD(List *l)'
     When given an argument that is a collection like a 'List' object,
     returns the first member of the collection.

'STR_IS_NULL(char *s)'
     Evaluates to True if the 'char *' argument evaluates to zero; i.e.,
     its value is '(null)', '0', '0x0' or the first character is an
     ASCII 'NUL' ('\0') byte.


File: ctalk.info,  Node: Required classes,  Next: Scoping,  Prev: C Macros,  Up: Methods

Required Classes
----------------

The keyword 'require' tells 'ctalk' to preload the class given as its
argument before any other classes or methods.

The following lines appear in the 'ctalklib' library.

     require Object;
     require Symbol;
     require String;

These statements tell 'ctalk' to first load the 'Object' class and its
methods, and then load the class 'Symbol' and its methods, and then
class 'String.' Ctalk loads the class and its methods at that point in
the program, before further processing of the source file.

The 'require' keyword always occurs in a global scope; that is, outside
of any method or function.


File: ctalk.info,  Node: Scoping,  Next: Templates,  Prev: Required classes,  Up: Methods

Scope of Objects
----------------

In Ctalk, an object can have a number of different scopes, and Ctalk
implements many more scopes for objects than for C variables.

All of the scopes are available when creating and modifying objects.  In
practice, however, you should only need to use a few of them.  Ctalk
uses many of the scopes internally.

These are the scopes that Ctalk implements.

'GLOBAL_VAR'
     An object that is declared globally; that is, outside of any
     function or method.
'LOCAL_VAR'
     An object declared within a function or method.
'ARG_VAR'
     An object derived from a C function argument that is used within a
     Ctalk expression.  This scope is normally used only internally.
'RECEIVER_VAR'
     An object created internally for receiver objects that do not
     already have objects.  Ctalk assigns RECEIVER_VAR objects C
     constants and constant expressions when they are used as receivers.
'PROTOTYPE_VAR'
     Used by the front end when evaluating objects that are declared as
     method parameters.
'CREATED_PARAM'
     Used mainly for temporary objects that are derived from C constants
     that are arguments to methods and functions.
'CVAR_VAR_ALIAS_COPY'
     Used for temporary and non-temporary objects that are created from
     C variables.
'CREATED_CVAR_SCOPE'
     This is a combination of CVAR_VAR_ALIAS_COPY|LOCAL_VAR scopes.
     Used for C variable objects that are only needed for the duration
     of an expression.  Also used for other values that aren't needed
     after an expression has been evaluated, like boolean method return
     values.
'SUBEXPR_CREATED_RESULT'
     Used internally for temporary objects that are the results of
     subexpressions.
'VAR_REF_OBJECT'
     Used for objects that are referred to by other objects; for example
     an object referred to by a 'Symbol' object may have this scope set.
'METHOD_USER_OBJECT'
     This scope is used mostly internally for objects that are returned
     by methods and saved as method resources.
'TYPECAST_OBJECT'
     Used internally for temporary objects that are derived from C type
     cast expressions.
You set a new object's scope with the '__ctalkCreateObject' or
'__ctalkCreateObjectInit' functions.  To change an existing object's
scope, use the '__ctalkSetObjectScope' library function to set an
object's scope.

Even though you can set an 'OBJECT *''s 'scope' directly, using these
functions insures that the object and all of its instance variables
maintain the same scope.

When creating an object with a function like '__ctalkCreateObjectInit',
you can declare a scope directly.
     result = __ctalkCreateObjectInit ("result",
                                       "Symbol", "Object",
                                       LOCAL_VAR, "0x0");
When altering the scope of an existing object, however, you should add
or subtract only that scope from the object's existing scope.

For example, to add a 'VAR_REF_OBJECT' scope to an object:
     __ctalkSetObjectScope (object, object -> scope | VAR_REF_OBJECT);
To remove the scope, use an expression like this.
     __ctalkSetObjectScope (object, object -> scope & ~VAR_REF_OBJECT);

For values of integral classes like 'Integer', 'LongInteger' or
'Symbol', '__ctalkCreateObjectInit' tries to convert the VALUE parameter
to its numeric value.  It the function can't figure out a way to convert
the argument to its numeric value, it issues a warning message.


     ctalk: can't convert d to an int.


In these cases (and in many others) it is easier to simply use an empty
string as the final parameter and then fill in the value after the
object is created, as in this example (assuming that the object is an
'Integer')..


     result = __ctalkCreateObjectInit
       (INTEGER_CLASSNAME, INTEGER_SUPERCLASSNAME, LOCAL_VAR, "");
     *(int *)result -> __o_value = int_value;
     *(int *)result -> instancevars -> __o_value = int_value;


In this case, the INTVAL, LLVAL, and SYMVAL macros can help make the
expression more readable, depending on whether the new object is an
'Integer', 'LongInteger', or 'Symbol'.


     INTVAL(result -> __o_value) = int_value;
     INTVAL(result -> instancevars -> __o_value) = int_value;



File: ctalk.info,  Node: Templates,  Next: Return values,  Prev: Scoping,  Up: Methods

Templates
---------

_Templates_ are simplified methods that are defined as macros and
written in C. They provide a method-compatible wrapper to C functions.

Template methods can appear in place of C functions in complex
expressions, and they must be used if a C function writes to its
arguments (e.g., like 'scanf(3)' or 'sscanf(3)').  For example, if we
have a template defined for the function 'myPrintMsg', then Ctalk
subsitutes the method expression wherever 'myPrintMsg' appears in an
expression like this one.


       if ((myInt = myPrintMsg (someMsg)) != 0) {
          _... do something..._
       }


After compilation, the expression looks like this.


       if ((myInt = CFunction cMyPrintMsg (someMsg)) != 0) {
          ...


You can also use 'myPrintMsg' on the left-hand side of an assignment,
like this.


       myInt = myPrintMsg (someMsg);

       _-or-_

       self = myPrintMsg (someMsg);


Additionally, you can use templates on their own, by prefacing the
method's name (the template function's alias) with its class object.


       CFuntion myPrintMsg (someMsg);


As the last example implies, templates are class methods in the
pseudo-class 'CFunction'.  Ctalk loads and caches templates where
necessary when compiling the input file, so you won't see any methods of
the 'CFunction' class unless the program calls for one or more of them.

If the template wraps a C function of the same name, then, of course,
you can also use the C function on its own.  However, templates don't
necessarily need to correspond to a C function; they can provide any set
of C expressions with a method compatible interface.

Ctalk defines a number of built-in templates for the standard C library.
You can determine if Ctalk substitutes a template for a C function by
giving the '--printtemplates' option to 'ctalk' when it compiles a
source file.  This displays the templates that the compiler loads and
caches (but doesn't necessarily send to the output).

You can define templates for application-specific C functions and
routines also.  Ctalk retrieves and caches them similarly to its
built-in templates, but they are cataloged and stored separately in each
user's '~/.ctalk/templates' directory.

As mentioned above, templates don't need to wrap a function of the same
name as the template.  That is, 'myPrintMsg', above, does not have to be
an actual function (although you need to prototype it that way).
Templates for C library functions always correspond to an actual library
function.  Program specific templates can serve as a wrapper for any
function or set of routines.

When compiling templates, the Ctalk compiler checks the user template
registry first.  If a user defines a template with the same name as one
of Ctalk's C library templates, then the compiler uses the user's
template instead of Ctalk's built-in template.  That means you can
define a template that replaces a C library template.

When creating a template for a function, you need to follow these steps.

   * Add a prototype of the function to the input file.  For example:


            OBJECT *myPrintMsg (char *text);


     Ctalk uses the prototype's argument list to check the number and
     type of arguments.  The prototype's argument list must be the same
     as the template's argument list.

   * Check that any terms in the expression before and after the
     template are compatible.  Ctalk can in most cases distinguish
     between objects and C variables in expressions.  Ctalk will try to
     warn you if it sees a mixed object/variable expression it can't
     handle.  If an expression causes an error, try breaking it into
     smaller pieces, with objects and methods in one set of terms, and C
     variables and operators in another.  Also, try making the template
     function the first term in the expression (or the first term after
     an assignment operator).  This expression, for example, is
     relatively easy to handle because everything that follows the
     template is normal C code.


          myFloat = rand () + 0.33 + (float)my_dbl;


   * Write a template for the function, and add it to the local
     directory's template cache with the 'template' command.  The
     following sections describe the format that templates use.

Writing Templates
-----------------

Templates are basically multiple line macros that provide a method
selector and method body in a #define preprocessor statement.  When
Ctalk finds a function name that has a template defined for it, it
subsitutes the template name for the function name in the expression,
adds the template's body to the output, and adds the template to the
CFunction classes' initialization.

Templates can accept arguments similarly to methods, and, like methods,
they return a C 'OBJECT *', or NULL.

Here is the template for the 'myPrintMsg()' C function.  The template
provides a wrapper for the 'printf(3)' function, and, like 'printf(3)',
returns an integer value (as an 'Integer' object).  The template
contains a few features that are part of the template protocol.


     #define myPrintMsg \n\
     cMyPrintMsg (char *text) {\n\
       char buf[255]; \n\
       int result; \n\
       OBJECT *objresult; \n\
       if (__ctalkIsObject(ARG(0))) {\n\
         result = printf ("myPrintMsg: %s\n", \n\
                           __ctalkToCCharPtr(ARG(0), 1)); \n\
         __ctalkDecimalIntegerToASCII (result, buf); \n\
         return __ctalkCreateObjectInit ("result", "Integer", \n\
                                         "Magnitude", LOCAL_VAR, buf); \n\
       } else { \n\
         __ctalkDecimalIntegerToASCII (-1, buf); \n\
         objresult =  __ctalkCreateObjectInit ("result", "Integer", \n\
                                         "Magnitude", LOCAL_VAR, buf); \n\
         __ctalkRegisterUserObject (objresult); \n\
         return objresult; \n\
       }\n\
     }


   * The template embeds newlines with the string '\n\'.  When the
     template is preprocessed, this expression joins the lines of the
     template but keeps the line endings intact.
   * The method selector, 'cMyPrintMsg' is built from the function name
     ('myPrintMsg') by uppercasing the first letter and prepending a 'c'
     to it.
   * The template must declare its arguments, like the 'char *text'
     declaration above, even though the actual arguments are objects, as
     described in the next item.
   * The expression '__ctalkIsObject(ARG(0))' checks that the argument
     to the template is a valid object.  You can acccess the template's
     arguments with the 'ARG' macro.  The first argument is 'ARG(0)',
     the second argment is 'ARG(1)', and so on.
   * The function, '__ctalkToCCharPtr()' translates the argument object
     into a 'char *' string that 'printf(3)' expects as its argument.
   * Normally templates create a return object manually, using the API
     function '__ctalkCreateObjectInit ()' or a similar function.  Note
     that '__ctalkCreateObjectInit ()' uses a 'char *' to store the
     value of the object, which is why many templates declare a buffer
     for the C function's result and use __ctalkDecimalIntegerToASCII
     ().  If the result is more complex, then the template might need to
     format it with a function like 'sprintf (3)'.  Templates can also
     return NULL, but if a program uses such a templated function in an
     assignment statement, it causes a program to generate a NULL
     argument object warning when the program is run.
   * Whenever a method returns an object it creates, it should register
     the object, for example by calling '__ctalkRegisterUserObject' as
     in the template above.  That way Ctalk can either maintain the
     object or clean it up when it needs to be deleted.  This function
     call is optional, but omitting it may cause memory leaks when the
     program is run.
   * A template can use macros, like 'LOCAL_VAR'.  The most convenient
     way to define macros is to '#include <ctalk/ctalkdefs.h>' somewhere
     in the input.  Many classes already do this, and the template can
     use the same set of macro definitions as the class libraries.

Cataloging Templates
--------------------

When looking up templates, Ctalk looks in the template registry file,
which is normally '~/.ctalk/templates/fnnames' for the name given in the
input.  If the function is aliased to another name by a macro
substitution, 'fnnames' contains the name of the alias also.

For example, on some systems, the function 'getc(3)' is a macro that
expands to '_IO_getc'.  The 'fnnames' file would then contain '_IO_getc'
as the templated function's name.

When the compiler finds the function's name or alias in 'fnnames', it
looks in the directory for the template file, which is named for the
first letter of the function's name.  That is, when looking for
'myPrintMsg's' template, Ctalk looks for a file named
'~/.ctalk/templates/m'.

The C library templates that come with Ctalk use the same scheme, except
that the template files are stored in a subdirectory of the class
library called 'libc'.  The registry is part or the run-time library, so
C library templates do not need a separate registry file.

The manual page, 'fnnames(5ctalk)' contains more information about the
'fnnames' file.  The 'templates(5ctalk)' manual page describes the
format of individual templates.


File: ctalk.info,  Node: Return values,  Next: Variable arguments,  Prev: Templates,  Up: Methods

Return Values
-------------

Internally, methods return either an 'OBJECT *' or 'NULL'.  If you write
a method that returns a C variable, Ctalk normally translates it into an
equivalent object.

Methods that return arrays declared in C generally assign the C array to
an equivalent 'Array' object.  The 'Array' object's size is the same as
the array declaration, regardless of how it the array's members are
initialized.

The 'Array' allocation only occurs for arrays declared with a subscript;
that is, a variable declared as 'int *' is not always stored in an
'Array' object, while a variable declared as 'int[SIZE]' is.

Ctalk treats C arrays declared as 'char[SIZE]' a little differently.  If
the method's definition says the return class of the method is 'Array',
then Ctalk returns an 'Array' of 'Character' objects; otherwise, it
returns a 'String' object.

Because Ctalk does not have equivalent classes for multi-dimensioned
arrays; that is, arrays with more than one subscript, it does not
translate the arrays automatically.  In these cases, the method might
return a multi-dimensioned array by assigning it to a 'Symbol' object.

Occasionally, you might need to return the result of an expression that
Ctalk can't translate automatically.  In that case, you can use the
'eval' keyword to evaluate the expression when the program is run, as in
this example.
     MyClass instanceMethod myMethod (void) {
       ...
       return eval <expression>
     }

If a method must create an object of its own to return, the object
should have the scope CREATED_PARAM, which tells the Ctalk libraries
that the the program only needs the object if it's the result of a
complete expression; if not, the program cleans up the object
automatically when it is no longer needed.  *Note
__ctalkRegisterUserObject::.


     return __ctalkCreateObjectInit ("myStringAnswer", "String",
                                     "Character", CREATED_PARAM,
                                     "The contents of the String object.");


If the program needs to store a return object for longer than the scope
that the object is called in, the method can save the object in its
object pool with the library function __ctalkRegisterUserObject, which
is described below.  *Note __ctalkRegisterUserObject::.


     String instanceMethod myMethod (void) {

       OBJECT *return_object;

       _... Do stuff. ..._

       return_object =  __ctalkCreateObjectInit ("myStringAnswer", "String",
                                     "Character", CREATED_PARAM,
                                     "The contents of the String object.");
       __ctalkRegisterUserObject (return_object);
       return return_object;

     }


Another case may be when a method needs to retrieve an object reference.
In these cases, the method may need to increase the object's reference
count.  However, such a method can also call
'__ctalkRegisterExtraObject' to save the object so its memory isn't lost
later.  The '__ctalkRegisterExtraObject' function does not, itself, set
the object's reference count, and it saves an object (not copies of
objects) only once.

Method Return Macros
....................

Alternatively, if a method needs to return an object of a particular
class, you can use the following 'methodReturn*' statements.  These are
macros that implement the statements to store and return objects which
represent different types or classes, like 'ints' as Integer objects,
'doubles' as Float objects, and so on.

These macros have been superseded in more recent versions of Ctalk,
which has the ability to insert the correct return code for any class of
object, and many C variables, functions, and expressions.  If the
compiler doesn't recognize some particular expression, however, these
macros may still be useful.

Remember that these return value functions are implemented as macros and
contain their own code block, so you can use them in places where normal
functions would cause a syntax error.

'methodReturnBoolean (int I)'
     Return a 'Boolean' object that Ctalk can evaluate to 'TRUE' or
     'FALSE' depending on the value of its argument.  Mostly deprecated;
     an expression like, '"return TRUE"' is equivalent.

'methodReturnFalse'
     Return a 'Boolean' object that evaluates to 'FALSE.' Deprecated;
     using the expression, 'return FALSE;' has the same effect.

'methodReturnInteger(int I)'
     Return an 'Integer' object with the value I.  Mostly deprecated; an
     expression like, '"return <int>"' is equivalent.

'methodReturnLongInteger(int L)'
     Return a 'LongInteger' object with the value L.  Mostly deprecated;
     an expression like, '"return <longlongint>|<longint>"' is
     equivalent.

'methodReturnNULL'
     Returns the C value 'NULL.' Deprecated; simply use the expression,
     'return NULL;' instead.

'methodReturnObject(OBJECT)'
     Return OBJECT.  Deprecated; the expression, 'return OBJECT' has the
     same effect.

'methodReturnObjectName(OBJECTNAME)'
     Return the object referred to by OBJECTNAME.  Also deprecated; like
     'methodReturObject', above, the expression, 'return OBJECT' has the
     same effect.

'methodReturnSelf'
     Returns the method's receiver, 'self'.  Slightly deprecated; simply
     using the statement, "'return self'," has the same effect.

'methodReturnString(char *S)'
     Return a 'String' object with the value S.  Mostly deprecated; an
     expression like, '"return <char *>|<string constant>"' is
     equivalent.

'methodReturnTrue'
     Return a 'Boolean' object that evaluates to 'TRUE.' Deprecated; use
     the expression, 'return TRUE;' instead.

The macros that return objects use the '__ctalkRegisterUserObject'
function to keep track of method's return values, and, if necessary,
other objects that the method creates.  *Note
__ctalkRegisterUserObject::.


File: ctalk.info,  Node: Variable arguments,  Next: Overloading,  Prev: Return values,  Up: Methods

Variable Arguments
------------------

C functions like 'scanf(3),' 'sscanf(3),' and 'fscanf(3)' have templates
that allow you to call them with a variable number of arguments.

If you need to call other C functions that use variable arguments, you
must call '__ctalkLibcFnWithMethodVarArgs' with the name of the
function, the method that contains the function's template, and the
function's return class.

The 'readFormat' method (implemented in 'String' and 'ReadFileStream'
classes) can scan a string or input file into the objects that the
program gives as arguments.  The methods also take care of
scalar-to-object translation, memory allocation, and several other
tasks.

However, programs can also accomplish the same thing manually.

For example, here is the code of the template method for 'fscanf(3),'
'cFscanf' ('CFunction' class), without the preprocessing directives.

     cFscanf (FILE *s, char *fmt,...) {
       EXPR_PARSER *parser;
       OBJECT *result_object;
       parser = __ctalkGetExprParserAt (__ctalkGetExprParserPtr ());
       result_object =
         __ctalkLibcFnWithMethodVarArgs ((int (*)())fscanf, parser -> e_method, "Integer");
       return result_object;
     }

At run time, the 'e_method' member of an expression parser contains the
method and its arguments.

The third argument of '__ctalkLibcFnWithMethodVarArgs' determines the
class of 'result_object.' For C library functions that use variable
arguments, the return class is 'Integer.'

The typecast '(int (*)())' in the first argument in front of 'fscanf' is
not strictly needed because we know that the number and types of
arguments to 'fscanf(3)' (or 'scanf(3)' or any other variable-argument
function) might vary from the '__ctalkLibcFnWithMethodVarArgs'
prototype, but it tells the compiler not to print a warning message in
that case.

If you simply need to print formatted output, the 'writeFormat' or
'printOn' methods (implemented in 'String', 'WriteFileStream' and many
other classes classes) perform format-argument translations
automatically.  Several classes also implement a 'readFmt' method, which
reads formatted input from a 'String' or 'ReadFileStream'.  *Note
writeFormat--class WriteFileStream::, and *note writeFormat--class
String::.


File: ctalk.info,  Node: Overloading,  Next: Variable method arguments,  Prev: Variable arguments,  Up: Methods

Overloading Methods
-------------------

You can always implement a method in different classes.  For example,
you can define a '+' method in 'Integer,' 'LongInteger,' 'Character,'
and 'Float' classes, and Ctalk calls the method defined for that class
of the receiver object.

Some operators also have methods implemented in a superclass, like
'Magnitude' in this case, which can provide any extra error checking and
processing that may be necessary, for example, if you try to use a unary
minus ('-') operator with a receiver like a 'Pen' or 'Rectangle' object.

When you overload methods _within_ a class, however, Ctalk does some
extra checking.  The compiler needs to examine the expression to find
out how many arguments the statement has, whether the operator is a
prefix operator, or whether the method's argument is a block of code or
a variable argument list, or whether the method uses a C calling
convention.

Ctalk can overload math operators when they are also used as prefix
operators.  Two examples of these are the unary minus ('-') and pointer
('*') methods, which have different methods than the operators that
perform subtraction and multiplication.  Writing methods that are prefix
operators is described above.  *Note Prefixes::.

Overloading Parameters
......................

Exactly when you should write methods that overload things like
parameters and variable arguments is somewhat within the philosophy of
programming languages.  For example, a common use of method overloading
based on the number of parameters is the, "getter/setter," type of
method, which retrieves and sets an object's private data.

In Ctalk, these are much less necessary than in other languages, because
Ctalk can address an object's private data with a message that has the
same name as an instance or class variable.  Since these messages bind
more tightly to receiver objects than messages that refer to methods,
these types of methods might not work the way you think they would.  So
be sure that if you write a method of this type, that the program is
actually using a method message, and not an instance data message.

Here is an example of overloading parameters.  Because the 'String'
class already has a 'concat' method (it overloads the '+' operator), we
overload the method, 'myConcat,' to concatenate one or two strings to
the receiver.

As long as the program is relatively simple, it's easy to keep track of
which methods already exist in a class.  In a bigger application,
though, you might want to define a subclass of 'String' class for this
program.


     String instanceMethod myConcat (String s1) {

       self = self + s1;

     }

     String instanceMethod myConcat (String s1, String s2) {

       self = self + s1 + s2;

     }

     int main () {
       String new s1;
       String new s2;
       String new s3;

       s1 = "Hello, ";
       s2 = "world! ";
       s3 = "Again.";

       s1 myConcat s2;
       printf ("%s\n", s1);

       s1 myConcat s2, s3;
       printf ("%s\n", s1);

     }


We should mention that the 'myConcat' method changes its receiver.  So
the arguments to the second 'myConcat' message simply get added to the
receiver again.  The output should look something like this.

     Hello, world!
     Hello, world! world! Again.


File: ctalk.info,  Node: Variable method arguments,  Next: Method functions,  Prev: Overloading,  Up: Methods

Variable Method Arguments
-------------------------

Ctalk supports variable arguments lists for methods that follow the
'stdarg.h' format for argument lists, where the argument assigned to the
last named parameter determines the number and type of the following
arguments.  (The manual page 'stdarg (3)' has more details.)


       String instanceMethod writeFormat (char *fmt, ...)


In addition, Ctalk supports argument lists with _no_ named parameters.
To implement this, Ctalk interprets an ellipsis as a variable argument
list, as usual.  It is then up to the method to interpret the arguments
as they appear on Ctalk's argument stack.

For this task, the '__ctalkNArgs' library function returns the number of
arguments that the run-time libraries place on the stack.  The method
can then interpret these arguments as necessary.

Here is the slightly abbreviated code for the 'List' : '=' method, which
should help illustrate this.  *Note List::.


     List instanceMethod = initEQ (...) {
       int n, i;
       OBJECT *arg;

       self delete;         /* Start with an empty List. */
       n = __ctalkNArgs ();

       for (i = (n - 1); i >= 0; --i) {
         arg = __ctalk_arg_internal (i);
         self push arg;
       }
     }



File: ctalk.info,  Node: Method functions,  Next: Errors,  Prev: Variable method arguments,  Up: Methods

Method Functions
----------------

Occasionally an application needs to call a method as a function.  One
example of this is a 'SignalHandler' method that the program installs as
the handler for signals from the operating system.

Methods that use a C calling convention need to do several things
differently than normal methods.
   * The method needs to use a C variable as its argument.
   * Because the method can be called with no receivers, Ctalk does not
     perform any of the normal initialization of local and parameter
     objects.
   * The method body needs to be written almost entirely in C.

In order to make Ctalk interpret a method parameter as a C variable, the
method must declare the parameter with the '__c_arg__' attribute.

_Note:_ C functions that are called by the operating system generally
need only one argument, and the '__c_arg__' attribute only works for
methods with a single parameter.

Additionally, to prevent Ctalk from adding local object initialization
code to the method, the method must contain the 'noMethodInit' keyword.

Here is an example of a method that is used as a signal handler, and
installed by the statements in 'main.'
     SignalHandler instanceMethod myHandler (__c_arg__ int signo) {
       noMethodInit;
       printf ("sigInt handler! Signal %d.\n", signo);
       return NULL;
     }

     int main () {

       SignalHandler new s;

       s setSigInt;
       s installHandler myHandler;
     }

The 'setSigInt' method (class 'SignalHandler') tells the 'SignalHandler'
object 's' that it is going to handle 'SIGINT' signals.  *Note
SignalHandler::, for the other signals that the class can handle.

The '__ctalkNewSignalEventInternal' function can generate and queue
'SignalEvent' objects, so the signal handler does not need to create
objects in order to send signal events to the application.  *Note
__ctalkNewSignalEventInternal::.

Including C Header Files
........................

Often you will need to use C functions and data types in method
functions.  However, you need to take care that if you include a C
header file, it might not be included later on if a class library
requires that file.

Normally Ctalk includes whatever C definitions it needs in the class
libraries.  However, that can cause the preprocessor to omit those
definitions from another source file, should the definitions be needed
later.

For example, in the method 'handleSignal', from the 'timeclient.c'
program, the method needs the definition of the 'time(2)' function.  If
you were to '#include' 'time.h' in the input, as in this example, then
'time.h''s definitions would not be included in the 'CTime' class later
on.
     #include <time.h>    /* Could cause errors later. */

     SignalHandler instanceMethod handleSignal (__c_arg__ int signo) {
       time_t t;
       char buf[MAXLABEL];
       noMethodInit;
       t = time (NULL);
       __ctalkDecimalIntegerToASCII (t, buf);
       __ctalkNewSignalEventInternal (signo, getpid (), buf);
       return NULL;
     }

The best way to avoid omitting dependencies is to include only the
definitions that the method needs.  In this case, you can include the
prototype of 'time(2)' in the source file.
     extern time_t time (time_t *__timer) __THROW;  /* From time.h. */

     SignalHandler instanceMethod handleSignal (__c_arg__ int signo) {
       time_t t;
       char buf[MAXLABEL];
       noMethodInit;
       t = time (NULL);
       __ctalkDecimalIntegerToASCII (t, buf);
       __ctalkNewSignalEventInternal (signo, getpid (), buf);
       return NULL;
     }

The 'time_t' type is defined with 'ctalklib', and is available to all
programs.

How to resolve multiple library definitions depends on the system's
header files, and may vary between different operating systems or
compiler versions.


File: ctalk.info,  Node: Errors,  Next: Cautions,  Prev: Method functions,  Up: Methods

Exception and Error Handling
----------------------------

There are two ways to handle error conditions in Ctalk.  You can simply
print an error or warning message in your code.  An error message
formats the text and data that you provide, the same as in a 'printf'
statement, and then exits the program.  Here is an example.
     _error ("Program exited with code %d.\n", result_code);

A '_warning' message is similar, but it prints the message and continues
processing.  *Note errorfuncs::.

The other way to handle errors is with exceptions.  This is the method
you need to use if an error occurs within a method, and the program
needs either to print a warning message, or exit.

There are two methods of class 'Exception' that handle exceptions in
application programs: 'pending' and 'handle.' There are also other API
functions, but they are mostly used internally to translate exceptions
into events that application programs can use.

These two methods are generally used together.  The method 'pending,' if
it returns 'TRUE,' signals that there is an exception pending.  Then the
function 'handle' handles the event by executing an exception handler.

Generally, events simply issue error messages.  It is up to you to
determine how the program should handle the exception: by exiting,
trying the procedure again, ignoring the condition, or some other
procedure.  Here is an example.

     Exception new e;
     ...
     inputStream openOn fileArg;
     if (e pending) {
        e handle;
       exit (1);
     }
     if (inputStream isDir) {
       printf ("Input is a directory.\n");
       exit (1);
     }
This is simply the way that Ctalk notifies the application if the method
'openOn' (class 'ReadFileStream') encountered an error while opening the
file named by its argument, 'fileArg.'

You should note that the program also checks whether the input is
actually a directory, because opening a directory as if it were a file
does not necessary cause an error condition.  The 'isDir' (class
'FileStream') method is one portable way to check if the input path is
actually a directory.

The method 'openOn,' like other methods, raises an exception if
necessary.  It does this with 'raiseException' (class
'SystemErrnoException').

Ctalk handles most 'stdio' error codes in this manner.  A program that
uses the 'ReadFileStream' and 'WriteFileStream' classes should rarely
need to use the C library's 'errno' macro, but it is still available if
applications need to check for other errors from the C libraries.

The Ctalk library also provides exceptions for missing arguments,
undefined methods, and other error conditions.  The file,
'include/except.h,' contains the definitions of Ctalk's compile and run
time exceptions.


File: ctalk.info,  Node: Cautions,  Next: Method keywords,  Prev: Errors,  Up: Methods

Cautions when Using Arguments with C Library Calls
--------------------------------------------------

The interface for C functions is in development.  You can use a C
function in a simple expression with any argument, as in the following
example.

     op1 = __ctalkGetInstanceVariableByName ("self", "value", TRUE);

However, if you want to use a C function in a complex expression, then
you must take care that the arguments to the function are C values that
correspond to a Ctalk class, unless the function has a template written
for it in the class library that performs the translations of specific
classes and data types.  *Note Templates::.

If you use a function in a method, and the compiler generates an,
"implicit declaration," warning, you can include the library function's
prototype in either the source file or in 'classes/ctalklib'.

Cautions when using 'Array' class elements in C expressions.
------------------------------------------------------------

If you want to use an 'Array' element in a C expression, you need to
take care that the value of the element translates to a 'void *,' which
is the C type that Ctalk returns the values of these elements as.

That means elements of class 'LongInteger' might be truncated, and
'Float' class array elements cannot be translated in this manner.

If array elements of these classes occur in C expressions, Ctalk prints
a warning at run time.

In these cases, it is necessary to convert the values to a compatible
pointer type, for example an object of class 'String.'


File: ctalk.info,  Node: Method keywords,  Next: Documentation,  Prev: Cautions,  Up: Methods

Method Keywords
---------------

'__c_arg__'
     Treat the next method argument as a C argument.  *Note Method
     functions::.

'classMethod'
     The 'classMethod' keyword declares a method, as described above.

'classVariable'
     Adds a class variable definition to a class.  This method needs to
     be used globally, when a class is declared.  The syntax is:

          PARENT_CLASS classVariable NAME [NATIVE_CLASS|TYPECAST_EXPR]
          [INITIAL_VALUE] [DOCSTRING] ;
     For example:

          FileStream class ReadFileStream;
          ReadFileStream classVariable stdin Symbol 0x0;

     The value of INITIAL_VALUE can be either a constant or an
     expression that evaluates to a constant.

     Ctalk can also translate a typecast into a native class for the
     variable.  Also refer to the entry for 'instanceVariable', below.
     *Note InstanceVariableKeyword::.

     Similarly, the DOCSTRING element is also optional.  *Note
     VariableDocStrings::.

'eval'
     Do not try to evaluate the following statement until run time.
     Methods can use this keyword if they need to wait until run time to
     determine an receiver's class and are not able to alias the object
     or otherwise inform the front end of the receiver's class before
     the program is run.

'instanceMethod'
     The 'instanceMethod' keyword declares a method, as described above.

'instanceVariable'
     Adds an instance variable definition to a class.  This method needs
     be used when the class is declared.  The syntax is:

          PARENT_CLASS instanceVariable NAME
          [NATIVE_CLASS|TYPECAST_EXPR] [INITIAL_VALUE] [DOCSTRING] ;

     For example:

          FileStream class ReadFileStream;
          ReadFileStream instanceVariable pos LongInteger 0L;

     The value of INITIAL_VALUE can be either a constant or an
     expression that evaluates to a constant.

     You can also use a typecast in place of the variable's
     NATIVE_CLASS. Ctalk can translate most builtin C types or typedefs
     to a class, but for less common data types, Ctalk will translate a
     pointer to the type as a Symbol object.

     Similarly, the DOCSTRING element is also optional.  *Note
     VariableDocStrings::.

     Note that the 'instanceVariable' method does not _create_ any
     variables.  Ctalk only creates instance variables for each object
     when it receives a constructor message (e.g., 'new') by a program.

'noMethodInit'
     Do not include method initialization code for the method.  *Note
     Method functions::.

'require'
     Require a class to be loaded before any other classes or methods.

'returnObjectClass'
     Set the return class of a method to the argument if it is different
     than the receiver class.  *Note Return values::.

'self'
     Return the method's receiver object.  In version 0.0.65, you can
     also use 'self' in arguments as a synonym for the receiver of the
     statement, as in this example.
          String new path;
          path = "/home/user/joe";

          printf ("%s", path subString 1, self length - 1);

     The use of 'self' in method arguments is experimental in version
     0.0.65, and it should be used with caution.

'super'
     The keyword 'super' has two different meanings.  It can modify a
     method, as in the following example.

          MyReceiverClass super new instanceObject;

     'super' can also represent the receiver's superclass object, so it
     can appear as a receiver, as in this example.

          return super new checksum;


File: ctalk.info,  Node: Documentation,  Next: Ctalk library,  Prev: Method keywords,  Up: Methods

Documenting Methods, Classes, and Variables
-------------------------------------------

Ctalk allows you to add publicly visible comments to methods, classes,
and instance and class variables.  These comments are different than
comments within the code that may have meaning only for specific
routines

If you want to add documentation for a class, Ctalk allows documentation
string is class declarations (see below).  *Note ClassDocStrings::.

You can also document instance and class variables.  *Note
VariableDocStrings::.

When documenting methods, Ctalk recognizes both C-style comments and C++
comments.

In addition, Ctalk recognizes a character string at the beginning of a
method or function as a public documentation string, and it adds a few
rules for comments and documentation strings that make it easier to
describe methods when browsing the class library.

Basically, if the method contains a comment or documentation string at
the start of a method or function body, then that style of comment is
used as the method's public documentation when it is referenced by other
programs.


     MyClass instanceMethod myMethod (Object myArg) {
       /* Using a C-style comment at the start of a method body,
          or a series of C-style comments, makes those comments
          available as the method's public documentation. */
       /* The public documentation can span several comments if the
          comments appear before any lines of source code. */

          _Method body..._


       /* That allows you to add (perhaps temporary) comments elsewhere
          in the method that do not appear as part of the method's
          public documentation. */

          _More lines of code..._

     }

     MyClass instanceMethod myMethod (Object myArg) {
       // A series of C++ comments before the first line of
       // code also can appear as the method's public
       // documentation.

          _Method body..._

       /* A different style of comment anywhere else within
          the method does not appear in the method's public
          documentation. */
     }

     MyClass instanceMethod myMethod (Object myArg) {
       "A character string at the start of the method also gets
        interpreted as a public documentation string."

        _Method body..._
     }


The Ctalk libraries contain several methods that can be useful when
printing documentation.  Particularly, the method 'methods' (in 'Object'
class) and 'methodSource' (in 'Application' class) can retrieve the
names of the methods in a class and their source code, and the method
'tokenize' (in 'String' class) can split the source code into tokens,
which you can then process.

Here's a simple application that retrieves a method's source code and
splits it into tokens.


     int main () {

       Application new app;
       String new methodStr;
       List new tokens;

       /* The first argument to methodSource is the class name, and
          the second argument is the method name. */
       methodStr = app methodSource "Application", "methodSource";

       methodStr tokenize tokens;

       tokens map {
         printf ("%s ", self);  /* This example simply prints the method's
                                   tokens, but you can perform any processing
                                   or formatting that you want here. */
       }
       printf ("\n");
     }


If you want only the prototype of the method; that is, the declaration
and the argument list, feed the output of 'methodSource' to
'methodPrototypes', which is also in class 'Application.' The
'methodPrototypes' method takes a string with the source code of a
method or methods as input, which means you can also extract all of the
prototypes of a class library.


     int main () {

       Application new app;
       String new src;
       String new prototypes;

       src = app methodSource "Object", "basicNew";

       prototypes = app methodPrototypes src;

       printf ("%s\n", prototypes);

     }


There are a few caveats:

The 'methods' method is designed to be quick, so it only finds methods
whose declaration appears on one line.  If you prefer method
declarations spread over several lines, you can read the entire class
file using 'readAll' (class 'ReadFileStream').  *Note ReadFileStream::.
Then you can tokenize the entire class file at once, which disregards
any line formatting, although tokenizing an entire file takes
considerably longer.

Also, The 'methodPrototypes' method does not do any special formatting;
it simply collects the prototypes into one 'String' object.

Class Documentation
...................

Ctalk also allows you add documentation to class declarations.  The
declaration syntax allows you to add an option character string between
the class name and the closing semicolon.  The syntax of a class
documentation is the following.


     SUPERCLASSNAME class CLASSNAME <DOCSTRING>;


For example, here is the class declaration of 'WriteFileStream' which
contains a documentation string.


     FileStream class WriteFileStream   "Defines the methods and instance
     variables that write data to files. Also defines the class variables
     stdoutStream and stderrStream, which are the object representation
     of the standard output and standard error streams.";


The 'classdoc' program can print the documentation string of a class if
it provides one.  The 'classdoc(1)' manual page provides more
information.

Instance and Class Variable Documentation
.........................................

You can add an optional documentation string to an instance or class
variable's declaration by enclosing the text within quotes immediately
before the final semicolon.


     WriteFileStream classVariable stdoutStream
     "Defines an object that contains the value of the system's standard output";


The main thing to watch out for is, syntactically, a documentation
string could be mistaken for a variable's initial value if one isn't
included in the definition.  For example, this definition uses a
character string as its initial value.


     ObjectInspector instanceVariable promptString String "> ";


So in this case, if you wanted to add a documentation string, you would
also need to include an initial value, otherwise the documentation
string would be mistaken for the variable's value.


                                                           /* Incorrect! */
     ObjectInspector instanceVariable promptString String
     "The string that is displayed as the object inspector's
     prompt";


Instead, you need to add both an an initial value, and the documentation
string.


                                                                /* Correct. */
     ObjectInspector instanceVariable promptString String "> "
     "The string that is displayed as the object inspector's
     prompt";



File: ctalk.info,  Node: Ctalk library,  Prev: Documentation,  Up: Methods

Ctalk Library Reference
-----------------------

This section describes some of the Ctalk library functions that you can
use in methods and, in many cases, in Ctalk programs generally.

The file 'classes/ctalklib' contains the prototypes of the library
functions.

'__argvName (char *S)'
     Set the name of the program at run time.  Normally this is the same
     as 'argv[0]'.

'__argvFileName (void)'
     Returns the name of the executable program.

'__arg_trace (int STACK_INDEX)'
     Prints the object at argument stack index STACK_INDEX.

'__ctalkAddClassVariable (OBJECT *CLASS_OBJECT, char *NAME, OBJECT *VARIABLE_OBJECT)'
     Add a class variable VARIABLE_OBJECTto CLASS_OBJECT.

'__ctalkAddInstanceVariable (OBJECT *OBJECT, char *NAME, OBJECT *VARIABLE_OBJECT)'
     Add an instance variable to an object.  Note that the function adds
     a copy of VARIABLE_OBJECT to OBJECT.

'__ctalkAliasObject (OBJECT *RCVR, OBJECT * TARGET)'
     Set the RCVR object's label to the TARGET object, so the TARGET
     object can be referred to by the RCVR object's identifier.  This
     function does not require RCVR to be the actual receiver of the
     method, so the results can be unpredictable if it is used in a
     context other than where 'self' is the first argument.  To insure
     that RCVR is the actual receiver of the calling method, use
     '__ctalkAliasReceiver (),' below.

'__ctalkAliasReceiver (OBJECT *RCVR, OBJECT * TARGET)'
     Like '__ctalkAliasObject (),' above, but the function checks that
     RCVR is the actual receiver of the calling method and returns
     'ERROR' ('-1') if it isn't.  Here is an example.


          String instanceMethod = setEqual (OBJECT *__stringArg) {
            // String assignment method. Assigns the argument  to the
            // receiver label.  Also does some String-specific
            // semantic stuff for different sorts of String objects.
            // Returns the new String object.

            __ctalkStringifyName (self, __stringArg);
            if (__ctalkAliasReceiver (self, __stringArg) != 0) {
              __ctalkAddInstanceVariable (self, "value", __stringArg);
              return self;
            } else {
              return __stringArg;
            }
          }


'__ctalkANSIClearPaneLine (OBJECT *PANEOBJECT, int LINENUMBER)'
     Clear (to spaces) the pane line at LINENUMBER.

'__ctalkANSITerminalPaneMapWindow (Object *CHILDPANE)'
     Map CHILDPANE onto the receiver pane.  The child pane's upper
     left-hand corner origin is relative to the receiver pane's origin.
     The receiver pane should be large enough to completely enclose the
     child pane.  The child pane is displayed at the next 'refresh'
     message.

'__ctalkANSITerminalPaneUnmapWindow (Object *CHILDPANE)'
     Removes the pane given as the argument from the receiver pane.

'__ctalkANSITerminalPanePutChar (int X, int Y, char C)'
     Store character C at coordinates X,Y in the pane's content region.
     The character will be displayed after the next 'refresh' message.

'__ctalkANSITerminalPaneRefresh (void)'
     Display the contents of 'ANSITerminalPane' objects on the display,
     including text and window decorations if any.

'__ctalkANSITerminalPaneUnMapWindow (Object CHILDPANE)'
     Unmap CHILDPANE from the receiver pane's visible area.  The child
     pane is not deleted; it is simply not displayed at the next
     'refresh' message.

'__ctalkARB (void)'
     Returns a boolean value of true if the GLEW libraries support the
     GLEW_ARB_vertex_shader and GLEW_ARB_fragment_shader extensions.
     Programs must call the '__ctalkInitGLEW' function before using this
     function.

'__ctalkArgBlkReturnVal (void)'
     Called by the calling function of an argument block to retrieve the
     block's return value, if any.

'__ctalkArgBlkSetCallerReturn (void)'
     Called by a map method to indicate to a calling method or function
     that an argument block has requested a return from the function or
     method that called it.  Map-type methods for general use should
     include a call to this function, which provides argument block
     support for 'return' statements.  Refer to
     '__ctalkRegisterArgBlkReturn', below, and the 'String : map' method
     for an example of these functions' use.

'__ctalkArrayElementToCCharPtr (OBJECT *ARRAY_ELEMENT)'
'__ctalkArrayElementToCChar (OBJECT *ARRAY_ELEMENT)'
'__ctalkArrayElementToCDouble (OBJECT *ARRAY_ELEMENT)'
'__ctalkArrayElementToCInt (OBJECT *ARRAY_ELEMENT)'
'__ctalkArrayElementToCLongLongInt (OBJECT *ARRAY_ELEMENT)'
'__ctalkArrayElementToCPtr (OBJECT *ARRAY_ELEMENT)'
     Translates the object ARRAY_ELEMENT's value to a C 'char *',
     'char', 'double', 'int', 'long long int', or 'void *'.

'__ctalkBackgroundMethodObjectMessage (OBJECT *RCVR, OBJECT *METHOD_INSTANCE)'
     Perform a method call by sending RCVR the message defined by
     METHOD_INSTANCE, which is a previously defined 'Method' object.
     *Note Method::.

     The function starts METHOD_INSTANCE as a separate process, which
     runs concurrently with the process that launched it.  The
     background process exits when METHOD_INSTANCE returns.

     The METHOD INSTANCE argument is a normal method.  However,
     '__ctalkBackgroundMethodObjectMessage' does not save the return
     object before METHOD_INSTANCE exits, and METHOD_INSTANCE, does not
     take any arguments.

     The function returns the PID of the child process, or '-1' on
     error.

     This function is used by the method 'backgroundMethodObjectMessage'
     (class 'Object').  Refer to the description of the method for more
     information.  *Note Object::.

     For examples of method instance calls, *Note methodObjectMessage::.

'__ctalkBackgroundMethodObjectMessage2Args (OBJECT *RCVR, OBJECT *METHOD_INSTANCE, OBJECT *ARG1, OBJECT *ARG2)'

     This function combines a background method instance call with two
     arguments.  Its function is similar to
     '__ctalkMethodObjectMessage', below.

     For examples of method instance calls, *Note methodObjectMessage::.

'__ctalkCallMethodFn (METHOD *METHOD)'
     Used internally to perform a method call.

'__ctalkCallingFnObjectBecome (OBJECT *OLD, OBJECT *NEW)'
     Used by 'Object' : 'become' to translate the receiver when 'become'
     is called within a function.

'__ctalkCallingInstanceVarBecome (OBJECT *OLD, OBJECT *NEW)'
     Used by 'Object' : 'become' to translate the receiver when the
     receiver is an instance variable.

'__ctalkCallingMethodObjectBecome (OBJECT *OLD, OBJECT *NEW)'
     Used by 'Object' : 'become' to translate the receiver when
     'become's' receiver is an object declared in another method.

'__ctalkCallingReceiverBecome (OBJECT *OLD, OBJECT *NEW)'
     Used by 'Object' : 'become' to translate the receiver when
     'become's' receiver also the receiver of the method that calls
     'become'.

'__ctalkCBoolToObj (bool B)'
     Create a 'Boolean' object with the boolean (either true or false)
     value of the argument.

'__ctalkCCharPtrToObj (char *S)'
     Create a String object from a C 'char *'.

'__ctalkConsoleReadLine (OBJECT *string_object, char *prompt_string)'
     Prints the prompt PROMPT_STRING to standard output of a terminal,
     then reads a line of text from the standard input, until it
     encounters a newline, and saves it as the value of STRING_OBJECT.

     If Ctalk is built with support for the GNU readline libraries, the
     function provides the readline libraries' command line editing and
     history facilities.  Otherwise, the function reads input up to a
     newline using only the basic text input and editing facilities
     provided by the stdio functions.

'__ctalkCreateArg (OBJECT *RECEIVER, char *METHODNAME, char *ARG_EXPR)'
     Create an argument for the following '__ctalk_method' or
     '__ctalk_primitive_method' function call.  Unlike '__ctalk_arg',
     this function always creates a new object.  Its primary use is to
     create local method objects that are fully instantiated into a
     class by a following 'new' method.

'__ctalkCreateArgA (OBJECT *RECEIVER, char *METHODNAME, char *ARG_EXPR)'
     Like '__ctalkCreateArg', creates local method objects that are
     instantiated into a class by a following 'new' method.  The
     '__ctalkCreateArgA ()' function is more specialized so it can be
     used when performing method cache fixups.

'__ctalkCDoubleToObj (doubleD)'
     Create a Float object from a C 'float' or 'double'.

'__ctalkCharRadixToChar (char *S)'
     Return the character as a C 'char' that is represented by the
     formatted argument.

     If S contains a number of more than one digit, then it is converted
     from an integer to the ASCII code of a character.

'__ctalkCharRadixToCharASCII (char *S)'
     Return a C string with a lexically correct character - a character
     enclosed in single quotes - from the formatted argument.  If S is
     already a character, then no conversion is done.

     If S contains a decimal number of more than one digit, then it is
     converted from a decimal integer to a character.

'__ctalkCFUNCReturnClass (CFUNC *FN, char *BUF)'
     Return in BUF the name of the class that corresponds to FN's return
     type.

'__ctalkCIntToObj (int I)'
     Create an 'Integer' object from a C 'int.'

'__ctalkCLongLongToObj (long long int L)'
     Create a 'LongInteger' object from a C 'long long int.'

'__ctalkClassMethodInitReturnClass (char *RCVR_CLASS, char *METHOD_NAME, char *RETURN_CLASS);'
     Set the return class of METHOD in RCVR_CLASS to RETURN_CLASS.

'__ctalkClassMethodParam (char *RCVRCLASSNAME, char *METHODNAME, OBJECT *(*SELECTOR_FN)(), char *PARAMCLASS, char *PARAMNAME, int PARAM_IS_POINTER)'
     Define a method parameter when initializing a class method.
     Normally the compiler generates this call for inclusion in
     '__ctalk_init ()' for the method initialization at run time.

'__ctalkClassObject (OBJECT *OBJECT)'
     Returns the class object of the argument.

'__ctalkClassVariableObject (OBJECT *var)'
     Return the object that 'var' is a class variable of, or NULL.

'__ctalkFree (void *P)'
     This is an API wrapper for Ctalk's memory free routines.  Much of
     the old code in the class libraries still uses __xfree () (which
     now gets macroized to __ctalkFree () anyway), but you should use
     __ctalkFree () in new class libraries.

     In cases where you prefer to call __xfree () directly, then you
     need to use the MEMADDR macro to cast the argument to a 'void **',
     i.e.,


            char *my_buf;

            ... do stuff ...

            __xfree (MEMADDR(my_buf));


     which is what __ctalkFree () does automagically.

'__ctalkLocalTime (long int UTCTIME, int *SECONDS_RETURN, int *MINUTES_RETURN, int *HOURS_RETURN, int *DOM_RETURN, int *MON_RETURN, int *YEARS_RETURN, int *DOW_RETURN, int *DOY_RETURN, int *HAVE_DST_RETURN)'
     Returns the system's local time in the arguments that return the
     current second, minute, hour, day of the month, month, year, day of
     the week, day of the year, and (T/F) whether the time uses daylight
     savings time.

     The first argument is the system's UTC time, as returned by the
     'time ()' library function.

'__ctalkCloseGLXPane (OBJECT *PANE_OBJECT)'
     Releases the pane's GLX context and the context's XVisualInfo
     struct, and deletes the PANE_OBJECT'S X11 window.

'__ctalkCloseX11Pane (OBJECT *PANE_OBJECT)'
     Deletes and closes subpanes of a main X11 window.

'__ctalkCopyPaneStreams (OBJECT *SRC, OBJECT *DEST)'
     Copy the SRC 'inputHandle' and 'outputHandle' values to DEST.

'__ctalkCopyCVariable (CVAR *C)'
     Return a 'CVAR *' to a copy of the argument.

'__ctalkCopyObject (OBJREF_T SRC, OBJREF_T DEST)'
     Return an 'OBJECT *' to a copy of the argument.

     _Note:_ When copying normal objects, you can translate them to
     'OBJREF_T' types with the 'OBJREF' macro.  When copying method
     arguments, it is necessary to alias the argument to an object.  See
     'at' (class 'Array') and 'atPut' (class 'AssociativeArray') for
     examples.

'__ctalkCreateArgEntry (void)'
     Used internally to create an ARG type, which maintains a method's
     argument entries.

'__ctalkCreateArgEntryInit (OBJECT *OBJ)'
     Creates an internal method argument entry and initializes the entry
     to the argument object.

'__ctalkDeleteArgEntry (ARG *ARG)'
     Delete a method ARG entry.

'__ctalkCreateObject (char *NAME, char *CLASS, char *SUPERCLASS, int SCOPE)'
     Create an object without instance variables with name NAME of class
     CLASS and superclass SUPERCLASS with scope SCOPE.

'__ctalkCreateObjectInit (char *NAME, char *CLASS, char *SUPERCLASS, int SCOPE, char *VALUE)'
     Create an object with name NAME of class CLASS and superclass
     SUPERCLASS with scope SCOPE and value VALUE.

     For more information about how to use '__ctalkCreateObjectInit',
     refer to the examples in *Note Scoping::, and other examples in
     this manual.

'__ctalkCreateWinBuffer (int X_SIZE, int Y_SIZE, int CELL_SIZE)'
     Create a buffer for a 'Pane' object's window.

'__ctalkCreateGLXMainWindow (OBJECT * PANE_OBJECT)'
     Normally called by the 'initialize' method in class
     'GLXCanvasPane', creates a X11 window with a GLX visual.  The
     visual's default attributes are: 'GLX_RGBA', 'GLX_DEPTH_SIZE', 24
     bits per pixel, and 'GLX_DOUBLEBUFFER'.  These attributes are
     adjustable via the instance variables in 'GLXCanvasPane' class.

     The SELF_OBJECT argument must be an instance of 'GLXCanvasPane'
     class.  This function fills in the object's 'visualInfoPtr'
     instance variable with a pointer to the 'XVisualInfo' structure
     specified by SELF_OBJECT.  *Note GLXCanvasPane::.

     Called by the 'initialize' methods (class 'X11Pane') to create a X
     window.  Returns the window system's ID for the window, an 'int'.
     *Note X11Pane::.

     'char *'TITLE) Similar to '__ctalkCreateX11MainWindow', except that
     if TITLE is non-null, the function uses it to set the new window's
     title.  Returns the X resource ID of the new window, an 'int'.
     *Note X11Pane::.

     Application programs can provide a window geometry specification
     which is used to set the window's size and placement *Note
     parseX11Geometry::.

     If a program doesn't specify a window size, then default size is
     250x250 pixels.  If the program doesn't specify a location for the
     window, then this function tries to do something intelligent with
     the initial window placement.  *Note ctalkX11SetSizeHints::.

     Creates an X subwindow that has the parent window defined by
     PARENTPANE_OBJECT'S 'xWindowID' instance variable.  The dimensions
     of the subwindow within the parent window are determined by the
     SUBPANE_OBJECT'S 'origin' and 'size' instance variables.  Creates a
     new graphics context for the window and saves its address in the
     SUBPANE_OBJECT'S 'xGC' instance variable.

     If the SUBPANE_OBJECT's 'backgroundColor' instance variable is set;
     for example, with a statement like this:


          myCanvasPane backgroundColor = "blue";


     Then the function initiazes and clears the window to the value of
     the 'backgroundColor' instance variable.  Otherwise, the function
     sets the window's color to black and clears the window.

     Also sets the display depth in the 'depth' instance variable, and
     the ID of the subwindow in the 'xWindowID' instance variable.

'__ctalkCriticalExceptionInternal (MESSAGE *ORIG, EXCEPTION EX, char *TEXT)'
     Raise a critical exception at run time.  The argument ORIG should
     be 'NULL.' This function should be called from a method.  This
     function saves a snapshot of the _calling method's_ run-time
     context.

     For an example, see 'raiseCriticalException' (class
     'SysErrnoException') in the Ctalk class library, which calls
     '__ctalkCriticalSysErrExceptionInternal,' below.

'__ctalkCriticalSysErrExceptionInternal (MESSAGE *ORIG, int ERRNO, char *TEXT)'
     A convenience function that calls
     '__ctalkCriticalExceptionInternal' with the Ctalk exception that
     corresponds to ERRNO, the C library's error macro.

'__ctalkCVARReturnClass (CVAR *VAR, char *BUF)'
     Return in BUF the name of the class that corresponds to VAR's data
     type.

     '__ctalkDecimalIntegerToChar' C function
'__ctalkDecimalIntegerToChar (int N, char *BUF)'
     Formats the ASCII 8-bit character representation of N as the first
     character in BUF, and returns '(char)n' as its return value.  If N
     is greater than 255 (0xff hex), returns the formatted character
     '(char)(n & 255)'.

'__ctalkDecimalIntegerToASCII (int I, char *S);'
     Format an ASCII representation of I, a decimal integer, in S.

'__ctalkLongLongToDecimalASCII (long long int L, char *BUF);'
'__ctalkLongLongToHexASCII (long long int L, char *BUF, bool UPPERCASE);'
'__ctalkLongToDecimalASCII (long int L, char *BUF);'
'__ctalkLongToHexASCII (long int L, char *BUF, bool UPPERCASE);'
     Format a decimal or hexadecimal ASCII representation of L, a long
     long int, in BUF, and return BUF.

     When using '__ctalkLongLongToHexASCII,' or '__ctalkLongToHexASCII,'
     if UPPERCASE is 'true', format the number using uppercase letters;
     e.g., '0XFFFF'; otherwise format the number using lowercase
     letters: '0xffff'.

'__ctalkDefaultSignalHandler (int SIGNO)'
     Set the handler of signal SIGNO to the system's default handler.

'__ctalkDefineClassMethod (char *CLASS, char *NAME, OBJECT *(*)(fn), int REQUIRED_ARGS);'

     Define a class method in class CLASS with name NAME, which calls
     the function FN, and requires REQUIRED_ARGS arguments.

'__ctalkDefineClassVariable (char *CLASS, char *NAME, char *VARCLASS, char *INIT_EXPR);'

     Define a class variable in class CLASS with NAME.  The variable is
     an object of class VARCLASS with the initial value INIT_EXPR.

'__ctalkDefineInstanceMethod (char *CLASS, char *NAME, OBJECT *(*)(fn), int REQUIRED_ARGS);'

     Define an instance method in class CLASS with name NAME, which
     calls the function FN, and requires REQUIRED_ARGS arguments.

'__ctalkDefineInstanceVariable (char *CLASS, char *NAME, char *VARCLASS, char *INIT_EXPR);'

     Define an instance variable in class CLASS with NAME.  The variable
     is an object of class VARCLASS with the initial value INIT_EXPR.

'__ctalkDefinedClassMethodObject (OBJECT *RCVR, char *CLASSNAME, char *METHOD_NAME)'
     Initialize a 'Method' object from the class method METHOD_NAME from
     class CLASSNAME.  Note that this function only works for methods
     that are already defined.  *Note Method::.

'__ctalkDefinedInstanceMethodObject (OBJECT *RCVR, char *CLASSNAME, char *METHOD_NAME)'
     Initialize a 'Method' object from the instance method METHOD_NAME
     from class CLASSNAME.  Note that this function only works for
     methods that are already defined.  *Note Method::.

'__ctalkDefineTemplateMethod (char *CLASSNAME, char *NAME, OBJECT *(*CFUNC)(), int REQUIRED_ARGS, int N_ARGS)'
     Defines a template method.  First calls __ctalkDefineClassMethod
     (), then performs additional initialization needed for templates.

'__ctalkDeleteLastExceptionInternal (void)'
     Deletes the most recent exception from Ctalk's internal exception
     list.

'__ctalkDeleteObject (OBJECT *OBJECT)'
     Delete an object, and any objects it refers to, if they are not
     referenced elsewhere.  It's a good idea to call '__objRefCntZero'
     first.  The object then won't be showing any extra references.

     Zeroing the reference count first causes the function to delete the
     object _completely_.  It bypasses Ctalk's internal mechanisms that
     decide when objects are no longer needed.  Don't use these
     functions unless you know where the object and any objects it
     refers to are declared.

     It should seldom be necessary to remove an object from a particular
     scope manually anyway.  But in that case, call '__objRefCntDec'
     instead, and then let Ctalk try to clean up the object when it goes
     out of scope.

     For example, to delete a scratch object using C,


          Object new tmpObject;
          OBJECT *tmpObject_alias;

          tmpObject_alias = tmpObject;

          __objRefCntZero (OBJREF(tmpObject_alias));
          __ctalkDeleteObject(tmpObject_alias);


     Translating the object to C should work in all cases, regardless of
     the surrounding code.  Of course, you can also use the 'delete'
     method (class 'Object') with many simple C expressions.


          Object tmpObject;
          OBJECT *tmpObject_alias;

          tmpObject delete;

          _..or.._

          tmpObject_alias delete;

          _..or even this expression.._

          tmpObject_alias -> instancevars delete;


     Deletes OBJ if there are no references to it, or if this is the
     last reference to the object.  In this case, the function works
     similarly to '__ctalkDeleteObject'.  Otherwise, the function
     decreases the object's reference count by 1.

'__ctalkDeleteObjectList (OBJECT *OBJECT)'
     Delete an object and any objects that link to it.

'__ctalkDeleteWinBuffer (OBJECT *PANEBUFFER_INSTANCE_VAR)'
     Deletes a 'paneBuffer' backing store allocated when a subclass of
     'Pane' creates an object.

'__ctalkDocDir (void)'
     Returns a 'char *' that contains the path where the Ctalk-specific
     documentation is installed on the system (i.e., documentation other
     than man pages and Texinfo manuals).

'__ctalkDoubleToASCII (double D, char *S);'
'__ctalkFloatToASCII (float F, char *S);'
'__ctalkLongDoubleToASCII (long double F, char *S);'
     Format an ASCII representation of the first argument in S.  Returns
     S.

     '__ctalkEnterArgBlockScope' C function
'__ctalkEnterArgBlockScope (void)'
     Ctalk inserts this call at the beginning of argument blocks.
     Checks that the block call is the result of an inline method call
     and sets the run-time stack's RTINFO structure to indicate a block
     call with the correct stack frame for the block's scope.

     '__ctalkExec' C function
'__ctalkExec(char *CMDLINE, OBJECT *STROBJECT)'
     Executes the command line given as the argument and waits for the
     subprocess to finish.  If the STROBJECT argument is non-NULL, the
     function saves the subprocesses' standard output as the object's
     'value'.  Normally, STROBJECT should be a 'String' object.

     If the STROBJECT argument is NULL, '__ctalkExec' reads and prints
     the subprogram's standard output to the terminal's standard output.

     '__ctalkExec' supports the redirection operators '>' or '>>', which
     send the subprocess's standard output to the file given as the
     redirection operator's target.  If CMDLINE is a shell script, it is
     executed by a sub-shell using the 'system(3)' library function.

     '__ctalkExitArgBlockScope' C function
'__ctalkExitArgBlockScope (void)'
     Ctalk inserts this function, which is currenly a no-op, as the last
     function call in an argument block.

'__ctalkErrorExit (void)'
     Cleans up the program's immediate object environment before a call
     to the C 'exit(3)' function.

'__ctalkEvalExpr (char *EXPR)'
     Evaluate EXPR and return an 'OBJECT *' to the result.

'__ctalkEvalExprU (char *EXPR)'
     Like '__ctalkEvalExpr', above, but '__ctalkEvalExprU' returns a C
     NULL instead of a null result object when an expression evaluates
     to 0.

'__ctalkExceptionInternal (MESSAGE *MSG, EXCEPTION E, char *TEXT)'
     Generate an exception of type E.  Exceptions are listed in
     'except.h', and in the description of 'Exception' class.  *Note
     Exception::.  If MSG is non-NULL, which is usually the case when
     the compiler generates and exception, the function records the line
     and column number of the exception.  If TEXT is non-NULL, the
     exception handler adds the text to the exception record, so it can
     be displayed when the program handles the exception.

     Programs should handle run-time exceptions as soon as possible
     after returning from a method.  The function
     '__ctalkHandleRunTimeExceptionInternal' is the normal exception
     handler, and '__ctalkTrapExceptionInternal' determines whether an
     exception has occurred.

'__ctalkFindClassVariable (char *VARNAME, int WARN)'
     Search the class library for _first occurrence_ of the class
     variable VARNAME.

     If WARN is 'TRUE,' issues a warning if the variable is not found.

     '__ctalkFindMethodByName' C function
'__ctalkFindMethodByName (OBJECT **OBJECT, const char *NAME, int WARN)'
     Returns the first instance or class method NAME if it exists in
     OBJECT's class or superclasses, or NULL if a method with that name
     isn't found.  If WARN is true, prints a warning message if the
     method isn't found.

'__ctalkFindPrefixMethodByName (OBJECT **RCVR, const char *NAME, int WARN)'
     Looks up a classes' instance method that matches NAME which has the
     'prefix' attribute set.  If WARN is true, prints a warning if the
     method is not found.

'__ctalkExceptionNotifyInternal (I_EXCEPTION *I)'
     The handler function of most exceptions.  Prints a message
     including any text provided as an argument to
     '__ctalkExceptionInternal'.

'__ctalkFilePtrFromStr (char *sFORMATTED_PTR)'
     Like '__ctalkGenericPtrFromStr (),' below, converts a string
     containing a formatted hexadecimal number to a pointer, and also
     checks that the pointer is a valid file.

     The function returns a 'void *' in order to keep Ctalk's header
     inclusion simple, or NULL if the argument does not contain a valid
     hexadecimal number, or if the pointer does not point to a valid
     file.

     This function can also set 'errno' in case of an error.

     Because the function returns a 'void *' an app or method must
     perform the cast from 'void *' to 'File *' when it calls this
     function.

'__ctalkFindClassMethodByFn (OBJECT **RCVR_P, OBJECT *(*FN)(), int WARN)'
     Finds a class method by calling '__ctalkGetClassMethodByFn' for the
     method's receiver and then the receivers of previous method calls.
     On success, returns the method, and RCVR_P contains the address of
     the method's receiver.

     If WARN is 'TRUE,' issues a warning if the method is not found.

'__ctalkFindClassMethodByName (OBJECT **RCVR_P, char *NAME, int WARN)'
     Finds a class method by by calling '__ctalkGetClassMethodByName'
     for the method's receiver and then the receivers of previous method
     calls.  On success, returns the method, and RCVR_P contains the
     address of the method's receiver.

     If WARN is 'TRUE,' issues a warning if the method is not found.

'__ctalkFindInstanceMethodByFn (OBJECT **RCVR_P, char *NAME, int WARN)'
     Finds an instance method by calling '__ctalkGetInstanceMethodByFn'
     for the method's receiver and then the receivers of previous method
     calls.  On success, returns the method, and RCVR_P contains the
     address of the method's receiver.

     If WARN is 'TRUE,' issues a warning if the method is not found.

'__ctalkFindInstanceMethodByName (OBJECT **RCVR_P, char *NAME, int WARN)'
     Finds an instance method by by calling
     '__ctalkGetInstanceMethodByName' for the method's receiver and then
     the receivers of previous method calls.  On success, returns the
     method, and RCVR_P contains the address of the method's receiver.

     If WARN is 'TRUE,' issues a warning if the method is not found.

'__ctalkSaveCVARArrayResource (char *NAME, int INITIALIZER_SIZE, void *var)'
     Saves an 'Array' object with the contents of 'var' in a method's
     object pool.

'__ctalkSaveCVARResource (char *NAME)'
     Saves the contents of C variable NAME in a method's object pool.

'__ctalkSaveOBJECTMemberResource (OBJECT *OBJECT)'
     Saves an 'OBJECT *' member to a method's resource pool.

'__ctalkSleep (int USECS)'
     Put a program to sleep for USECS microseconds.  The operating
     system restores the program to a running state no sooner than that
     amount of time has elapsed.

'__ctalkSort (OBJECT *COLLECTION, bool SORTDESCENDING)'
'__ctalkSortByName (OBJECT *COLLECTION, bool SORTDESCENDING)'
     Sorts a collection's members into ascending or descending order.
     '__ctalkSort' performs the sort using the collection members'
     values, while '__ctalkSortByName' uses the members' names.

     The algorithm used is very simple minded, although due to the
     mechanics of finding earlier/later collection members, it is as
     fast as divide-and-conquer algorithms for small or medium sized
     collections.  For large collections it is probably more practical
     to sort the collection as an 'OBJECT **' array and create a new
     list based on the collection members' sorted order.

     However, it is almost always faster to add members to collections
     in the order you want them sorted rather than trying to re-arrange
     the collection later.  For this, refer to the methods in the
     'SortedList' class *Note SortedList::.

'__ctalkStrToPtr (char *PTR)'
     Converts a formatted hexadecimal number to a 'void *'.  The
     function '__ctalkGenericPtrFromStr', below, performs some extra
     validation.

'__ctalkGenericPtrFromStr (char *S)'
     A wrapper function for '__ctalkStrToPtr ()' that performs some
     extra validation of the string argument.  These functions convert a
     string containing a formatted hexadecimal number (e.g.,
     '"0xnnnnnn"' or "'"0XNNNNNN"' into a 'void *.' Both of the
     functions return a 'void *', or NULL if the string does not contain
     a valid hexadecimal number.

'__ctalkGetCallingFnObject (char *NAME, char *CLASSNAME)'
     When used within 'Object : become', returns the object with the
     name NAME in the class CLASSNAME from 'become's' calling function.
     Also adjusts its caller indexes if 'become' is called within an
     argument block.

'__ctalkGetCallingMethodObject (char *NAME, char *CLASSNAME)'
     When used within 'Object : become', returns the object with the
     name NAME in the class CLASSNAME from 'become's' calling method.
     Also adjusts its caller indexes if 'become' is called within an
     argument block.

'__ctalkGetCArg (OBJECT *OBJ)'
     Retrieves the CVAR of the C variable named by OBJ.

'__ctalkGetInstanceMethodByFn (OBJECT *class_object, OBJECT *(*FN)(void), int WARN)'
     Returns the method that defines function FN from CLASS_OBJECT, or
     NULL if the method doesn't exist.  If WARN is true, prints a
     warning message if the method isn't found.

'__ctalkGetInstanceMethodByName (OBJECT *class_object, const char *NAME, int WARN)'
     Returns the method named NAME from CLASS_OBJECT, or NULL if the
     class doesn't define a method with that name.  If WARN is true,
     prints a warning message if the method isn't found.

'__ctalkGetReceiverPtr (void)'
     Returns an 'int' with the current value of the receiver stack
     pointer.

'__ctalkGetRS (void)'
     Returns a 'char' with the current record separator.  The record
     separator determines, among other uses, how regular expression
     characters act at line endings.  *Note RecordSeparator::.

'__ctalkGetRunTimeException (void)'
     Remove the first exception from the exception queue and return the
     exception's message as a char *.

'__ctalkGetTemplateCallerCVAR (char * NAME)'
     If called from within a function template, looks up the 'CVAR' NAME
     in the calling function or method.  This function returns a
     temporary object with the name and class, superclass, and value
     that correspond to the 'CVAR''s data type.  The return object
     persists until the next time this function is called.

'__ctalkGetClass (char * CLASSNAME)'
     Get the class object for CLASSNAME.

'__ctalkGetClassMethodByFn (OBJECT *RCVR, OBJECT *(*FN)(void), int WARN)'
     Return a class method of RCVR'S class with the run-time function
     FN.

     If WARN is 'TRUE,' issue a warning if the method is not found.

'__ctalkGetClassMethodByName (OBJECT *RCVR, char *NAME, int WARN)'
     Return a class method of RCVR'S class with the name NAME.

     If WARN is 'TRUE,' issue a warning if the method is not found.

'__ctalkGetExprParserAt (int IDX)'
     Return the expression parser, which is a struct 'EXPR_PARSER'
     typedef, at stack index IDX.

'__ctalkGetExprParserPtr (void)'
     Return the expression parser pointer, and 'int.'

'__ctalkGetClassVariable (OBJECT *RECEIVER, char *VARNAME, int)'
     WARN) Return the class variable named VARNAME from the receiver's
     class object, or 'NULL' if the variable does not exist.  If WARN is
     'TRUE,' issue a warning message if the variable is not found.

'__ctalkGetExceptionTrace (void)'
     Return 'TRUE' if a program has enabled exception walkbacks, 'FALSE'
     otherwise.

'__ctalkGetInstanceVariable (OBJECT *RECEIVER, char *VARNAME, int)'
     WARN) Return the instance variable named VARNAME from the receiver,
     or 'NULL' if the variable does not exist.  If WARN is 'TRUE,' issue
     a warning message if the variable is not found.

'__ctalkGetInstanceVariableByName (char *RECEIVER_NAME, char *VARNAME, int)'
     WARN) Return the instance variable named VARNAME from the object
     named by RECEIVER_NAME, or 'NULL' if the variable does not exist.
     If WARN is 'TRUE,' issue a warning message if the variable is not
     found.

'__ctalkGetPrefixMethodByName (OBJECT *class_object, const char *NAME, int WARN)'
     Returns the method named NAME from CLASS_OBJECT that has the
     'prefix' attribute set, or NULL if the class doesn't define a
     prefix method with that name.  If WARN is true, prints a warning
     message if the method isn't found.

'__ctalkGetTypeDef (char * NAME)'
     Return the 'CVAR' of the typedef NAME.

'__ctalkGetX11KeySym (int KEYCODE, int SHIFT_STATE, int KEYPRESS)'
     Returns an 'int' with the keyboard mapping of a keypress in X
     applications.  This allows programs to distinguish between modifier
     keypresses (e.g., shift, control, and alt), and alphanumeric
     keypresses.

     The first and second parameters are taken from an XKeyPressEvent or
     XKeyReleaseEvent structure.  The third parameter, KEYPRESS, should
     be true for Keypress events and false for keyrelease events.

     For alphanumeric keys, this function does not automatically modify
     the ASCII code of a key that is pressed when the shift key (or any
     other modifier key) is pressed.  That is, pressing 'A' and 'a' both
     return the ASCII value 97.  It is up to the program to record
     whether the shift key is pressed at the same time, and to provide
     the shifted character itself if necessary.

     Refer to the 'run' method in 'GLXCanvasPane' class for an example.

     This function uses 'XGetKeyboardMapping(3)' internally.

'__ctalkGLEW20 (void)'
     Returns a boolean value of true if the GLEW library supports
     version 2.0 extensions, mainly for OpenGL programs that use
     shaders.  Programs must call the '__ctalkInitGLEW' function before
     using this function.

'__ctalkGlobalObjectBecome (OBJECT *OLD, OBJECT *NEW)'
     Called when the receiver of 'Object : become' is a global object.

'__ctalkGlobFiles (char *PATTERN, OBJECT *list)'
     If the system's C libraries support file globbing with the 'glob'
     library function, '__ctalkGlobFiles' returns the file and directory
     pathnames that match PATTERN in the 'List' object given as the LIST
     argument.

     For information about how the C library matches file patterns,
     refer to the 'glob(3)' and related manual pages.

'__ctalkGLUTVersion (void)'
'__ctalkGLUTCreateMainWindow (char *TITLE)'
'__ctalkGLUTInitWindowGeometry (int X, int Y, int WIDTH, int HEIGHT)'
'__ctalkGLUTInit (int ARGC, char **ARGV)'
'__ctalkGLUTRun (void)'
'__ctalkGLUTInstallDisplayFn (void (*FN)())'
'__ctalkGLUTInstallReshapeFn (void (*FN)(int, int))'
'__ctalkGLUTInstallIdleFn (void (*FN)())'
'__ctalkGLUTInstallOverlayDisplayFunc (void (*FN)())'
'__ctalkGLUTInstallKeyboardFunc (void (*FN)(unsigned char, int, int))'
'__ctalkGLUTInstallMouseFunc (void (*FN)(int, int, int, int))'
'__ctalkGLUTInstallMotionFunc (void (*FN)(int, int))'
'__ctalkGLUTInstallPassiveMotionFunc (void (*FN)(int, int))'
'__ctalkGLUTInstallVisibilityFunc (void (*FN)(int))'
'__ctalkGLUTInstallEntryFunc (void (*FN)(int))'
'__ctalkGLUTInstallSpecialFunc (void (*FN)(int, int, int))'
'__ctalkGLUTInstallSpaceballMotionFunc (void (*FN)(int, int, int))'
'__ctalkGLUTInstallSpaceballRotateFunc (void (*FN)(int, int, int))'
'__ctalkGLUTInstallSpaceballButtonFunc (void (*FN)(int, int))'
'__ctalkGLUTInstallButtonBoxFunc (void (*FN)(int, int))'
'__ctalkGLUTInstallDialsFunc (void (*FN)(int, int))'
'__ctalkGLUTInstallTabletMotionFunc (void (*FN)(int, int, int, int))'
'__ctalkGLUTInstallMenuStatusFunc (void (*FN)(int, int, int))'
'__ctalkGLUTInstallMenuStateFunc (void (*FN)(int))'
'__ctalkGLUTInstallMenuStateFunc (void (*FN)(int))'
'__ctalkGLUTSphere (double, int, int, int);'
'__ctalkGLUTCube (double, int);'
'__ctalkGLUTCone (double, double, int, int, int);'
'__ctalkGLUTTorus (double, double, int, int, int);'
'__ctalkGLUTDodecahedron (int);'
'__ctalkGLUTOctahedron (int);'
'__ctalkGLUTTetrahedron (int);'
'__ctalkGLUTIcosahedron (int);'
'__ctalkGLUTTeapot (double, int);'
'__ctalkGLUTFullScreen (void);'
'__ctalkGLUTPosition (int, int);'
'__ctalkGLUTReshape (int, int);'
'__ctalkGLUTWindowID (char *WINDOW_NAME)'
     The functions that make up Ctalk's glue layer for the GLUT API. For
     their use, refer to the methods in GLUTApplication class.

'__ctalkGLXAlpha (float ALPHA)'
     Sets the alpha (opacity) channel for outline text rendering.
     Values should be between 0.0 (transparent) and 1.0 (opaque).  The
     Ctalk library's default value is 1.0 (opaque).

'__ctalkGLXDrawText (char *TEXT)'
     This is another convenience function that draws text on a
     'GLXCanvasPane' using a X font that the program registered with the
     pane's GLX context via a previous call to '__ctalkGLXUseXFont'.

     The 'GLXCanvasPane' class defines several methods that facilitate
     drawing with X fonts when using GLX. *Note GLXCanvasPane::.

'__ctalkGLXDrawTextFT (char *TEXT, float X, float Y)'
     Draws TEXT at the matrix coordinates given by the X,Y arguments.
     Programs should call at least '__ctalkGLXUseFTFont' before calling
     this function.

'__ctalkGLXExtensionsString (void)'
     Returns a 'char *' containing the extensions supported glX.

'__ctalkGLXExtensionSupported (char *EXTNAME)'
     Returns a boolean value of True if the system's glX extension
     supports EXTNAME, False otherwise.

'__ctalkGLXFrameRate (void)'
     Returns a 'float' with the frames per second of the calling
     program.  The function averages the rate over each interval of
     approximately five seconds.

'__ctalkGLXFreeFTFont (void)'
     Frees the font and library data from a previous call to
     '__ctalkGLXUseFTFont.'

'__ctalkGLXFreeXFont (void)'
     Frees X font data that was allocated by a previous call to
     '__ctalkGLXUseXFont'.  The 'GLXCanvasPane' class defines several
     methods that facilitate drawing with X fonts when using GLX. *Note
     GLXCanvasPane::.

'__ctalkGLXFullScreen (OBJECT *SELFOBJECT, char *WINTITLE)'
     Toggles the window's full screen mode on and off.

'__ctalkGLXNamedColorFT (char *COLORNAME)'
     Sets the foreground color for drawing text with Freetype fonts to
     the named X11 color given as the argument.

'__ctalkGLXPixelHeightFT (int PXHEIGHT)'
     Sets the height of the current Freetype face in use to the pixel
     height given as the argument.

'__ctalkGLXRefreshRate (void)'
     Returns a 'float' with the display's refresh rate if the OpenGL
     installation supports the 'GLX_OML_sync_control' extension.  If
     OpenGL doesn't support 'GLX_OML_sync_control', the function prints
     a warning message on the terminal and returns -1.

'__ctalkGLXSwapBuffers (OBJECT *GLXPANE_OBJECT)'
     This is an API-level wrapper for the GLXSwapBuffers library
     function.

'__ctalkGLXSwapControl (int INTERVAL)'
     Sets the swap buffer synchronization to 1/interval.  If interval is
     0, disables buffer swap synchronization.  If the machine's OpenGL
     does not support the 'GLX_MESA_swap_control' extension, the
     function is a no-op.  Returns 0 on success, -1 if the extension is
     not supported.

'__ctalkGLXTextWidth (char *TEXT)'
     Returns an 'int' with the width in pixels of TEXT rendered in the
     current font.  The program must first have selected a X font using
     '__ctalkGLXUseFon'.  If no font is selected, the function returns
     '-1'.

'__ctalkGLXUseFTFont (String FONTFILENAME)'
     Initializes the Freetype library and loads the font from the file
     given as the argument.  Use '__ctalkGLXFreeFTFont' to release the
     font data before calling this function again when changing fonts.

'__ctalkGLXUseXFont (OBJECT *GLXCANVASPANEOBJECT, char *FONTNAME)'
     This is a convenience function that registers the X font, FONTNAME
     for use with GLXCANVASPANEOBJECT, first by retrieving the X font
     data for FONTNAME, then registering the font using
     'glXUseXFont(3)'.

     After the program has finished drawing with the font, the program
     should call '__ctalkGLXFreeXFont'.

     The 'GLXCanvasPane' class defines several methods that facilitate
     drawing with X fonts when using GLX. *Note GLXCanvasPane::.

'__ctalkGLXFullScreen (void)'
     Returns a boolean value of true if the window is using Freetype
     fonts, false otherwise.

'__ctalkGLXWindowPos2i (int X, int Y)'
     This is a wrapper for the 'glWindowPos2i' function, which several
     methods in 'GLXCanvasPane' class use.

     Because 'glWindowPos2i' is an extension in many GL implementations,
     Ctalk checks for the function's presence when compiling the
     libraries.

     If the GL implementation does not provide 'glWindowPos2i', then any
     Ctalk program that tries to use this function (or one of the
     methods that call it), prints an error message and exits.

'__ctalkGLXWinXOrg (void)'
'__ctalkGLXWinYOrg (void)'
'__ctalkGLXWinXSize (void)'
'__ctalkGLXWinYSize (void)'
     These functions return an int with the window's current origin and
     size.

'__ctalkGUIPaneDrawCircleBasic (void *DISPLAY, int WINDOW_ID, int GC, int CENTER_X, int CENTER_Y, int RADIUS, int FILL, int PEN_WIDTH, int ALPHA char *FG_COLOR_NAME, char *BG_COLOR_NAME)'
     Draws a circle centered at CENTER_X,CENTER_Y with radius RADIUS.
     The dimensions are given in pixels.  If FILLED is true, then the
     function draws a filled circle; otherwise, the circle's edge has
     the width PEN_WIDTH.

     This function is a synonym for '__ctalkX11PaneDrawCircleBasic'.

'__ctalkGUIPaneClearRectangle (OBJECT *PANE_OBJECT, int X, int Y, int WIDTH, int HEIGHT)'
     Clear a rectangular region in a GUI Pane object.  Also clear the
     region in any buffers associated with the object.

'__ctalkGUIPaneClearWindow (OBJECT *PANE_OBJECT)'
     Clear a pane object's window.

'__ctalkGUIPaneDrawLine (OBJECT *PANE_OBJECT, OBJECT *LINE_OBJECT, OBJECT *PEN_OBJECT)'
     Draw a line specified by LINE_OBJECT (an instance of 'Line' class)
     using PEN_OBJECT (an instance of 'Pen' class).

'__ctalkGUIPaneDrawLineBasic (void *DISPLAY, int DRAWABLE_ID, int GC_PTR, int X_START, int Y_START, int X_END, int Y_END, int PEN_WIDTH, int ALPHA, char *PEN_COLOR)'
'__ctalkX11PaneDrawLineBasic (void *DISPLAY, int DRAWABLE_ID, int GC_PTR, int X_START, int Y_START, int X_END, int Y_END, int PEN_WIDTH, int ALPHA, char *PEN_COLOR)'
     Draw a line between the points (x_start,y_start) and (x_end, y_end)
     with the color, and transparency using the drawable ID, graphics
     context, and pen color, width, and transparency given as arguments.

     This function is a synonym for '__ctalkX11PaneDrawPointBasic.'

'__ctalkGUIPaneDrawPoint (OBJECT *PANE_OBJECT, OBJECT *POINT_OBJECT, OBJECT *PEN_OBJECT)'
     Draw a point on PANE_OBJECT specified by POINT_OBJECT using
     PEN_OBJECT.

'__ctalkGUIPaneDrawRectangle (OBJECT *PANE_OBJECT, OBJECT *RECTANGLE_OBJECT, OBJECT *PEN_OBJECT, int FILL)'
     Draw a rectangle on PANE_OBJECT specified by RECTANGLE_OBJECT using
     PEN_OBJECT.  If FILL is non-zero, draw a filled rectangle.

'__ctalkGUIPaneDrawRoundedRectangle (OBJECT *PANE_OBJECT, OBJECT *RECTANGLE_OBJECT, OBJECT *PEN_OBJECT, int FILL, int RADIUS)'
     This is similar to '__ctalkGUIPaneDrawRectangle', except that it
     takes an extra argument, RADIUS, which specifies the radius of the
     arcs that are used to draw the corners.

'__ctalkGUIPanePutStr (OBJECT *PANE_OBJECT, int X, int Y, char *STRING)'
     Display 'String' object STRING at coordinates X,Y on PANE_OBJECT.
     You can select the font with the 'font' method in class 'X11Pane'.
     This function relies on instance variables defined in 'X11Pane'
     class.  The '__ctalkX11PanePutStrBasic' function, below, provides a
     more flexible interface to the X libraries.

'__ctalkGUIPaneRefresh (OBJECT *PANE_OBJECT, int SRCX, int SRCY, int SRCWIDTH, int SRCHEIGHT, int DESTX, int DESTY)'
     Refresh the Pane object by updating the visible window with
     PANE_OBJECT's buffers and, if necessary, notifying the GUI library
     that the window has been updated.

'__ctalkGUISetBackground (OBJECT *PANE_OBJECT, char *COLOR)'
     Set the background of a pane's window to COLOR.  This function is
     intended only for objects that have an actual window; e.g.,
     'X11Pane' objects.  For all other visual types, like pixmaps, use
     __ctalkX11SetBackgroundBasic.

'__ctalkX11SubWindowGeometry (OBJECT * PARENTPANE, char * GEOMSTR, int *X_OUT, int *Y_OUT, int *width_out, int *HEIGHT_OUT)'
     Parses a string that contains the geometry specification of a
     subwindow, and returns the width and height of the subwindow and
     its X,Y position within the parent pane's window.

     A geometry specification has the form:


          width[%]xheight[%]+x_org[%]+y_org[%]


     The _x, y, width, and height_ parameters are interpreted as the
     actual origin and size of the subwindow, unless a parameter is
     followed by a percent sign ('%').  In that case, the dimension is
     interpreted as a fraction of the parent window's corresponding
     vertical or horizontal dimension.

'__ctalkX11TextFromData (void *DISPLAY, int DRAWABLE_ID, int GD_PTR, char *TEXT)'
     Displays TEXT on DRAWABLE_ID.

'__ctalkX11TextWidth (char *FONTDESC, char *TEXT)'
     Returns an 'int' with the width in screen pixels of the TEXT
     argument when rendered in the font named by FONTDESC.  There is
     more information about how to use fonts in the sections that
     discuss the X graphics classes.  *Note X11Font::.

'__ctalkHandleRunTimeException (void)'
     Execute the exception handler for a pending exception.  The
     'handle' method (class 'Exception') calls this function.  *Note
     Exception::.

'__ctalkHandleRunTimeExceptionInternal (void)'
     Execute the exception handler for a pending exception.  If the
     exception is generated by an expression, execute the exception
     handler only if further expressions or subexpressions need to be
     evaluated.

'__ctalkHaveFTFaceBasic (void)'
     Returns TRUE if an application has created a new FreeType2 font
     face, FALSE otherwise.  This is a lower level library function that
     apps should not need to use directly, and may go away in the
     future.

'__ctalkHexIntegerToASCII (unsigned int PTR, char *S)'
     Format a hexadecimal representation of PTR in S.  The return value
     is the formatted string in S.

     On 64-bit machines, the prototype is:


          char *__ctalkHexIntegerToASCII (unsigned long long int ptr, char *buf)


'__ctalkIgnoreSignal (int SIGNO)'
     Set the handler for SIGNO to ignore the signal.

'__ctalkIncKeyRef (OBJECT *OBJECT, int INC, int OP)'
'__ctalkIncStringRef (OBJECT *OBJECT, int IDX, int OP)'
     Increment the reference to the value of OBJECT, a 'String' or 'Key'
     object, or one of its subclasses, by IDX.  If IDX is negative,
     decrements the reference to the value of the receiver.  If the
     reference is before or after the start or end of the receiver's
     value, further uses of the object return NULL.

     The argument OP can be one of the following constants, which are
     defined in 'ctalkdefs.h'.

     'TAG_REF_PREFIX'
          Increments (or decrements) the value of the receiver
          immediately.  Normally this is used for prefix '++' and '--'
          operators, and also '+=' and '-=' operators.

     'TAG_REF_POSTFIX'
          Increments (or decrements) the value of the receiver after its
          value is accessed.  Used normally for postfix '++' and '--'
          operators.

     'TAG_REF_TEMP'
          Adds a temporary reference that is cleared after the receiver
          is next read.  Normally you would use this for expressions
          that assign the reference to another object, as in this
          example.


               String new str1;
               String new str2;

               str1 = "Hello, world!";

               str2 = str1 + 3;


          The object 'str2' is assigned the calculated reference.  The
          value of 'str1' is unaffected.

'__ctalkInitGLEW (void)'
     Initialize the GLEW library.  Programs must call this function
     before performing any operations that use OpenGL extensions.

'__ctalkInlineMethod (OBJECT *RCVR, METHOD *METHOD, int N_ARGS, ...)'
     Call a method or block of code that is an argument to another
     method.  The class of RCVR and the class of METHOD do not need to
     be the same.  Currently, only the 'map' method uses inline method
     calls.  For an example of the '__ctalkInlineMethod ()''s use, see
     'map' (implemented by the 'List', 'Array', and 'AssociativeArray'
     classes).  This function can (and should) be used to implement
     inline method messages or code blocks when streaming over
     collections.

     The N_ARGS argument specifies the number of arguments to be passed
     to the target method.  Currently '__ctalkInlineMethod ()' supports
     0 - 6 arguments.

'__ctalkIntRadixToDecimalASCII (char *INTBUF)'
     Return a C string with the integer formatted in INTBUF formatted as
     a decimal (base 10) integer.

'__ctalkInstallHandler (int SIGNO, OBJECT *(*METHOD_C_FUNCTION)())'
     Set the handler of signal SIGNO to METHOD_C_FUNCTION.  The
     prototype of METHOD_C_FUNCTION is similar to the intermediate C
     prototype of Ctalk's methods.  Signal handlers installed with this
     function reset the handler to the default after each use, except
     for handlers on DJGPP platforms.

'__ctalkInstallPrefix (void)'
     Returns a 'char *' with the top-level directory where Ctalk is
     installed.  Ctalk's installation uses this directory as the
     top-level directory of its installation layout; for example, in
     relative terms, this is where Ctalk's various components get
     installed:


          Executables:            _prefixdir_/bin
          Libraries:              _prefixdir_/lib
          Class Libraries:        _prefixdir_/include/ctalk
          Texinfo Manuals:        _prefixdir_share/info
          Manual Pages:           _prefixdir_/share/man
          Searchable Docs:        _prefixdir_/share/ctalk


'__ctalkIntanceMethodInitReturnClass (char *RCVRCLASSNAME, char *METHODNAME, char *RETURNCLASSNAME)'
     Set the return class of method METHODNAME of class RCVRCLASSNAME to
     RETURNCLASSNAME.

'__ctalkInstanceVarsFromClassObject (OBJECT *OBJ)'
     Add the instance variables defined by OBJ'S class object.

'__ctalkInstanceVarIsCallersReceiver (void)'
     Used by 'Object: become'.  Returns True if the receiver object is
     an instance variable, False otherwise.

'__ctalkInitFTLib (void)'
     Initialize the system's FreeType2 library.  Returns 0 if
     successful, ERROR ('-1') if unsuccessful or if the library isn't
     available.  This is a lower level function that should not normally
     be needed by apps directly, and may go away in the future.

'__ctalkInstanceMethodParam (char *RCVRCLASSNAME, char *METHODNAME, OBJECT *(*SELECTOR_FN)(), char *PARAMCLASS, char *PARAMNAME, int PARAM_IS_POINTER)'
     Define a method parameter when initializing a method.  Normally the
     compiler generates this call for inclusion in '__ctalk_init ()' for
     the method initialization at run time.

'__ctalkIntFromCharConstant (char *STR)'
     Returns the 'int' value of the character constant STR.  Recognizes
     all of the escape sequences that Ctalk uses, whether the constant
     is enclosed in single quotes or not.  Also recognizes backslash
     escape sequences and the following control character constants.


          Escape Sequence    Int Value
          \0                 0
          \a                 1
          \b                 2
          \e                 27
          \f                 6
          \n                 10
          \r                 13
          \t                 9
          \v                 11


     The '\e' escape sequence is an extension to the C language
     standard.

'__ctalkIsClassVariableOf (char *CLASS, char *VARNAME)'
     Returns 'TRUE' if VARNAME is a class variable of CLASS, 'FALSE'
     otherwise.

'__ctalkIsCallersReceiver (void)'
     Used by 'Object : become' to determine if an object is the calling
     method's receiver.

'__ctalkIsDir (char *PATH)'
     Returns 'TRUE' if PATH is a directory, 'FALSE' otherwise.

'__ctalkIsInstanceMethod (OBJECT *SELF_OBJECT, char *METHOD_NAME)'
'__ctalkIsClassMethod (OBJECT *SELF_OBJECT, char *METHOD_NAME)'
     The functions return True if the method given by METHOD_NAME is an
     instance or class method, respectively, in SELF_OBJECT'S class.

'__ctalkIsInstanceVariableOf (char *CLASS, char *VARNAME)'
     Returns 'TRUE' if VARNAME is an instance variable of CLASS, 'FALSE'
     otherwise.

'__ctalkIsObject (OBJECT *O)'
     Return 'TRUE' if if O is a valid object, 'FALSE' otherwise.

'__ctalkIsSubClassOf (char *CLASSNAME, char *SUPERCLASSNAME)'
     Return 'TRUE' if CLASSNAME is a subclass of SUPERCLASSNAME, 'FALSE'
     otherwise.

'__ctalkLastMatchLength (void)'
     Return the length of the match from the last call to
     '__ctalkMatchText', below.

'__ctalkLibcFnWithMethodVarArgs (int (*LIBCFN)(), METHOD *METHOD, char *LIBCFN_RETURN_CLASS)'
     Call the C library function LIBCFN using with its template method
     METHOD.  For C library functions that use 'stdarg.h' variable
     arguments, LIBCFN_RETURN_CLASS should be 'Integer.'

     When evaluating an expression, the currently executing method is
     contained in the current 'EXPR_PARSER'.  *Note
     __ctalkGetExprParserAt::.

     _Note:_ This version of Ctalk only supports variable-argument
     functions on 32-bit Intel platforms.  If you try to use a
     variable-argument function on another hardware platform, Ctalk
     issues a warning and returns 'NULL.'

'__ctalkLogMessage (char *, ...)'
     Formats the message given as the argument and writes the message to
     the system's syslog facility.

'__ctalkMatchAt (Integer N)'
'__ctalkMatchIndexAt (Integer N)'
     Returns, respectively, the text, or the character index matched by
     the N'TH parenthesized subexpression during a previous call to
     '__ctalkMatchText' (i.e., a backreference).  The argument, N, is
     '0' for the first parenthesized subexpression, '1' for the next
     subexpression, and so on.  If the _n'_th pattern didn't match any
     text, returns NULL. *Note Pattern Matching::.

'__ctalkMatchText (char *PATTERN, char *TEXT, long long int *OFFSETS)'
     Find the occurences of PATTERN in TEXT.  Returns the index of each
     match in the OFFSETS array, with the list terminated by -1.
     Returns the number of matches, or -1 if there are no matches.

'__ctalkMatchPrintToks (bool PRINTTOKS)'
     If PRINTTOKS is 'true', then Ctalk prints the regular expression
     tokens and the matching text for every regular expression match,
     which can be useful for debugging regular expressions.

'__ctalkMapGLXWindow (OBJECT *GLXCANVASPANE_OBJECT)'
     Maps a 'GLXCanvasPane's' window to the display and creates a
     'GLXContext' for the window, and makes the GLXContext current.

     Saves the GLXContext pointer in the receiver's 'glxContextPtr'
     instance variable.  *Note GLXCanvasPane::.

'__ctalkMapX11Window (OBJECT *X11PANE_OBJECT)'
     The X library interface of the 'map' (class 'X11Pane') method *Note
     X11Pane::.  This function is a wrapper for the 'XMapWindow' and
     'XMapSubwindows' Xlib functions.

'__ctalkMethodObjectMessage (OBJECT *RCVR, OBJECT *METHOD_INSTANCE)'
     Perform a method call by sending RCVR the message defined by
     METHOD_INSTANCE, which is a previously defined 'Method' object.
     *Note Method::.

     The function returns '0' on success, '-1' on error.

     For examples of 'Method' object calls, *Note methodObjectMessage::.

'__ctalkMethodObjectMessage (OBJECT *RCVR, OBJECT *METHOD_INSTANCE, OBJECT *ARG1, OBJECT *ARG2)'
     Perform a method call by sending RCVR the message defined by
     METHOD_INSTANCE, which is a previously defined 'Method' object.

     The parameters ARG1 and ARG2 are the arguments to the method
     instance.  'Method' objects with two arguments are commonly used in
     graphical event dispatchers, particularly in 'X11PaneDispatcher'
     class.  This helps simplify the event dispatcher methods.

     The function returns '0' on success, '-1' on error.

     For examples of 'Method' object calls, *Note methodObjectMessage::.

'__ctalkMethodReturnClass (char *CLASSNAME)'
     Set the return class of an instance or class method during method
     initialization.

'__ctalkNArgs (void)'
     Returns an 'int' with the number of arguments passed to the current
     method.

'__ctalkNMatches (void)'
     Returns an 'int' with the number of matches from the last call to
     __ctalkMatchText.

'__ctalkNewFTFace (void)'
     Initialize a new FreeType2 face object.  This is a lower level
     library function that apps should not need to use directly, and may
     go away in the future.

'__ctalkNewSignalEventInternal (int SIGNO, int PID, char *DATA)'
     Generate and queue a 'SignalEvent' object for signal SIGNO with
     process ID PID.  The DATA argument is a 'String' object that the
     program can use to pass information back to the application.

'__ctalkNonLocalArgBlkReturn (void)'
     Returns a 'bool' value of true or false to an argument block's
     parent method to indicate whether the argument block executed a
     'return' statement.

'__ctalkObjValPtr (OBJECT *O, void *PTR)'
     Set the value of the object O to PTR.

'__ctalkPeekExceptionTrace (void)'
     Returns a 'char *' with the text of the most recent exception and
     its stack trace.

'__ctalkPeekRunTimeException (void)'
     Returns a 'char *' with the text of the most recent exception.

'__ctalkPendingException (void)'
     A convenience method for '__ctalkTrapException.' Returns 'TRUE' if
     an exception is pending, 'FALSE' otherwise.

'__ctalkPrintExceptionTrace (void)'
     Print a walkback of the current exception's copy of the program
     call stack.

'__ctalkPrintObject (OBJECT *OBJECT)'
     Print the object given by the argument, and its instance variables,
     to standard output.

'__ctalkPrintObjectByName (OBJECT *OBJECT_NAME)'
     Print the object named by OBJECT_NAME to the standard output.

'__ctalkProcessWait (int CHILD_PROCESSID, int *CHILD_RETURN_VALUE_OUT, int *CHILD_TERM_SIG_OUT, int *ERRNO_OUT)'
     Checks the status of the child process specified by
     CHILD_PROCESSID.

     If the return value of '__ctalkProcessWait' is 0, then there is no
     change in the child processes' status to report.  A return value
     equal to CHILD_PROCESSID indicates that the child process has
     exited.  If the return value is -1, then there was an error either
     in the process that called '__ctalkProcessWait', the child process,
     or both.

     When '__ctalkProcessWait's' return value is equal to
     CHILD_PROCESSID, the function returns the child processes' return
     value in CHILD_RETURN_VALUE_OUT.  If the child process was
     terminated by an uncaught signal, the signal number is returned in
     CHILD_TERM_SIG_OUT.

     If the function's return value is -1, then function returns the
     system's error code in ERRNO_OUT.

'__ctalkRaiseX11Window (OBJECT *X11PANE_OBJECT)'
     The X library interface of the 'raise' (class 'X11Pane') method.

'__ctalkReceiverReceiverBecome (OBJECT *OBJECT)'
     Used by 'become' (class 'Object') to change the calling method's
     receiver to the object given as the argument.

'__ctalkReferenceObject (OBJECT *OBJ, OBJECT *REFFED_OBJ)'
     Sets OBJ'S value to REFFED_OBJ'S hexadecimal address.  Also
     incrememts REFFED_OBJ'S reference count by 1 and adds
     VAR_REF_OBJECT to its scope.

'__ctalkRegisterArgBlkReturn (int RETURN_CODE, OBJECT *RETURN_OBJECT)'
     This function gets called when Ctalk encounters a return statement
     in an argument block.  The first argument is the return code of the
     argument block itself (typically an 'Integer' object with a value
     of -2, which signals the 'map' method that the argument block has
     requested a return from the parent function or method), and the
     second argument is the object that is to be returned by the caller.

     The following example should hopefully explain how these functions
     work together.  The comments indicate where the compiler inserted
     these functions.


          int main () {
            String new str;

            str = "Hello, world!";

            str map {
              if (self == 'o') {
                break;
              }
              printf ("%c", self);
            }
            printf ("\n");

            str map {
              switch (self)
                {
                case 'a':
                case 'e':
                case 'i':
                case 'o':
                case 'u':
          	if (self == 'o') {
          	  printf ("\n");
          	  return 11;          /* __ctalkRegisterArgBlkReturn inserted   */
          	}                    /* here.  The String map method, which is */
          	break;                /* the argument block's direct caller,    */
                }                      /* contains a __ctalkArgBlkSetCallerReturn*/
              (Character *)self -= 32;  /* function call.                         */
              printf ("%c", self);
            }
            printf ("\n");
          }


          /* After the argument block call, the compiler inserts a
             construct like the following:

              if (__ctalkNonLocalArgBlkReturn ()) {
                  return __ctalkToCInteger (__ctalkArgBlkReturnVal (), 1);
              }

            This retrieves the argument block's return value if any,
            and returns from the calling function.
          */

     The 'String : map' method contains an example of how an argument
     block can signal a return from the function or method that called
     it.  Refer also to the '__ctalkArgBlkSetCallerReturn' and
     '__ctalkArgBlkClearCallerReturn' functions above.

'__ctalkRegisterBoolReturn (int T-OR-F-ARG)'
     Returns a boolean object with a true or false value depending on
     the value of T-OR-F-ARG.  If the Boolean class variables 'boolTrue'
     or 'boolFalse' are defined, returns one of those objects.
     Otherwise, creates a 'Boolean' object with the value true or false.

'__ctalkRegisterCharPtrReturn (char *VAR)'
     Saves a C 'char *' method return value to the method's resource
     pool.

'__ctalkRegisterCharPtrReturn (char VAR)'
     Saves a C 'char' method return value to the method's resource pool.

'(char *TYPE, char *QUALIFIER, char *QUALIFIER2, char *QUALIFIER3, char *QUALIFIER4, char *STORAGE_CLASS, char *NAME, int N_DEREFS, int ATTRS, int IS_UNSIGNED, int SCOPE)'
     Register a C typedef with an application.  This function is
     typically used by '__ctalk_init' to register typedefs defined in C
     include files and elsewhere.

'__ctalkRegisterExtraObject (OBJECT *CREATED_OBJECT)'
     Save an object retrieved by a function so it may be referred to
     later.  This function registers each object only once and does not
     adjust the object's reference count or scope.  The
     '__ctalkRegisterExtraObject' function silently ignores request to
     register global and class objects.  Refer to the entry for
     '__ctalkRegisterUserObject,' below.

'__ctalkRegisterFloatReturn (double d)'
     Registers a C 'double' return value as a 'Float' method resource
     object.  Note that the C libraries do not automatically convert C
     'floats' to 'doubles', so if you register a C 'float' as a method
     resource, you need to cast it to a 'double' first.

'__ctalkRegisterIntReturn (int RETURNVAL)'
     Registers a C 'int' method return value as an 'Integer' method
     resource object.

'__ctalkRegisterIntReturn (long long int RETURNVAL)'
     Registers a C 'long long int' method return value as a
     'LongInteger' method resource.

'__ctalkRegisterUserFunctionName (char *NAME)'
     Registers the names of C functions in the program, mainly for
     diagnostic messages.  This function is added automatically to
     '__ctalk_init' whenever a C function in the source code is parsed
     and is called at the start of a program.

'__ctalkRegisterUserObject (OBJECT *CREATED_OBJECT)'
     Save objects created by a method so they may be referred to later.
     New objects registered by this function have a reference count of
     1, and have the additional scope 'METHOD_USER_OBJECT'.  This
     function is also used by many of the 'methodReturn*' macros, and if
     necessary you can included it in a method if you need to register
     an object in some non-standard manner.  *Note Returning method
     values::.

     Note that global objects and class objects do not need to be
     registered.  In fact, registering such objects as method resources
     can confuse the object's entries in their respective dictionaries,
     because method resources have a separate dictionary of their own.
     If a method tries to register a class object or global object,
     '__ctalkRegisterUserObject' silently ignores the request.

'__ctalkReplaceVarEntry (VARENTRY *VARENTRY, OBJECT *NEW_OBJECT)'
     This function has been superceded.  If you want to attach an Object
     to another tag, it's only necessary to use an assignment statement.
     See '__ctalkAliasReceiver ()' for an example

'__ctalkRtGetMethod (void)'
     Returns the currently executing method as a 'METHOD *' from the
     call stack, or NULL if called from within a C function.

'__ctalkRtReceiver (OBJECT *RECEIVER_OBJECT)'
     Sets the call stack's receiver to RECEIVER_OBJECT.  The function
     however, does not alter the currently executing method's receiver
     on the receiver stack.

'__ctalkRtReceiverObject (void)'
     Returns the currently executing method's receiver object from the
     call stack.

'__ctalkRtSaveSourceFileName (char *FN)'
     Called during the initialization of a function or method to store
     the name of its source file.

'__ctalkRtGetMethodFn (void)'
     Returns the C function pointer (an 'OBJECT *(*)()' of the currently
     executing method, or NULL if called from within a C function.

'__ctalkRtMethodClass (OBJECT *CLASS_OBJECT)'
     Sets the class object of the currently executing method to
     CLASS_OBJECT.

'(OBJECT *CLASS_OBJECT)'
     Returns the class object of the currently executing method.

'__ctalkSearchBuffer (char *PATTERN, char *BUFFER, long long *OFFSETS)'
     Finds all occurrences of PATTERN in BUFFER, and returns the
     positions of the matches in OFFSETS, terminated by -1.

'__ctalkSelectXFontFace (void *DISPLAY, int DRAWABLE_ID, int GC_PTR, int FACE)'
     Selects the typeface of the currently selected font, if available,
     which should have been loaded with a call like
     '__ctalkX11UseFontBasic', or the equivalent calls for FreeType
     fonts.

     The argument, FACE, may be one of the following.


          X_FACE_REGULAR
          X_FACE_BOLD
          X_FACE_ITALIC
          X_FACE_BOLD_ITALIC


     Because these functions use shared memory to manage each X
     typeface's metrics, it is generally necessary to call this function
     after calling '__ctalkOpenX11InputClient' in order to display
     multiple faces with the correct character spacing.

'__ctalkSelfPrintOn (void)'
     Print the calling method's arguments to the receiver.  This
     function is called directly by 'printOn' (class 'String') and
     similar methods.  *Note String::.

'__ctalkSetExceptionTrace (int VAL)'
     Enable or disable exception method traces in 'handle' (class
     'Exception') and other methods.  *Note Exception::.

'__ctalkSetObjectName (OBJECT *OBJECT, char *NAME)'
     Sets the name of OBJECT to NAME.

'__ctalkSetObjectScope (OBJECT *OBJECT, int SCOPE)'
     Set the scope of OBJECT to SCOPE.  Note that many of Ctalk's scopes
     are only used internally.  The scopes that are useful in methods
     are defined in 'ctalkdefs.h'.  Those definitions are listed here
     along with their values.  *Note Scoping::.


          GLOBAL_VAR          (1 << 0)
          LOCAL_VAR           (1 << 1)
          CREATED_PARAM       (1 << 6)
          CVAR_VAR_ALIAS_COPY (1 << 7)
          VAR_REF_OBJECT      (1 << 9)
          METHOD_USER_OBJECT  (1 << 10)


'__ctalkSetObjectValue (OBJECT *OBJECT, char *VALUE)'
     This is a wrapper for '__ctalkSetObjectValueVar ()', below, which
     was used in earlier versions of the class libraries.  You should
     use '__ctalkSetObjectValueVar ()' instead.

'__ctalkSetObjectValueAddr (OBJECT *OBJECT, void *MEM_ADDR, int DATA_LENGTH)'
     Set OBJECT'S value to a pointer to the memory area MEM_ADDR.  The
     object must be a member of Vector class or one of its subclasses.
     The function also sets the object 'length' instance variable, and
     adds OBJECT_VALUE_IS_MEMORY_VECTOR to its attributes, and registers
     the vector * address.

'__ctalkSetObjectValueBuf (OBJECT *OBJECT, char *BUF)'
     Set the 'value' instance variable to the buffer BUF.  Unlike
     '__ctalkSetObjectValue ()' and '__ctalkSetObjectValueVar (),' this
     function replaces the value of OBJECT with BUF, even if BUF is
     empty, so you can add a random-length buffer to OBJECT.

'__ctalkSetObjectValueVar (OBJECT *OBJECT, char *VALUE)'
     Set the value of OBJECT to VALUE.  If VALUE is 'NULL', sets
     OBJECT's value to Ctalk's '(null)' string.

'__ctalkSetObjPtr (OBJECT *OBJECT, void *P)'
     Save the pointer P in OBJECT.

'__ctalkSetRS (char RECORD_SEPARATOR_CHAR)'
     Set's the current program's record separator character, which
     determines, among other things, how regular expression
     metacharacters work with line endings.  *Note RecordSeparator::.

'__ctalkSignalHandlerBasic (int SIGNO)'
     Provides a basic signal handler that is more robust than the
     methods in 'SignalHandler' class, but less flexible.  Causes the
     application to terminate and print a walkback trace if enabled.

     Applications can use '__ctalkInstallHandler ()' to install the
     signal handler.  In this case it works similarly to a method with a
     C calling protocol.  Here is the 'installExitHandlerBasic' method
     from 'Application' class.


          Application instanceMethod installExitHandlerBasic (void) {
            __ctalkInstallHandler
              (__ctalkSystemSignalNumber ("SIGINT"),
               (OBJECT *(*)())__ctalkSignalHandlerBasic);

            return NULL;
          }


'__ctalkSpawn (char *COMMAND, int RESTRICT_IO)'
     The '__ctalkSpawn' function launches the program named by COMMAND
     as a daemon process, and then returns to the parent program and
     continues execution of the parent.

     The function returns the process id of the child process.

     The daemon process runs as a true daemon - that is, without a
     controlling terminal, and without the standard input, output, or
     error channels.  All communication between the daemon and the
     parent program should take place with UNIX interprocess
     communication facilities.

     If RESTRICT_IO is non-zero, the program changes the daemon
     processes' working directory to '/' and sets its umask to '0'.

     Traditionally, a parent program exits immediately after spawning a
     daemon process.  But '__ctalkSpawn' maintains the session process -
     the process that handles the session and I/O initialization before
     it launches the daemon.  The session process stays active until the
     parent process exits and orphans it.  Then the session process
     exits also, leaving the daemon to run completely in the background
     until it is killed.  That means, while the parent program is
     running, there can be _three_ entries in the system's process
     table, when viewed with a program like 'ps' or 'top'.  However, it
     also mimimizes the possibility of causing zombie processes should
     any part of the program quit unexpectedly.

     You should note that '__ctalkSpawn' does not use a shell or any
     shell facilities to exec the daemon process, which means the
     function doesn't support I/O redirection or globbing.  If you want
     the parent process to handle the child processes' I/O, refer to the
     '__ctalkExec' function.  *Note ctalkExec::.

'__ctalkStringifyName (OBJECT *SRC, OBJECT *DEST)'
     When called by a function like 'String' : '=', performs some
     munging of different types of 'String' objects in order to keep the
     API consistent for different types of 'String' objects.

'__ctalkSplitText (char *TEXT, OBJECT *LIST_OUT)'
     Splits a text buffer into word tokens, and returns the tokens as
     members of LIST_OUT.  This function preserves newlines and spaces,
     and places HTML-style format tags in their own tokens.  This is
     used by classes like 'X11TextPane' to split its text buffer before
     displaying the wrapped text.  *Note X11TextPane::.

'__ctalkStrToPtr (char *S)'
     If S is a C string formatted as a hexadecimal number with the
     format '0x'NNNNNNN, return a C 'void *' pointer with that address.

'__ctalkSysErrExceptionInternal (MESSAGE *ORIG, int ERRNO, char *TEXT)'
     Generates an exception base on ERRNO with the text TEXT.  Ctalk
     translates ERRNO in an exception that represents the C library's
     'errno' error definitions.  The ORIG argument provides the line and
     column number where the exception occurred.  If NULL, the exception
     doesn't record the line and column information.

'__ctalkSystemSignalName (int SIGNO)'
     Returns a string containing a mnemonic name like 'SIGINT' or
     'SIGHUP' that corresponds to SIGNO.  Includes the mnemonics of the
     common signals defined by POSIX standards.

'__ctalkSymbolReferenceByName (OBJECT *OBJECT)'
     Used in 'Symbol : =' and similar methods returns a boolean value of
     'true' if the object (the argument to the method normally) was
     retrieved by its name, or false if the argument is the result of
     pointer math or indirection.  This allows the method to determine
     whether it needs to perform additional indirection or pointer math
     on the argument before assigning it the the receiver.

'__ctalkSystemSignalNumber (char *SIGNAME)'
     For a signal named SIGNAME, return the number system-dependent
     number of the signal.  The function defines names POSIX 1990
     signals on most systems.  Refer to the system's 'signal(2)' (or
     similar) manual page for information.

'__ctalkTemplateCallerCVARCleanup (void)'
     Cleans up after a '__ctalkGetTemplateCallerCVAR' call.  *Note
     __ctalkGetTemplateCallerCVAR::.  Ctalk calls this function
     internally; you should not need to use it in your own programs.

     Note that this function does not know about parameter substitution.
     If you want to print an object that is an argument to a method, use
     the 'ARG(N)' macro, and reference the 'name' member.  *Note ARG
     macro::.
          __ctalkPrintObject(ARG(0)->__o_name);

'__ctalkTerminalHeight (void)'
'__ctalkTerminalWidth (void)'
     Returns the height and width of the terminal in character rows and
     columns.  If the terminal does not support reporting its size,
     these functions return 0.

'__ctalkToCArrayElement (OBJECT *O)'
     Translate the value of an 'Integer,' 'Character,' 'String,' or
     'LongInteger' array element to a 'void *' that points to its
     corresponding C data type.

'__ctalkToCCharPtr (OBJECT *OBJ, int KEEP)'
     Returns the value of OBJ as a C 'char *'.  If KEEP is zero, deletes
     OBJ if possible.

'__ctalkToCDouble (OBJECT *OBJ)'
     Returns the value of OBJ as a C 'double'.

'__ctalkToCIntArrayElement (OBJECT *OBJ)'
     Returns the value of OBJ as a C 'int'.  This function has mostly
     been superceded by '__ctalkToCInteger' (below).

'__ctalkToCInteger (OBJECT *OBJ)'
     Returns the value of OBJ as a C 'int'.  The value can be a binary,
     octal, decimal, or hexadecimal number.  Prints a warning message if
     the value is not a valid number or is out of range.

'__ctalkTrapException (void)'
     If there is a run-time exception pending, returns the first
     exception in Ctalk's internal format.  Otherwise, returns NULL.

'__ctalkTrapExceptionInternal (void)'
     Similar to '__ctalkTrapException', except that it works with the
     passes in the compiler as well as the run time library.

'__ctalkObjectPrintOn (OBJECT *OBJECT)'
     Print the calling method's arguments to the argument's 'value'
     instance variable.  This function is called directly by 'printOn'
     (class 'ANSITerminalStream') and similar methods.  *Note
     ANSITerminalStream::.

'__ctalkOpenX11InputClient (OBJECT *X11TERMINALSTREAM_OBJECT)'
     Start a GUI program's input client in the background.  The input
     client receives input events, like mouse motion and keypresses, and
     window events, like resize notifications from the X display server,
     and sends the information to the application program so that it can
     queue 'InputEvent' objects which the app can then process.

     The argument is a 'X11TerminalStream' object, which is normally
     created with a 'X11Pane' object, and which programs can refer to by
     the 'X11Pane' object's 'inputStream' instance variable.

     This is the lower-level function that the 'openEventStream' (class
     'X11Pane') method uses to begin communicating with the X display
     server.  For an example, refer to the 'X11TerminalStream' section.
     *Note X11TerminalStream::.

'__ctalkUNIXSocketOpenReader (char *SOCKETPATH)'
     Opens a UNIX domain socket, binds the socket to the path given by
     SOCKETPATH, and places the socket in listening mode.

     Returns the file descriptor of the new socket on success, or -1 if
     an error occured, in which case the C library sets the variable
     'errno'.

'__ctalkUNIXSocketOpenWriter (char *SOCKETPATH)'
     Opens a UNIX domain socket and connects to the socket given by
     SOCKETPATH.

     Returns the file descriptor of the new socket on success, or -1 if
     an error occurs, in which case the C library sets the variable
     'errno'.

'__ctalkUNIXSocketRead (int SOCKFD, void * BUF_OUT)'
     Reads data from the socket given by SOCKFD.  On success, returns
     the data read in BUF_OUT and the return value is the number of
     bytes read.  On error returns -1 and the C library sets the
     variable ERRNO.

'__ctalkUNIXSocketShutdown (int SOCKFD, int HOW)'
     This function is a wrapper for the C library's 'shutdown' function.
     Shuts down the socket identified by the SOCKFD argument.  The
     second argument, HOW, can be either 'SHUT_RD, SHUT_WR, or SHUT_RW.'
     These constants are defined in 'UNIXNetworkStream' class and
     described in the 'shutdown(1)' manual page.

     The function returns 0 on success, or -1 if an error occurred.

'__ctalkUNIXSocketWrite (int SOCKFD, void * DATA, int LENGTH)'
     Writes LENGTH bytes of DATA to the socket given by SOCKFD.

     On success returns the number of bytes written, or returns -1 on
     error, in which case the C library sets the variable 'errno'.

'__ctalkUTCTime (void)'
     Returns an 'int' with the system's UTC time.  This function is
     currently a wrapper for the 'time(2)' function.  Because
     'time(2)''s argument is an 'int *', it can often be more reliable
     to use '__ctalkUTCTime' and let the library worry about the
     argument's storage.  There is also a template for 'time(2)' if you
     want to use the function directly in complex expressions.

'__ctalkWarning (char *FMT, ...)'
     Prints a formatted message to the terminal.  Unlike '_warning' and
     other functions, does not add line numbers or input file
     information to the output.

'__ctalkWrapText (unsigned int DRAWABLE, unsigned int GC_PTR, OBJECT *TEXT_LIST, int PANE_WIDTH, int LMARGIN)'
     Formats the text in TEXT_LIST to be displayed between LMARGIN and
     PANE_WIDTH (the right edge of the drawing surface given as the
     first argument..  The TEXT_LIST list should have been generated by
     '__ctalkSplitText'.  The '__ctalkWrapText' function uses the
     current typeface to determine character widths.  If no font or
     typeface is selected, uses the default font, "fixed" to format the
     text.

'__ctalkX11CloseClient (OBJECT *PANE_OBJECT)'
     Closes the main program's connection to the X11 client and exits
     the client process.

'__ctalkX11CloseParentPane (OBJECT *PANE_OBJECT)'
     Closes and deletes an application's main X11 window, and its
     buffers and other data.  Does not delete subpanes - see
     __ctalkCloseX11Pane () (above) to delete subpanes.  Applications
     should delete subpanes before closing and deleting the main window.
     For an example of the functions' use, refer to the method 'X11Pane
     : deleteAndClose'.  *Note X11Pane::.

'__ctalkX11ClearRectangleBasic (void *DISPLAY, int VISUAL_ID, int GC_PTR, int X, int Y, int WIDTH, int HEIGHT)'
     Clear a rectangle of a visual type like a pixmap to the background
     color.

'__ctalkX11Colormap (void)'
     Returns the X resource ID of the display's default colormap.  It's
     contained in a library function because the X headers define some
     of the DefaultColormap's dependent macros after DefaultColormap,
     which is not compatible with the ctpp preprocessor.

'__ctalkX11CopyPixmapBasic (void *DISPLAY, int DEST_DRAWABLE_ID, int DEST_GC_PTR, int SRC_DRAWABLE_ID, int SRC_X_ORG, int SRC_Y_ORG, int SRC_WIDTH, int SRC_HEIGHT, int DEST_X_ORG, int DEST_Y_ORG)'
     Copies the drawable SRC_DRAWABLE_ID to DEST_DRAWABLE_ID, with the
     dimensions of the source graphic given by SRC_X_ORG, SRC_Y_ORG,
     SRC_WIDTH, and SRC_HEIGHT.  The image is drawn with its upper
     left-hand corner positioned at DEST_X_ORG, DEST_Y_ORG on the
     destination drawable.

     This function is called by 'X11CanvasPane' : 'copy'.  For an
     example, refer the 'X11CanvasPane' classes' description.  *Note
     X11CanvasPane::.

'__ctalkX11CreateGC (int DRAWABLE)'
     Create a X GC and return its address as a 'void *'.

'__ctalkX11CreatePixmap (void *DISPLAY, int X_DRAWABLE, int WIDTH, int HEIGHT, int DEPTH)'
     reate a X pixmap and return its X resource ID as an unsigned int.

'__ctalkX11CreatePaneBuffer (OBJECT *PANE_OBJECT, int WIDTH, int HEIGHT, int DEPTH)'
     Create the buffers for a pane object's X window.  Applications
     normally call this function when the pane object is created or when
     a subpane is attached to a parent pane.  This function sets the
     PANE_OBJECT'S 'paneBuffer' and 'paneBackingStore' instance
     variables.

'__ctalkX11DeletePixmap (int DRAWABLE_ID)'
     Delete the server-side pixmap whose ID is given as the argument.

'__ctalkX11Display (void)'
     Return a pointer to the X display, opening the display if
     necessary.

'__ctalkX11DisplayHeight (void)'
     Returns an 'int' with the display's height in pixels.

'__ctalkX11DisplayWidth (void)'
     Returns an 'int' with the display's width in pixels.

'__ctalkX11FontCursor (OBJECT *CURSOR_OBJECT, int CURSOR_ID)'
     Set CURSOR_OBJECT's value to a X11 CURSOR_ID.  Cursor ID's are
     defined by the X server in the include file 'X11/cursorfont.h'.
     *Note X11Cursor::.

'__ctalkX11FreeGC (int GC_ADDR)'
     Free the X11 graphics context pointed to by GC_ADDR.  The address
     of the GC is given as an 'int' which does not require any special
     handling by methods; the library function casts GC_ADDR to a 'GC
     *'.

'__ctalkX11FreePaneBuffer (OBJECT *PANE_OBJECT)'
     Release the server-side buffers used by PANE_OBJECT.  Note that
     this function is being phased out; programs should use
     '__ctalkX11DeletePixmap', which does not rely on hard-coded
     instance variable names.

'__ctalkX11FreeSizeHints (void)'
     Frees the data allocated by '__ctalkX11SetSizeHints ()', below.

'__ctalkX11GetSizeHints (int WIN_ID, int *X_ORG_RETURN, int *Y_ORG_RETURN, int *WIDTH_RETURN, int *HEIGHT_RETURN, int *WIN_GRAVITY_RETURN, int *FLAGS_RETURN)'
     Get the actual size and placement of the window, as reported by the
     X server, after the window is created, normally with
     '__ctalkCreateX11MainWindow ()'.

'__ctalkX11InputClient (OBJECT *STREAMOBJECT int FD)'
     The 'X11TerminalStream' input client.  This function is not used
     directly by any method but is a process of the
     '__ctalkOpenX11InputClient' function, above.

'__ctalkX11MakeEvent (OBJECT *EVENTOBJECT_VALUE_VAR, OBJECT *inputqueue)'
     Encapsulates much of the function of the 'X11TerminalStream :
     queueInput' method: receives the data for an X event from the X11
     input client and saves it in an 'InputEvent' object, then queues
     the 'InputEvent' object in the 'X11TerminalStream''s 'inputQueue'.

'__ctalkX11MoveWindow (OBJECT *PANE_OBJECT, int X, int Y)'
     Move PANE_OBJECT's window so that its origin is at X,Y.

'__ctalkX11OpenInputClient (OBJECT *STREAMOBJECT)'
     The library interface of the 'X11TerminalStream' class's input
     client.  This function is called by 'openInputClient' (class
     'X11TerminalStream').  The STREAMOBJECT argument is a
     'X11TerminalStream' object, generally the stream created by 'new'
     (class 'X11Pane').  *Note X11TerminalStream::.

'__ctalkX11ParseGeometry (char *GEOMSTRING, int* X, int* Y, int* Y, int* WIDTH, int* HEIGHT)'
     Parses a X11 geometry string and returns the values specified in
     the X, Y, WIDTH, or HEIGHT variables.  If the geometry string does
     not specify one of these values, sets the corresponding variable to
     zero.

     For information about the format of a X11 geometry specification,
     refer to the 'XParseGeometry(3)' manual page.

'__ctalkX11PaneDrawCircleBasic (void *DISPLAY, int WINDOW_ID, int GC, int CENTER_X, int CENTER_Y, int RADIUS, int FILL, int PEN_WIDTH, int ALPHA, char *FG_COLOR_NAME, char * BG_COLOR_NAME)'
     Draws a circle centered at CENTER_X,CENTER_Y with radius RADIUS.
     The dimensions are given in pixels.  If FILLED is true, then the
     function draws a filled circle; otherwise, the circle's edge has
     the width PEN_WIDTH.

     This function is a synonym for '__ctalkGUIPaneDrawCircleBasic'.

'__ctalkX11PanePutStr (OBJECT *PANE_OBJECT, int X, int Y, char *STR)'
     Displays STR at window coordinates X,Y on PANE_OBJECT's drawable in
     the pane's current font.  If 'pane_object' is buffered, writes the
     string to the pane's buffers, and the string is displayed at the
     next 'refresh' method call.

     Note that this method is slowly being superceded because it relies
     on instance variable names that are defined in several class
     libraries.  If the application uses different drawables than
     PANE_OBJECT's window surface or its buffers, use
     '__ctalkX11PanePutStrBasic' instead.

'__ctalkX11SetSizeHints (int X, int Y, intp WIDTH, int HEIGHT, int GEOM_FLAGS)'
     Set the window size hints based on the window dimensions set by the
     application.  The GEOM_FLAGS argument has the format provided by
     the '__ctalkX11ParseGeometry ()' function, above.  Normally this
     function is called by a 'X11Pane*' class when initializing a
     window.

     If an application calls this function, it must also call
     '__ctalkX11FreeSizeHints ()', above.

'__ctalkX11ResizePaneBuffer (OBJECT *PANE_OBJECT, int WIDTH, int HEIGHT)'
     Resize PANE_OBJECT's buffers to width WIDTH and height HEIGHT.  New
     programs should use '__ctalkX11ResizePixmap', which does not rely
     on hard-coded instance variable names.

'__ctalkX11ResizePixmap (void *DISPLAY, int, PARENT_DRAWABLE_ID, int SELF_XID, int GC, int OLD_WIDTH, int OLD_HEIGHT, int NEW_WIDTH, int NEW_HEIGHT, int DEPTH, int *NEW_PIXMAP_RETURN)'
     Create a new Pixmap with the dimensions NEW_WIDTH and NEW_HEIGHT
     that contains the contents of the original pixmap.  Returns the X
     ID of the new pixmap in NEW_PIXMAP_RETURN.

'__ctalkX11ResizeWindow (OBJECT *PANE_OBJECT, int WIDTH, int HEIGHT, int DEPTH)'
     Resize a pane object's X window.  Returns '1' on success, '0' if
     the window's new size is <= its current size, and '-1' if there is
     an error.

'__ctalkX11PaneClearRectangle (OBJECT *PANE_OBJECT, int X, int Y, int WIDTH, int HEIGHT)'
     Clears a rectangle in PANE_OBJECT's window.  Note that this
     function is deprecated - it relies on the Pane object having
     specific instance variables.  New programs should use
     '__ctalkX11PaneClearRectangleBasic' instead.

'__ctalkX11PaneDrawLine (OBJECT *PANE_OBJECT, OBJECT *LINE_OBJECT, OBJECT *PEN_OBJECT)'
     Draw a line on the drawable identified by PANE_OBJECT *Note
     X11Pane::, with the endpoints given by LINE_OBJECT *Note Line::,
     with the line width and color defined in PEN_OBJECT *Note Pen::.
     This function is a synonym for '__ctalkGUIPaneDrawLine' on systems
     with a X Window System display.

'__ctalkX11PaneDrawLineBasic (int DRAWABLE_ID, int GC_PTR, int X_START, int Y_START, int X_END, int Y_END, int PEN_WIDTH, int ALPHA, char *PEN_COLOR)'
     Draw a line between the points (x_start,y_start) and (x_end, y_end)
     with the color, and transparency using the drawable ID, graphics
     context, and pen color, width, and transparency given as arguments.

'__ctalkX11PaneDrawPoint (OBJECT *PANE_OBJECT, OBJECT *point_object, OBJECT *PEN_OBJECT)'
     Draw a point on the drawable id given in PANE_OBJECT *Note
     X11Pane::, with the location given by POINT_OBJECT *Note Point::,
     with the radius and color given by PEN_OBJECT *Note Pen::.  This
     function is a synonym for '__ctalkGUIPaneDrawPoint' on systems that
     use the X Window system.

'__ctalkX11PaneDrawPointBasic (void *DISPLAY, int DRAWABLE_ID, int GC_PTR, int X, int Y, int PEN_WIDTH, int ALPHA, char *PEN_COLOR)'
     Draw a point of the size, position, color, and transparency using
     the drawable ID, graphics context, and Pen color, transparency, and
     width given as arguments.

'__ctalkX11PaneClearWindow (OBJECT *PANE_OBJECT)'
     Clears PANE_OBJECT's window.  Note that this function is deprecated
     - it relies on the Pane object having specific instance variables.
     New programs should use

'__ctalkX11PaneDrawRectangle (OBJECT *PANE_OBJECT, OBJECT *RECTANGLE_OBJECT, OBJECT *PEN_OBJECT, Integer FILL)'
     Draw a rectangle on the drawable identified by PANE_OBJECT *Note
     X11Pane::, with the dimensions given by RECTANGLE_OBJECT *Note
     Rectangle::, and with the line width and color given by PEN_OBJECT
     *Note Pen::.  If FILL is true, draw a filled rectangle.

'__ctalkX11PanePutStrBasic (void *DISPLAY, int VISUAL_ID,int GC_PTR, int X, int Y, char *TEXT)'
     Write the string TEXT on the drawable named by VISUAL_ID at X,Y
     using the graphics context pointed to by GC_PTR.  If the drawable
     is a 'X11CanvasPane' buffer, the text will not be visible until the
     next call to the pane's 'refresh' method.

'__ctalkX11PaneRefresh (OBJECT *PANE_OBJECT, int SRC_X_ORG, int SRC_Y_ORG, int SRC_WIDTH, int SRC_HEIGHT, int DEST_X_ORG, int DEST_Y_ORG)'
     If PANE_OBJECT is a buffered pane, copy the contents of the pane
     buffer(s) within the rectangle given by SRC_X_ORG, SRC_Y_ORG,
     SRC_WIDTH, SRC_HEIGHT to the visible window at DEST_X, DEST_Y.

'__ctalkX11QueryFont (OBJECT *FONT_OBJECT, char *XLFD)'
     Fills in FONT_OBJECT's 'ascent', 'descent', 'maxWidth', 'height',
     and 'fontDesc' instance variables with the font metrics returned by
     the X server for the font given by XLFD.

'__ctalkX11SetBackground (OBJECT *PANE_OBJECT, char *COLOR_NAME)'
     Set PANE_OBJECT's background color to COLOR_NAME.  This function is
     being phased out because it uses named instance variables of
     PANE_OBJECT.  Programs should use '__ctalkX11SetBackgroundBasic
     ()', below, instead.

'__ctalkX11SetBackgroundBasic (void *DISPLAY, int visual_xid, int GC_PTR, char *COLOR)'
     Sets the background color of any class with a X11 visual and
     graphics context.

'__ctalkX11SetForegroundBasic (void *DISPLAY, int visual_xid, int GC_PTR, char *COLOR)'
     Sets the foreground color of any class with a X11 drawable and
     graphics context.

'__ctalkX11SetResource (void *DISPLAY, int DRAWABLE_ID, char *RESOURCE_NAME, char *RESOURCE_VALUE)'
     Sets the X11 resource RESOURCE_NAME to RESOURCE_VALUE for the
     drawable identified by DRAWABLE_ID.

'__ctalkX11SetWMNameProp (OBJECT *PANE_OBJECT, char *NAME)'
     Sets the WMName property PANE_OBJECT's window to NAME.  This is the
     window property that window managers use to set the window frame's
     title.

'__ctalkX11UseCursor (OBJECT *PANE_OBJECT, OBJECT *CURSOR_OBJECT)'
     Sets the X11 cursor of PANE_OBJECT to CURSOR_OBJECT.  *Note
     X11Cursor::.

'__ctalkX11UseXRender (bool B)'
     If B is true, draw using the X Render entension if it is available.
     If B is false, use Xlib for drawing even if X Render is available.

'__ctalkX11UseFontBasic (void *DISPLAY, int DRAWABLE_ID, int GC_PTR, char *FONT_DESC)'
     Sets the font of the graphics context GC_PTR and drawable
     DRAWABLE_ID for further string printing operations.  See use in
     'X11Bitmap' class, where the GC pointer, which is an opaque object,
     is encoded as an 'int', in order to avoid confusion with 'OBJECT
     *'s'.

'__ctalkX11UsingXRender (void)'
     Returns a boolean value of True if the program is using the X
     Render extension for drawing, False otherwise.  To use the X Render
     extension, the extension and its supporting libraries must be
     available when the Ctalk libraries are built, and the program has
     not changed the default setting, normally via
     '__ctalkX11UseRender', above.

'__ctalkX11XPMFromData (void *DISPLAY, int DRAWABLE_ID, int GC_PTR, int X_ORG, int Y_ORG, char **XPM_DATA)'
     Draw a X pixmap at the x,y position on the drawable named by
     DRAWABLE_ID.  The XPM_DATA argument is the declaration of the data
     given in a XPM file, and has the C data type 'char **'.

'__ctalkX11XPMInfo (void *DISPLAY, char **XPM_DATA, int *WIDTH_RET, int *HEIGHT_RET, int *N_COLORS_RET, int *CHARS_PER_COLOR_RET)'
     Returns the width, height, number of colors, and characters per
     color of the XPM data referred to by XPM_DATA

'__ctalkXPMToGLTexture (char **XPM_DATA, unsigned short int ALPHA, int *WIDTH_OUT, int *HEIGHT_OUT, void **TEXEL_DATA_OUT)'
'__ctalkXPMToGLXTexture (char **XPM_DATA, unsigned short int ALPHA, int *WIDTH_OUT, int *HEIGHT_OUT, void **TEXEL_DATA_OUT)'
     Read the XPM data pointed to by XPM_DATA, and return the OpenGL
     texture data pointed to by TEXEL_DATA_OUT.

     The ALPHA parameter defines the texture data transparency and
     should be in the range 0 - 0xffff.  The alpha channel's effect may
     not be apparent in the image that is displayed, because OpenGL has
     its own set of functions to perform texture blending.

     For Mesa OpenGL implementations, like those found on Linux systems,
     textures have the format GL_RGBA and the data type
     GL_UNSIGNED_INT_8_8_8_8.  To define a basic 2-dimensional texture
     to the OpenGL API, use an OpenGL function like this.


          glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, my_width, my_height, 0,
                        GL_RGBA, GL_UNSIGNED_INT_8_8_8_8, my_texel_data);


     Apple OpenGL implmentations use a different internal format, so a
     program would define a texture from the '__ctalkXPMToGLXTexture'
     function's output like this.


          glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, my_width, my_height, 0,
                        GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, my_texel_data);


     Note that the function does not make any changes for 1-dimensional
     or 3-dimensional textures, nor for textures that might be rendered
     as mipmaps.  The specific texture parameters depend on the nature
     of the texture and the surface that it's applied to...  in most
     cases, though OpenGL works best with a XPM that has a geometry that
     is an even multiple of 2; e.g., 512x512 or 1024x1024 pixels.

     Both functions are similar, and generic enough to work with any
     OpenGL toolkit - the main difference is that either of the
     functions can be implemented for either a GLUT or GLX development
     environemnt independently, and that the GLX version is compatible
     with 64-bit machines.

'__ctalkXftAscent (void)'
     Returns an 'int' with the currently selected font's height in
     pixels above the baseline.

'__ctalkXftAscent (void)'
     Returns an 'int' with the currently selected font's height in
     pixels below the baseline.

'__ctalkXftFgRed (void)'
'__ctalkXftFgGreen (void)'
'__ctalkXftFgBlue (void)'
'__ctalkXftFgAlpha (void)'
     Returns 'int' values 0-0xffff for the selected font's red, green,
     blue, and alpha values.

'__ctalkXftRed (unsigned short VAL)'
'__ctalkXftGreen (unsigned short VAL)'
'__ctalkXftBlue (unsigned short VAL)'
'__ctalkXftAlpha (unsigned short VAL)'
     Set the current Xft font's foreground color channels individually.
     The value of the argument must be between 0 and 65535 (0xffff hex).

'__ctalkXftFontPathFirst (char *PATTERN)'
     Return the path of the first font file that matches PATTERN.  If
     pattern is '*' or an empty string ('""'), return the first path of
     all the fonts that are available to the library.

'__ctalkXftFontPathNext (void)'
     Return a string containing the path of the next font file that
     matches the pattern given to '__ctalkXftFontPathFirst ()', above.

'__ctalkXftSelectedFontDescriptor (void)'
     Return the font descriptor of the selected font as a 'char *'.

'__ctalkXftGetStringDimensions (char *STR, int *X, int *Y, int *WIDTH, int *HEIGHT)'
     Return the x and y origin, and width and height of STR in the
     currently selected FreeType font.  Because the dimensions are
     absolute, X and Y are normally 0.  If the Xft library is not
     initialized or not available, the function returns 0 for all of the
     dimensions.

'__ctalkXftHeight (void)'
     Returns an 'int' with the font's height above and below the
     baseline in pixels, and including any additional vertical spacing.

'__ctalkXftInitLib (void)'
     Initializes the Freetype outline font library.  If the system is
     not configured to use outline fonts *Note X11FreeTypeFont::, then
     the function prints a message and exits the program.

'__ctalkXftInitialized (void)'
     Returns TRUE if the FreeType font library is available and
     initialized, FALSE otherwise.

'__ctalkXftListFontsFirst (char *XFTPATTERN)'
     Initializes the FreeType library to list fonts and returns a 'char
     *' that contains the first font descriptor that contains the string
     XFTPATTERN.  If XFTPATTERN is emtpy ('""') or '*', then the
     function returns the first font, and the following calls to
     '__ctalkXftListFontsNext ()' match all of the fonts available to
     the FreeType library.

'__ctalkXftListFontsNext (void)'
     Returns a 'char *' with the next matching font descriptor of a font
     listing initialized by '__ctalkXftListFontsFirst ()'.

'__ctalkXftListFontsNext (void)'
     Cleans up after a series of list fonts function calls.

'__ctalkXftMajorVersion (void)'
     Returns an 'int' with the Xft library's major version number.

'__ctalkXftMaxAdvance (void)'
     Returns an 'int' with the maximum horizontal dimension in pixels of
     any of the selected font's characters.

'__ctalkXftMinorVersion (void)'
     Returns an 'int' with the Xft library's minor version number.

'__ctalkXftQualifyFontName (char *PATTERN)'
     Return the qualified font name string for PATTERN.

'__ctalkXftRevision (void)'
     Returns an 'int' with the Xft library's revision number.

'__ctalkXftSelectedFamily (void)'
     Returns a 'char *' string that contains family of the selected
     font.

'__ctalkXftSelectedPointSize (void)'
     Return the point size of the selected font as a C DOUBLE.

'__ctalkXftSelectedSlant (void)'
     Returns an 'int' that contains slant of the selected font.

'__ctalkXftSelectedSlant (void)'
     Returns an 'int' that contains slant of the selected font.

'__ctalkXftSelectedFontDescriptor (void)'
     Returns a 'char *' string that contains the descriptor of the
     selected font.

'__ctalkXftSelectedFontDescriptor (void)'
     Returns a 'char *' string that contains the file path descriptor of
     the selected font.

'__ctalkXftSelectFont (char *FAMILY, int SLANT, int WEIGHT, int DPI, double POINT_SIZE)'
     Selects the FreeType font that matches the arguments.  Returns 0 if
     successful in matching the font given by the arguments.  If no
     matching font is found, the current font does not change, and the
     method returns -1.  The 'selectFont' method (class
     'X11FreeTypeFont' contains a description of the parameters
     recognized by the function.  *Note X11FreeTypeFont-selectFont::.

'__ctalkXftSelectFontFromXLFD (char *XLFD)'
     Selects fonts in the FreeType font library using a XLFD
     specification.  When selecting outline fonts: the libraries use the
     fields: family, weight, slant, dpi-x, and pixel height.  An example
     XLFD would be the following.


          -*-Nimbus Sans L-medium-r-*-*-12-72-*-*-*-*-*-*


     Note that the function does not translate between bitmap and
     outline font families - the font libraries pick the closest match
     to the font metrics given in the XLFD, regardless of type style.

     Also, the outline font libraries use a single dpi metric for both
     the vertical and horizontal resolution, so only the 'resx' field of
     the XLFD is actually used.

'__ctalkXftSetForegrounc (int RED, int GREEN, int BLUE, int ALPHA)'
     Sets the red, green, blue, and alpha values for the selected font.
     The values are 'ints' and have a range of 0-0xffff.

'__ctalkXftSetForegroundFromNamedColor (String COLORNAME)'
     Sets the selected outline font's red, green, and blue values from
     the named X11 color given as the argument.

'__ctalkXftVersion (void)'
     Returns an 'int' with the Xft library's version number, which is
     (__ctalkXftMajorVersion () * 10000) + (__ctalkXftMinorVersion *
     100) + __ctalkXftRevsion ().

'__ctalk_arg (char *RCVR, char *METHOD,void *ARG)'
     Define an argument for the following '__ctalk_method ()' call.

'__ctalk_arg_cleanup (OBJECT *RESULT)'
     Remove an argument used by the previous method call.  If used
     within an expression, then RESULT, the return object of the
     previous method call, may not be NULL. If used after a
     '__ctalk_method ()' call, then RESULT may be NULL.

'__ctalk_arg_internal (int N_TH_ARG)'
     Return the N_TH_ARG that method was called with, as an 'OBJECT *.'
     The first argument's index on the stack is 0 within the caller's
     argument frame, and the last argument is METHOD -> N_PARAMS - 1.

'__ctalk_arg_value_internal (int N_TH_ARG)'
     Return the value object of the N_TH_ARG that method was called
     with, as an 'OBJECT *,' if available.  If it isn't (for example, if
     the value instance variable is used as an argument alone, and not
     the parent object), then the function returns the argument object.

     As with '__ctalk_arg_internal (),' The first argument's index on
     the stack is 0 within the caller's argument frame, and the last
     argument is METHOD -> N_PARAMS - 1.

'__ctalk_arg_pop (void)'
'__ctalk_arg_pop_deref (void)'
     Removes and returns the last object pushed onto the argument stack.
     '__ctalk_arg_pop_deref' also decreases the object's reference count
     by one.

'__ctalk_class_initialize (void)'
     Called by __ctalk_init () to perform any neeeded initialization the
     before any classes are defined.

'__ctalk_define_class (ARG**ARGS)'
     The primitive method that Ctalk executes when it encounters the
     'class' keyword.

'__ctalk_dictionary_add (OBJECT*OBJECT)'
     Add an object to the Ctalk global dictionary, or, if the object is
     a class object, to the class library.

'__ctalk_exitFn (int APP_EXIT)'
     Called just before a 'return' statement when returning from a C
     function.  If the function is 'main', then APP_EXIT should be
     non-zero, to indicate that the program is finished, and to clean up
     the global objects and the class library.

'__ctalk_initFn (void)'
     Called at the beginning of a function to register the function's
     name.

'__ctalk_initLocalObjects (void)'
     Called during method or function initialization to delete old local
     objects before creating new objects.

'__ctalk_get_object (char *NAME, char *CLASSNAME)'
     Retrieves the object NAME.  If CLASSNAME is non-null, retrieves the
     object by name and class.

'__ctalk_init (char *PROGRAM_NAME)'
     Initialize the Ctalk class libraries when the program starts.  The
     argument, PROGRAM_NAME is normally 'argv[0]'.

'__ctalk_method (char *RCVR_OBJECT_NAME, OBJECT *(METHOD_FN *)(), char *METHOD_NAME)'
     Perform a simple Ctalk method call, in places where the call can be
     used after one or more calls to '__ctalk_arg' and followed by
     '__ctalk_arg_cleanup'.  For complex expressions or expressions
     occurring within control structures, Ctalk normally uses
     '__ctalkEvalExpr' instead.

'__ctalk_new_object (ARG **ARGS)'
     The primitive function that is called by the 'new' method.

'__ctalk_primitive_method (char *RCVR_NAME, char *METHOD_NAME, int ATTRS)'
     Call primitive method METHOD_NAME with receiver RCVR_NAME.  The
     ATTRS argument can be METHOD_SUPER_ATTR, which uses the receiver's
     superclass as the receiver redirects the method's arguments to a
     superclass method.

'__ctalk_process_exitFn (int APP_EXIT)'
     Similar to '__ctalk_exitFn', above, except that the function is
     meant to be invoked by child processes on exit, so it does not try
     to manage other child processes.

'__ctalk_receiver_pop (void)'
     Pops the most recent receiver object off the receiver stack and
     returns it.

'__ctalk_receiver_push (OBJECT *OBJECT)'
     Push OBJECT onto the receiver stack, without changing its reference
     count.  This can be useful in conjunction with
     '__ctalk_receiver_pop' to quickly retrieve the current receiver
     object.


           currentReceiver = __ctalk_receiver_pop ();
           __ctalk_receiver_push (currentReceiver);


'__ctalk_register_c_method_arg (char *DECL, char *TYPE, char *QUALIFIER, char *QUALIFIER2, char *STORAGE_CLASS, char *NAME, int TYPE_ATTRS, int N_DEREFS, int INITIALIZER_SIZE, int SCOPE, int ATTRS, void *VAR)'
     Registers a C variable for use as an argument in the following
     method call.  The arguments provide the information given by the
     variable's declaration so that it can be re-created by Ctalk.  The
     last parameter, VAR, contains the address of the actual C variable
     in memory.

     There are also abbreviated versions of
     '__ctalk_register_c_method_arg',
     __ctalk_register_c_method_arg_b|c|d, which work similarly but don't
     try to handle syntax elements that aren't present in the variable's
     declaration.

'__ctalk_self_internal (void)'
     Return the current method's receiver object as an 'OBJECT *'.

'__ctalk_self_internal (void)'
     Return the current method receiver's 'value' instance variable as
     an 'OBJECT *' if it exists, or the receiver object otherwise (for
     example, if the receiver is the 'value' instance variable itself
     instead of the parent object).

'__ctalk_set_global (char *NAME, char *CLASSNAME)'
     Adds the object NAME of class CLASSNAME to ctalk's global
     dictionary.  This function is normally called during program
     initialization.

'__ctalk_set_local (OBJECT *OBJ)'
'__ctalk_set_local_by_name (char *OBJ_NAME)'
     Make OBJ a method- or function-local object.  This function is
     normally called during a method or function's initialization when
     the local objects are created with a 'new' method.  The
     '__ctalk_set_local_by_name' function is similar, except that it
     retrieves the global object by looking up its name in the global
     dictionary.

'__ctalk_to_c_char (OBJECT *OBJ)'
     Returns the value of OBJ as a C 'char' if possible.  If the value
     is an ASCII code, converts the value to the actual 'char'.

'__ctalk_to_c_char_ptr (OBJECT *OBJ)'
     Returns the value of OBJ as a C 'char *'.  This function has been
     mostly replaced by '__ctalkToCCharPtr', which you should use
     instead.

'__ctalk_to_c_double (OBJECT *OBJ)'
     Returns the value of OBJ as a C 'double'.  This function performs
     the conversion with the C library function 'strtod'.  Currently
     only supports the translation of base 10 values.

'__ctalk_to_c_int (OBJECT *OBJ)'
     Returns the value of OBJ as a C 'int'.  This function handles
     values in hexadecimal, octal, using the C library function
     'strtol', and binary, using Ctalk's internal routines.  Also
     handles ASCII-to-char conversions if the argument is a 'Character'
     object.

'__ctalk_to_c_longlong (OBJECT *obj)'
     Returns the value of OBJ, which is normally an instance of
     'LongInteger' class, as a C 'long long int'.  This function uses
     the C library function 'strtoll' to perform the conversion.
     Currently only handles 'LongInteger' object values in base 10.

'__ctalk_to_c_ptr (OBJECT *O)'
     Translate the value of an object into a C 'void *.' If the value
     isn't a pointer, then return the address of the value in memory.

'__ctalk_to_c_ptr_u (OBJECT *O)'
     Translate the value of an object into a C 'void *.' This is an
     unbuffered verson of '__ctalk_to_c_ptr ()', above.  That is, if the
     value of the object is an empty string, '(NULL)', or '0x0', it
     returns 'NULL'.  This allows you to compare objects to 'NULLs' in C
     expressions without the generating compiler warnings.

     ('X11TextEditorPane' class)

'__edittext_delete_char (OBJECT *x11texteditorpane_object)'
'__edittext_insert_at_point (OBJECT *x11texteditorpane_object, int keycode, int shift_state, int keypress)'
'__edittext_line_end (OBJECT *x11texteditorpane_object)'
'__edittext_line_start (OBJECT *x11texteditorpane_object)'
'__edittext_xk_keysym (int KEYCODE, int SHIFT_STATE, int KEYPRESS)'
'__edittext_next_char (OBJECT *x11texteditorpane_object)'
'__edittext_next_line (OBJECT *x11texteditorpane_object)'
'__edittext_next_page (OBJECT *x11texteditorpane_object)'
'__edittext_prev_char (OBJECT *x11texteditorpane_object)'
'__edittext_prev_line (OBJECT *x11texteditorpane_object)'
'__edittext_prev_page (OBJECT *x11texteditorpane_object)'
'__edittext_scroll_down (OBJECT *x11texteditorpane_object)'
'__edittext_scroll_up (OBJECT *x11texteditorpane_object)'
'__edittext_text_start (OBJECT *x11texteditorpane_object)'
'__edittext_text_end (OBJECT *x11texteditorpane_object)'
'__edittext_point_to_click (OBJECT *x11texteditorpane_object, int pointer_x, int pointer_y)'
'__edittext_index_from_pointer (OBJECT *x11texteditorpane_object, int pointer_x, int pointer_y)'
'__edittext_insert_str_at_click (OBJECT *x11texteditorpane_object, int click_x, int click_y, char *)'
'__edittext_insert_str_at_point (OBJECT *x11texteditorpane_object, char *)'
'__edittext_get_primary_selection (OBJECT *x11texteditorpan_eobject, void **buf_out, int *size_out)'
'__edittext_set_selection_owner (OBJECT *x11texteditorpane_object)'
'__edittext_recenter (OBJECT *x11texteditorpane_object)'
     Text editing functions used by 'X11TextEditorPane' objects.  For
     more information, refer to 'X11TextEditorPane' class..  *Note
     X11TextEditorPane::.

'_error (char *FMT, ...)'
     Display an error message and exit the program.

'__inspector_trace (int STACK_INDEX)'
'__inspect_get_arg (int STACK_INDEX)'
'__inspect_get_receiver (int STACK_INDEX)'
'__inspect_get_global (char *OBJ_NAME)'
'__inspect_get_local (int STACK_INDEX, char *OBJ_NAME)'
'__receiver_trace (int STACK_INDEX)'
'__inspect_globals (void)'
'__inspect_locals (void)'
'__inspect_short_help (void)'
'__inspect_long_help (void)'
     Functions used internally by Ctalk's object inspector.  The
     function parameters are designed to be consistent with the syntax
     of the inspector commands, although not every function makes use of
     them.  For details refer to the 'inspect(3ctalk)' manual page, the
     'inspectors' section of the 'ctalktools.info' Texinfo manual, and
     the 'inspect' method in 'ObjectInspector' class.

'__rt_init_library_paths (void)'
     Initialize Ctalk's library paths.  The function first checks the
     value of the 'CLASSLIBDIRS' environment variable for a
     colon-separated list of directories, then adds the location of
     CLASSLIBDIR which is configured when Ctalk is built, and
     CLASSLIBDIR'ctalk'.

'__warning_trace (void)'
     A generic stack trace function that prints a trace of the call
     stack wherever it is inserted in a program.

'__xalloc (int SIZE)'
     Allocates a block of memory of SIZE characters and returns a
     pointer to the memory.  If the alloc call fails, generates an
     '_error' message and exits the program.

'__xfree (void **ADDR)'
     Frees the block of memory pointed to by *ADDR, then sets the ADDR
     to to NULL. *ADDR must be a block of memory previously allocated by
     '__xalloc', above, or a similar 'malloc' call.  When used in a
     program, wrapping ADDR in the 'MEMADDR()' macro provides the
     correct dereferencing for the allocated memory and its pointer.
     The example shows how the 'MEMADDR()' macro is used.


          char *my_ptr;

          my_ptr = (char *)__xalloc (BUF_SIZE);

          _... do stuff ..._

          __xfree (MEMADDR(my_ptr));


'__xrealloc (void **ADDR, int SIZE)'
     Re-allocates the block of memory pointed to by *ADDR to size.  If
     SIZE is larger than the original block of memory, the contents of
     ADDR are preserved.  As with '__xfree', above, the 'MEMADDR' macro
     provides the correct dereferencing for the reference to ADDR.

'_warning (char *FMT, ...)'
     Print a warning message.

'__objRefCntInc (obj_ref)'

     Increment the reference count of an object and its instance
     variables.  This function takes an object reference as its
     argument.  You can use the 'OBJREF' macro to cast the object to an
     object reference.

'__objRefCntDec (obj_ref)'

     Decrement the reference count of an object and its instance
     variables.  As with all of the '__objRefCnt*' functions,
     '__objRefCntDec' takes an object reference as its argument.  You
     can use the 'OBJREF' macro to cast the object to an object
     reference.

'__objRefCntSet (obj_ref, int REFCOUNT)'

     Set the reference count of an object and its instance variables to
     REFCNT.  As with all of the '__objRefCnt*' functions,
     '__objRefCntDec' takes an object reference as its argument.  You
     can use the 'OBJREF' macro to cast the object to an object
     reference.

     _Note:_ '__objRefCntSet' will not set an object's reference count
     to zero.  That is, if you give '0' as the second argument, the call
     has no effect.  Use '__objRefCntZero' instead.  That might sound
     silly, but it's much more reliable overall, in a
     programming-by-contract way.

'__objRefCntZero (obj_ref)'

     Set the reference count of an object and its instance variables to
     0 (zero).  As with all of the '__objRefCnt*' functions,
     '__objRefCntZero' takes an object reference as its argument.  You
     can use the 'OBJREF' macro to cast the object to an object
     reference.

     You should not need to use this function unless you're _completely_
     deleting an object.  Refer to the '__ctalkDeleteObject' function
     for more information.

'__refObj (OBJECT **OBJ1, OBJECT **OBJ2)'
     Assign OBJ2 to OBJ1.  If OBJ1 already points to an object,
     decrement its reference count.  Increment the reference count of
     OBJ2 by 1.  When calling functions that use 'OBJECT **' arguments,
     they correspond to the OBJREF_T typedef, and Ctalk defines the
     macro OBJREF() to cast an object to an OBJREF_T.

'_store_int (OBJECT *RECEIVER, OBJECT *arg)'
     This is a primitive that stores the value of ARG in RECEIVER, which
     is an 'Integer'.  Checks the class of 'arg', and if ARG is not an
     'Integer', converts it to an 'Integer' value.  If RECEIVER a
     pointer to a value, then it stores ARG as a fully-fledged object.

'BOOLVAL(INTEGERORBOOLVALUE)'
     This macro returns the value of an 'Integer' or 'Boolean' object,
     or any of 'Boolean's' subclasses (or just about any other scalar
     value), as a C 'bool'.  For an example of its use, refer to the
     entry for the *Note INTVAL_Macro::.

'INTVAL(INTEGEROBJECTVALUE)'
     A macro that returns the value of an 'Integer' object, or any of
     'Integer's' subclasses, as a C 'int'.  Uses an 'OBJECT *'s'
     '__o_value' member directly, as in this example.


          OBJECT *my_int_object_alias = myInt;

          int a = INTVAL(my_int_object_alias -> __o_value);


'is_zero_q (char *str)'
     Returns a 'bool' if the number represented by the string evaluates
     to zero, false otherwise.

'LLVAL(LONGINTEGERVALUE)'
     A macro that returns the value of a 'LongInteger' object, or any of
     'LongInteger's' subclasses, as a C long long int.  For an example
     of its use, refer to the entry for the *Note INTVAL_Macro::.

'obj_ref_str (char *STR)'
     If STR contains a formatted hexadecimal number of the format
     '0xNNNNNN' that points to an object, return an 'OBJECT *' reference
     to the object, 'NULL' otherwise.

'str_is_zero_q (char *STR)'
     Like 'is_zero_q', above, except that it also checks for an empty
     string (and returns true), as well as a string that contains only
     the digit '0', which causes the function to return false.

'substrcat (char *DEST, char *SRC, int START_INDEX, int END_INDEX)'
     Concatenate the substring of SRC from START_INDEX to END_INDEX to
     DEST.

'substrcpy (char *DEST, char *SRC, int START_INDEX, int END_INDEX)'
     Copy a substring of SRC from START_INDEX to END_INDEX to DEST.

'SYMTOOBJ (SYMBOLVALUE)'
     This is another macro that converts a 'Symbol's' reference to an
     'OBJECT *'.  This macro can be used on the right-hand side of an
     assignment statement.


          if ((value_object =
              SYMTOOBJ((self_object -> instancevars) ?
                       (self_object -> instancevars -> __o_value) :
                       (self_object -> __o_value))) != NULL) {
                return value_object;
              }


'SYMVAL(SYMBOLVALUE)'
     A macro that returns the value of a 'Symbol' object, or any of
     'Symbol's' subclasses, as a C 'uintptr_t *', which is guaranteed to
     be valid for 32- and 64-bit machines.

     However, due to the way that pointers work in C, 'SYMVAL' only
     works on the left-hand side of an assignment; you just need a cast
     (for example to 'OBJECT *') in order to avoid compiler warnings
     when it appears on the right-hand side of an assignment.  Here is
     an example:


          SYMVAL(object_alias->__o_value) = (OBJECT *)some_ptr;


     However, if he label on the right-hand side is also a 'Symbol', the
     'Symbol' class duplicates the address that the operand points to,
     not the operand itself.


          SYMVAL(object_alias->__o_value) = SYMVAL(some_ptr -> __o_value);


     For another, perhaps more basic, example of the macro's use, refer
     to the entry for the *Note INTVAL_Macro::.

'OBJREF(OBJ)'
     Creates a reference to an object.  This macro returns an 'OBJECT
     **', but using the macro allows the definition of an object
     reference to change without affecting too much code.  'OBJREF' is
     used with the '__objRefCnt*' functions, and in other places.

'TRIM_LITERAL(S)'
     A macro that trims the quotes from a literal string.  It expands to
     'substrcpy (S, S, 1, strlen (S) - 2)'.

'TRIM_CHAR(C)'
     A macro that trims the quotes from a literal character.  It expands
     to 'substrcpy (C, C, 1, strlen (C) - 2)'

'TRIM_CHAR_BUF(S)'
     A macro that trims nested single quotes from a literal character.
     'TRIM_CHAR_BUF' also checks whether a single quote (''') is the
     actual character.

'xfopen (const char *path, const char *mode)'
'xfprintf (FILE *stream, const char *fmt, ...)'
'xfscanf (FILE *stream, const char *fmt, ...)'
'xmemcpy (void *s, const void *s, size_t)'
'xmemmove (void *s, const void *s, size_t)'
'xmemset (void *s, int c, size_t n)'
'xsprintf (char *s, const char *fmt, ...)'
'xstrcat (char *d, const char *s)'
'xstrncat (char *d, const char *s, size_t)'
'xstrcpy (char *d, const char *s)'
'xstrncpy (char *d, const char *, size_t)'
     These are portable wrappers for systems that #define their own
     (possibly more secure) versions of library functions.  For the
     exact prototype and definition, you should consult the system's
     manual page for the corresponding library function (e.g.,
     'strcpy(3)' for the definition of 'xstrcpy').

