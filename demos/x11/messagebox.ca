/* messagebox.ca - X11ButtonPane Demonstration */

#include <ctalk/ctalkdefs.h>

/* See the X11FreeTypeFont section of the the Ctalk reference. */
#define FTFONT_BOLD   200
#define FTFONT_MEDIUM 100

int main (void) {
  X11Pane new mainWindow;
  X11PaneDispatcher new dispatcher;
  X11ButtonPane new button;
  X11LabelPane new label;
  X11MessageBoxPane new messageBox;
  InputEvent new e;

  mainWindow backgroundColor = "blue";
  button backgroundColor = "blue";
  label backgroundColor = "blue";
  label textColor = "white";
  label canFocus = false;
  label borderWidth = 0;

  mainWindow initialize 255, 200;
  mainWindow inputStream eventMask = 
    EXPOSE|ENTERWINDOWNOTIFY|LEAVEWINDOWNOTIFY|BUTTONPRESS|BUTTONRELEASE|KEYPRESS|KEYRELEASE|WINDELETE|MOVENOTIFY;

  dispatcher attachTo mainWindow;
  button attachTo dispatcher, "110x50+73+100";
  label attachTo dispatcher, "177x80+34+15";
  messageBox attachTo dispatcher, "300x200";

  mainWindow map;
  mainWindow raiseWindow;

  mainWindow openEventStream;

  mainWindow setWMTitle "X11MessageBoxPane Demo";

  label ftFontVar initFontLib;
#if 1
label ftFont "DejaVu Sans", 0, FTFONT_BOLD, 0, 12.0;
  label ftFontVar saveSelectedFont;
  button ftFont "DejaVu Sans", 0, FTFONT_MEDIUM, 0, 10.0;
  button ftFontVar saveSelectedFont;
#endif  

  label multiLine "X11MessageBoxPane\nDemo";

  button label multiLine "Open\nMessageBox";

  button label highlightBackgroundColor = "gray90";

  /* Icon IDs, like ICON_INFO, are defined in ctalkdefs.h. */
  messageBox resources replaceAt "iconID", ICON_INFO;

  /* The program uses the "replaceAt" method because the key/value
     entry for "backgroundColor" the X11MessageBoxPane : new method
     has alread created an entry for backgroundColor. */
   messageBox resources replaceAt "backgroundColor", "blue";
  messageBox resources replaceAt "messageText",
    	       "Hello, messageBox!\nYour message text here.";
  messageBox resources replaceAt "messageColor", "lightgray";	       

  button draw;
  button refresh;
  label draw;
  label refresh;


  while (TRUE) {
    mainWindow inputStream queueInput;
    if (mainWindow inputStream eventPending) {
      e become mainWindow inputStream inputQueue unshift;

      mainWindow subPaneNotify e;

      switch (e eventClass value)
	{
	case EXPOSE:
	  button subPaneExpose (button, e);
	  label subPaneExpose (label, e);
	  break;
	case BUTTONRELEASE:
	  if (button haveClick) {
	    button clearClick;
	  }
	  button highlight = false;
	  button clicked = false;
	  button draw;
	  button refresh;
	  messageBox show;
	  break;
	case WINDELETE:
 	  mainWindow deleteAndClose;
	  exit (0);
	  break;
	}
    } else {
      usleep (1000);
    }
  }

}
