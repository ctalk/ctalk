/* popupmenu.ca - X11PopupMenu Demonstration -*-c-*- */

#include <ctalk/ctalkdefs.h>

/* See the X11FreeTypeFont section of the the Ctalk reference. */
#define FTFONT_BOLD   200
#define FTFONT_MEDIUM 100

/*
 *  Objects that are targets of menu items 
 *  need to be within the scope of the popup's
 *  methods.  The simplest way to do this is to
 *  make them global.
 */
X11MessageBoxPane new aboutBox;
X11MessageBoxPane new msgBox;
X11YesNoBoxPane new yesNoBox;
X11TextEntryBox new textEntryBox;
X11FileSelectDialog new fileBox;

X11MessageBoxPane instanceMethod configure (void) {
  self resources replaceAt "backgroundColor", "darkblue";
  self resources replaceAt "foregroundColor", "darkblue";
  self resources replaceAt "messageColor", "white";
  self resources replaceAt "messageText",
    "X11PopupMenu Demo\nCtalk Version: 0.67";
  self resources replaceAt "iconID", ICON_INFO;

}

/* 
   This is initialized internally when we create the app's
   window. 
*/
extern Atom wm_delete_window;

X11PopupMenu instanceMethod clientExit (X11Pane parentPane) {
  "This is a typical handler to exit an app from a menu entry.
  It simulates a user selecting a close window option on the
  window's title bar. It still needs an independent connection to
  the display server, however."
  XEvent e;
  Display *d_l;
  if ((d_l = XOpenDisplay (getenv ("DISPLAY"))) != NULL) {
    e.type = ClientMessage;
    e.xclient.serial = 0l;
    e.xclient.send_event = true;
    e.xclient.display = d_l;
    e.xclient.window = parentPane xWindowID;
    e.xclient.format = 32;
    e.xclient.data.l[0] = wm_delete_window;
    XSendEvent (d_l, parentPane xWindowID, true, 0l, &e);
    XFlush (d_l);
    XCloseDisplay (d_l);
  }
}

int main (void) {
  X11Pane new mainWin;
  X11PaneDispatcher new dispatcher;
  X11LabelPane new heading, subHeading;
  X11PopupMenu new mainMenu, dialogMenu;
  InputEvent new e;
  XEvent ev_ret;
  Display *display;

  /*
   *  To Add a Submenu - 
   *  1. In the entry that pops up the submenu, which is 
   *     "Dialog Boxes>" here, add a '>' to the end of the
   *     label, which marks the entry as a submenu launcher.
   *     The '>" is displayed in the menu's right margin
   *     where the item appears.
   *  2. The submenu launcher's expression needs to be the
   *     name that you want the submenu referred to as - 
   *     here, that's "dialogMenu."
   *  3. Add the submenu to the parents menu's "subMenus"
   *     AssociativeArray, again using the name that you
   *     want to identify the submenu by - again, that's
   *     "dialogMenu" in this example.
   *  
   */
  dialogMenu add "X11FileSelectDialog...", "fileBox show";
  dialogMenu add "X11MessageBoxPane...", "msgBox show";
  dialogMenu add "X11TextEntryBox...", "textEntryBox show";
  dialogMenu add "X11YesNoBoxPane...", "yesNoBox show";

  mainMenu add "Dialog Widget Classes>", "dialogMenu";
  mainMenu add "About...", "aboutBox show";
  mainMenu add "Exit", "self clientExit parentPane";
  mainMenu subMenus atPut "dialogMenu", dialogMenu;

  heading canFocus = false;
  heading resources replaceAt "borderWidth", 0;
  subHeading canFocus = false;
  subHeading resources replaceAt "borderWidth", 0;

  heading ftFontVar notifyLevel XFT_NOTIFY_NONE;

  heading ftFontVar initFontLib;

  aboutBox configure;

  mainWin backgroundColor = "blue";
  heading resources replaceAt "backgroundColor", "blue";
  subHeading resources replaceAt "backgroundColor", "blue";
  
  mainWin initialize 255, 200;
  /*
   * Select which X events we want to handle.
   */
  mainWin inputStream eventMask = 
    EXPOSE|ENTERWINDOWNOTIFY \
    |LEAVEWINDOWNOTIFY|BUTTONPRESS \
    |BUTTONRELEASE|KEYPRESS|KEYRELEASE \
    |MOVENOTIFY|WINDELETE \
    |WMFOCUSCHANGENOTIFY;

  dispatcher attachTo mainWin;
  heading attachTo dispatcher, "177x60+c+25";
  subHeading attachTo dispatcher, "190x60+c+75";

  /* The dialogs, which are launched by the menu, still need
     to be attached to the menu's parent window, even if it's
     only to set their dimensions similar to the main window's 
     dimensions. */
  aboutBox attachTo dispatcher, "300x200";
  fileBox attachTo dispatcher, "250x350";
  msgBox attachTo dispatcher, "250x350";
  textEntryBox attachTo dispatcher, "350x250";
  yesNoBox attachTo dispatcher, "250x350";

  mainWin map;
  mainWin raiseWindow;

  mainWin openEventStream;

  mainWin setWMTitle "X11PopupMenu Demo";

  heading multiLine "X11PopupMenu\nDemo";
  heading resources replaceAt "textColor", "lightgray";
  heading resources replaceAt "foregroundColor", "blue";

  subHeading resources replaceAt "ftFont", "DejaVu Sans-8";
  subHeading resources replaceAt foregroundColor, "blue";
  subHeading resources replaceAt textColor, "lightgray";
  subHeading multiLine "Click anywhere\nto display the menu.";

  while (TRUE) {
    mainWin inputStream queueInput;
    if (mainWin inputStream eventPending) {
      e become mainWin inputStream inputQueue unshift;

      mainWin subPaneNotify e;

      switch (e eventClass value)
	{
	case EXPOSE:
	  heading subPaneExpose (heading, e);
	  subHeading subPaneExpose (subHeading, e);
	  break;
	case BUTTONPRESS:
	  mainMenu popup mainWin, e xEventData5, e xEventData6;
	  display = mainMenu displayPtr;
	  while (XCheckTypedEvent (display, ButtonPress, &ev_ret))
	    ;
	  break;
	case WINDELETE:
 	  mainWin deleteAndClose;
	  exit (0);
	  break;
	}
    } else {
      usleep (1000);
    }
  }

}
