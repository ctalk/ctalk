/* $Id: X11ListPane,v 1.3 2021/05/16 14:05:29 rkiesling Exp $ -*-C-*-*/

/*
  This file is part of Ctalk.
  Copyright © 2020  Robert Kiesling, rk3314042@gmail.com.
  Permission is granted to copy this software provided that this copyright
  notice is included in all source code modules.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
*/

#include <ctalk/ctalkdefs.h>

/* 
   X11ListPane Class

   Resources

   borderColor              "gray"
   scrollBorderColor        "darkgray"
   scrollWidth              10
   borderWidth              1
   scrollBorderWidth        1
   thumbMargin              2
   font                     "sans serif-12";
   leftMargin               4
   keyScrollIncrement       4
   thumbColor               "darkgray"
   textColor                "black"
   selectColor              "skyblue"
   scrollMargin             2
   vAlignHint               -2
   selectStyle              LIST_SELECT_PANE

*/

X11CanvasPane class X11ListPane;

X11ListPane instanceVariable items List NULL;
X11ListPane instanceVariable viewStartY Integer  0;
X11ListPane instanceVariable scrollWidth Integer 0;
X11ListPane instanceVariable buttonState Integer 0;
X11ListPane instanceVariable thumbOrg Point NULL;
X11ListPane instanceVariable thumbExt Point NULL;
X11ListPane instanceVariable shiftState Integer 0;
X11ListPane instanceVariable lineHeight Integer 0;
X11ListPane instanceVariable vAlignHint Integer 0;
X11ListPane instanceVariable borderPen Pen NULL;
X11ListPane instanceVariable scrollBorderPen Pen NULL;
X11ListPane instanceVariable selectionPen Pen NULL;

String class ItemBox;

ItemBox instanceVariable org Point 0;
ItemBox instanceVariable ext Point 0;
ItemBox instanceVariable size Point 0;
ItemBox instanceVariable selected Boolean false;

static int y_1 = 0, x_1 = 0, d_y = 0;
static int scroll_max_y, scroll_boundary_y, scroll_min_y;
static int last_click_nth = -1;
static int scrollmargin, scrollwidth, thumbwidth;
static int display_line_height;
static int select_style, text_left_margin;
static int thumborg_x, thumbext_x;

/*
 *  Helps speed up scrolling on slower systems.  If you
 *  have a fast system, you can set this to 0 and have
 *  finer scrolling.
 */
#define MIN_SCROLL 3
/*
 *  How many pixels to scroll for a mouse wheel (Button4 and Button5) 
 *  event.
 */
#define WHEEL_ADJ 12

ItemBox instanceMethod = setEqual (OBJECT *__newObject) {
  "This is basically Object : =, but we define it here so Ctalk
  doesn't try to use String : =, which is ItemBox's immediate
  superclass."

  if (__ctalkAliasObject (self, __newObject) != 0) {
    printf ("ItemBox : = : Could not set object, \"%s,\" value.\n", self name);
    if (self traceEnabled)
      __warning_trace ();
    return NULL;
  }

  return __newObject;
}

X11ListPane instanceMethod selectFont (void) {
  "A convenience method.  selectFont is synonymous with, 
   'self ftFontVar selectFont.'"
  self ftFontVar selectFont;
}

X11ListPane instanceMethod calcThumb (void) {
  Integer new margin, usableScroll;
  Float new nItems, itemsPerPage, visiblePct;
  ItemBox new item;
  double px_size;

  usableScroll = self resources integerAt "scrollWidth";
  margin = self resources integerAt "thumbMargin";

  scroll_max_y = self size y - margin;
  scroll_boundary_y = scroll_max_y - 5; /* gives us a boundary where we
					  can move the thumb to the limit
					  of the channel in case the user
					  moves it too far. */
  scroll_min_y = margin;

  /* The (Object *) cast tells Ctalk to use Object : = . not 
     String : =, which is in ItemBox's immediate superclass. */
  (Object *)item = **self items;

#if 1

  /* For testing. */
  itemsPerPage = (self size y asFloat) / (item size y asFloat);

#else  

  itemsPerPage = self size y asFloat / item size y asFloat;

#endif    

  nItems = self items size asFloat;
  visiblePct = itemsPerPage / nItems;

  px_size = scroll_max_y * visiblePct;
  self thumbExt y = px_size asInteger;

  if (self thumbExt y > scroll_max_y)
    self thumbExt y = scroll_max_y;

  self thumbOrg x = margin;
  self thumbExt x = margin + usableScroll;
  thumborg_x = margin;
  thumbext_x = margin + usableScroll;
  /* initial position at the top of the scrollbar */
  self thumbOrg y = margin;

}

X11ListPane instanceMethod moveThumb (Integer py) {
  self thumbOrg y += py;
  self thumbExt y += py;
}

X11ListPane instanceMethod add (String itemText) {
  Symbol new itemPtr;
  Integer new nth, itemWidth;

  *itemPtr = ItemBox basicNew itemText, itemText;

  nth = self items size;
  itemWidth = self ftFontVar textWidth itemText;

  (*itemPtr) org x = (self resources integerAt "scrollWidth") +
    (self resources integerAt "leftMargin");
  (*itemPtr) org y = (nth * self ftFontVar height);

  (*itemPtr) ext x = (*itemPtr) org x + itemWidth;
  /* This is here for testing. */
  (*itemPtr) ext y = ((nth * self ftFontVar height) + self ftFontVar height);

  (*itemPtr) size x = itemWidth;
  (*itemPtr) size y = self ftFontVar height;

  self items push *itemPtr;

  self calcThumb;
}

X11ListPane instanceMethod new (String paneName) {
  Method new exposeMethod, kbdMethod, buttonMethod, motionMethod, 
    resizeMethod;

  X11ListPane super new paneName;
  
  exposeMethod definedInstanceMethod "X11ListPane", "onExpose";
  paneName setMethodHandler "expose", exposeMethod;

  kbdMethod definedInstanceMethod "X11ListPane", "onKey";
  paneName setMethodHandler "kbdinput", kbdMethod;

  buttonMethod definedInstanceMethod "X11ListPane", "onClick";
  paneName setMethodHandler "pointerinput", buttonMethod;

  motionMethod definedInstanceMethod "X11ListPane", "onMotion";
  paneName setMethodHandler "pointermotion", motionMethod;

  resizeMethod definedInstanceMethod "X11ListPane", "onResize";
  paneName setMethodHandler "resize", resizeMethod;

  paneName resources atPut "borderColor", "gray";
  paneName resources atPut "scrollWidth", 10;
  paneName resources atPut "borderWidth", 2;
  paneName resources atPut "thumbMargin", 2;
  paneName resources atPut "font", "sans-serif-12";
  paneName resources atPut "leftMargin", 4;
  paneName resources atPut "keyScrollIncrement", 4;
  paneName resources atPut "thumbColor", "darkgray";
  paneName resources atPut "textColor", "black";
  paneName resources atPut "selectColor", "skyblue";
  paneName resources atPut "scrollMargin", 1;
  paneName resources atPut "vAlignHint", -2;
  paneName resources atPut "selectStyle", LIST_SELECT_PANE;
  paneName resources atPut "scrollBorderColor", "darkgray";
  paneName resources atPut "scrollBorderWidth", 1;

  return paneName;
}

/* These are from x11defs.h. */
#define BUTTON1MASK  (1 << 0)
#define BUTTON2MASK  (1 << 1)
#define BUTTON3MASK  (1 << 2)  

#define shiftStateShift (1 << 0)
#define shiftStateCtrl  (1 << 1)

X11ListPane instanceMethod unSelectAll (void) {
  self items map {
    (ItemBox *)self selected = false;
  }
}

X11ListPane instanceMethod selectRange (Integer nthClicked) {
  Integer new minSelected, maxSelected;
  ItemBox new item;
  int i;
  i = 0;
  minSelected = -1;
  maxSelected = -1;
  self items map {
    item = self;
    if (item selected && (minSelected == -1)) {
      minSelected = i;
    } else if ((i >= nthClicked) && (minSelected == -1)) {
      minSelected = i;
    } else if (minSelected != -1) {
      if (item selected) {
	maxSelected = i;
      }
    }
    ++i;
  }

  i = 0;
  self items map {
    item = self;
    if (i >= minSelected && i <= maxSelected) {
      item selected = true;
    }
    ++i;
  }
}

X11ListPane instanceMethod onClick (Object subPane, InputEvent event) {
  ItemBox new item, lastItem;
  int i, y_2, scroll_adj;
  
  switch (event eventClass)
    {
    case BUTTONPRESS:
      switch (event xEventData4)
	{
	case Button1:
	  subPane buttonState |= BUTTON1MASK;
	  /* On the first MotionNotify after a click, 
	     in onMotion, below, 
             (d_y = (event xEventData2 - y_1)) == 0  
	     This insures that onMotion uses only the change in
	     the pointer Y (d_y) to move the thumb, and ignores the
	     absolute Y coord of the click, so onMotion doesn't try
	     to position the scroll thumb at the Y coord of the click,
	     which means the thumb doesn't move if (when) the user clicks
	     anywhere between the top and bottom of the thumb. */
	  y_1 = event xEventData2;
	  y_2 = y_1 + self viewStartY;
	  if (event xEventData1 > self scrollWidth) {
	    i = 0;
	    self items map {
	      /* Simplifies expressions. */
	      item = self;
	      if (super shiftState == 0) {
		if ((y_2 >= item org y) && (y_2 <= item ext y)) {
		  /* Clicking on the same item twice de-selects it. */
		  if (last_click_nth == -1) {
		    last_click_nth = i;
		    item selected = true;
		  } else {
		    if (i != last_click_nth) {
		      lastItem = *(super items + last_click_nth);
		      lastItem selected = false;
		      last_click_nth = i;
		      item selected = true;
		    } else {
		      last_click_nth = -1;
		      item selected = false;
		    }
		  }
		}
	      } else if (super shiftState & shiftStateShift) {
		if ((y_2 >= item org y) && (y_2 <= item ext y)) {
		  if (last_click_nth == i) {
		    last_click_nth = -1;
		    item selected = false;
		  } else {
		    last_click_nth = i;
		    item selected = true;
		  }
		}
	      } else if (super shiftState & shiftStateCtrl) {
		if ((y_1 >= item org y) && (y_1 <= item ext y)) {
		  if (last_click_nth == i) {
		    last_click_nth = -1;
		    super unSelectAll;
		  } else {
		    last_click_nth = i;
		    item selected = true;
		    super selectRange i;
		  }
		}
	      }
	      ++i;
	    }
	  }
	  self draw;
	  self refresh;
	  break;
	case Button2:
	  subPane buttonState |= BUTTON2MASK;
	  break;
	case Button3:
	  subPane buttonState |= BUTTON3MASK;
	  break;
	case Button4:
	  break;
	case Button5:
	  break;
	}
      break;
    case BUTTONRELEASE:
      switch (event xEventData4)
	{
	case Button1:
	  subPane buttonState &= ~BUTTON1MASK;
	  break;
	case Button2:
	  subPane buttonState &= ~BUTTON2MASK;
	  break;
	case Button3:
	  subPane buttonState &= ~BUTTON3MASK;
	  break;
	case Button4:
	  if (self viewStartY - WHEEL_ADJ > 0) {
	    self moveThumb (-WHEEL_ADJ);
	    self viewStartY -= WHEEL_ADJ;
	    self draw;
	    self refresh;
	  } else if (self viewStartY > 0) {
	    scroll_adj = self viewStartY;
	    self moveThumb (-scroll_adj);
	    self viewStartY -= scroll_adj;
	    self draw;
	    self refresh;
	  }
	  break;
	case Button5:
	  if (self thumbOrg y + WHEEL_ADJ < scroll_max_y) { 
	    self moveThumb WHEEL_ADJ; 
	    self viewStartY += WHEEL_ADJ;
	    self draw;
	    self refresh;
	  }
	  break;
	}
      break;
    }
}

X11ListPane instanceMethod onMotion (Object subPane, InputEvent event) {

  int thumborg_y_tmp;

  if (event xEventData1 <= thumbext_x) {
    if (self buttonState & BUTTON1MASK) {
      d_y = event xEventData2 - y_1;
      if (abs (d_y) < MIN_SCROLL)
	return NULL;
      y_1 += d_y;
      self thumbOrg y += d_y;
      self thumbExt y += d_y;
      self viewStartY += d_y;
      thumborg_y_tmp = self thumbOrg y;
      if (thumborg_y_tmp > scroll_boundary_y) {
	d_y = (self thumbOrg y - scroll_boundary_y);
	self thumbOrg y -= d_y;
	self thumbExt y -= d_y;
	self viewStartY -= d_y;
      } else if (thumborg_y_tmp < 2) {
	if (thumborg_y_tmp >= 0) {
	  d_y = (2 - self thumbOrg y);
	  self thumbOrg y += d_y;
	  self thumbExt y += d_y;
	  self viewStartY += d_y;
	} else {
	  d_y = -self thumbOrg y;
	  d_y += 2;
	  self thumbOrg y += d_y;
	  self thumbExt y += d_y;
	  self viewStartY += d_y;
	}
      }
      self draw;
      self refresh;
    }
  }
}

#ifndef XK_Up
#define XK_Up 0xff52
#endif
#ifndef XK_Down
#define XK_Down 0xff54
#endif
#define CTRL_N 14
#define CTRL_P 16

#ifndef XK_Control_L
#define XK_Control_L  0xffe3
#endif
#ifndef XK_Control_R
#define XK_Control_R  0xffe4
#endif
#ifndef XK_Shift_L
#define XK_Shift_L 0xffe1
#endif
#ifndef XK_Shift_R
#define XK_Shift_R 0xffe2
#endif

X11ListPane instanceMethod onKey (Object subPane,
				    InputEvent __event) {
  Integer new scrollInc;

  /* We could simply declare subPane as a X11ListPane in the 
     parameter list.  This is here for testing. */
  scrollInc = (X11ListPane *)subPane resources integerAt
    "keyScrollIncrement";

  if (__event eventClass == KEYPRESS) {
    switch (__event xEventData5)
      {
      case XK_Up:
      case CTRL_P:
	if ((subPane viewStartY  - scrollInc) > 0) {
	  subPane viewStartY -= scrollInc;
	}
	break;
      case XK_Down:
      case CTRL_N:
	if ((subPane viewStartY + scrollInc) < subPane size y) {
	  subPane viewStartY += scrollInc;
	}
      case XK_Control_R:
      case XK_Control_L:
	subPane shiftState |= shiftStateCtrl;
	break;
      case XK_Shift_R:
      case XK_Shift_L:
	subPane shiftState |= shiftStateShift;
	break;
      }
  } else if (__event eventClass == KEYRELEASE) {
    switch (__event xEventData5)
      {
      case XK_Control_R:
      case XK_Control_L:
	subPane shiftState &= ~shiftStateCtrl;
	break;
      case XK_Shift_R:
      case XK_Shift_L:
	subPane shiftState &= ~shiftStateShift;
	break;
      }
  }

}

X11ListPane instanceMethod onExpose (Object subPane, InputEvent event) {
  subPane draw;
  subPane refresh;
}

X11ListPane instanceMethod attachTo (Object parentPane,
				       String geomspec) {
  "Register the receiver pane as a subpane of the X11Pane
  given as the argument.  Generally parent pane should
  be a X11PaneDispatcher object."
  X11Bitmap new xPaneBuffer;
  X11Bitmap new xPaneBackingStore;
  int x, y, width, height;
  self super attachTo (parentPane, geomspec);
  self paneBuffer become xPaneBuffer;
  self paneBackingStore become xPaneBackingStore;

  __ctalkX11SubWindowGeometry (parentPane, geomspec,
				 &x, &y, &width, &height);
  self viewWidth = width;
  self viewHeight = height;
  self size x = width;
  self size y = height;
  self origin x = x;
  self origin y = y;

  /*
   *  The evaluation of these statements  needs to be deferred
   *  until run time.  See the comment in the other, "attachTo,"
   *  method, below.
   */
  (X11Bitmap *)self paneBuffer create self displayPtr, self xWindowID,
    self size x, self size y, self depth;
  (X11Bitmap *)self paneBuffer background (self backgroundColor);
  (X11Bitmap *)self paneBackingStore create self displayPtr, self xWindowID,
    self size x, self size y, self depth;

  self paneBuffer background "white";
  self paneBuffer clear;

  self ftFontVar selectFontFromFontConfig self resources at "font";
  self ftFontVar saveSelectedFont;

  display_line_height = self ftFontVar textHeight "T";
  scrollmargin = self resources integerAt "scrollMargin";
  scrollmargin += self resources integerAt "borderWidth";
  scrollwidth = self resources integerAt "scrollWidth";
  thumbwidth = scrollmargin + (scrollwidth - (scrollmargin * 2));
  /* Also set the instance variable in case somebody uses it. */
  self scrollWidth = scrollwidth;

  self lineHeight = self ftFontVar textHeight "T";
  self vAlignHint = self resources integerAt "vAlignHint";
  select_style = self resources integerAt "selectStyle";
  text_left_margin = self resources integerAt "leftMargin";

  self borderPen colorName = self resources at "borderColor";
  self borderPen width = self resources integerAt "borderWidth";
  self scrollBorderPen colorName = self resources at "scrollBorderColor";
  self scrollBorderPen width = self resources integerAt "scrollBorderWidth";
  self selectionPen colorName = self resources at "selectColor";
  self selectionPen width = 1;

  return NULL;
}

X11ListPane instanceMethod dumpList (void) {
  "For testing."
  ItemBox new item;
  
  self items map {
    item = self;
    printf ("%s: org: %d,%d\text: %d,%d\tsize: %d,%d\n", item, item org x,
	    item org y, item ext x, item ext y, item size x, item size y);
  }
}

X11ListPane instanceMethod drawItemList (void) {
  ItemBox new item;
  Integer new tViewExtX, tViewStartY, tViewTopPx;
  void *d;
  unsigned int xid;
  unsigned long gc_ptr;
  
  self ftFontVar selectFont;
  self ftFontVar namedX11Color self resources at "textColor";

  tViewExtX = self size x - self scrollWidth - 
    (self resources integerAt "leftMargin") - 5;
  tViewStartY = self viewStartY + self vAlignHint;
  tViewTopPx = self viewStartY - self lineHeight;
  d = self displayPtr;
  xid = self paneBuffer xID;
  gc_ptr = self paneBuffer xGC;

  if (select_style == LIST_SELECT_ITEM) {
    /* Here we need to check the width of each list item, and
       we just do the complete loop, so we don't have to
       check select_style for each item, also. */
    self items map {
      item = self;

      if (tViewTopPx <= item org y) {
	if (item selected == true) {

	  super drawFilledRectangle (item org x,
				     /* Try to center the rectangle 
					vertically over the text. */
				     (item ext y - super viewStartY
				      - super lineHeight),
				     item size x,
				     item size y, super selectionPen);
	}
        __ctalkX11PanePutStrBasic (d, xid, gc_ptr,
                                   item org x, 
                                   item ext y - tViewStartY,
                                   item value);
      }
    }
  } else {
    self items map {
      item = self;

      if (tViewTopPx <= item org y) {
	if (item selected == true) {

	  super drawFilledRectangle (item org x,
				     /* Try to center the rectangle 
					vertically over the text. */
				     (item ext y - super viewStartY
				      - super lineHeight),
                                     tViewExtX, 
				     item size y, super selectionPen);
	}
        /* for testing here, too */
        __ctalkX11PanePutStrBasic (d, xid, gc_ptr,
                                   item org x, 
                                   item ext y - tViewStartY,
                                   item value);
      }
    }
  }
}

X11ListPane instanceMethod drawThumb (void) {
  self pen colorName = self resources at "thumbColor";
  self drawFilledRectangle scrollmargin, self thumbOrg y,
    thumbwidth, self thumbExt y;

}

X11ListPane instanceMethod draw (void) {

  self background "white";
  self clear;

 self drawRectangle self resources integerAt "scrollWidth", 0,
	self size x, self size y, self borderPen;

  self drawRectangle 0, 0, self resources integerAt "scrollWidth",
    self size y, self scrollBorderPen;
  
  self drawThumb;
  self drawItemList;
}

X11ListPane instanceMethod nItemsSelected (void) {
  "Returns an Integer with the number of items currently selected.
   This allows a program to determine whether it can use the
   selectedItem and selectedItemText methods to return a single item, 
   or the selectedItems method to return a list of items."
  ItemBox new item;
  int i;
  returnObjectClass Integer;
  i = 0;
  self items map {
    item = self;
    if (item selected == true) {
      ++i;
    }
  }
  return i;
}

X11ListPane instanceMethod selectedItemN (void) {
  returnObjectClass Integer;
  return last_click_nth;
}

X11ListPane instanceMethod selectedItemText (void) {
  String new s;
  ItemBox new item;
  int i;
  returnObjectClass String;
  i = 0;
  s = "";
  self items map {
    /*
     *  Here, too, cast to Object class here so we can copy the full
     *  object - otherwise, a cast to ItemBox would only resolve to
     *  String : =, i.e., ItemBox's immediate superclass.
     */
    item = (Object *)self;
    if (i == last_click_nth) {
      s = item value;
    }
    ++i;
  }
  return s;
}

X11ListPane instanceMethod selectedItems (List itemsOut) {
  "Returns the text of each item currently selected a String
   and pushed onto the itemsOut list which is given as an
   argument."
  ItemBox new item;
  Symbol new itemTextPtr;
  returnObjectClass List;
  self items map {
    item = self;
    if (item selected == true) {
      *itemTextPtr = String basicNew item value, item value;
      itemsOut push *itemTextPtr;
    }
  }
  return itemsOut;
}

X11ListPane instanceMethod selectedItemsN (List itemsOut) {
  ItemBox new item;
  Symbol new itemNPtr;
  int i;
  returnObjectClass List;

  i = 0;
  self items map {
    item = self;
    if (item selected == true) {
      *itemNPtr = Integer basicNew i asString, i;
      itemsOut push *itemNPtr;
    }
    ++i;
  }
  return itemsOut;
}

X11ListPane instanceMethod onResize (X11TextEditorPane subPane, 
				     InputEvent event) {
  int x_out, y_out, width_out, height_out;

  __ctalkX11WxHGeometry (event xEventData3, event xEventData4,
			 subPane subPaneGeometry,
			 &x_out, &y_out, &width_out, &height_out);

  subPane size x = width_out;
  subPane size y = height_out;
  subPane origin x = x_out;
  subPane origin y = y_out;

  __ctalkX11MoveWindow (subPane, x_out, y_out);
  __ctalkX11ResizeWindow (subPane, width_out, height_out, subPane depth);

  (X11Bitmap *)self paneBuffer resize self xWindowID,
    self size x, self size y;
  (X11Bitmap *)self paneBuffer background (self backgroundColor);
  (X11Bitmap *)self paneBackingStore resize self xWindowID,
    self size x, self size y;

  subPane calcThumb;
  subPane draw;
  subPane refresh;
}
