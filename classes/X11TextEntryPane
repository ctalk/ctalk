/* $Id: X11TextEntryPane,v 1.39 2020/05/14 20:20:49 rkiesling Exp $ -*-C-*-*/

/*
  This file is part of Ctalk.
  Copyright © 2020  Robert Kiesling, rk3314042@gmail.com.
  Permission is granted to copy this software provided that this copyright
  notice is included in all source code modules.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
*/

X11CanvasPane class X11TextEntryPane;

Character class CharCell;

/* 
 *   X11TextEntryPane Class - Text Entry Widget
 *
 *
 *   Resources:
 *
 *     backgroundColor     String   "white"
 *     textColor           String   "black"
 *     font                String   "mono-12:weight=medium:slant=regular"
 *     borderWidth         Integer  2
 *     borderColor         String   "gray"
 *     vPad                Integer  4
 *     hPad                Integer  4
 *     font                String   "mono-12:weight=medium:slant=roman"
 *                                  Linux       MacOS
 *     spacingHint         Integer  -3          0
 *
 */

X11TextEntryPane instanceVariable cursor X11Cursor 0;
X11TextEntryPane instanceVariable shiftState Integer 0;
X11TextEntryPane instanceVariable hover Boolean false;
X11TextEntryPane instanceVariable cursorX Integer 0;
X11TextEntryPane instanceVariable chars List NULL;
X11TextEntryPane instanceVariable eWidth Integer 0
"When calculating the width of monospace CharCells (recommended), 
we use the width of an 'e' as the width of each character; in case
the font's widths aren't even.";

CharCell instanceVariable width Integer 0;

X11TextEntryPane instanceMethod new (String paneName) {
  Method new enterMethod, leaveMethod, kbdMethod, exposeMethod;

  X11TextEntryPane super new paneName;

  enterMethod definedInstanceMethod "X11TextEntryPane", "subPaneEnter";
  paneName setMethodHandler "enternotify", enterMethod;

  leaveMethod definedInstanceMethod "X11TextEntryPane", "subPaneLeave";
  paneName setMethodHandler "leavenotify", leaveMethod;

  kbdMethod definedInstanceMethod "X11TextEntryPane", "subPaneKbd";
  paneName setMethodHandler "kbdinput", kbdMethod;

  exposeMethod definedInstanceMethod "X11TextEntryPane", "subPaneExpose";
  paneName setMethodHandler "expose", exposeMethod;

#ifdef __APPLE__
  paneName resources atPut "font", "mono-12:weight=normal:slant=roman";
  paneName resources atPut "spacingHint", -1;
#else  
  paneName resources atPut "font", "mono-12:weight=normal:slant=roman";
  paneName resources atPut "spacingHint", -3;
#endif  
  paneName resources atPut "textColor", "black";
  paneName resources atPut "backgroundColor", "white";
  paneName resources atPut "borderWidth", 2;
  paneName resources atPut "borderColor", "gray";
  paneName resources atPut "vPad", 4;
  paneName resources atPut "hPad", 4;

  return paneName;
}

X11TextEntryPane instanceMethod attachTo (X11Pane parentPane,
					   String geomspec) {
  "Register the receiver pane as a subpane of the X11Pane
  given as the argument.  Generally parent pane should
  be a X11PaneDispatcher object.  At this time, a geometry
  specification like, '300x200', i.e., without the x and
  y origins, is okay - the Ctalk libraries center the
  message box above the parent window."
    /* X11Bitmap new xPaneBuffer;
       X11Bitmap new xPaneBackingStore; *//***/
  String new parentGeometry;
  int x, y, width, height;
  unsigned int mainWinID;
  
  self displayPtr = self mainWindow displayPtr;
  self paneBuffer backgroundColor = self resources at "backgroundColor";
  self super attachTo (parentPane, geomspec);

  self container = parentPane;
  (X11Bitmap *)self paneBuffer create self displayPtr, self xWindowID,
    self size x, self size y, self depth;
  (X11Bitmap *)self paneBackingStore create self displayPtr, self xWindowID,
    self size x, self size y, self depth;

  __ctalkX11SubWindowGeometry (parentPane, geomspec,
			       &x, &y, &width, &height);

  self size x = width;
  self size y = height;
  self origin x = x;
  self origin y = y;

  self resources atPut "geometry", geomspec;

  self cursor xterm;

  return NULL;
}

X11TextEntryPane instanceMethod refresh (void) {
  self super refresh;
}

X11TextEntryPane instanceMethod drawCursor (void) {
  Integer new hPad;

  hPad = self resources at "hPad";

  self paneBuffer drawLine self cursorX, hPad,
    self cursorX, self size y - hPad, self pen; 

}

X11TextEntryPane instanceMethod inputWidth (List input, Integer startIdx) {
  Integer new i, width, spacing;
  CharCell new c;
  returnObjectClass Integer;

  width = 0;
  i = 0;
  spacing = self resources at "spacingHint";
  input map {
    if (i >= startIdx) {
      (Object *)c = self;
      width += c width;
      width += spacing;
    }
    ++i;
  }
  return width;
}

X11TextEntryPane instanceMethod draw (void) {
  Integer new baseLineY, pxSize;
  Integer new vPad, hPad, borderWidth;
  Integer new textWidthPx, clipStartIdx;
  Integer new entryChars;
  String new entryText;
  Integer new idx, spacing;
  CharCell new cm;
  
  if (self eWidth == 0) {
    self eWidth = self ftFontVar textWidth "e";
  }

  self paneBuffer background (self resources at "backgroundColor");
  self paneBuffer foreground (self resources at "backgroundColor");
  self paneBuffer clear;

  self pen colorName = self resources at "borderColor";
  self pen width = self resources at "borderWidth";
  self drawRectangle 0, 0, self size x, self size y;

  self ftFontVar selectFontFromFontConfig (self resources at "font");

  pxSize = (self ftFontVar pointSize *
	    (self ftFontVar dpi / 72)) asInteger;
  self ftFontVar namedX11Color self resources at "textColor";

  entryText = self chars asString;

  vPad = self resources at "vPad";
  hPad = self resources at "hPad";
  borderWidth = self resources at "borderWidth";
  
  baseLineY = self size y - borderWidth - hPad - (self ftFontVar descent);

  entryChars = entryText length;
  for (clipStartIdx = 0; clipStartIdx < entryChars; ++clipStartIdx) {
    textWidthPx = self inputWidth self chars, clipStartIdx;
    if (textWidthPx < ((self size x - vPad) * .75))
      break;
  }
  
  self cursorX = vPad;

  idx = 0;
  spacing = self resources at "spacingHint";
  self chars map {
    if (idx >= clipStartIdx) {
      (Object *)cm = self;
      super paneBuffer putStr super cursorX, baseLineY, cm asString;
      if (super ftFontVar isMonospace) {
	super cursorX += super eWidth + spacing;
      } else {
	super cursorX += cm width;
      }
    }
    ++idx;
  }

  if (self hover)
    self drawCursor;

}

X11TextEntryPane instanceMethod subPaneEnter (Object subPane,
					      InputEvent event) {
  if (event eventData == subPane xWindowID) {
    subPane useCursor subPane cursor;
    subPane hover = true;
    subPane draw;
    subPane refresh;
  }
}

X11TextEntryPane instanceMethod subPaneLeave (Object subPane,
					      InputEvent event) {
  if (event eventData == subPane xWindowID) {
    subPane defaultCursor;
    subPane hover = false;
    subPane draw;
    subPane refresh;
  }
}

X11TextEntryPane instanceMethod subPaneExpose (Object subPane,
					       InputEvent event) {
  self draw;
  self super refresh;
}

/* Some of these are also defined in X11TextEditorPane class and edittext.c. */
#define shiftStateShift     (1 << 0)
#define shiftStateCtrl      (1 << 1)
#define shiftStateCapsLock  (1 << 2)

/* From X11/keysymdef.h, in case your machine defines these differently. */
#ifndef XK_Control_L
#define XK_Control_L  0xffe3
#endif
#ifndef XK_Control_R
#define XK_Control_R  0xffe4
#endif
#ifndef XK_Shift_L
#define XK_Shift_L 0xffe1
#endif
#ifndef XK_Shift_R
#define XK_Shift_R 0xffe2
#endif
#ifndef XK_Caps_Lock
#define XK_Caps_Lock 0xffe5
#endif
#ifndef XK_Backspace
#define XK_Backspace 0xff08
#endif

X11TextEntryPane instanceMethod subPaneKbd (Object subPane,
					    InputEvent event) {
  char c;
  CharCell new cc, cm;
  if (event eventData == subPane xWindowID) {

    if (event eventClass == KEYPRESS) {
      switch (event xEventData5)
	{
	case XK_Shift_L:
	case XK_Shift_R:
	  subPane shiftState |= shiftStateShift;
	  break;
	case XK_Control_L:
	case XK_Control_R:
	  subPane shiftState |= shiftStateCtrl;
	  break;
	case XK_Caps_Lock:
	  /* sticky key */
	  if (subPane shiftState & shiftStateCapsLock) {
	    subPane shiftState &= ~shiftStateCapsLock;
	  } else {
	    subPane shiftState |= shiftStateCapsLock;
	  }
	  break;
	case XK_Backspace:
	  /* at the moment, insertion is always at the end
	     of the text */
	  if (self chars size > 0) {
	    cc = self chars pop;
	    self draw;
	    self refresh;
	  }
	  break;
	default:
	  c = __edittext_xk_keysym (event xEventData4, self shiftState,
				    event xEventData5);
	  if ((subPane shiftState & shiftStateShift) ||
	      (subPane shiftState & shiftStateCapsLock)) {
	    /* We're just gonna do the shifted keys here. */
	    switch (c)
	      {
	      case '0':	c = ')'; break;
	      case '1': c = '!'; break;
	      case '2': c = '@'; break;
	      case '3': c = '#'; break;
	      case '4': c = '$'; break;
	      case '5': c = '%'; break;
	      case '6': c = '^'; break;
	      case '7': c = '&'; break;
	      case '8': c = '*'; break;
	      case '9': c = '('; break;
	      case '-': c = '_'; break;
	      case '=':	c = '+'; break;
	      case '\\':c = '|'; break;
	      case '`':	c = '~'; break;
	      case '[': c = '{'; break;
	      case ']':	c = '}'; break;
	      case ';':	c = ':'; break;
	      case '\'':c = '\"';break;
	      case ',': c = '<'; break;
	      case '.':	c = '>'; break;
	      case '/': c = '?'; break;
	      default: c &= ~32; break;
	      }
	  }
	  subPane entryText += c asString;
	  cc become CharCell basicNew c asString, c;
	  cc width = self ftFontVar textWidth cc asString;
	  self chars push cc;
	  self draw;
	  self refresh;
	  break;
	}
    } else if (event eventClass == KEYRELEASE) {
      switch (event xEventData5)
	{
	case XK_Shift_L:
	case XK_Shift_R:
	  subPane shiftState &= ~shiftStateShift;
	  break;
	case XK_Control_L:
	case XK_Control_R:
	  subPane shiftState &= ~shiftStateCtrl;
	  break;
	default:
	  break;
	}
    }
  }
}

X11TextEntryPane instanceMethod entryText (void) {
  returnObjectClass String;

  return self chars asString;
}
