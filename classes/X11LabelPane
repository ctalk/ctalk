/* $Id: X11LabelPane,v 1.2 2021/05/29 21:53:36 rkiesling Exp $ -*-c-*-*/

/*
  This file is part of Ctalk.
  Copyright © 2020, 2021  Robert Kiesling, rk3314042@gmail.com.
  Permission is granted to copy this software provided that this copyright
  notice is included in all source code modules.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
*/

/*
 *    X11LabelPane Class.
 */

/* 
 *  The X11LabelPane class defines the following resources.
 *
 *  font             A Fontconfig font specification.  These
 *                     are described in the X11FreeTypeFont
 *                     section of the Ctalk Language Reference.
 *  xFont              A X Logical Font Descriptor.  See
 *                     xfontsel(1).
 *
 *    These are all X11 compatible color names. Refer to 
 *      showrgb (1).
 *
 *      textColor                "black"
 *      foregroundColor          "white"
 *      backgroundColor          "gray"
 *      grayedColor              "gray"
 *      borderColor              "black"
 *      highlightTextColor       "black"
 *      highlightForegroundColor "orange"
 *      highlightBorderColor     "black"
 *      font                     "sans serif-12"
 *      boldFont                 "sans serif-12:weight=bold"
 *
 *  borderWidth                  1
 *  highlightBorderWidth         2
 *  highlightTextBold            false
 *
 *  NOTE: The corresponding instance variables are still in the
 *  the class definition, but they will go away in the future.
 */


X11CanvasPane class X11LabelPane;

#include <ctalk/ctalkdefs.h>

X11LabelPane instanceVariable border Boolean true
"Draw a border around the label.";
X11LabelPane instanceVariable borderColor String "black"
"The normal color of the border.";
X11LabelPane instanceVariable borderWidth Integer 0
"The normal width of the border.";
X11LabelPane instanceVariable margin Integer 2
"The distance between the border and the edge of the pane.";
X11LabelPane instanceVariable padding Integer 2
"The minimum distance between the interior of the border and the 
label's text.";
X11LabelPane instanceVariable textColor String "black"
"Color of the text when not highlighted.";
X11LabelPane instanceVariable textLine String ""
"Text of a single-line label.";
X11LabelPane instanceVariable highlightBorderWidth Integer 2
"Width of a highlighted border.";
X11LabelPane instanceVariable highlightBorderColor String "black"
"Color of a highlighted border.";
X11LabelPane instanceVariable highlightTextColor String "black"
"Color of highlighted text.";
X11LabelPane instanceVariable highlightForegroundColor String "skyblue"
"Color of highlighted background.";
X11LabelPane instanceVariable grayed Boolean false
"True if the label is grayed.";
X11LabelPane instanceVariable grayedColor String "gray"
"Color of grayed text.";
X11LabelPane instanceVariable haveMultiLine Boolean false
"True if the label text is composed of multiple lines.";
X11LabelPane instanceVariable textLines Array NULL
"Text of a multi-line label.";
X11LabelPane instanceVariable leading Integer 1
"Distance between text lines.  This is only effective when using
Freetype fonts - X fonts have leading included in the character
glyphs.";
X11LabelPane instanceVariable lineHeight Integer 0
"The height of a line of text, which is the font height plus the leading";
X11LabelPane instanceVariable parHeight Integer 0
"For multi-line labels, the height of all of the lines of text.
For single-line labels, the lineHeight and parHeight are the same.";
X11LabelPane instanceVariable justify Integer LABEL_CENTER
"Justify the text on the left or right side of the label, or center
the text.";
X11LabelPane instanceVariable radius Integer 0
"If greater than 0, draw borders as rounded rectangles with the radius
equal to this value";
X11LabelPane instanceVariable initialized Boolean false;
X11LabelPane instanceVariable boldFont X11FreeTypeFont NULL;

X11LabelPane instanceMethod new (String __paneName) {
  Method new exposeMethod;
  Method new enterMethod;
  Method new leaveMethod;
  Method new resizeMethod;

  X11LabelPane super new __paneName;

  exposeMethod definedInstanceMethod "X11LabelPane", "subPaneExpose";
  __paneName setMethodHandler "expose", exposeMethod;
  enterMethod definedInstanceMethod "X11LabelPane", "subPaneEnter";
  __paneName setMethodHandler "enternotify", enterMethod;
  leaveMethod definedInstanceMethod "X11LabelPane", "subPaneLeave";
  __paneName setMethodHandler "leavenotify", leaveMethod;
  resizeMethod definedInstanceMethod "X11LabelPane", "subPaneResize";
  __paneName setMethodHandler "resize", resizeMethod;

  __paneName resources atPut "backgroundColor", "gray";
  __paneName resources atPut "foregroundColor", "white";
  __paneName resources atPut "font", "sans-serif-12";
  __paneName resources atPut "boldFont", "sans-serif-12:weight=bold";
  __paneName resources atPut "textColor", "black";
  __paneName resources atPut "borderColor", "black";
  __paneName resources atPut "highlightTextColor", "black";
  __paneName resources atPut "highlightForegroundColor", "skyblue";
  __paneName resources atPut "xFont", "fixed";
  __paneName resources atPut "borderWidth", 1;
  __paneName resources atPut "highlightBorderWidth", 2;
  __paneName resources atPut "grayedColor", "gray";
  __paneName resources atPut "highlightBorderColor", "black";
  __paneName resources atPut "highlightTextBold", false;

  return __paneName;
}

X11LabelPane instanceMethod subPaneResize (X11Pane subPane,
					    InputEvent event) {
  int x_out, y_out, width_out, height_out;

  __ctalkX11WxHGeometry (event xEventData3, event xEventData4,
			 subPane subPaneGeometry,
			 &x_out, &y_out, &width_out, &height_out);

  self size x = width_out;
  self size y = height_out;
  self origin x = x_out;
  self origin y = y_out;

  __ctalkX11MoveWindow (subPane, x_out, y_out);
  __ctalkX11ResizeWindow (subPane, width_out, height_out, subPane depth);

  (X11Bitmap *)self paneBuffer resize self xWindowID,
    self size x, self size y;
  (X11Bitmap *)self paneBuffer background (self backgroundColor);
  (X11Bitmap *)self paneBackingStore resize self xWindowID,
    self size x, self size y;

}

X11LabelPane instanceMethod subPaneExpose (Object __subPane,
					  InputEvent __event) {
  "Handle an Expose event by redrawing the pane's contents
  on the parent window."
    self draw;
}

X11LabelPane instanceMethod subPaneEnter (Object __subPane,
					  InputEvent __event) {
  if (__subPane canFocus) {
    __subPane highlight = true;
    __subPane draw;
  }
}

X11LabelPane instanceMethod subPaneLeave (Object __subPane,
					  InputEvent __event) {
  if (__subPane canFocus) {
    __subPane highlight = false;
    __subPane draw;
  }
}

X11LabelPane instanceMethod selectFontOld (void) {
  "This has been superceded by X11CanvasPane : selectFont -
    use at own risk. ... "
  if (self resources keyExists "font") {
    self ftFontVar selectFontFromFontConfig self resources at "font";
  } else {
    /* for backward compatibility */
    self ftFontVar selectFontFromFontConfig self resources at "font";
  }
  self ftFontVar saveSelectedFont;
  self ftFontVar selectFont;
}

X11LabelPane instanceMethod font (String fontDesc) {
  self paneBuffer font fontDesc;
  self fontDescStr = fontDesc;
  self fontVar getFontInfo fontDesc;
  self resources replaceAt "xFont", fontDesc;
  __ctalkX11UseFontBasic (self displayPtr, self xWindowID, self xGC, fontDesc);
}

X11LabelPane instanceMethod text (String textArg) {
  self textLine = textArg;
}

X11LabelPane instanceMethod multiLine (String textArg) {

  if (!textArg split "\n", self textLines) {
    self textLines atPut 0, textArg;
  }
  self haveMultiLine = true; 
}

X11LabelPane instanceMethod __drawJustified (String textArg,
					     Integer lineStartY) {
  Integer new hAir, hCenter, lTextWidth;

  lTextWidth = self ftFontVar textWidth textArg;

  switch (self justify)
    {
    case LABEL_LEFT:
      self putStrXY self margin + self padding +
	self resources at "highlightBorderWidth", lineStartY value, textArg;
      break;
    case LABEL_CENTER:
      hCenter = (self size x / 2) - (lTextWidth / 2);
      hAir = hCenter - (hCenter / 10);
      self putStrXY hAir, lineStartY value, textArg;
      break;
    case LABEL_RIGHT:
      self putStrXY ((self size x) -
		     (self margin + self padding +
		      self resources at "highlightBorderWidth") -
		     lTextWidth,
		     lineStartY value, textArg);
      break;
    }

}

X11LabelPane instanceMethod fillStyle (void) {
  if (self grayed) {
    self background self resources at "foregroundColor";
  } else {
    if (self highlight) {
      self paneBuffer background self resources at "highlightForegroundColor";
    } else {
      self background self resources at "foregroundColor";
    }
  }
}

X11LabelPane instanceMethod borderStyle (void) {
  if (self grayed) {
    /* self pen width = self resources at "borderWidth"; *//***/
    self pen width = self borderWidth;
    self pen colorName = self resources at "grayedColor";
    self background self resources at "foregroundColor";
  } else {
    if (self highlight) {
      self pen width = self resources at "highlightBorderWidth";
      self pen colorName = self resources at "highlightBorderColor";
      self paneBuffer background self resources at "highlightForegroundColor";
    } else {
      /* self pen width = self resources at "borderWidth"; *//***/
      self pen width = self borderWidth;
      self pen colorName = self resources at "borderColor";
      self background self resources at "foregroundColor";
    }
  }
}

X11LabelPane instanceMethod drawBorder (void) {
  if (self radius > 0) {
    self drawRoundedRectangle (self margin),
      (self margin), 
      self size x - (self margin * 2),
      self size y - (self margin * 2),
      self radius;
  } else {
    self drawRectangle (self margin),
      (self margin),
      /* probably needs some adjustment in the drawing
	 functions, so these are consistent. */
      self size x - (self margin * 2),
      self size y - self margin;
  }
}

X11LabelPane instanceMethod draw (void) {
  Integer new lineStartY, vAir;
  
  self paneBuffer clear;
  self fillStyle;

  if (!self initialized) {
    /* Normally a widget class does its instance variable initialization
       in an "attachTo" method.  This class just uses the super : attachTo
       method instead, so we just initialize the instance variable states
       here. */
    self borderWidth = self resources at "borderWidth";
    self initialized = true;
    self ftFontVar selectFontFromFontConfig (self resources at "font");
    self ftFontVar namedX11Color self resources at "textColor";
    self ftFontVar saveSelectedFont;
    self boldFont selectFontFromFontConfig (self resources at "boldFont");
    self boldFont namedX11Color self resources at "textColor";
    self boldFont saveSelectedFont;
    self lineHeight = self ftFontVar height + self leading;
    self parHeight = self lineHeight * self textLines size;
  }

  if (self ftFontVar libIsInitialized) {
    if (self border) {
      self borderStyle;
      self drawBorder;
    }
    if (self grayed) {
      self ftFontVar alpha 0x8888;
      self faceRegular;
    } else {
      if (self highlight) {
	self ftFontVar namedX11Color self resources at "highlightTextColor";
	if (self resources integerAt "highlightTextBold" == true) {
	  self selectFont boldFont;
	} else {
	  self selectFont;
	}
      } else {
	self selectFont;
      }
    }

    vAir = self size y / 10;

    if (self haveMultiLine) {
      lineStartY = (self size y / 2) - (self parHeight / 2) + vAir;
      self textLines map {
	super __drawJustified self, lineStartY;
	lineStartY += super lineHeight;
      }
    } else {
      lineStartY = (self size y / 2) - (self lineHeight / 2) + vAir;
      self __drawJustified self textLine, lineStartY;
    }

  } else {
    /* X11 font */
    if (self grayed) {
      self foreground self resources at "grayedColor";
    } else {
      if (self highlight) {
        self foreground self resources at "highlightTextColor";
	if (self resources integerAt "highlightTextBold" == true) {
	  self faceBold;
 	} else {
	  self faceRegular;
	}
      } else {
	self foreground self resources at "textColor";
      }
    }
    self font self resources at "xFont";
    if (self haveMultiLine) {

      vAir = self size y / 10;
      lineStartY = (self size y / 2) - (self parHeight / 2) + vAir;

      self textLines map {
	super __drawJustified self, lineStartY;
	lineStartY += /* super fontVar height; */ super lineHeight;
      }

    } else {

      self __drawJustified self textLine, 
	((self size y / 2) - (self fontVar height / 2)) +
	(self fontVar height / 2);

    }
  }

  self refresh;
}

X11LabelPane instanceMethod drawButtonLayout (void) {
  "Similar to the draw method, except this method uses
   a different algorithm for spacing text."
    Integer new lineStartY, vAir;
  
  if (!self initialized) {
    /* See the comment in the draw method. */
    self borderWidth = self resources at "borderWidth";
    self initialized = true;
    self ftFontVar selectFontFromFontConfig (self resources at "font");
    self ftFontVar namedX11Color self resources at "textColor";
    self ftFontVar saveSelectedFont;
    self boldFont selectFontFromFontConfig (self resources at "boldFont");
    self boldFont namedX11Color self resources at "textColor";
    self boldFont saveSelectedFont;
    self lineHeight = self ftFontVar height + self leading;
    self parHeight = self lineHeight * self textLines size;
  }

  self paneBuffer clear;
  self fillStyle;

  if (self border) {
    self borderStyle;
    self drawBorder;
  }

  if (self ftFontVar libIsInitialized) {
    /* X11FreeTypeFont */
    if (self grayed) {
      self faceRegular;
      self ftFontVar namedX11Color self grayedColor;
    } else {
      if (self highlight) {
        self ftFontVar namedX11Color self resources at "highlightTextColor";
	if (self resources integerAt "highlightTextBold" == true) {
	  self faceBold;
 	} else {
	  self faceRegular;
	}
      } else {
        self ftFontVar namedX11Color self resources at "textColor";
	self faceRegular;
      }
    }
    if (self haveMultiLine) {

      /* self parHeight = (self ftFontVar ascent + self leading) *
	 self textLines size; */
      vAir = self size y / 20;
      lineStartY = (self size y / 2) - (self parHeight / 2) +
	self ftFontVar ascent - vAir;
      
      self textLines map {
	super __drawJustified self, lineStartY;
	lineStartY += super lineHeight;
      }
      
    } else {

      vAir = self size y / 20;
      self __drawJustified self textLine, 
	(self size y / 2) + (self ftFontVar ascent / 2) - vAir;

    }
  } else {
    if (self grayed) {
      self foreground self grayedColor;
    } else {
      if (self highlight) {
        self foreground self resources at "highlightTextColor";
      } else {
        self foreground self resources at "textColor";
      }
    }
    if (self haveMultiLine) {

      vAir = self size y / 10;
     self parHeight = self fontVar ascent  *
       self textLines size;
      lineStartY = (self size y / 2) - (self parHeight / 2) +
	(self fontVar ascent / 2) +  vAir;

      self textLines map {
	super __drawJustified self, lineStartY;
	lineStartY += super lineHeight;
      }

    } else {

      vAir = self size y / 20;
      self __drawJustified self textLine, 
      (self size y / 2) + (self fontVar ascent / 2) - vAir;

    }
  }

  self refresh;
}

