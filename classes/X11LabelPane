/* $Id: X11LabelPane,v 1.43 2020/04/23 22:47:45 rkiesling Exp $ -*-c-*-*/

/*
  This file is part of Ctalk.
  Copyright © 2020  Robert Kiesling, rk3314042@gmail.com.
  Permission is granted to copy this software provided that this copyright
  notice is included in all source code modules.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
*/

/*
 *    X11LabelPane Class.
 */

/* 
 *  The X11LabelPane class defines the following resources.
 *
 *  ftFont             A Fontconfig font specification.  These
 *                     are described in the X11FreeTypeFont
 *                     section of the Ctalk Language Reference.
 *  xFont              A X Logical Font Descriptor.  See
 *                     xfontsel(1).
 *
 *    These are all X11 compatible color names. Refer to 
 *      showrgb (1).
 *
 *      textColor                "black"
 *      foregroundColor          "white"
 *      backgroundColor          "gray"
 *      grayedColor              "gray"
 *      borderColor              "black"
 *      highlightTextColor       "black"
 *      highlightForegroundColor "orange"
 *      highlightBorderColor     "black"
 *
 *  borderWidth                  1
 *  highlightBorderWidth         2
 *  highlightTextBold            false
 *
 *  NOTE: The corresponding instance variables are still in the
 *  the class definition, but they will go away in the future.
 */


X11CanvasPane class X11LabelPane;

#include <ctalk/ctalkdefs.h>

X11LabelPane instanceVariable border Boolean true
"Draw a border around the label.";
X11LabelPane instanceVariable borderColor String "black"
"The normal color of the border.";
X11LabelPane instanceVariable borderWidth Integer 1
"The normal width of the border.";
X11LabelPane instanceVariable margin Integer 2
"The distance between the border and the edge of the pane.";
X11LabelPane instanceVariable padding Integer 2
"The minimum distance between the interior of the border and the 
label's text.";
X11LabelPane instanceVariable textColor String "black"
"Color of the text when not highlighted.";
X11LabelPane instanceVariable textLine String ""
"Text of a single-line label.";
X11LabelPane instanceVariable highlightBorderWidth Integer 2
"Width of a highlighted border.";
X11LabelPane instanceVariable highlightBorderColor String "black"
"Color of a highlighted border.";
X11LabelPane instanceVariable highlightTextColor String "black"
"Color of highlighted text.";
X11LabelPane instanceVariable highlightForegroundColor String "skyblue"
"Color of highlighted background.";
X11LabelPane instanceVariable grayed Boolean false
"True if the label is grayed.";
X11LabelPane instanceVariable grayedColor String "gray"
"Color of grayed text.";
X11LabelPane instanceVariable haveMultiLine Boolean false
"True if the label text is composed of multiple lines.";
X11LabelPane instanceVariable textLines Array NULL
"Text of a multi-line label.";
X11LabelPane instanceVariable leading Integer 1
"Distance between text lines.  This is only effective when using
Freetype fonts - X fonts have leading included in the character
glyphs.";
X11LabelPane instanceVariable justify Integer LABEL_CENTER
"Justify the text on the left or right side of the label, or center
the text.";
X11LabelPane instanceVariable radius Integer 0
"If greater than 0, draw borders as rounded rectangles with the radius
equal to this value";

X11LabelPane instanceMethod new (String __paneName) {
  Method new exposeMethod;
  Method new enterMethod;
  Method new leaveMethod;

  X11LabelPane super new __paneName;

  exposeMethod definedInstanceMethod "X11LabelPane", "subPaneExpose";
  __paneName setMethodHandler "expose", exposeMethod;
  enterMethod definedInstanceMethod "X11LabelPane", "subPaneEnter";
  __paneName setMethodHandler "enternotify", enterMethod;
  leaveMethod definedInstanceMethod "X11LabelPane", "subPaneLeave";
  __paneName setMethodHandler "leavenotify", leaveMethod;

  __paneName resources atPut "backgroundColor", "gray";
  __paneName resources atPut "foregroundColor", "white";
  __paneName resources atPut "ftFont", "sans-serif-12";
  __paneName resources atPut "textColor", "black";
  __paneName resources atPut "borderColor", "black";
  __paneName resources atPut "highlightTextColor", "black";
  __paneName resources atPut "highlightForegroundColor", "orange";
  __paneName resources atPut "xFont", "fixed";
  __paneName resources atPut "borderWidth", 1;
  __paneName resources atPut "highlightBorderWidth", 2;
  __paneName resources atPut "grayedColor", "gray";
  __paneName resources atPut "highlightBorderColor", "black";
  __paneName resources atPut "highlightTextBold", false;

  return __paneName;
}

X11LabelPane instanceMethod subPaneExpose (Object __subPane,
					  InputEvent __event) {
  "Handle an Expose event by redrawing the pane's contents
  on the parent window."
    self draw;
}

X11LabelPane instanceMethod subPaneEnter (Object __subPane,
					  InputEvent __event) {
  if (__subPane canFocus) {
    __subPane highlight = true;
    __subPane draw;
  }
}

X11LabelPane instanceMethod subPaneLeave (Object __subPane,
					  InputEvent __event) {
  if (__subPane canFocus) {
    __subPane highlight = false;
    __subPane draw;
  }
}

X11LabelPane instanceMethod font (String fontDesc) {
  self paneBuffer font fontDesc;
  self fontDescStr = fontDesc;
  self fontVar getFontInfo fontDesc;
  self resources replaceAt "xFont", fontDesc;
  __ctalkX11UseFontBasic (self displayPtr, self xWindowID, self xGC, fontDesc);
}

X11LabelPane instanceMethod text (String textArg) {
  self textLine = textArg;
}

X11LabelPane instanceMethod multiLine (String textArg) {

  if (!textArg split "\n", self textLines) {
    self textLines atPut 0, textArg;
  }
  self haveMultiLine = true; 
}

#if 0 /***/
X11LabelPane instanceMethod __highlightBackground (String color) {
  "Highlight the background without affecting the original
   background color containd in the receiver's backgroundColor
   instance variable."
  if (self paneBuffer xID > 0) {
      self paneBuffer background color;
    }
}
#endif

X11LabelPane instanceMethod __drawJustified (String textArg,
					     Integer textWidth,
					     Integer lineStartY) {

  switch (self justify)
    {
    case LABEL_LEFT:
      self putStrXY self margin + self padding +
	self resources at "highlightBorderWidth", lineStartY value, textArg;
      break;
    case LABEL_CENTER:
      self putStrXY ((self size x / 2) - (textWidth / 2)),
	lineStartY value, textArg;
      break;
    case LABEL_RIGHT:
      self putStrXY ((self size x) -
		     (self margin + self padding +
		      self resources at "highlightBorderWidth") -
		     textWidth,
		     lineStartY value, textArg);
      break;
    }

}

X11LabelPane instanceMethod fillStyle (void) {
  if (self grayed) {
    self background self resources at "foregroundColor";
  } else {
    if (self highlight) {
      self paneBuffer background self resources at "highlightForegroundColor";
    } else {
      self background self resources at "foregroundColor";
    }
  }
}

X11LabelPane instanceMethod borderStyle (void) {
  if (self grayed) {
    self pen width = self resources at "borderWidth";
    self pen colorName = self resources at "grayedColor";
    self background self resources at "foregroundColor";
  } else {
    if (self highlight) {
      self pen width = self resources at "highlightBorderWidth";
      self pen colorName = self resources at "highlightBorderColor";
      self paneBuffer background self resources at "highlightForegroundColor";
    } else {
      self pen width = self resources at "borderWidth";
      self pen colorName = self resources at "borderColor";
      self background self resources at "foregroundColor";
    }
  }
}

X11LabelPane instanceMethod drawBorder (void) {
  if (self radius > 0) {
    self drawRoundedRectangle (self margin),
      (self margin), 
      self size x - (self margin * 2),
      self size y - (self margin * 2),
      self radius;
  } else {
    self drawRectangle (self margin),
      (self margin), 
      self size x - (self margin * 2),
      self size y - (self margin * 2);
  }
}

X11LabelPane instanceMethod draw (void) {
  Integer new ts, parheight, lineStartY, vAir;
  
  self paneBuffer clear;
  self fillStyle;
  if (self border) {
    self borderStyle;
    self drawBorder;
  }

  if (self ftFontVar libIsInitialized) {
    /* X11FreeTypeFont */
    self ftFontVar selectFontFromFontConfig self resources at "ftFont";
    self ftFontVar saveSelectedFont;
    if (self grayed) {
      /* leave like this until we figure out why lighter grays don't
	 display */
      self ftFontVar namedX11Color "dimgray";
      self ftFontVar alpha 0x8888;
      self faceRegular;
    } else {
      if (self highlight) {
	self ftFontVar namedX11Color self resources at "highlightTextColor";
	if (self resources at "highlightTextBold") {
	  self faceBold;
 	} else {
	  self faceRegular;
	}
      } else {
	self ftFontVar namedX11Color self resources at "textColor";
	self faceRegular;
      }
    }
    if (self haveMultiLine) {

      parheight = (self ftFontVar height + self leading) *
	self textLines size;
      vAir = self size y / 10;
      lineStartY = (self size y / 2) - (parheight / 2) + vAir;


      self textLines map {
	ts = super ftFontVar textWidth self;
	super __drawJustified self, ts, lineStartY;
	lineStartY += super ftFontVar height + super leading;
      }
      
    } else {

      ts = self ftFontVar textWidth (self textLine);
      self __drawJustified self textLine, ts,
	(self size y / 2) - (self ftFontVar height / 2) +
	(self ftFontVar height / 2);

    }
  } else {
    /* X11 font */
    if (self grayed) {
      self foreground self resources at "grayedColor";
    } else {
      if (self highlight) {
        self foreground self resources at "highlightTextColor";
      } else {
	self foreground self resources at "textColor";
      }
    }
    self font self resources at "xFont";
    if (self haveMultiLine) {

      parheight = self fontVar height  *
	self textLines size;
      vAir = self size y / 10;
      lineStartY = (self size y / 2) - (parheight / 2) + vAir;

      self textLines map {
	ts = super fontVar textWidth self;
	super __drawJustified self, ts, lineStartY;
	lineStartY += super fontVar height;
      }

    } else {

      ts = self fontVar textWidth (self textLine);
      self __drawJustified self textLine, ts,
	((self size y / 2) - (self fontVar height / 2)) +
	(self fontVar height / 2);

    }
  }

  self refresh;
}

X11LabelPane instanceMethod drawButtonLayout (void) {
  "Similar to the draw method, except this method uses
   a different algorithm for spacing text."
    Integer new ts, parheight, lineStartY, vAir;
  
  self paneBuffer clear;
  self fillStyle;
  if (self border) {
    self borderStyle;
    self drawBorder;
  }

  if (self ftFontVar libIsInitialized) {
    /* X11FreeTypeFont */
    self ftFontVar selectFontFromFontConfig self resources at "ftFont";
    self ftFontVar saveSelectedFont;
    if (self grayed) {
      self faceRegular;
      self ftFontVar namedX11Color self grayedColor;
    } else {
      if (self highlight) {
	if (self resources at "highlightTextBold") {
	  self faceBold;
 	} else {
	  self faceRegular;
	}
        self ftFontVar namedX11Color self resources at "highlightTextColor";
      } else {
	self faceRegular;
        self ftFontVar namedX11Color self resources at "textColor";
      }
    }
    if (self haveMultiLine) {

      parheight = (self ftFontVar ascent + self leading) *
	self textLines size;
      vAir = self size y / 20;
      lineStartY = (self size y / 2) - (parheight / 2) +
	self ftFontVar ascent - vAir;
      
      self textLines map {
	ts = super ftFontVar textWidth self;
	super __drawJustified self, ts, lineStartY;
	lineStartY += super ftFontVar ascent + super leading;
      }
      
    } else {

      vAir = self size y / 20;
      ts = self ftFontVar textWidth (self textLine);
      self __drawJustified self textLine, ts,
	(self size y / 2) + (self ftFontVar ascent / 2) - vAir;

    }
  } else {
    if (self grayed) {
      self foreground self grayedColor;
    } else {
      if (self highlight) {
        self foreground self resources at "highlightTextColor";
      } else {
        self foreground self resources at "textColor";
      }
    }
    if (self haveMultiLine) {

      vAir = self size y / 10;
      parheight = self fontVar ascent  *
	self textLines size;
      lineStartY = (self size y / 2) - (parheight / 2) +
	(self fontVar ascent / 2) +  vAir;

      self textLines map {
	ts = super fontVar textWidth self;
	super __drawJustified self, ts, lineStartY;
	lineStartY += super fontVar ascent;
      }

    } else {

      vAir = self size y / 20;
      ts = self fontVar textWidth (self textLine);
      self __drawJustified self textLine, ts,
	(self size y / 2) + (self fontVar ascent / 2) - vAir;

    }
  }

  self refresh;
}

