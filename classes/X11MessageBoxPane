/* $Id: X11MessageBoxPane,v 1.59 2020/03/27 20:18:14 rkiesling Exp $ -*-C-*-*/

/*
  This file is part of Ctalk.
  Copyright © 2020  Robert Kiesling, rk3314042@gmail.com.
  Permission is granted to copy this software provided that this copyright
  notice is included in all source code modules.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
*/

/* 
   X11MessageBoxPane Class

   This class uses the following resources:

   backgroundColor      String    gray
   pad                  Integer   10
   messageText          String    Your\Message\nHere
   buttonText           String    Ok

*/

X11PaneDispatcher class X11MessageBoxPane;

X11MessageBoxPane instanceVariable button X11ButtonPane NULL;
X11MessageBoxPane instanceVariable label  X11LabelPane NULL;
X11MessageBoxPane instanceVariable initialized Boolean false;


X11MessageBoxPane instanceMethod new (String paneName) {
  Method new exposeMethod, buttonPressMethod;

  X11MessageBoxPane super new paneName;
  
  exposeMethod definedInstanceMethod "X11MessageBoxPane", "subPaneExpose";
  paneName setMethodHandler "expose", exposeMethod;

  buttonPressMethod definedInstanceMethod "X11MessageBoxPane",
    "subPaneButton";
  paneName setMethodHandler "pointerinput", buttonPressMethod;
  
  paneName backgroundColor = "white";
  paneName foregroundColor = "black";

  paneName resources atPut "backgroundColor", "gray";
  paneName resources atPut "pad", 10;
  paneName resources atPut "messageText", "Your\nMessage\nHere";
  paneName resources atPut "buttonText", "Ok";

  return paneName;
}

X11MessageBoxPane instanceMethod subPaneExpose (Object __subPane,
					  InputEvent __event) {
  "Handle an Expose event by redrawing the pane's contents
  on the parent window."
    __subPane draw;
    __subPane refresh;
}

X11MessageBoxPane instanceMethod subPaneButton (Object __subPane,
					  InputEvent __event) {
  switch (__event eventClass)
    {
    case BUTTONPRESS:
      self button clicked = true;
      if (!self button clickSet)
	self button clickSet = true;
      break;
    case BUTTONRELEASE:
      self button clicked = false;
      break;
    }
  self button draw;
  self button refresh;
}

X11MessageBoxPane instanceMethod attachTo (Object parentPane,
					   String geomspec) {
  "Register the receiver pane as a subpane of the X11Pane
  given as the argument.  Generally parent pane should
  be a X11PaneDispatcher object.  If the main window of the
  program has set foreground and background colors, the 
  X11MessageBoxPane window inherites the colors."
  X11Pane new mainWin;
  X11Bitmap new xPaneBuffer;
  X11Bitmap new xPaneBackingStore;
  int x, y, width, height;
  
  self displayPtr = self mainWindow displayPtr;
  mainWin become parentPane mainWindow;

  self container = parentPane;
  self paneBuffer become xPaneBuffer;
  self paneBackingStore become xPaneBackingStore;

  __ctalkX11SubWindowGeometry (parentPane, geomspec,
			       &x, &y, &width, &height);

  self size x = width;
  self size y = height;
  self origin x = x;
  self origin y = y;

  if (!self foregroundColor) {
    if (mainWin foregroundColor)
      self foregroundColor = mainWin foregroundColor;
  }
  if (!self backgroundColor) {
    if (mainWin backgroundColor)
      self backgroundColor = mainWin backgroundColor;
  }

  if (mainWin ftFontVar libIsInitialized) {
    self ftFontVar become mainWin ftFontVar;
  } else if (mainWin fontVar fontId != 0) {
    self fontVar become mainWin fontVar;
  } else {
    self font "fixed";
  }

  return NULL;
}

X11MessageBoxPane instanceMethod fill (String colorName) {
  "Sets the message box's background color to the argument and 
   fills the messagebox's area with that color.  Temporarily
   sets the pane's foreground to the background color so the 
   color change is visible without drawing anything else."
    String new saveFgColor;
  String new saveFgColor;


  saveFgColor = self foregroundColor;
  self paneBuffer background colorName;
  self paneBuffer foreground colorName;
  XFillRectangle (self displayPtr, self paneBuffer xID, self paneBuffer xGC,
		  0, 0, self size x, self size y);
  self paneBuffer foreground saveFgColor;
}

X11MessageBoxPane instanceMethod draw (void) {
  
  self fill self resources at "backgroundColor";

  self label draw;
  self button draw;
}

X11MessageBoxPane instanceMethod refresh (void) {
  __ctalkGUIPaneRefresh (self, 0, 0,
   			 self size x,
   			 self size y,
   			 0, 0);
  self label refresh;
  self button refresh;
}

X11MessageBoxPane instanceMethod withdraw (void) {
  __ctalkCloseX11DialogPane (self);
  XUnmapSubwindows (self displayPtr, self xWindowID);
  XUnmapWindow (self displayPtr, self xWindowID);
  XFlush (self displayPtr);
}

extern Atom wm_delete_dialog;

X11MessageBoxPane instanceMethod initWidgets (void) {
  "Initialize the message box's button and label widgets.  The
   message box defers constructing the new widgets until just
   before it is displayed, so any modifications to the defaults
   (colors, dimensions, etc.) can be done here, mainly by
   subclassing the X11MessageBox class (for the present, at 
   least, until Ctalk includes some sort of resource manager).
   However, waiting until now to construct the widgets also
   has the advantage that all of the other objects and methods
   in a program have been defined."

  X11ButtonPane new l_button;
  X11LabelPane new l_label;

  if (self initialized)
    return NULL;

  Integer new usable_height, usable_width, padInt, label_width_px,
    label_height_px, label_x_px, label_y_px, button_y_px;
  String new geomspec;

  padInt = self resources at "pad";

  usable_height = self size y - (padInt * 2);
  usable_width = self size x - (padInt * 2);
  label_width_px = usable_width;
  label_height_px = usable_height * .8 - (padInt / 2);
  label_x_px = padInt;
  label_y_px = padInt;

  geomspec printOn "%dx%d+%d+%d", label_width_px, label_height_px,
    label_x_px, label_y_px;

  l_label background self resources at "backgroundColor";
  l_label multiLine self resources at "messageText";
  l_label border = false;

  self label become l_label;

  self label attachTo self, geomspec;

  self button become l_button;

  button_y_px = label_height_px + (padInt * 2);

  geomspec printOn "20%%x30+40%%+%d", button_y_px;
  self button attachTo self, geomspec;

  self button label text (self resources at "buttonText");

  self initialized = true;

}

extern void __enable_dialog (void);

X11MessageBoxPane instanceMethod show (void) {
  Display *display;
  Window win_id;
  XEvent xev;
  X11PaneDispatcher new dispatcher;
  X11Pane new mainWin;
  InputEvent new e;

  dispatcher = *self container;
  mainWin = dispatcher mainWindow;
  
  if (!self initialized) {

    win_id = __ctalkX11CreateDialogWindow (self);
    self xWindowID = win_id;
    dispatcher modalWin = win_id;
    dispatcher modalPane = self;

    display = self displayPtr;
  
    (X11Bitmap *)self paneBuffer create self displayPtr, self xWindowID, 
      self size x, self size y, self depth;
    (X11Bitmap *)self paneBuffer background (self backgroundColor);
    (X11Bitmap *)self paneBuffer foreground (self foregroundColor);
    (X11Bitmap *)self paneBackingStore create self displayPtr, self xWindowID,
      self size x, self size y, self depth;

    self initWidgets;
  } else {

    __enable_dialog ();

    win_id = self xWindowID;
    display = self displayPtr;

  }

  XMapWindow (display, win_id);
  XMapSubwindows (display, win_id);
  XRaiseWindow (display, win_id);

  self clearWindow;

  while (1) {
    if (XPending (display)) {
      XNextEvent (display, &xev);
      switch (xev.type)
	{
	case ButtonPress:
	  if (xev.xbutton.window == self button xWindowID) {
	    e eventClass = BUTTONPRESS;
	    self methodObjectMessage self handlePointerInput, self, e;
	  }
	  break;
	case ButtonRelease:
	  self withdraw;
	  dispatcher modalWin = 0;
	  dispatcher modalPane = NULL;
	  if (xev.xbutton.window == self button xWindowID) {
	    e eventClass = BUTTONRELEASE;
	    self methodObjectMessage self handlePointerInput, self, e;
	  }
	  return self;
	  break;
	case Expose:
	  self methodObjectMessage self handleExpose, self, e;
	  break;
	case ClientMessage:
	  if(xev.xclient.data.l[0] == wm_delete_dialog) {
	    self withdraw;
	    dispatcher modalWin = 0;
	    dispatcher modalPane = NULL;
	    return self;
	  }
	  break;
	}
    } else {
      usleep (5000);
    }
  }

}

