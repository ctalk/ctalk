/* $Id: X11MessageBoxPane,v 1.7 2020/02/28 15:21:49 rkiesling Exp $ -*-C-*-*/

/*
  This file is part of Ctalk.
  Copyright © 2020  Robert Kiesling, rk3314042@gmail.com.
  Permission is granted to copy this software provided that this copyright
  notice is included in all source code modules.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
*/

X11PaneDispatcher class X11MessageBoxPane;

X11MessageBoxPane instanceVariable popup Boolean true;

X11MessageBoxPane instanceMethod new (String paneName) {
  Method new exposeMethod;

  X11MessageBoxPane super new paneName;
  
  exposeMethod definedInstanceMethod "X11MessageBoxPane", "subPaneExpose";
  paneName setMethodHandler "expose", exposeMethod;
  return paneName;
}

X11MessageBoxPane instanceMethod subPaneExpose (Object __subPane,
					  InputEvent __event) {
  "Handle an Expose event by redrawing the pane's contents
  on the parent window."
    printf ("subPaneExpose!\n");
#if 0 /***/
    __subPane refresh;
#endif  
}

X11MessageBoxPane instanceMethod attachTo (Object parentPane,
					   String geomspec) {
  "Register the receiver pane as a subpane of the X11Pane
  given as the argument.  Generally parent pane should
  be a X11PaneDispatcher object."
  X11Bitmap new xPaneBuffer;
  X11Bitmap new xPaneBackingStore;
  int x, y, width, height;
  
  self displayPtr = self mainWindow displayPtr;

  /* self super attachTo parentPane; *//***/
  /*
   ***  NOTE THIS IS NOT ADDED TO THE DISPATCHER's CHILDREN LIST
        IMMEDIATELY.
   */
  self container = parentPane;
  self paneBuffer become xPaneBuffer;
  self paneBackingStore become xPaneBackingStore;

  __ctalkX11SubWindowGeometry (parentPane, geomspec,
			       &x, &y, &width, &height);

  self size x = width;
  self size y = height;
  self origin x = x;
  self origin y = y;

  self backgroundColor = "blue";

  /*
   *  The evaluation of these statements  needs to be deferred
   *  until run time.  See the comment in the other, "attachTo,"
   *  method, below.
   */
  (X11Bitmap *)self paneBuffer create self xWindowID, self size x, 
    self size y, self depth;
  (X11Bitmap *)self paneBuffer background (self backgroundColor);
  (X11Bitmap *)self paneBackingStore create self xWindowID, self size x, 
    self size y, self depth;

  self paneBuffer background self backgroundColor;

  return NULL;
}

X11MessageBoxPane instanceMethod draw (void) {

  XFillRectangle (self displayPtr, self paneBuffer xID,
		  self paneBuffer xGC,
		  0, 0, self paneBuffer width, self paneBuffer height);
}

X11MessageBoxPane instanceMethod refresh (void) {
  Display *disp;
  Drawable buffer_id;
  Drawable win_id;
  GC gc;

  disp = self displayPtr;
  buffer_id = self paneBuffer xID;
  win_id = self xWindowID;
  gc = self xGC;
  XCopyArea (disp, buffer_id, win_id, gc,
	     0, 0, self size x, self size y, 0, 0);
}

X11MessageBoxPane instanceMethod withdraw (void) {
  self deleteAndClose;
}

extern Atom wm_delete_window;

X11MessageBoxPane instanceMethod show (void) {
  Display *d;
  Window win_id;
  XEvent xev;
  X11PaneDispatcher new dispatcher;

  dispatcher = *self container;
  
  win_id = __ctalkX11CreateDialogWindow (self);
  self xWindowID = win_id;
  dispatcher modalWin = win_id;

  d = self displayPtr;

  XMapWindow (d, win_id);
  XRaiseWindow (d, win_id);

  while (TRUE) {
    if (XPending (d)) {
      XNextEvent (d, &xev);
      switch (xev.type)
	{
	case Expose:
	  printf ("expose!\n");
	  self draw;
	  self refresh;
	  break;
	case ClientMessage:
	  if(xev.xclient.data.l[0] == wm_delete_window) {
	    self withdraw;
	    return;
	  }
	  break;
	}
    } else {
      usleep (1000);
    }
  }
  return self;
}
