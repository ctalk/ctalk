/* $Id: X11MessageBoxPane,v 1.2 2021/01/29 00:48:41 rkiesling Exp $ -*-C-*-*/

/*
  This file is part of Ctalk.
  Copyright © 2020  Robert Kiesling, rk3314042@gmail.com.
  Permission is granted to copy this software provided that this copyright
  notice is included in all source code modules.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
*/

/* 
   X11MessageBoxPane Class

   This class uses the following resources:

   backgroundColor      String    "gray"
   foregroundColor      String    "gray"
   pad                  Integer   10
   messageColor         String    "black"
   messageFont          String    "sans serif-12"
   messageText          String    "Sample message text."
   buttonText           String    "Ok"
   geometry             String    <w>x<h>+<x>+<y>
   iconID               Integer   0
   titleText            String    "Message"
   
*/

X11PaneDispatcher class X11MessageBoxPane;

X11MessageBoxPane instanceVariable button X11ButtonPane NULL;
X11MessageBoxPane instanceVariable label  X11LabelPane NULL;
X11MessageBoxPane instanceVariable icon X11Bitmap NULL;
X11MessageBoxPane instanceVariable initialized Boolean false;
X11MessageBoxPane instanceVariable mainWindowPtr Symbol NULL;
X11MessageBoxPane instanceVariable keyState Integer 0;

/* We only need this to handle Tab and Enter keyboard 
   equivalents. */
#define KEY_TAB   1
#define KEY_ENTER 2

#include <ctalk/ctalkdefs.h>

X11MessageBoxPane instanceMethod new (String paneName) {
  Method new exposeMethod, buttonPressMethod, kbdInputMethod,
    enterMethod, leaveMethod;

  X11MessageBoxPane super new paneName;
  
  exposeMethod definedInstanceMethod "X11MessageBoxPane", "subPaneExpose";
  paneName setMethodHandler "expose", exposeMethod;

  buttonPressMethod definedInstanceMethod "X11MessageBoxPane",
    "subPaneButton";
  paneName setMethodHandler "pointerinput", buttonPressMethod;
  
  kbdInputMethod definedInstanceMethod "X11MessageBoxPane",
    "subPaneKbdInput";
  paneName setMethodHandler "kbdinput", kbdInputMethod;

  enterMethod definedInstanceMethod "X11MessageBoxPane",
    "subPaneEnter";
  paneName setMethodHandler "enternotify", enterMethod;
  leaveMethod definedInstanceMethod "X11MessageBoxPane",
    "subPaneLeave";
  paneName setMethodHandler "leavenotify", leaveMethod;

  paneName resources atPut "backgroundColor", "gray";
  paneName resources atPut "foregroundColor", "gray";
  paneName resources atPut "pad", 10;
  paneName resources atPut "messageText", "Hello, messageBox!\nSample message text.";

  paneName resources atPut "buttonText", "Ok";
  paneName resources atPut "iconID", 0;
  paneName resources atPut "titleText", "Message";
  paneName resources atPut "messageColor", "black";
  paneName resources atPut "messageFont", "sans serif-12";

  return paneName;
}

/* These are from X11/keysymdef.h if your machine defines them
   differently. */
#ifndef XK_Tab
#define XK_Tab  0xff09
#endif
#ifndef XK_Return
#define XK_Return  0xff0d
#endif

X11MessageBoxPane instanceMethod subPaneKbdInput (Object __subPane,
						  InputEvent __event) {
  switch (__event xEventData4)
    {
    case XK_Tab:
      self keyState = KEY_TAB;
      if (self button label borderWidth > 0) {
	self button label highlightBorderWidth =
	  self button label borderWidth * 2;
      } else {
	self button label highlightBorderWidth = 2;
      }
      self button label highlight = true;
      self draw;
      self refresh;
      break;
    case XK_Return:
      if (self keyState == KEY_TAB) {
	self keyState = KEY_ENTER;
      }
      break;
    }
}

X11MessageBoxPane instanceMethod subPaneExpose (Object __subPane,
					  InputEvent __event) {
  "Handle an Expose event by redrawing the pane's contents
  on the parent window."
    __subPane draw;
    __subPane refresh;
}

X11MessageBoxPane instanceMethod subPaneButton (Object __subPane,
					  InputEvent __event) {
  switch (__event eventClass)
    {
    case BUTTONPRESS:
      self button clicked = true;
      if (!self button clickSet)
	self button clickSet = true;
      break;
    case BUTTONRELEASE:
      self button clicked = false;
      break;
    }
  self button draw;
  self button refresh;
}

X11MessageBoxPane instanceMethod subPaneEnter (Object subPane,
					  InputEvent __event) {
  if (__event eventData == subPane button xWindowID) {
    if (subPane button canFocus) {
      if (self button clicked) {
	self button clicked = false;
      }
      if (!self button hover) {
	subPane button label highlight = true;
	self button hover = true;
      }
      if (!self button radius)
	self button label drawButtonLayout;
      subPane button draw;
      subPane button refresh;
    }
  } else if (self button clicked) {
    self button clicked = false;
    if (!self button radius)
      self button label drawButtonLayout;
    subPane button draw;
    subPane button refresh;
  }
}

X11MessageBoxPane instanceMethod subPaneLeave (Object subPane,
					  InputEvent __event) {
  if (__event eventData == subPane button xWindowID) {
    if (subPane button canFocus) {
      if (self button hover) {
	subPane button label highlight = false;
	if (self button clicked)
	  self button clicked = false;
	self button label drawButtonLayout;
	subPane button draw;
	subPane button refresh;
	self button hover = false;
      }
    }
  }
}

X11MessageBoxPane instanceMethod attachTo (X11Pane parentPane,
					   String geomspec) {
  "Register the receiver pane as a subpane of the X11Pane
  given as the argument.  Generally parent pane should
  be a X11PaneDispatcher object.  At this time, a geometry
  specification like, '300x200', i.e., without the x and
  y origins, is okay - the Ctalk libraries center the
  message box above the parent window."
  X11Bitmap new xPaneBuffer;
  X11Bitmap new xPaneBackingStore;
  String new parentGeometry;
  int x, y, width, height;
  unsigned int mainWinID;
  
  self displayPtr = self mainWindow displayPtr;

  self container = parentPane;
  self paneBuffer become xPaneBuffer;
  self paneBackingStore become xPaneBackingStore;

  __ctalkX11SubWindowGeometry (parentPane, geomspec,
			       &x, &y, &width, &height);

  self size x = width;
  self size y = height;
  self origin x = x;
  self origin y = y;

  self resources atPut "geometry", geomspec;

  self mainWindowPtr = parentPane mainWindow;

  return NULL;
}

X11MessageBoxPane instanceMethod fill (String colorName) {
  "Sets the message box's background color to the argument and 
   fills the messagebox's area with that color.  Temporarily
   sets the pane's foreground to the background color so the 
   color change is visible without drawing anything else."
    String new saveFgColor;


  saveFgColor = self foregroundColor;
  self paneBuffer background colorName;
  self paneBuffer foreground colorName;
  XFillRectangle (self displayPtr, self paneBuffer xID, self paneBuffer xGC,
		  0, 0, self size x, self size y);
  self paneBuffer foreground saveFgColor;
}

X11MessageBoxPane instanceMethod draw (void) {
  
  self fill self resources at "backgroundColor";

  self label draw;
  self button draw;

  if (self resources at "iconID" > 0) {
    self paneBuffer copy self icon, 0, 0, ICON_WIDTH_PX, ICON_HEIGHT_PX,
      ((self resources at "pad") * 2),
      ((self resources at "pad") + (self label size y / 2) -
       (ICON_HEIGHT_PX / 2));
  }
}

X11MessageBoxPane instanceMethod refresh (void) {
  __ctalkGUIPaneRefresh (self, 0, 0,
   			 self size x,
   			 self size y,
   			 0, 0);
  self label refresh;
  self button refresh;
}

X11MessageBoxPane instanceMethod withdraw (void) {
  __ctalkCloseX11DialogPane (self);
  XUnmapSubwindows (self displayPtr, self xWindowID);
  XUnmapWindow (self displayPtr, self xWindowID);
  XFlush (self displayPtr);
}

X11MessageBoxPane instanceMethod drawIcon (void) {

  switch (self resources at "iconID")
    {
    case ICON_STOP:
      self icon iconStop;
      break;
    case ICON_CAUTION:
      self icon iconCaution;
      break;
    case ICON_INFO:
      self icon iconInfo;
      break;
    }
}

X11MessageBoxPane instanceMethod initWidgets (void) {
  "Initialize the message box's button and label widgets.  The
   message box defers constructing the new widgets until just
   before it is displayed, so any modifications to the defaults
   (colors, dimensions, etc.) can be done here, mainly by
   subclassing the X11MessageBox class (for the present, at 
   least, until Ctalk includes some sort of resource manager).
   However, waiting until now to construct the widgets also
   has the advantage that all of the other objects and methods
   in a program have been defined."

  X11ButtonPane new l_button;
  X11LabelPane new l_label;
  X11Bitmap new l_icon;
  Integer new usable_height, usable_width, padInt, label_width_px,
    label_height_px, label_x_px, label_y_px, button_y_px;
  String new geomspec;

  if (self initialized)
    return NULL;

  padInt = self resources at "pad";

  usable_height = self size y - (padInt * 2);
  usable_width = self size x - (padInt * 2);
  label_width_px = usable_width;
  label_height_px = usable_height * .8 - (padInt / 2);
  label_x_px = padInt;
  label_y_px = padInt;

  if (self resources at "iconID" > 0) {
    label_x_px += ICON_WIDTH_PX + (padInt * 2);
    label_width_px -= (ICON_WIDTH_PX + (padInt * 2));
  }

  geomspec printOn "%dx%d+%d+%d", label_width_px, label_height_px,
    label_x_px, label_y_px;

  l_label resources replaceAt "backgroundColor",
    (self resources at "backgroundColor");
  l_label resources replaceAt "foregroundColor",
    (self resources at "foregroundColor");
  l_label multiLine self resources at "messageText";
  l_label border = false;
  l_label resources replaceAt "textColor",
    (self resources at "messageColor");
  l_label resources replaceAt "font",
    (self resources at "messageFont");
  l_label justify = LABEL_LEFT;

  self label become l_label;

  self label attachTo self, geomspec;

  self button become l_button;
  self children push l_button;

  button_y_px = label_height_px + (padInt * 2);

  geomspec printOn "20%%x30+40%%+%d", button_y_px;
  self button attachTo self, geomspec;

  self button label text (self resources at "buttonText");

  if (self resources at "iconID" > 0) {
    l_icon create self displayPtr, self paneBuffer xID,
      ICON_WIDTH_PX, ICON_HEIGHT_PX, self paneBuffer depth;
    l_icon background self resources at "foregroundColor";
    self icon become l_icon;
    self drawIcon;
  }

  self initialized = true;

}

extern Atom wm_delete_dialog;
extern void __enable_dialog (OBJECT *);

/* Use a Non-Dialog Container - 
   Uncomment the #define below if we want to keep track of the 
   container when the messagebox is opened from a non-dialog window - 
   unlike a validatedtextentrybox - otherwise we might need to think
   of some other way to keep track of the subPanes for keyboard
   equivalents. */
/* #define NDC */
   
X11MessageBoxPane instanceMethod show (void) {
  "Displays the pane's window. Note that th method uses raw X
   events. This is because the pane maintains its own connection
   to the display, and the event handler can be contained in
   this method."
  Display *display;
  Window win_id;
  XEvent xev;
#if NDC
  /* This might be temporary - We may need for the dispatcher to
     keep track of the subPanes externally for keystroke equivalents,
     and we may also need to add a library function to determine if
     we should not be checking the container if the pane is opened
     via a dialog. */
  X11PaneDispatcher new dispatcher;
#endif  
  X11Pane new mainWin;
  InputEvent new e;

#if NDC
  dispatcher = *self container;
  mainWin = dispatcher mainWindow;
#endif  
  
  if (!self initialized) {

    win_id = __ctalkX11CreateDialogWindow (self);
    self xWindowID = win_id;
#if NDC
    dispatcher modalWin = win_id;
    dispatcher modalPane = self;
#endif    

    display = self displayPtr;
  
    (X11Bitmap *)self paneBuffer create self displayPtr, self xWindowID, 
      self size x, self size y, self depth;
    (X11Bitmap *)self paneBuffer background
      (self resources at "backgroundColor");
    self paneBuffer backgroundColor = self resources at "backgroundColor";
    (X11Bitmap *)self paneBuffer foreground
      (self resources at "foregroundColor");
    (X11Bitmap *)self paneBackingStore create self displayPtr, self xWindowID,
      self size x, self size y, self depth;

    self initWidgets;
  } else {

    __enable_dialog (self);

    win_id = self xWindowID;
    display = self displayPtr;

  }

  XMapWindow (display, win_id);
  XMapSubwindows (display, win_id);
  XRaiseWindow (display, win_id);

  self clearWindow;

  while (1) {
    if (XPending (display)) {
      XNextEvent (display, &xev);
      switch (xev.type)
	{
	case ButtonPress:
	  if (xev.xbutton.window == self button xWindowID) {
	    e eventClass = BUTTONPRESS;
	    self methodObjectMessage self handlePointerInput, self, e;
	  }
	  break;
	case ButtonRelease:
	  if (xev.xbutton.window == self button xWindowID) {
	    e eventClass = BUTTONRELEASE;
	    self methodObjectMessage self handlePointerInput, self, e;
	    self withdraw;
#if NDC
	    dispatcher modalWin = 0;
	    dispatcher modalPane = NULL;
#endif	    
	    return self;
	  }
	  break;
	case EnterNotify:
	  if (xev.xbutton.window == self button xWindowID) {
	    e eventClass = ENTERWINDOWNOTIFY;
	    e eventData = xev.xbutton.window;
	    self methodObjectMessage self handleEnterNotify, self, e;
	  }
	  break;
	case LeaveNotify:
	  if (xev.xbutton.window == self button xWindowID) {
	    e eventClass = LEAVEWINDOWNOTIFY;
	    e eventData = xev.xbutton.window;
	    self methodObjectMessage self handleLeaveNotify, self, e;
	  }
	  break;
	case KeyPress:
	  e eventClass = KEYPRESS;
	  /* For the Tab and Enter keys, we don't need to worry
	     about the shift keys */
	  e xEventData4 = __edittext_xk_keysym
	    (xev.xkey.keycode, xev.xkey.state, 0);
	  self methodObjectMessage self handleKbdInput, self, e;
	  if (self keyState == KEY_ENTER) {
	    self withdraw;
#if NDC
	    dispatcher modalWin = 0;
	    dispatcher modalPane = NULL;
#endif	    
	    return self;
	  }
	  break;
	case Expose:
	  self methodObjectMessage self handleExpose, self, e;
	  break;
	case ClientMessage:
	  if(xev.xclient.data.l[0] == wm_delete_dialog) {
	    self withdraw;
#if NDC
	    dispatcher modalWin = 0;
	    dispatcher modalPane = NULL;
#endif
	    return self;
	  }
	  break;
	}
    } else {
      usleep (5000);
    }
  }

}

X11MessageBoxPane instanceMethod showManaged (X11ButtonPane buttonPane) {
  "Similar to the show method, but this method takes as it
   argument the pane that caused the message box to open;
   for example, if pressing a X11ButtonPane opened the 
   message window, this method unclicks and unhighlights
   the button that opened the message box.  This method can
   be subclassed to manage any X11Pane subclass."
    
  XUnmapWindow (buttonPane displayPtr, buttonPane xWindowID);
  buttonPane hover = false;
  buttonPane highlight = false;
  buttonPane clicked = false;
  buttonPane draw;
  buttonPane refresh;
  self show;
  XMapWindow (buttonPane displayPtr, buttonPane xWindowID);
  
}
