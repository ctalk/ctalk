/* $Id: X11TerminalStream,v 1.17 2020/01/12 22:20:53 rkiesling Exp $ -*-c-*-*/

/*
  This file is part of Ctalk.
  Copyright © 2005 - 2012, 2019  Robert Kiesling, rk3314042@gmail.com.
  Permission is granted to copy this software provided that this copyright
  notice is included in all source code modules.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
*/

/*
 *    X11TerminalStream class.
 */

/* X event classes */
#define KBDCHAR           (1 << 0)
#define KBDCUR            (1 << 1)
#define WINDELETE         (1 << 2)
#define BUTTONPRESS       (1 << 3)
#define BUTTONRELEASE     (1 << 4)
#define KEYPRESS          (1 << 5)
#define KEYRELEASE        (1 << 6)
#define MOTIONNOTIFY      (1 << 7)
#define EXPOSE            (1 << 8)
#define MAPNOTIFY         (1 << 12)
#define CONFIGURENOTIFY   (1 << 15)
#define MOVENOTIFY        (1 << 16)
#define RESIZENOTIFY      (1 << 17)
#define SELECTIONREQUEST  (1 << 18)
#define SELECTIONCLEAR    (1 << 19)
#define FOCUSCHANGENOTIFY (1 << 20)
#define ENTERWINDOWNOTIFY (1 << 21)
#define LEAVEWINDOWNOTIFY (1 << 22)

#include <stdio.h>
#if defined(__sparc__) && defined(__svr4__)
#include <sys/time.h>
#else /* Linux */
#include <sys/select.h>
#endif

#include <string.h>
#include <errno.h>

TerminalStream class X11TerminalStream
"A X11TerminalStream object maintains input from the
display to the application.  If receives input events
from the system and creates InputEvent objects to
record the input, and queues the InputEvents so a
program can handle them.";
X11TerminalStream instanceVariable inputPID Integer 0;
X11TerminalStream instanceVariable clientFD Integer 0;
X11TerminalStream instanceVariable eventMask Integer 0;

static int client_handle = -1;
static int event_mask = -1;

X11TerminalStream instanceMethod openInputClient (void) {
  "Start the X Window System client and server."
  __ctalkOpenX11InputClient (self);
  client_handle = self clientFD;
  event_mask = self eventMask;
  return self;
}

X11TerminalStream instanceMethod parentPane (void) {
  "Return the receiver's parent pane."
  OBJECT *receiver_alias,
    *parent_alias;
  returnObjectClass X11Pane;
  receiver_alias = self;
  if (receiver_alias -> __o_p_obj) {
    parent_alias = receiver_alias -> __o_p_obj;
  } else {
    parent_alias = NULL;
  }
  return parent_alias;
}

/*
 eventClass       XEvent      xEventData1 xEventData2 xEventData3 xEventData4 xEventData5
 BUTTONPRESS      xbutton     x           y           state       button 
 BUTTONRELEASE
 KEYPRESS         xkey        x           y           state       keycode     Modified XK Code 
 KEYRELEASE       xkey        x           y           state       keycode     Modified XK Code 
 CONFIGURENOTIFY  xconfigure  x           y           height      width       border_width
 MOVENOTIFY       xconfigure  x           y           height      width       border_width
 RESIZENOTIFY     xconfigure  x           y           height      width       border_width
 MOTIONNOTIFY     xmotion     x           y           state       is_hint
 MAPNOTIFY        xmap        event       window
 EXPOSE           xexpose     x           y           width       height      count
 */

/* From x11defs.h */
#define _SCLASS 0
#define _SWIN   1
#define _SDT1   2

int read_x_event (int fd, int *eventclass, int *win, unsigned int data[]) {
  int i, d_size;
  unsigned int a[9];

  d_size = sizeof (unsigned int) * 8;

  if (read (fd, a, d_size) != d_size) {
    printf ("ctalk: read_x_event: %s.\n", strerror (errno));
    return -1;
  }
  *eventclass = a[_SCLASS];
  *win = a[_SWIN];
  memcpy ((void *)data, (void *)&a[_SDT1],
	    sizeof (unsigned int) * 6);
  
  return SUCCESS;

}

void save_x_event (OBJECT *event_value_obj, int event_class, int win,
		   int data[]) {
  OBJECT *var;
  int i;
  /* Relies on the fact that instance variables are ordered in the
     parent object in the same order that they are declared.  If that
     ever changes, the equivalent assigments are in the #ifdef-#else
     clause below.  For now, this is faster. */
  var = event_value_obj -> next;
  INTVAL(var -> instancevars -> __o_value) =
    INTVAL(var -> __o_value) = event_class;
  var = var -> next;
  INTVAL(var -> instancevars -> __o_value) =
    INTVAL(var -> __o_value) = win;

  for (var = var -> next, i = 0; i < 6; var = var -> next, ++i)
    INTVAL(var -> instancevars -> __o_value) =
      INTVAL(var -> __o_value) = data[i];
}

X11TerminalStream instanceMethod queueInput (void) {
  "Retrieve a X event, and return it as an InputEvent
  object."
  int r, event_class, win;
  unsigned int data[6];
  fd_set rfds;
  struct timeval tv;
  InputEvent new clientEvent;

  FD_ZERO(&rfds);
  FD_SET(client_handle, &rfds);
  tv.tv_sec = 0;
  tv.tv_usec = 500;
 select_again:
  if ((r = select (client_handle + 1, &rfds, NULL, NULL, &tv)) > 0) {

    /* Event_class and win are separate args to make the code more 
       readable, 'tho that quality is debatable at this point. */
    if (!read_x_event (client_handle, &event_class, &win, data)) {
    
      if (event_mask != 0) {
	if (!(event_mask & event_class)) {
	  goto select_again;
	}
      }

#if 1
      save_x_event (clientEvent, event_class, win, data);
#else 
      clientEvent eventClass = event_class;
      clientEvent eventData = win;
      clientEvent xEventData1 = data[0];
      clientEvent xEventData2 = data[1];
      clientEvent xEventData3 = data[2];
      clientEvent xEventData4 = data[3];
      clientEvent xEventData5 = data[4];
      clientEvent xEventData6 = data[5];
#endif      

      switch (event_class)
	{
	case CONFIGURENOTIFY:
	  if (clientEvent xEventData1)
	    self parentPane origin x = clientEvent xEventData1;
	  if (clientEvent xEventData2)
	    self parentPane origin y = clientEvent xEventData2;
	  self parentPane size x = clientEvent xEventData3;
	  self parentPane size y = clientEvent xEventData4;
	  break;
	case MOVENOTIFY:
	  self parentPane origin x = clientEvent xEventData1;
	  self parentPane origin y = clientEvent xEventData2;
	  self parentPane size x = clientEvent xEventData3;
	  self parentPane size y = clientEvent xEventData4;
	  break;
	case RESIZENOTIFY:
	  self parentPane size x = clientEvent xEventData3;
	  self parentPane size y = clientEvent xEventData4;
	  break;
	}
      self inputQueue push clientEvent;
    }
  }
}

