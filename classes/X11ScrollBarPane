/* $Id: X11ScrollBarPane,v 1.20 2020/01/21 22:11:06 rkiesling Exp $ -*-c-*-*/

/*
  This file is part of Ctalk.
  Copyright © 2014, 2020  Robert Kiesling, rk3314042@gmail.com.
  Permission is granted to copy this software provided that this copyright
  notice is included in all source code modules.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
*/

/*
 *    X11ScrollBarPane class.
 *
 */

require X11Pane;
require X11PaneDispatcher;

#define SCROLLBAR_WIDTH 20
#define DEFAULT_THUMB_HEIGHT 20

X11CanvasPane class X11ScrollBarPane
"A X11ScrollBarPane object draws a simple scroll bar on
the left-hand side of a window, and handles pointer
motion and scroll thumb movement within the scroll
region.";
X11ScrollBarPane instanceVariable arrowCursor X11Cursor NULL;
X11ScrollBarPane instanceVariable grabCursor X11Cursor NULL;
X11ScrollBarPane instanceVariable frame Rectangle NULL;
X11ScrollBarPane instanceVariable thumb Rectangle NULL;
X11ScrollBarPane instanceVariable framePen Pen NULL;
X11ScrollBarPane instanceVariable thumbPen Pen NULL;
X11ScrollBarPane instanceVariable thumbErasePen Pen NULL;
X11ScrollBarPane instanceVariable thumbHeight Integer DEFAULT_THUMB_HEIGHT;
// These are derived from the frame and thumb rectangles.
// They're here because they're quicker to evaluate.
X11ScrollBarPane instanceVariable frameTopStartX Integer 0;
X11ScrollBarPane instanceVariable frameTopStartY Integer 0;
X11ScrollBarPane instanceVariable frameBottomEndX Integer 0;
X11ScrollBarPane instanceVariable frameBottomEndY Integer 0;
X11ScrollBarPane instanceVariable thumbTopStartX Integer 0;
X11ScrollBarPane instanceVariable thumbTopStartY Integer 0;
X11ScrollBarPane instanceVariable thumbBottomEndX Integer 0;
X11ScrollBarPane instanceVariable thumbBottomEndY Integer 0;
X11ScrollBarPane instanceVariable dragStartX Integer 0;
X11ScrollBarPane instanceVariable dragStartY Integer 0;
X11ScrollBarPane instanceVariable dragging Boolean FALSE;
X11ScrollBarPane instanceVariable lastY Integer 0;

X11ScrollBarPane instanceVariable padding Integer 1;
X11ScrollBarPane instanceVariable frameWidthVar Integer 1;
X11ScrollBarPane instanceVariable margin Integer 1;

Integer new scrollbarTopStartX, scrollbarTopStartY,
  scrollbarBottomEndX, scrollbarBottomEndY;

X11ScrollBarPane instanceMethod pointIsInFrame (Integer pointX,	
						Integer pointY) {
  "Returns a Boolean object with the value of True if the
  mouse pointer is over the scroll bar frame, False
  otherwise."
  returnObjectClass Boolean;

  if (scrollbarTopStartX == -1) {
    scrollbarTopStartX = self frameTopStartX;
    scrollbarTopStartY = self frameTopStartY;
    scrollbarBottomEndX = self frameBottomEndX;
    scrollbarBottomEndY = self frameBottomEndY;
  }

  if (pointX >= scrollbarTopStartX &&
      pointX <= scrollbarBottomEndX &&
      pointY >= scrollbarTopStartY &&
      pointY <= scrollbarBottomEndY) {
    return TRUE;
  } else {
    return FALSE;
  }
}

X11ScrollBarPane instanceMethod pointIsInThumb (Integer pointX,
						Integer pointY) {
  "Returns a Boolean object with the value of True if the
  mouse pointer is over the scroll thumb, False
  otherwise."
  returnObjectClass Boolean;

  if ((pointX >= (self thumbTopStartX)) &&
      (pointX <= (self thumbBottomEndX)) &&
      (pointY >= (self thumbTopStartY)) &&  /* printf ("%d\n", deltaY); */


      (pointY <= (self thumbBottomEndY))) {
    return TRUE;
  } else {
    return FALSE;
  }
}

X11ScrollBarPane instanceMethod thumbDimensions (Integer deltaY,
						 Integer thumbHeight) {
  "Set the coordinates for sliding the thumb to its new
  position using the new Y origin and the height of the
  thumb."
    Integer new totalMargin;

  totalMargin = self margin + self frameWidthVar + self padding;
  
  self thumb dimensions totalMargin,
    deltaY,
    (self size x - (totalMargin * 2)),
    thumbHeight;

  self thumbTopStartX = self thumb top start x;
  self thumbTopStartY = self thumb top start y;
  self thumbBottomEndX = (self thumbTopStartX) + self thumb bottom end x;
  self thumbBottomEndY = (self thumbTopStartY) + (self thumb bottom end y);

}

X11ScrollBarPane instanceMethod drawThumb (void) {
  "Draw the thumb rectangle."
    __ctalkGUIPaneDrawRectangle (self, self thumb, self thumbPen, TRUE);
}

X11ScrollBarPane instanceMethod eraseThumb (void) {
  "Erase the thumb rectangle."
  __ctalkGUIPaneDrawRectangle (self, self thumb, self thumbErasePen, TRUE);
}

X11ScrollBarPane instanceMethod refresh (void) {
  "Redraw the scrollbar."

  if (self dragging)
    self eraseThumb;
  else
    self drawThumb;

  __ctalkGUIPaneDrawRectangle (self, self frame, self framePen, FALSE);

  __ctalkGUIPaneRefresh (self, 0, 0,
   			 self size x,
   			 self size y,
   			 self origin x, self origin y);
}

X11ScrollBarPane instanceMethod subPaneResize (Object __subPane, 
					  InputEvent __event) {
  "Resize the receiver pane.  This is the resize event
  handler called by the parent window's pane dispatcher
  This method is under construction and is currently a
  no-op."
  return NULL;
}

X11ScrollBarPane instanceMethod subPaneDestroy (Object __subPane, 
					  InputEvent __event) {
  "Delete the receiver pane's pixmaps and graphics
  contexts.  This is the event handler called by the
  parent window's pane dispatcher.  Uses a temporary
  X11Pixmap object to cast the paneBuffer and
  paneBackingStore instance variables, which were
  changed from Symbol to X11Pixmap objects, which is
  mentioned in the attachTo method's comments."
  X11Pixmap new tmpPixmap;
  tmpPixmap become self paneBuffer;
  XFreePixmap (X11Pane xDisplay, tmpPixmap xID);
  XFreeGC (X11Pane xDisplay, (GC) self paneBuffer xGC);
  tmpPixmap become self paneBackingStore;
  XFreePixmap (X11Pane xDisplay, tmpPixmap xID);
  XFreeGC (X11Pane xDisplay, (GC) self paneBackingStore xGC);

  return NULL;
}

X11ScrollBarPane instanceMethod subPaneExpose (Object __subPane,
					  InputEvent __event) {
  "Handle an Expose event by redrawing the pane's contents
  on the parent window."
  __subPane refresh;
}

X11ScrollBarPane instanceMethod subPanePointerInput (Object __subPane,
						  InputEvent __event) {
  "Handle ButtonPress and ButtonRelease events.  If the
  pointer is over the scroll thumb and the right mouse
  button is pressed, change the cursor and indicate the
  start of a click-and-drag.  If the right mouse button
  is released over the scroll frame, change the cursor
  to a vertical arrow."
  if (__event eventClass == 8) {
    if (self pointIsInThumb (__event xEventData1, __event xEventData2)) {
      self useCursor self grabCursor;
      self dragStartX = __event xEventData1;
      self dragStartY = __event xEventData2;
      self dragging = TRUE;
    }
  }
  if (__event eventClass == 16) {
    if (self pointIsInFrame (__event xEventData1, __event xEventData2)) {
      self useCursor self arrowCursor;
    } else {
      self defaultCursor;
    }
    if (self dragging)
      self dragging = FALSE;
    self refresh;
  }
  return NULL;
}

X11ScrollBarPane instanceMethod __moveThumb (Integer updatedY) {
  __ctalkGUIPaneDrawRectangle (self, self thumb, self thumbErasePen, TRUE);
  self thumbDimensions updatedY, self thumbHeight;
  __ctalkGUIPaneDrawRectangle (self, self thumb, self thumbPen, TRUE);
  __ctalkGUIPaneRefresh (self, 0, 0, self size x, self size y,
			 self origin x, self origin y);
}

X11ScrollBarPane instanceMethod subPanePointerMotion (Object __subPane,
					  InputEvent __event) {
  "Handle pointer motion events from the parent window's
  event dispatcher.  If not dragging (ie, the right
  mouse button is not pressed), change the cursor on a
  mouseover in the scrollbar frame.  Otherwise, move
  the scroll thumb.  Uses a lot of C library calls
  directly for speed."
  Integer new y;
  Integer new updatedY, totalMargin;

  totalMargin = self margin + self frameWidthVar + self padding;

  y = __event xEventData2 value;

  if (self dragging) {
    updatedY = self thumbTopStartY + (y - self lastY);
    /* Make adjustments if needed so the thumb doesn't get drawn past
       either end of the pane, or the percent is outside 0-100%. */
    if (updatedY < 0) {
      self lastY = 0; updatedY = totalMargin;
    } else if (updatedY > ((self size y) - (totalMargin + self thumbHeight))){
      self lastY = ((self size y) - ((totalMargin * 2) + self thumbHeight));
      updatedY = ((self size y) - (totalMargin + self thumbHeight));
    } else {
      self lastY = y;
    }
    self __moveThumb updatedY;
  } else {
    if (self pointIsInFrame  (__event xEventData1, __event xEventData2)) {
      self useCursor self arrowCursor;
    } else {
      self defaultCursor;
    }
  }
    
  return NULL;
}

X11ScrollBarPane instanceMethod new (String __paneName) {
  "The X11ScrollBarPane constructor.  The argument, a
  String, contains the name of the new object.  Sets
  pen colors and line widths for the scroll frame and
  thumb, and the X event handlers."

  Method new resizeMethod;
  Method new destroyMethod;
  Method new exposeMethod;
  Method new pointerInputMethod;
  Method new pointerMotionMethod;
  X11ScrollBarPane super new __paneName;
  __paneName arrowCursor scrollArrow;
  __paneName grabCursor grabMove;
  resizeMethod definedInstanceMethod "X11ScrollBarPane", "subPaneResize";
  destroyMethod definedInstanceMethod "X11ScrollBarPane", "subPaneDestroy";
  exposeMethod definedInstanceMethod "X11ScrollBarPane", "subPaneExpose";
  pointerInputMethod definedInstanceMethod "X11ScrollBarPane", 
    "subPanePointerInput";
  pointerMotionMethod definedInstanceMethod "X11ScrollBarPane", 
    "subPanePointerMotion";
  __paneName setMethodHandler "resize", resizeMethod;
  __paneName setMethodHandler "destroy", destroyMethod;
  __paneName setMethodHandler "expose", exposeMethod;
  __paneName setMethodHandler "pointerinput", pointerInputMethod;
  __paneName setMethodHandler "pointermotion", pointerMotionMethod;

  __paneName background "white";
  __paneName framePen width = __paneName frameWidthVar;
  __paneName framePen colorName = "black";
  __paneName thumbPen colorName = "gray";
  __paneName thumbErasePen colorName = "white";

  scrollbarTopStartX = -1;

  return __paneName;
}

X11ScrollBarPane instanceMethod attachTo (Object parentPane) {
  "Register the receiver pane as a subpane of the X11Pane
  given as the argument."
  X11Bitmap new xPaneBuffer;
  X11Bitmap new xPaneBackingStore;
   self super attachTo parentPane;
  self paneBuffer become xPaneBuffer;
  self paneBackingStore become xPaneBackingStore;

  self size x = SCROLLBAR_WIDTH;
  self size y = parentPane size y;
  self origin x = 0;
  self origin y = 0;

  self frameWidth self frameWidthVar;

  self frameTopStartX = self frame top start x;
  self frameTopStartY = self frame top start y;
  self frameBottomEndX = self frame bottom end x;
  self frameBottomEndY = self frame bottom end y;

  self thumbDimensions
    self margin + self frameWidthVar + self padding,
    self thumbHeight;

  (X11Bitmap *)self paneBuffer create self xWindowID, self size x, 
    self size y, self depth;
  (X11Bitmap *)self paneBuffer background (self backgroundColor);
  (X11Bitmap *)self paneBackingStore create self xWindowID, self size x, 
    self size y, self depth;

  return NULL;
}

X11ScrollBarPane instanceMethod attachTo (Object parentPane,
					   String geomspec) {
  "Register the receiver pane as a subpane of the X11Pane
  given as the argument."
  X11Bitmap new xPaneBuffer;
  X11Bitmap new xPaneBackingStore;
  int x, y, width, height;

  self super attachTo (parentPane, geomspec);

  /* These expressions also remove any buffers created by superclass
     methods, but they don't necessarily delete them immediately. */
  self paneBuffer become xPaneBuffer;
  self paneBackingStore become xPaneBackingStore;

  __ctalkX11SubWindowGeometry (parentPane, geomspec,
			       &x, &y, &width, &height);
  self size x = width;
  self size y = height;
  self origin x = x;
  self origin y = y;

  self frameWidth self frameWidthVar;

  self frameTopStartX = self frame top start x;
  self frameTopStartY = self frame top start y;
  self frameBottomEndX = self frame bottom end x;
  self frameBottomEndY = self frame bottom end y;

  self thumbDimensions
    self margin + self frameWidthVar + self padding,
    self thumbHeight;

  (X11Bitmap *)self paneBuffer create self xWindowID, self size x, 
    self size y, self depth;
  (X11Bitmap *)self paneBuffer background (self backgroundColor);
  (X11Bitmap *)self paneBackingStore create self xWindowID, self size x, 
    self size y, self depth;

  return NULL;
}

X11ScrollBarPane instanceMethod background (String colorNameArg) {
  self super background colorNameArg;
  self thumbErasePen colorName = colorNameArg;
}

X11ScrollBarPane instanceMethod frameWidth (Integer widthArg) {

  Integer new borderHalf, borderIn, totalMargin;

  self frameWidthVar = widthArg;
  self framePen width = widthArg;

  switch (widthArg)
    {
    case 0:
      break;
    case 1:
      self frame dimensions self margin, self margin,
	self size x - ((self margin * 2) + (self frameWidthVar)),
	self size y - ((self margin * 2) + (self frameWidthVar));
      break;
    default:
      borderHalf = widthArg / 2;
      if ((widthArg % 2) == 0) {
	borderIn = (self margin * 2) + (borderHalf * 2);
      } else {
	borderIn = (self margin * 2) + (borderHalf * 2 + 1);
      }
      self frame dimensions self margin + borderHalf,
	self margin + borderHalf,
	self size x - borderIn, self size y - borderIn;
      break;
    }

  totalMargin = self margin + self frameWidthVar + self padding;
  self thumb top start x = totalMargin;
  self thumb top end x = (self size x - (totalMargin * 2));
  self thumb bottom start x = totalMargin;
  self thumb bottom end x = (self size x - (totalMargin * 2));

  self thumbTopStartX = self thumb top start x;
  self thumbTopStartY = self thumb top start y;
  self thumbBottomEndX = (self thumbTopStartX) + self thumb bottom end x;
  self thumbBottomEndY = (self thumbTopStartY) + (self thumb bottom end y);
}

X11ScrollBarPane instanceMethod thumbPercent (Float pct) {
  "Calculates the thumb's height as a percent of the scrollbar's
   trough height."
  self thumbHeight = (self size y - ((self margin * 2) +
				     (self frameWidthVar * 2) +
				     (self padding * 2))) * pct;

  __ctalkGUIPaneDrawRectangle (self, self thumb, self thumbErasePen, TRUE);
  self thumbDimensions lastY, self thumbHeight;
  __ctalkGUIPaneDrawRectangle (self, self thumb, self thumbPen, TRUE);
  __ctalkGUIPaneRefresh (self, 0, 0, self size x, self size y,
			 self origin x, self origin y);
}

X11ScrollBarPane instanceMethod percent (void) {
  "Returns a Float between 0.0 and 1.0 with the vertical position
   of the thumb in the scrollbar's trough as a percent of the 
   trough's height."
  returnObjectClass Float;

  Float new usableTrough, fl, pct;

  usableTrough = self size y - ((self margin * 2) +
				(self frameWidthVar * 2) +
				(self padding * 2) +
				(self thumbHeight));
  fl = self lastY;
  pct = fl / usableTrough;
  return pct;
}
