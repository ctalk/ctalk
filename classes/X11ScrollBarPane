/* $Id: X11ScrollBarPane,v 1.49 2020/05/06 00:46:26 rkiesling Exp $ -*-c-*-*/

/*
  This file is part of Ctalk.
  Copyright © 2014, 2020  Robert Kiesling, rk3314042@gmail.com.
  Permission is granted to copy this software provided that this copyright
  notice is included in all source code modules.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
*/

/*
 *    X11ScrollBarPane class.
 *
 */

require X11Pane;
require X11PaneDispatcher;

#define SCROLLBAR_WIDTH 20
#define DEFAULT_THUMB_HEIGHT 20

X11CanvasPane class X11ScrollBarPane
"A X11ScrollBarPane object draws a simple scroll bar on
the left-hand side of a window, and handles pointer
motion and scroll thumb movement within the scroll
region.";
X11ScrollBarPane instanceVariable arrowCursor X11Cursor NULL;
X11ScrollBarPane instanceVariable grabCursor X11Cursor NULL;
X11ScrollBarPane instanceVariable frame Rectangle NULL;
X11ScrollBarPane instanceVariable thumb Rectangle NULL;
X11ScrollBarPane instanceVariable framePen Pen NULL;
X11ScrollBarPane instanceVariable thumbPen Pen NULL;
X11ScrollBarPane instanceVariable thumbErasePen Pen NULL;
X11ScrollBarPane instanceVariable thumbHeight Integer DEFAULT_THUMB_HEIGHT;
X11ScrollBarPane instanceVariable dragging Boolean FALSE;
X11ScrollBarPane instanceVariable lastY Integer 0;
X11ScrollBarPane instanceVariable padding Integer 1;
X11ScrollBarPane instanceVariable frameWidthVar Integer 1;
X11ScrollBarPane instanceVariable margin Integer 1;
X11ScrollBarPane instanceVariable bevel Boolean true;
X11ScrollBarPane instanceVariable thumbPix X11Bitmap 0;
X11ScrollBarPane instanceVariable thumbBackgroundColor String "darkgray";
X11ScrollBarPane instanceVariable mouseOver Boolean false;

Boolean new haveBevel;

#define THUMBPIXMAPWIDTH (self thumb top end x)
#define THUMBVCLIP (self thumb bottom start y)
#define WIDGETTOPSTARTX (self frame top start x)
#define WIDGETTOPSTARTY (self frame top start y)
#define WIDGETBOTTOMENDX (self frame bottom end x)
#define WIDGETBOTTOMENDY (self frame bottom end y)
#define THUMBTOPSTARTX (self thumb top start x)
#define THUMBTOPSTARTY (self thumb top start y)
#define THUMBBOTTOMENDX (THUMBTOPSTARTX + self thumb bottom end x)
#define THUMBBOTTOMENDY (THUMBTOPSTARTY + self thumb bottom end y)

X11ScrollBarPane instanceMethod pointIsInThumb (Integer pointX,
						Integer pointY) {
  "Returns a Boolean object with the value of True if the
  mouse pointer is over the scroll thumb, False
  otherwise."
  returnObjectClass Boolean;

  if ((pointX >= THUMBTOPSTARTX) &&
      (pointX <= THUMBBOTTOMENDX) &&
      (pointY >= THUMBTOPSTARTY) && 
      (pointY <= THUMBBOTTOMENDY)) {
    return TRUE;
  } else {
    return FALSE;
  }
}

X11ScrollBarPane instanceMethod thumbDimensions (Integer deltaY,
						 Integer thumbHeight) {
  "Set the coordinates for sliding the thumb to its new
  position using the new Y origin and the height of the
  thumb."
    Integer new totalMargin;

  totalMargin = self margin + self frameWidthVar + self padding;
  
  self thumb dimensions totalMargin,
    deltaY,
    (self size x - (totalMargin * 2)),
    thumbHeight;
}

X11ScrollBarPane instanceMethod makeThumb (void) {
  
  if (self bevel) {
    self thumbPix create self displayPtr, self xWindowID,
      THUMBPIXMAPWIDTH, self displayHeight, self depth;
    self thumbPix background self thumbBackgroundColor;
    self thumbPix clear;
  }

}

X11ScrollBarPane instanceMethod drawThumb (void) {
  "Draw the thumb rectangle."
  if (!self bevel) {
    __ctalkGUIPaneDrawRectangle (self, self thumb, self thumbPen, TRUE);
  } else {
    self paneBuffer copy self thumbPix, 0, 0,
      THUMBPIXMAPWIDTH, THUMBVCLIP,
      self thumb top start x, self thumb top start y;
  }
}

X11ScrollBarPane instanceMethod eraseThumb (void) {
  "Erase the thumb rectangle."
  __ctalkGUIPaneDrawRectangle (self, self thumb, self thumbErasePen, TRUE);
}

X11ScrollBarPane instanceMethod refresh (void) {
  "Redraw the scrollbar."
    Pen new p;
  Integer new totalMargin;

  if (self bevel && !haveBevel) {
    totalMargin = self margin + self frameWidthVar + self padding;

    self thumbPix drawRectangle  0, 0,
      self thumbPix width, self thumbPix height,
      TRUE, 1, self thumbBackgroundColor, 0;

    p width = 1;
    p colorName = "gray89";
    self thumbPix drawLine 0, 0, self thumbPix width, 0, p;
    self thumbPix drawLine 1, 1, self thumbPix width - 1, 1, p;

    p colorName = "gray86";
    self thumbPix drawLine 0, 1, 0, THUMBVCLIP, p;
    self thumbPix drawLine 1, 2, 1, THUMBVCLIP - 1, p;

    p colorName = "darkslategray";

    self thumbPix drawLine 1, THUMBVCLIP, self thumbPix width,
      THUMBVCLIP, p;
    self thumbPix drawLine self thumbPix width, 1,
      self thumbPix width, THUMBVCLIP, p;

    self thumbPix drawLine 2, THUMBVCLIP - 1,
      self thumbPix width,
      THUMBVCLIP - 1, p;
    self thumbPix drawLine self thumbPix width - 1, 2,
      self thumbPix width - 1, THUMBVCLIP, p;

    haveBevel = true;
  }

  if (self dragging)
    self eraseThumb;
  else
    self drawThumb;

  __ctalkGUIPaneDrawRectangle (self, self frame, self framePen, FALSE);

  __ctalkGUIPaneRefresh (self, 0, 0,
   			 self size x,
   			 self size y,
   			 self origin x, self origin y);

}

X11ScrollBarPane instanceMethod subPaneResize (Object __subPane, 
					  InputEvent __event) {
  "Resize the receiver pane.  This is the resize event
  handler called by the parent window's pane dispatcher."
  X11Pane new mainWindowObj;
  int x, y, width, height;

  if (__subPane subPaneGeometry length == 0) {
    if (__ctalkX11ResizeWindow (__subPane, __event xEventData3,
				__event xEventData4,
				__subPane depth) > 0) {
      __subPane size x = __event xEventData3;
      __subPane size y = __event xEventData4;
      (X11Bitmap *)self paneBuffer resize self xWindowID,
	__event xEventData3, __event xEventData4;
      (X11Bitmap *)self paneBackingStore resize self xWindowID,
	__event xEventData3, __event xEventData4;
      haveBevel = false;
      self refresh;
    }
  } else {
    self super subPaneResize (__subPane, __event);

    mainWindowObj = self mainWindow;

    __ctalkX11SubWindowGeometry (mainWindowObj, self subPaneGeometry,
				   &x, &y, &width, &height);
    __subPane origin x = x;
    __subPane origin y = y;
    __subPane size x = width;
    __subPane size y = height;

    (X11Bitmap *)self paneBuffer resize self xWindowID,
      __event xEventData3, __event xEventData4;
    (X11Bitmap *)self paneBackingStore resize self xWindowID,
      __event xEventData3, __event xEventData4;
    self frameWidth self frameWidthVar;
    haveBevel = false;
    self refresh;
  }
  return NULL;
}

X11ScrollBarPane instanceMethod subPaneDestroy (Object __subPane, 
					  InputEvent __event) {
  "Delete the receiver pane's pixmaps and graphics
  contexts.  This is the event handler called by the
  parent window's pane dispatcher.  Uses a temporary
  X11Pixmap object to cast the paneBuffer and
  paneBackingStore instance variables, which were
  changed from Symbol to X11Pixmap objects, which is
  mentioned in the attachTo method's comments."
  X11Pixmap new tmpPixmap;
  tmpPixmap become self paneBuffer;
  XFreePixmap (self displayPtr, tmpPixmap xID);
  XFreeGC (self displayPtr, (GC) self paneBuffer xGC);
  tmpPixmap become self paneBackingStore;
  XFreePixmap (self displayPtr, tmpPixmap xID);
  XFreeGC (self displayPtr, (GC) self paneBackingStore xGC);

  return NULL;
}

X11ScrollBarPane instanceMethod subPaneExpose (Object __subPane,
					  InputEvent __event) {
  "Handle an Expose event by redrawing the pane's contents
  on the parent window."
  __subPane refresh;
}

X11ScrollBarPane instanceMethod subPanePointerInput (Object __subPane,
						  InputEvent __event) {
  "Handle ButtonPress and ButtonRelease events.  If the
  pointer is over the scroll thumb and the right mouse
  button is pressed, change the cursor and indicate the
  start of a click-and-drag.  If the right mouse button
  is released over the scroll frame, change the cursor
  to a vertical arrow."
  if (__event eventClass == 8) {
    if (self pointIsInThumb (__event xEventData1, __event xEventData2)) {
      self useCursor self grabCursor;
      self dragging = TRUE;
    }
  } else if (__event eventClass == 16) {
    if (self mouseOver) {
      self useCursor self arrowCursor;
    } else {
      self defaultCursor;
    }
    if (self dragging)
      self dragging = FALSE;
    /* self refresh; *//***/
  }
  return NULL;
}

X11ScrollBarPane instanceMethod __moveThumb (Integer updatedY) {
  if (!self bevel) {
    __ctalkGUIPaneDrawRectangle (self, self thumb, self thumbErasePen, TRUE);
    self thumbDimensions updatedY, self thumbHeight;
    __ctalkGUIPaneDrawRectangle (self, self thumb, self thumbPen, TRUE);
    __ctalkGUIPaneRefresh (self, 0, 0, self size x, self size y,
			   self origin x, self origin y);
  } else {
    __ctalkGUIPaneDrawRectangle (self, self thumb, self thumbErasePen, TRUE);
    self thumbDimensions updatedY, self thumbHeight;
    self paneBuffer copy self thumbPix, 0, 0,
      THUMBPIXMAPWIDTH, THUMBVCLIP,
      self thumb top start x, self thumb top start y;
    __ctalkGUIPaneRefresh (self, 0, 0, self size x, self size y,
			   self origin x, self origin y);
  }
}

unsigned int t_t = 0;

X11ScrollBarPane instanceMethod subPanePointerMotion (Object __subPane,
					  InputEvent __event) {
  "Handle pointer motion events from the parent window's
  event dispatcher.  If not dragging (ie, the right
  mouse button is not pressed), change the cursor on a
  mouseover in the scrollbar frame.  Otherwise, move
  the scroll thumb.  Uses a lot of C library calls
  directly for speed."
  Integer new y;
  Integer new updatedY, totalMargin;

  totalMargin = self margin + self frameWidthVar + self padding;

  y = __event xEventData2 value;

  if (self dragging) {
    /* printf ("%u %d\n", t_t++, y); */
    updatedY = THUMBTOPSTARTY + (y - self lastY);
    /* Make adjustments if needed so the thumb doesn't get drawn past
       either end of the pane, or the percent is outside 0-100%. */
    if (updatedY < 0) {
      self lastY = 0; updatedY = totalMargin;
    } else if (updatedY > ((self size y) - (totalMargin + self thumbHeight))){
      self lastY = ((self size y) - ((totalMargin * 2) + self thumbHeight));
      updatedY = ((self size y) - (totalMargin + self thumbHeight));
    } else {
      self lastY = y;
    }
    self __moveThumb updatedY;
  } else {
    if (self mouseOver) {
      self useCursor self arrowCursor;
    } else {
      self defaultCursor;
    }
  }
    
  return NULL;
}

X11ScrollBarPane instanceMethod new (String __paneName) {
  "The X11ScrollBarPane constructor.  The argument, a
  String, contains the name of the new object.  Sets
  pen colors and line widths for the scroll frame and
  thumb, and the X event handlers."

  Method new resizeMethod;
  Method new destroyMethod;
  Method new exposeMethod;
  Method new pointerInputMethod;
  Method new pointerMotionMethod;
  Method new enterNotifyMethod, leaveNotifyMethod;
  X11ScrollBarPane super new __paneName;
  __paneName arrowCursor scrollArrow;
  __paneName grabCursor grabMove;
  resizeMethod definedInstanceMethod "X11ScrollBarPane", "subPaneResize";
  destroyMethod definedInstanceMethod "X11ScrollBarPane", "subPaneDestroy";
  exposeMethod definedInstanceMethod "X11ScrollBarPane", "subPaneExpose";
  pointerInputMethod definedInstanceMethod "X11ScrollBarPane", 
    "subPanePointerInput";
  pointerMotionMethod definedInstanceMethod "X11ScrollBarPane", 
    "subPanePointerMotion";
  enterNotifyMethod definedInstanceMethod "X11ScrollBarPane",
    "subPaneEnterNotify";
  leaveNotifyMethod definedInstanceMethod "X11ScrollBarPane",
    "subPaneLeaveNotify";
  __paneName setMethodHandler "resize", resizeMethod;
  __paneName setMethodHandler "destroy", destroyMethod;
  __paneName setMethodHandler "expose", exposeMethod;
  __paneName setMethodHandler "pointerinput", pointerInputMethod;
  __paneName setMethodHandler "pointermotion", pointerMotionMethod;
  __paneName setMethodHandler "enternotify", enterNotifyMethod;
  __paneName setMethodHandler "leavenotify", leaveNotifyMethod;

  __paneName background "white";
  __paneName framePen width = __paneName frameWidthVar;
  __paneName framePen colorName = "black";
  __paneName thumbPen colorName = __paneName thumbBackgroundColor;
  __paneName thumbErasePen colorName = "white";

  haveBevel = false;

  return __paneName;
}

X11ScrollBarPane instanceMethod attachTo (Object parentPane) {
  "Register the receiver pane as a subpane of the X11Pane
  given as the argument."
  X11Bitmap new xPaneBuffer;
  X11Bitmap new xPaneBackingStore;
   self super attachTo parentPane;
  self paneBuffer become xPaneBuffer;
  self paneBackingStore become xPaneBackingStore;

  self size x = SCROLLBAR_WIDTH;
  self size y = parentPane size y;
  self origin x = 0;
  self origin y = 0;

  self displayPtr = self mainWindow displayPtr;

  self frameWidth self frameWidthVar;

  self thumbDimensions
    self margin + self frameWidthVar + self padding,
    self thumbHeight;

  (X11Bitmap *)self paneBuffer create self displayPtr, self xWindowID,
    self size x, self size y, self depth;
  (X11Bitmap *)self paneBuffer background (self backgroundColor);
  (X11Bitmap *)self paneBackingStore create self displayPtr, self xWindowID,
    self size x, self size y, self depth;

  self makeThumb;

  return NULL;
}

X11ScrollBarPane instanceMethod attachTo (Object parentPane,
					   String geomspec) {
  "Register the receiver pane as a subpane of the X11Pane
  given as the argument."
  X11Bitmap new xPaneBuffer;
  X11Bitmap new xPaneBackingStore;
  int x, y, width, height;

  self subPaneGeometry = geomspec;

  self super attachTo (parentPane, geomspec);

  self displayPtr = self mainWindow displayPtr;

  /* These expressions also remove any buffers created by superclass
     methods, but they don't necessarily delete them immediately. */
  self paneBuffer become xPaneBuffer;
  self paneBackingStore become xPaneBackingStore;

  __ctalkX11SubWindowGeometry (parentPane, geomspec,
			       &x, &y, &width, &height);
  self size x = width;
  self size y = height;
  self origin x = x;
  self origin y = y;

  self frameWidth self frameWidthVar;

  self thumbDimensions
    self margin + self frameWidthVar + self padding,
    self thumbHeight;

  (X11Bitmap *)self paneBuffer create self displayPtr, self xWindowID,
    self size x, self size y, self depth;
  (X11Bitmap *)self paneBuffer background (self backgroundColor);
  (X11Bitmap *)self paneBackingStore create self displayPtr, self xWindowID,
    self size x, self size y, self depth;

  self makeThumb;
  return NULL;
}

X11ScrollBarPane instanceMethod background (String colorNameArg) {
  self super background colorNameArg;
  self thumbErasePen colorName = colorNameArg;
}

X11ScrollBarPane instanceMethod frameWidth (Integer widthArg) {

  Integer new borderHalf, borderIn, totalMargin;

  self frameWidthVar = widthArg;
  self framePen width = widthArg;

  switch (widthArg)
    {
    case 0:
      break;
    case 1:
      self frame dimensions self margin, self margin,
	self size x - ((self margin * 2) + (self frameWidthVar)),
	self size y - ((self margin * 2) + (self frameWidthVar));
      break;
    default:
      borderHalf = widthArg / 2;
      if ((widthArg % 2) == 0) {
	borderIn = (self margin * 2) + (borderHalf * 2);
      } else {
	borderIn = (self margin * 2) + (borderHalf * 2 + 1);
      }
      self frame dimensions self margin + borderHalf,
	self margin + borderHalf,
	self size x - borderIn, self size y - borderIn;
      break;
    }

  totalMargin = self margin + self frameWidthVar + self padding;
  self thumb top start x = totalMargin;
  self thumb top end x = (self size x - (totalMargin * 2));
  self thumb bottom start x = totalMargin;
  self thumb bottom end x = (self size x - (totalMargin * 2));

}

X11ScrollBarPane instanceMethod thumbPercent (Float pct) {
  "Calculates the thumb's height as a percent of the scrollbar's
   trough height."
  self thumbHeight = (self size y - ((self margin * 2) +
				     (self frameWidthVar * 2) +
				     (self padding * 2))) * pct;

  if (self bevel) {
    __ctalkGUIPaneDrawRectangle (self, self thumb, self thumbErasePen, TRUE);
    self thumbDimensions lastY, self thumbHeight;
    haveBevel = false;
    __ctalkGUIPaneRefresh (self, 0, 0, self size x, self size y,
			   self origin x, self origin y);
  } else {
    __ctalkGUIPaneDrawRectangle (self, self thumb, self thumbErasePen, TRUE);
    self thumbDimensions lastY, self thumbHeight;
    __ctalkGUIPaneDrawRectangle (self, self thumb, self thumbPen, TRUE);
    __ctalkGUIPaneRefresh (self, 0, 0, self size x, self size y,
			   self origin x, self origin y);
  }
}

X11ScrollBarPane instanceMethod percent (void) {
  "Returns a Float between 0.0 and 1.0 with the vertical position
   of the thumb in the scrollbar's trough as a percent of the 
   trough's height."
  returnObjectClass Float;

  Float new usableTrough, fl, pct;

  usableTrough = self size y - ((self margin * 2) +
				(self frameWidthVar * 2) +
				(self padding * 2) +
				(self thumbHeight));
  fl = self lastY;
  pct = fl / usableTrough;
  return pct;
}

X11ScrollBarPane instanceMethod subPaneEnterNotify (void) {
  self useCursor self arrowCursor;
    self mouseOver = true;
}

X11ScrollBarPane instanceMethod subPaneLeaveNotify (void) {
    self defaultCursor;
    self mouseOver = false;
}
 
 
