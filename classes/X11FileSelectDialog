L/* $Id: X11FileSelectDialog,v 1.3 2020/08/24 20:54:02 rkiesling Exp $ -*-C-*-*/

/*
  This file is part of Ctalk.
  Copyright © 2020  Robert Kiesling, rk3314042@gmail.com.
  Permission is granted to copy this software provided that this copyright
  notice is included in all source code modules.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
*/

/* 
   X11FileSelectDialog Class - Text Entry Dialog

   Resources: 

   listFont       "sans serif-12"

*/

X11ListBox class X11FileSelectDialog;

X11FileSelectDialog instanceMethod getExpandedDir (String dirPattern,
						   SortedList filesOut) {
  DirectoryStream new dir;
  String new qualPath;

  if (dirPattern contains "." == -1 ||
      dirPattern contains '~' == -1 ||
      dirPattern contains '$' == -1) {
    qualPath = dirPattern;
  } else if (dirPattern == ".") {
    qualPath = dir getCwd;
  }
  
  dir sortedDirectoryList qualPath, filesOut;
}

X11FileSelectDialog instanceMethod initWidgets (void) {
  "Initialize the entry box's button and label widgets.  The
   message box defers constructing the new widgets until just
   before it is displayed, so any modifications to the defaults
   (colors, dimensions, etc.) can be done here, mainly by
   subclassing the X11MessageBox class (for the present, at 
   least, until Ctalk includes some sort of resource manager).
   However, waiting until now to construct the widgets also
   has the advantage that all of the other objects and methods
   in a program have been defined."

  X11ButtonPane new l_button, r_button;
  X11LabelPane new l_label;
  X11ListPane new l_list;
  X11Bitmap new l_icon;
  Integer new usable_height, usable_width, padInt, label_width_px,
    label_height_px, label_x_px, label_y_px, button_y_px;
  Integer new list_height_px, list_width_px, list_x_px,
    list_y_px;
  String new geomspec;
  InputEvent new e;
  SortedList new dirItems;


  if (self initialized)
    return NULL;

  padInt = self resources at "pad";

  usable_height = self size y - (padInt * 2);
  usable_width = self size x - (padInt * 2);
  label_width_px = usable_width;
  l_label selectFont;
  label_height_px = (l_label ftFontVar height * 3);
  label_x_px = padInt;
  label_y_px = padInt;

  geomspec printOn "%dx%d+%d+%d", label_width_px, label_height_px,
    label_x_px, label_y_px;

  l_label resources replaceAt "backgroundColor",
    (self resources at "backgroundColor");
  l_label resources replaceAt "foregroundColor",
    (self resources at "foregroundColor");
  l_label multiLine self resources at "messageText";
  l_label border = false;
  l_label resources replaceAt "textColor",
    (self resources at "messageColor");
  l_label resources replaceAt "ftFont",
    (self resources at "messageFont");
  l_label justify = LABEL_LEFT;

  self label become l_label;

  self label attachTo self, geomspec;

  list_height_px = 50;        /* this will be -50 in the geometry string */
  list_width_px = usable_width;
  list_x_px = padInt;
  list_y_px = label_height_px + padInt;

  geomspec printOn "%dx-%d+%d+%d", list_width_px, list_height_px,
    list_x_px, list_y_px;

  self listPane become l_list;
  self listPane attachTo self, geomspec;
  self children push self listPane;

  self listPane resources replaceAt "font", (self resources at "listFont");

  self getExpandedDir ".", dirItems;
  dirItems map {
    super listPane add self;
  }

  self lbutton become l_button;
  self children push l_button;
  self rbutton become r_button;
  self children push r_button;

  button_y_px = 46;   /* -46 in the geomspecs */

  geomspec printOn "20%%x36+20%%+-%d", button_y_px;
  self lbutton attachTo self, geomspec;

  geomspec printOn "20%%x36+60%%+-%d", button_y_px;
  self rbutton attachTo self, geomspec;

  self lbutton label text (self resources at "leftButtonText");
  self rbutton label text (self resources at "rightButtonText");

  self initialized = true;

}

#if 0
X11ListBox instanceVariable listPane X11ListPane NULL;
X11ListBox instanceVariable items List NULL "These are the text of the 
items to be added to the dialog's list when the dialog is first popped 
up and its listbox constructed";

#define KEY_TAB   1
#define KEY_ENTER 2

X11ListBox instanceMethod new (String paneName) {
  Method new exposeMethod, buttonPressMethod, kbdInputMethod,
    enterMethod, leaveMethod;

  X11ListBox super new paneName;
  
  enterMethod definedInstanceMethod "X11ListBox",
    "subPaneEnter";
  paneName setMethodHandler "enternotify", enterMethod;

  leaveMethod definedInstanceMethod "X11ListBox",
    "subPaneLeave";
  paneName setMethodHandler "leavenotify", leaveMethod;

  paneName resources atPut "listFont", "sans-serif-12";

  /* These are modifications of the resources set in X11YesNoBoxPane : new. */
  paneName resources replaceAt "leftButtonText", "Cancel";
  paneName resources replaceAt "rightButtonText", "OK";

  /* This is modified from X11MessageBoxPane : new. */
  paneName resources replaceAt "titleText", "Select an Item";

  return paneName;
}

X11ListBox instanceMethod draw (void) {
  
  self label draw;
  self listPane draw;
  self listPane refresh;

  self lbutton draw;
  self rbutton draw;

}

X11ListBox instanceMethod initWidgets (void) {
  "Initialize the entry box's button and label widgets.  The
   message box defers constructing the new widgets until just
   before it is displayed, so any modifications to the defaults
   (colors, dimensions, etc.) can be done here, mainly by
   subclassing the X11MessageBox class (for the present, at 
   least, until Ctalk includes some sort of resource manager).
   However, waiting until now to construct the widgets also
   has the advantage that all of the other objects and methods
   in a program have been defined."

  X11ButtonPane new l_button, r_button;
  X11LabelPane new l_label;
  X11ListPane new l_list;
  X11Bitmap new l_icon;
  Integer new usable_height, usable_width, padInt, label_width_px,
    label_height_px, label_x_px, label_y_px, button_y_px;
  Integer new list_height_px, list_width_px, list_x_px,
    list_y_px;
  String new geomspec;
  InputEvent new e;


  if (self initialized)
    return NULL;

  padInt = self resources at "pad";

  usable_height = self size y - (padInt * 2);
  usable_width = self size x - (padInt * 2);
  label_width_px = usable_width;
  l_label selectFont;
  label_height_px = (l_label ftFontVar height * 3);
  label_x_px = padInt;
  label_y_px = padInt;

  geomspec printOn "%dx%d+%d+%d", label_width_px, label_height_px,
    label_x_px, label_y_px;

  l_label resources replaceAt "backgroundColor",
    (self resources at "backgroundColor");
  l_label resources replaceAt "foregroundColor",
    (self resources at "foregroundColor");
  l_label multiLine self resources at "messageText";
  l_label border = false;
  l_label resources replaceAt "textColor",
    (self resources at "messageColor");
  l_label resources replaceAt "ftFont",
    (self resources at "messageFont");
  l_label justify = LABEL_LEFT;

  self label become l_label;

  self label attachTo self, geomspec;

  list_height_px = 50;        /* this will be -50 in the geometry string */
  list_width_px = usable_width;
  list_x_px = padInt;
  list_y_px = label_height_px + padInt;

  geomspec printOn "%dx-%d+%d+%d", list_width_px, list_height_px,
    list_x_px, list_y_px;

  self listPane become l_list;
  self listPane attachTo self, geomspec;
  self children push self listPane;

  self listPane resources replaceAt "font", (self resources at "listFont");
  self items map {
    super listPane add self;
  }

  self lbutton become l_button;
  self children push l_button;
  self rbutton become r_button;
  self children push r_button;

  button_y_px = 46;   /* -46 in the geomspecs */

  geomspec printOn "20%%x36+20%%+-%d", button_y_px;
  self lbutton attachTo self, geomspec;

  geomspec printOn "20%%x36+60%%+-%d", button_y_px;
  self rbutton attachTo self, geomspec;

  self lbutton label text (self resources at "leftButtonText");
  self rbutton label text (self resources at "rightButtonText");

  self initialized = true;

}

X11ListBox instanceMethod subPaneEnter (Object subPane,
					  InputEvent __event) {
  if (__event eventData == subPane lbutton xWindowID) {
    if (subPane lbutton canFocus) {
      if (self lbutton clicked) {
	self lbutton clicked = false;
      }
      if (!self lbutton hover) {
	subPane lbutton label highlight = true;
	self lbutton hover = true;
      }
      if (!self lbutton radius)
	self lbutton label drawButtonLayout;
      subPane lbutton draw;
      subPane lbutton refresh;
    }
    return NULL;
  } else if (__event eventData == subPane rbutton xWindowID) {
    if (subPane rbutton canFocus) {
      if (self rbutton clicked) {
	self rbutton clicked = false;
      }
      if (!self lbutton hover) {
	subPane rbutton label highlight = true;
	self rbutton hover = true;
      }
      if (!self lbutton radius)
	self rbutton label drawButtonLayout;
      subPane rbutton draw;
      subPane rbutton refresh;
    }
    return NULL;
  } else if (__event eventData == subPane listPane xWindowID) {
    subPane listPane onEnter subPane listPane, __event;
    return NULL;
  }

  /* The event comes from any other window. */
  if (self lbutton clicked) {
    self lbutton clicked = false;
    self lbutton hover = false;
    if (!self lbutton radius)
      self lbutton label drawButtonLayout;
    subPane lbutton draw;
    subPane lbutton refresh;
  }
  if (self rbutton clicked) {
    self rbutton clicked = false;
    self rbutton hover = false;
    if (!self rbutton radius)
      self rbutton label drawButtonLayout;
    subPane rbutton draw;
    subPane rbutton refresh;
  }
}

X11ListBox instanceMethod subPaneLeave (Object subPane,
					  InputEvent __event) {
  if (__event eventData == subPane lbutton xWindowID) {
    if (subPane lbutton canFocus) {
      if (self lbutton hover) {
	subPane lbutton label highlight = false;
	if (self lbutton clicked)
	  self lbutton clicked = false;
	self lbutton label drawButtonLayout;
	subPane lbutton draw;
	subPane lbutton refresh;
	self lbutton hover = false;
      }
    }
  } else if (__event eventData == subPane rbutton xWindowID) {
    if (subPane rbutton canFocus) {
      if (self rbutton hover) {
	subPane rbutton label highlight = false;
	if (self rbutton clicked)
	  self rbutton clicked = false;
	self rbutton label drawButtonLayout;
	subPane rbutton draw;
	subPane rbutton refresh;
	self rbutton hover = false;
      }
    }
  } else if (__event eventData == subPane listPane xWindowID) {
    subPane listPane onLeave subPane listPane, __event;
  }
}

extern Atom wm_delete_dialog;
extern void __enable_dialog (OBJECT *);

X11ListBox instanceMethod show (void) {
  "Displays the pane's window. Note that th method uses raw X
   events. This is because the pane maintains its own connection
   to the display, and the event handler can be contained in
   this method."
  returnObjectClass Integer;
  Display *display;
  Window win_id;
  XEvent xev;
  X11PaneDispatcher new dispatcher;
  X11Pane new mainWin;
  InputEvent new e;

  dispatcher = *self container;
  mainWin = dispatcher mainWindow;
  
  if (!self initialized) {

    win_id = __ctalkX11CreateDialogWindow (self);
    self xWindowID = win_id;
    dispatcher modalWin = win_id;
    dispatcher modalPane = self;

    display = self displayPtr;
  
    (X11Bitmap *)self paneBuffer create self displayPtr, self xWindowID, 
      self size x, self size y, self depth;
    (X11Bitmap *)self paneBuffer background
      (self resources at "backgroundColor");
    self paneBuffer backgroundColor = self resources at "backgroundColor";
    (X11Bitmap *)self paneBuffer foreground
      (self resources at "foregroundColor");
    (X11Bitmap *)self paneBackingStore create self displayPtr, self xWindowID,
      self size x, self size y, self depth;

    self initWidgets;
  } else {

    __enable_dialog (self);

    win_id = self xWindowID;
    display = self displayPtr;

  }

  XMapWindow (display, win_id);
  XMapSubwindows (display, win_id);
  XRaiseWindow (display, win_id);

  self clearWindow;
  self returnVal = 0;

  while (1) {
    if (XPending (display)) {
      XNextEvent (display, &xev);
      switch (xev.type)
	{
	case ButtonPress:
	  if ((xev.xbutton.window == self lbutton xWindowID) ||
	      (xev.xbutton.window == self rbutton xWindowID)) {
	    e eventClass = BUTTONPRESS;
	    self methodObjectMessage self handlePointerInput, self, e;
	  } else if (xev.xbutton.window == self listPane xWindowID) {
	    e eventClass = BUTTONPRESS;
	    e xEventData1 = xev.xbutton.x;
	    e xEventData2 = xev.xbutton.y;
	    e xEventData3 = xev.xbutton.state;
	    e xEventData4 = xev.xbutton.button;
	    self listPane onClick self listPane, e;
	  }
	  break;
	case ButtonRelease:
	  if ((xev.xbutton.window == self lbutton xWindowID) ||
	      (xev.xbutton.window == self rbutton xWindowID)) {
	    e eventClass = BUTTONRELEASE;
	    self listPane onClick self listPane, e;
	    self withdraw;
	    dispatcher modalWin = 0;
	    dispatcher modalPane = NULL;
	    return self returnVal;
	  } else if (xev.xbutton.window == self listPane xWindowID) {
	    e eventClass = BUTTONRELEASE;
	    e xEventData1 = xev.xbutton.x;
	    e xEventData2 = xev.xbutton.y;
	    e xEventData3 = xev.xbutton.state;
	    e xEventData4 = xev.xbutton.button;
	    self listPane onClick self listPane, e;
	  }
	  break;
	case EnterNotify:
	  if ((xev.xbutton.window == self lbutton xWindowID) ||
	      (xev.xbutton.window == self rbutton xWindowID) ||
	      (xev.xbutton.window == self listPane xWindowID)) {
	    e eventClass = ENTERWINDOWNOTIFY;
	    e eventData = xev.xbutton.window;
	    self subPaneEnter self, e;
	  }
	  break;
	case LeaveNotify:
	  if ((xev.xbutton.window == self lbutton xWindowID) ||
	      (xev.xbutton.window == self rbutton xWindowID) ||
	      (xev.xbutton.window == self listPane xWindowID)) {
	    e eventClass = LEAVEWINDOWNOTIFY;
	    e eventData = xev.xbutton.window;
	    self subPaneLeave self, e;
	  }
	  break;
	case KeyPress:
	case KeyRelease:
	  if (xev.xkey.window == self listPane xWindowID) {
	    /* Here for testing. */
#if 0
	    e eventClass = (xev.type == KeyPress) ? KEYPRESS : KEYRELEASE;
#else	    
	    if (xev.type == KeyPress) {
	      e eventClass = KEYPRESS;
	    } else {
	      e eventClass = KEYRELEASE;
	    }
#endif	    
	    e eventData = xev.xkey.window;
	    e xEventData4 = xev.xkey.keycode;
	    e xEventData5 = __edittext_xk_keysym
	      (xev.xkey.keycode, xev.xkey.state, 0);
	    self listPane onKey self listPane, e;
	  }
	  break;
	case Expose:
	  if (xev.xexpose.count == 0)
	    self subPaneExpose self, e;
	  break;
	case MotionNotify:
	  if (xev.xmotion.window == self listPane xWindowID) {
	    e eventClass = MOTIONNOTIFY;
	    e eventData = xev.xmotion.window;
	    e xEventData1 = xev.xmotion.x;
	    e xEventData2 = xev.xmotion.y;
	    e xEventData3 = xev.xmotion.state;
	    e xEventData4 = xev.xmotion.is_hint;
	    self listPane onMotion self listPane, e;
	  }
	  break;
	case SelectionRequest:
	  __entrytext_send_selection (self displayPtr, &xev);
	  break;
	case ClientMessage:
	  if(xev.xclient.data.l[0] == wm_delete_dialog) {
	    self withdraw;
	    dispatcher modalWin = 0;
	    dispatcher modalPane = NULL;
	    self returnVal = YESNO_NONE;
	    self returnText = "";
	    self entryContents = self entryPane entryText;
	    return self returnVal;
	  }
	  break;
	}
    } else {
      usleep (5000);
    }
  }

}

#endif
